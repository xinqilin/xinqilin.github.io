<!doctype html><html lang=zh-tw><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Docker 網路模式詳解：容器間通訊與外部連接 - Bill.Lin's Notes</title><meta name=description content="深入解析 Docker 提供的各種網路模式，包括 Bridge、Host、None 和 Container 模式，並詳細說明如何建立自訂網路以實現容器間的順暢通訊與外部連接。"><link rel=stylesheet href=https://xinqilin.github.io/css/style.min.css><link rel=stylesheet href=https://xinqilin.github.io/css/chroma.min.css><link rel=icon type=image/svg+xml href=/images/Bill-coding.svg><link rel=icon type=image/x-icon href=/images/Bill-coding.ico><meta property="og:title" content="Docker 網路模式詳解：容器間通訊與外部連接"><meta property="og:description" content="深入解析 Docker 提供的各種網路模式，包括 Bridge、Host、None 和 Container 模式，並詳細說明如何建立自訂網路以實現容器間的順暢通訊與外部連接。"><meta property="og:type" content="article"><meta property="og:url" content="https://xinqilin.github.io/post/devops/docker-network/"></head><body><div class=container><header class=header><nav class=nav><div class=nav-left><a href=https://xinqilin.github.io/ class=nav-title><img src=/images/Bill-coding.svg alt="Site Icon" class=nav-icon>
Bill.Lin's Notes</a></div><div class=nav-center><a href=https://xinqilin.github.io/ class=avatar-link><div class=avatar-container><div class=avatar-ring></div><img src=/images/Bill-coding.svg alt="Bill's Avatar" class=nav-avatar-center></div></a></div><div class=nav-right><ul class=nav-menu><li class=nav-item><a href=https://xinqilin.github.io/ class=nav-link>Me</a></li><li class=nav-item><a href=/posts/ class="nav-link posts">Posts</a></li><li class=nav-item><a href=/categories/ class="nav-link categories">Categories</a></li><li class=nav-item id=search-container><a href=# id=search-trigger class=nav-link>Search</a>
<input type=text id=search-input placeholder=Search...><div id=search-results-container></div></li></ul></div></nav></header><style>.container{max-width:1100px}#search-container{position:relative}#search-input{position:absolute;top:50%;left:0;transform:translateY(-50%);height:100%;width:0;padding:0;margin:0;opacity:0;visibility:hidden;border:none;border-radius:12px;font-family:inherit;font-size:1em;color:#4a5568;background-color:#fff;outline:none;transition:width .35s ease,opacity .3s ease,padding .35s ease;z-index:10}#search-container.search-active #search-trigger{opacity:0;visibility:hidden}#search-container.search-active #search-input{width:220px;padding:.6rem 1.2rem;opacity:1;visibility:visible;box-shadow:0 4px 20px rgba(0,0,0,.1);border:1px solid #e2e8f0}#search-results-container{display:none;position:absolute;top:calc(100% + 5px);left:0;width:320px;max-height:400px;overflow-y:auto;background-color:#fff;border:1px solid #ddd;border-radius:8px;box-shadow:0 8px 25px rgba(0,0,0,.15);z-index:1001}.search-result-link{display:block;text-decoration:none;color:inherit;padding:12px 15px;border-bottom:1px solid #eee;transition:background-color .2s ease}.search-result-link:hover{background-color:#f8f9fa}.search-result-link:last-child{border-bottom:none}.search-result-title{font-size:1em;font-weight:600;color:#333;margin:0 0 5px}.search-result-link:hover .search-result-title{color:#61c8e0}.search-result-summary{font-size:.9em;color:#666;margin:0;line-height:1.4;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}</style><main class=main-content><article class=post><header class=post-header><h1 class=post-title>Docker 網路模式詳解：容器間通訊與外部連接</h1><div class=post-meta><div class=post-info><time class=post-date>2021年07月26日</time>
<span class=post-author>by Bill.Lin</span>
<span class=reading-time>2 分鐘閱讀</span></div><div class=post-categories><a href=/categories/devops class=category-link>DevOps</a></div></div></header><div class=post-content><h2 id=概述>概述</h2><p>Docker 網路是容器化應用程式的基石，它決定了容器如何與外部世界通訊，以及容器之間如何互相連接。理解 Docker 的網路模式對於建構穩健、可擴展的容器化應用程式至關重要。本文將詳細介紹 Docker 提供的幾種主要網路模式及其應用場景。</p><h2 id=docker-網路模式>Docker 網路模式</h2><p>Docker 提供了多種網路驅動程式，每種驅動程式都提供不同的網路功能。最常用的包括 <code>bridge</code>、<code>host</code>、<code>none</code> 和 <code>container</code>。</p><h3 id=1-bridge-橋接模式>1. Bridge (橋接模式)</h3><ul><li><strong>說明</strong>：這是 Docker 的預設網路模式。當您不指定網路模式時，Docker 會自動為容器分配一個 IP 位址，並將其連接到一個名為 <code>docker0</code> 的虛擬橋接器上。每個容器都會獲得一個獨立的網路堆疊。</li><li><strong>工作原理</strong>：<ul><li>Docker 會在主機上建立一個名為 <code>docker0</code> 的虛擬橋接器。</li><li>每個容器都會建立一對虛擬乙太網卡 (veth pair)，其中一端連接到容器內的 <code>eth0</code>，另一端連接到 <code>docker0</code> 橋接器。</li><li>容器可以透過 <code>docker0</code> 橋接器與同一橋接器上的其他容器通訊，也可以透過主機的網路介面與外部網路通訊。</li></ul></li><li><strong>優點</strong>：提供良好的隔離性，容器間預設不直接暴露埠。</li><li><strong>缺點</strong>：容器需要透過埠映射才能從外部訪問。</li></ul><h3 id=2-host-主機模式>2. Host (主機模式)</h3><ul><li><strong>說明</strong>：在主機模式下，容器不會有自己的獨立網路堆疊，而是直接使用主機的網路堆疊。這意味著容器會直接使用主機的 IP 位址和埠。</li><li><strong>工作原理</strong>：容器內的應用程式會直接綁定到主機的網路介面和埠上。</li><li><strong>優點</strong>：網路效能最佳，因為沒有額外的網路層。</li><li><strong>缺點</strong>：<ul><li>容器不再與主機隔離，容器內應用程式使用的埠不能與主機上已佔用的埠衝突。</li><li>安全性較低，因為容器直接暴露在主機網路中。</li></ul></li><li><strong>使用方式</strong>：<code>--network host</code></li></ul><h3 id=3-none-無網路模式>3. None (無網路模式)</h3><ul><li><strong>說明</strong>：在無網路模式下，容器會建立一個獨立的網路堆疊，但不會對其進行任何網路配置。容器將沒有網路介面，無法與外部通訊。</li><li><strong>工作原理</strong>：容器只包含一個 <code>lo</code> (loopback) 介面。</li><li><strong>優點</strong>：適用於只需要計算資源而不需要網路連接的特殊場景，或者需要手動配置網路的進階情況。</li><li><strong>缺點</strong>：容器無法進行任何網路通訊，除非手動配置。</li><li><strong>使用方式</strong>：<code>--network none</code></li></ul><h3 id=4-container-容器模式>4. Container (容器模式)</h3><ul><li><strong>說明</strong>：在容器模式下，新建立的容器不會有自己的網路堆疊，而是與另一個已存在的容器共享其網路堆疊。這意味著兩個容器會共享同一個 IP 位址和埠空間。</li><li><strong>工作原理</strong>：兩個容器共享同一個網路命名空間。</li><li><strong>優點</strong>：適用於需要緊密協同工作的應用程式，例如主應用程式容器和一個代理或日誌收集容器。</li><li><strong>缺點</strong>：兩個容器會共享埠，可能導致埠衝突。</li><li><strong>使用方式</strong>：<code>--network container:&lt;name_or_id></code></li></ul><h2 id=常用-docker-網路指令>常用 Docker 網路指令</h2><table><thead><tr><th style=text-align:left>指令</th><th style=text-align:left>說明</th><th style=text-align:left>範例</th></tr></thead><tbody><tr><td style=text-align:left><code>docker network ls</code></td><td style=text-align:left>列出所有 Docker 網路。</td><td style=text-align:left><code>docker network ls</code></td></tr><tr><td style=text-align:left><code>docker network prune</code></td><td style=text-align:left>刪除所有未使用的網路。</td><td style=text-align:left><code>docker network prune</code></td></tr><tr><td style=text-align:left><code>docker network inspect &lt;network_name_or_id></code></td><td style=text-align:left>顯示指定網路的詳細資訊，包括連接到該網路的容器。</td><td style=text-align:left><code>docker network inspect bridge</code></td></tr><tr><td style=text-align:left><code>docker inspect &lt;container_id></code></td><td style=text-align:left>顯示指定容器的詳細資訊，包括其網路配置。</td><td style=text-align:left><code>docker inspect &lt;container_id></code></td></tr></tbody></table><h2 id=自訂網路-user-defined-bridge-networks>自訂網路 (User-defined Bridge Networks)</h2><p>雖然 Docker 預設的 <code>bridge</code> 網路 (<code>docker0</code>) 已經足夠應付許多情況，但強烈建議您建立<strong>自訂橋接網路 (User-defined Bridge Networks)</strong>。自訂網路提供了更好的隔離性、內建的 DNS 解析和更靈活的配置。</p><h3 id=優點>優點</h3><ul><li><strong>內建 DNS 解析</strong>：在自訂網路中，容器可以透過服務名稱（而不是 IP 位址）互相通訊，因為 Docker 會為自訂網路提供內建的 DNS 解析服務。這使得容器的 IP 位址變化不再是問題。</li><li><strong>更好的隔離性</strong>：自訂網路中的容器預設只能與同一網路中的其他容器通訊，提供了更好的安全性。</li><li><strong>可移植性</strong>：在 Docker Compose 中，自訂網路是預設行為，這使得多容器應用程式的定義更加簡潔和可移植。</li></ul><h3 id=建立自訂網路>建立自訂網路</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 建立一個名為 &#39;my_network&#39; 的自訂橋接網路</span>
</span></span><span class=line><span class=cl>docker network create my_network
</span></span></code></pre></td></tr></table></div></div><h3 id=將容器連接到自訂網路>將容器連接到自訂網路</h3><p>在啟動容器時，使用 <code>--network</code> 參數指定自訂網路名稱：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 啟動第一個 Tomcat 容器，連接到 &#39;my_network&#39;</span>
</span></span><span class=line><span class=cl>docker run -d -p 8080:8080 --network my_network --name tomcat_1 tomcat
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 啟動第二個 Tomcat 容器，連接到 &#39;my_network&#39;</span>
</span></span><span class=line><span class=cl>docker run -d -p 8081:8080 --network my_network --name tomcat_2 tomcat
</span></span></code></pre></td></tr></table></div></div><p>現在，<code>tomcat_1</code> 和 <code>tomcat_2</code> 容器都在 <code>my_network</code> 中，它們可以透過彼此的容器名稱（<code>tomcat_1</code> 和 <code>tomcat_2</code>）互相通訊，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 進入 tomcat_1 容器內部</span>
</span></span><span class=line><span class=cl>docker <span class=nb>exec</span> -it tomcat_1 bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 在 tomcat_1 容器內部 ping tomcat_2</span>
</span></span><span class=line><span class=cl>ping tomcat_2
</span></span></code></pre></td></tr></table></div></div><h3 id=容器模式的限制與自訂網路的優勢>容器模式的限制與自訂網路的優勢</h3><p>您原先的範例中，嘗試讓兩個 Tomcat 容器共享網路，但由於埠衝突而失敗：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 坑 （下面起不起來因兩台 tomcat 都用 8080 映射出去）</span>
</span></span><span class=line><span class=cl><span class=c1># 借用 tomcat_1 網路</span>
</span></span><span class=line><span class=cl>docker run -d -p 8080:8080 --name tomcat_1 tomcat
</span></span><span class=line><span class=cl>docker run -d -p 8081:8080 --network container:tomcat_1 --name tomcat_2 tomcat <span class=c1># 會失敗，因為 tomcat_2 試圖使用 tomcat_1 的 8080 埠</span>
</span></span></code></pre></td></tr></table></div></div><p>這是因為在 <code>container</code> 模式下，兩個容器共享同一個網路命名空間，包括埠空間。如果 <code>tomcat_1</code> 已經佔用了 8080 埠，那麼 <code>tomcat_2</code> 就無法再使用這個埠。</p><p>相比之下，使用自訂網路則沒有這個問題。每個容器在自訂網路中仍然擁有自己的獨立網路堆疊和埠空間，只是它們可以透過網路名稱互相發現和通訊。這使得自訂網路成為多容器應用程式之間通訊的更優雅和健壯的解決方案。</p><p>透過理解和善用 Docker 網路模式，您可以更有效地設計和管理您的容器化應用程式。</p></div><footer class=post-footer><div class=post-tags><span class=tags-label>標籤：</span>
<a href=/tags/docker class=tag-link>#Docker</a>
<a href=/tags/network class=tag-link>#Network</a>
<a href=/tags/devops class=tag-link>#DevOps</a>
<a href=/tags/containerization class=tag-link>#Containerization</a>
<a href=/tags/bridge class=tag-link>#Bridge</a>
<a href=/tags/host class=tag-link>#Host</a></div></footer></article><nav class=post-nav><div class=post-nav-links><div class=post-nav-prev><span class=post-nav-label>上一篇</span>
<a href=https://xinqilin.github.io/post/devops/dockerfile-docker_in_docker/ class=post-nav-link>多階段 Dockerfile：建構跨平台 Selenium 應用程式映像檔</a></div><div class=post-nav-next><span class=post-nav-label>下一篇</span>
<a href=https://xinqilin.github.io/post/devops/docker-compose/ class=post-nav-link>Docker Compose 完整指南：多容器應用程式的定義與執行</a></div></div></nav></main><footer class=footer><div class=footer-content><p>&copy; 2025 Bill Lin. All rights reserved.</p><div class=social-links><a href=https://github.com/xinqilin class=social-link target=_blank rel=noopener>github</a></div></div></footer><script src=/js/search.js></script></div></body></html>