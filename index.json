[{"content":"👋 歡迎來到 Bill.Lin\u0026rsquo;s Notes 這裡是我的技術學習筆記和心得分享空間。主要記錄程式開發過程中遇到的問題、解決方案，以及對各種技術的理解和實踐經驗。\n📚 主要內容 🧮 演算法與資料結構 經典演算法實作與分析 LeetCode 解題思路與技巧 資料結構的應用場景 💻 後端開發 Java: 語言特性、集合框架、並發程式設計 Kotlin: 語法糖、協程、與 Java 互操作 Spring: IoC/DI、AOP、MVC、Security、Boot 🏗️ 架構設計 設計模式: GoF 23 種設計模式的理論與實踐 SOLID 原則: 物件導向設計的五大原則 分散式系統: 微服務、訊息佇列、分散式鎖 🐳 DevOps Docker: 容器化部署與最佳實踐 CI/CD: 自動化建構與部署流程 監控: 應用效能監控與日誌管理 🛠️ 開發工具 Linux: 常用指令與腳本編寫 Git: 版本控制與協作工作流 Hugo: 靜態網站生成器的使用心得 🎯 寫作目標 記錄學習過程: 將學習到的知識點整理成筆記，加深理解 分享實踐經驗: 分享在實際專案中遇到的問題和解決方案 建立知識體系: 透過持續寫作，建立完整的技術知識架構 幫助他人學習: 希望這些筆記能對其他開發者有所幫助 📖 文章特色 理論與實踐並重: 不僅說明原理，更著重實際應用 程式碼範例豐富: 提供完整可執行的程式碼示例 循序漸進: 從基礎概念到進階應用，逐步深入 持續更新: 根據新的學習心得和技術發展持續更新內容 🤝 聯絡方式 如果您對文章內容有任何問題或建議，歡迎透過以下方式聯絡：\nGitHub: xinqilin Email: 請透過 GitHub 聯絡 🙏 致謝 感謝所有在技術學習路上給予幫助的同事、朋友和開源社群。特別感謝那些無私分享技術知識的部落格作者和教程創作者，您們的分享讓我受益良多。\n「學而時習之，不亦說乎」- 論語\n希望這個小小的技術筆記空間，能成為知識分享和交流的平台。讓我們一起在技術的海洋中探索和成長！\n","permalink":"https://xinqilin.github.io/about/","tags":null,"title":"關於 Bill.Lin's Notes"},{"content":"概述 FTP（File Transfer Protocol）是企業環境中常用的檔案傳輸協定。本文提供一個完整、安全且可靠的 FTP 工具類實作，適用於生產環境的檔案上傳、下載和管理需求。\n核心特性 ✅ 配置外部化：所有連線資訊透過配置檔案管理 ✅ 連線池管理：支援連線複用，提升效能 ✅ 完整錯誤處理：詳細的異常處理和重試機制 ✅ 檔案操作：上傳、下載、刪除、列表等完整功能 ✅ 安全考量：密碼加密、連線超時、資源釋放 ✅ 日誌記錄：完整的操作日誌和監控 依賴配置 Maven 依賴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;dependencies\u0026gt; \u0026lt;!-- Apache Commons Net --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-net\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-net\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.9.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot Starter --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 配置處理 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Gradle 依賴 1 2 3 4 5 dependencies { implementation \u0026#39;commons-net:commons-net:3.9.0\u0026#39; implementation \u0026#39;org.springframework.boot:spring-boot-starter\u0026#39; annotationProcessor \u0026#39;org.springframework.boot:spring-boot-configuration-processor\u0026#39; } 配置類設計 FTP 配置屬性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package com.example.config; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; @Component @ConfigurationProperties(prefix = \u0026#34;ftp\u0026#34;) public class FtpProperties { private String host; private int port = 21; private String username; private String password; private String basePath = \u0026#34;/\u0026#34;; private int connectTimeout = 30000; // 30 秒 private int dataTimeout = 60000; // 60 秒 private int bufferSize = 8192; // 8KB private String encoding = \u0026#34;UTF-8\u0026#34;; private boolean passiveMode = true; private int maxConnections = 10; // Getters and Setters public String getHost() { return host; } public void setHost(String host) { this.host = host; } public int getPort() { return port; } public void setPort(int port) { this.port = port; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getBasePath() { return basePath; } public void setBasePath(String basePath) { this.basePath = basePath; } public int getConnectTimeout() { return connectTimeout; } public void setConnectTimeout(int connectTimeout) { this.connectTimeout = connectTimeout; } public int getDataTimeout() { return dataTimeout; } public void setDataTimeout(int dataTimeout) { this.dataTimeout = dataTimeout; } public int getBufferSize() { return bufferSize; } public void setBufferSize(int bufferSize) { this.bufferSize = bufferSize; } public String getEncoding() { return encoding; } public void setEncoding(String encoding) { this.encoding = encoding; } public boolean isPassiveMode() { return passiveMode; } public void setPassiveMode(boolean passiveMode) { this.passiveMode = passiveMode; } public int getMaxConnections() { return maxConnections; } public void setMaxConnections(int maxConnections) { this.maxConnections = maxConnections; } } 應用配置檔案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # application.yml ftp: host: ${FTP_HOST:ftp.example.com} port: ${FTP_PORT:21} username: ${FTP_USERNAME:} password: ${FTP_PASSWORD:} base-path: ${FTP_BASE_PATH:/uploads} connect-timeout: 30000 data-timeout: 60000 buffer-size: 8192 encoding: UTF-8 passive-mode: true max-connections: 10 # 生產環境建議使用環境變數 # export FTP_HOST=your-ftp-server.com # export FTP_USERNAME=your-username # export FTP_PASSWORD=your-secure-password 核心工具類實作 FTP 連線工廠 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 package com.example.util; import org.apache.commons.net.ftp.FTPClient; import org.apache.commons.net.ftp.FTPReply; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import com.example.config.FtpProperties; import java.io.IOException; import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; @Component public class FtpConnectionFactory { private static final Logger logger = LoggerFactory.getLogger(FtpConnectionFactory.class); @Autowired private FtpProperties ftpProperties; private final BlockingQueue\u0026lt;FTPClient\u0026gt; connectionPool = new LinkedBlockingQueue\u0026lt;\u0026gt;(); /** * 建立 FTP 連線 */ public FTPClient createConnection() throws IOException { FTPClient ftpClient = new FTPClient(); try { // 設定連線參數 ftpClient.setConnectTimeout(ftpProperties.getConnectTimeout()); ftpClient.setDataTimeout(ftpProperties.getDataTimeout()); ftpClient.setControlEncoding(ftpProperties.getEncoding()); ftpClient.setBufferSize(ftpProperties.getBufferSize()); // 建立連線 ftpClient.connect(ftpProperties.getHost(), ftpProperties.getPort()); // 檢查連線回應 int replyCode = ftpClient.getReplyCode(); if (!FTPReply.isPositiveCompletion(replyCode)) { ftpClient.disconnect(); throw new IOException(\u0026#34;FTP 伺服器拒絕連線，回應碼：\u0026#34; + replyCode); } // 登入 boolean loginSuccess = ftpClient.login(ftpProperties.getUsername(), ftpProperties.getPassword()); if (!loginSuccess) { ftpClient.disconnect(); throw new IOException(\u0026#34;FTP 登入失敗，請檢查使用者名稱和密碼\u0026#34;); } // 設定檔案傳輸模式 ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); // 設定被動/主動模式 if (ftpProperties.isPassiveMode()) { ftpClient.enterLocalPassiveMode(); } else { ftpClient.enterLocalActiveMode(); } logger.info(\u0026#34;FTP 連線建立成功：{}:{}\u0026#34;, ftpProperties.getHost(), ftpProperties.getPort()); return ftpClient; } catch (IOException e) { logger.error(\u0026#34;建立 FTP 連線失敗：{}\u0026#34;, e.getMessage()); if (ftpClient.isConnected()) { try { ftpClient.disconnect(); } catch (IOException ex) { logger.warn(\u0026#34;關閉失敗的 FTP 連線時發生錯誤：{}\u0026#34;, ex.getMessage()); } } throw e; } } /** * 歸還連線到連線池 */ public void returnConnection(FTPClient ftpClient) { if (ftpClient != null \u0026amp;\u0026amp; ftpClient.isConnected()) { if (connectionPool.size() \u0026lt; ftpProperties.getMaxConnections()) { connectionPool.offer(ftpClient); } else { closeConnection(ftpClient); } } } /** * 從連線池獲取連線 */ public FTPClient getConnection() throws IOException { FTPClient ftpClient = connectionPool.poll(); if (ftpClient == null || !ftpClient.isConnected()) { return createConnection(); } return ftpClient; } /** * 關閉連線 */ public void closeConnection(FTPClient ftpClient) { if (ftpClient != null) { try { if (ftpClient.isConnected()) { ftpClient.logout(); ftpClient.disconnect(); } } catch (IOException e) { logger.warn(\u0026#34;關閉 FTP 連線時發生錯誤：{}\u0026#34;, e.getMessage()); } } } } 主要 FTP 工具類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 package com.example.util; import org.apache.commons.net.ftp.FTPClient; import org.apache.commons.net.ftp.FTPFile; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import com.example.config.FtpProperties; import java.io.*; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import java.util.ArrayList; import java.util.List; @Component public class FtpUtil { private static final Logger logger = LoggerFactory.getLogger(FtpUtil.class); @Autowired private FtpConnectionFactory connectionFactory; @Autowired private FtpProperties ftpProperties; /** * 上傳檔案 * * @param localFile 本地檔案 * @param remotePath 遠端路徑（相對於 basePath） * @return 上傳是否成功 */ public boolean uploadFile(File localFile, String remotePath) { if (!localFile.exists() || !localFile.isFile()) { logger.error(\u0026#34;本地檔案不存在或不是檔案：{}\u0026#34;, localFile.getAbsolutePath()); return false; } try (FileInputStream fis = new FileInputStream(localFile)) { return uploadFile(fis, remotePath, localFile.getName()); } catch (IOException e) { logger.error(\u0026#34;讀取本地檔案失敗：{}\u0026#34;, e.getMessage()); return false; } } /** * 上傳檔案流 * * @param inputStream 輸入流 * @param remotePath 遠端路徑 * @param fileName 檔案名稱 * @return 上傳是否成功 */ public boolean uploadFile(InputStream inputStream, String remotePath, String fileName) { FTPClient ftpClient = null; try { ftpClient = connectionFactory.getConnection(); // 確保遠端目錄存在 String fullPath = buildFullPath(remotePath); createDirectoryIfNotExists(ftpClient, fullPath); // 切換到目標目錄 if (!ftpClient.changeWorkingDirectory(fullPath)) { logger.error(\u0026#34;無法切換到目錄：{}\u0026#34;, fullPath); return false; } // 上傳檔案 boolean result = ftpClient.storeFile(fileName, inputStream); if (result) { logger.info(\u0026#34;檔案上傳成功：{}/{}\u0026#34;, fullPath, fileName); } else { logger.error(\u0026#34;檔案上傳失敗：{}/{}\u0026#34;, fullPath, fileName); } return result; } catch (IOException e) { logger.error(\u0026#34;上傳檔案時發生錯誤：{}\u0026#34;, e.getMessage()); return false; } finally { connectionFactory.returnConnection(ftpClient); closeQuietly(inputStream); } } /** * 下載檔案 * * @param remotePath 遠端路徑 * @param fileName 檔案名稱 * @param localFile 本地檔案 * @return 下載是否成功 */ public boolean downloadFile(String remotePath, String fileName, File localFile) { FTPClient ftpClient = null; try { ftpClient = connectionFactory.getConnection(); String fullPath = buildFullPath(remotePath); if (!ftpClient.changeWorkingDirectory(fullPath)) { logger.error(\u0026#34;遠端目錄不存在：{}\u0026#34;, fullPath); return false; } // 確保本地目錄存在 File parentDir = localFile.getParentFile(); if (!parentDir.exists()) { parentDir.mkdirs(); } try (FileOutputStream fos = new FileOutputStream(localFile)) { boolean result = ftpClient.retrieveFile(fileName, fos); if (result) { logger.info(\u0026#34;檔案下載成功：{}/{} -\u0026gt; {}\u0026#34;, fullPath, fileName, localFile.getAbsolutePath()); } else { logger.error(\u0026#34;檔案下載失敗：{}/{}\u0026#34;, fullPath, fileName); } return result; } } catch (IOException e) { logger.error(\u0026#34;下載檔案時發生錯誤：{}\u0026#34;, e.getMessage()); return false; } finally { connectionFactory.returnConnection(ftpClient); } } /** * 刪除檔案 * * @param remotePath 遠端路徑 * @param fileName 檔案名稱 * @return 刪除是否成功 */ public boolean deleteFile(String remotePath, String fileName) { FTPClient ftpClient = null; try { ftpClient = connectionFactory.getConnection(); String fullPath = buildFullPath(remotePath); if (!ftpClient.changeWorkingDirectory(fullPath)) { logger.error(\u0026#34;遠端目錄不存在：{}\u0026#34;, fullPath); return false; } boolean result = ftpClient.deleteFile(fileName); if (result) { logger.info(\u0026#34;檔案刪除成功：{}/{}\u0026#34;, fullPath, fileName); } else { logger.error(\u0026#34;檔案刪除失敗：{}/{}\u0026#34;, fullPath, fileName); } return result; } catch (IOException e) { logger.error(\u0026#34;刪除檔案時發生錯誤：{}\u0026#34;, e.getMessage()); return false; } finally { connectionFactory.returnConnection(ftpClient); } } /** * 列出目錄中的檔案 * * @param remotePath 遠端路徑 * @return 檔案列表 */ public List\u0026lt;FtpFileInfo\u0026gt; listFiles(String remotePath) { FTPClient ftpClient = null; List\u0026lt;FtpFileInfo\u0026gt; fileList = new ArrayList\u0026lt;\u0026gt;(); try { ftpClient = connectionFactory.getConnection(); String fullPath = buildFullPath(remotePath); if (!ftpClient.changeWorkingDirectory(fullPath)) { logger.error(\u0026#34;遠端目錄不存在：{}\u0026#34;, fullPath); return fileList; } FTPFile[] ftpFiles = ftpClient.listFiles(); for (FTPFile ftpFile : ftpFiles) { FtpFileInfo fileInfo = new FtpFileInfo(); fileInfo.setName(ftpFile.getName()); fileInfo.setSize(ftpFile.getSize()); fileInfo.setDirectory(ftpFile.isDirectory()); fileInfo.setModifyTime(ftpFile.getTimestamp()); fileList.add(fileInfo); } logger.info(\u0026#34;成功列出目錄 {} 中的 {} 個檔案\u0026#34;, fullPath, fileList.size()); } catch (IOException e) { logger.error(\u0026#34;列出檔案時發生錯誤：{}\u0026#34;, e.getMessage()); } finally { connectionFactory.returnConnection(ftpClient); } return fileList; } /** * 檢查檔案是否存在 * * @param remotePath 遠端路徑 * @param fileName 檔案名稱 * @return 檔案是否存在 */ public boolean fileExists(String remotePath, String fileName) { FTPClient ftpClient = null; try { ftpClient = connectionFactory.getConnection(); String fullPath = buildFullPath(remotePath); if (!ftpClient.changeWorkingDirectory(fullPath)) { return false; } FTPFile[] files = ftpClient.listFiles(fileName); return files != null \u0026amp;\u0026amp; files.length \u0026gt; 0; } catch (IOException e) { logger.error(\u0026#34;檢查檔案存在性時發生錯誤：{}\u0026#34;, e.getMessage()); return false; } finally { connectionFactory.returnConnection(ftpClient); } } /** * 建立完整路徑 */ private String buildFullPath(String remotePath) { String basePath = ftpProperties.getBasePath(); if (!StringUtils.hasText(remotePath)) { return basePath; } // 規範化路徑 String normalizedBasePath = basePath.endsWith(\u0026#34;/\u0026#34;) ? basePath : basePath + \u0026#34;/\u0026#34;; String normalizedRemotePath = remotePath.startsWith(\u0026#34;/\u0026#34;) ? remotePath.substring(1) : remotePath; return normalizedBasePath + normalizedRemotePath; } /** * 遞迴建立目錄 */ private void createDirectoryIfNotExists(FTPClient ftpClient, String path) throws IOException { String[] pathElements = path.split(\u0026#34;/\u0026#34;); StringBuilder currentPath = new StringBuilder(); for (String element : pathElements) { if (StringUtils.hasText(element)) { currentPath.append(\u0026#34;/\u0026#34;).append(element); if (!ftpClient.changeWorkingDirectory(currentPath.toString())) { if (ftpClient.makeDirectory(currentPath.toString())) { logger.debug(\u0026#34;建立目錄：{}\u0026#34;, currentPath.toString()); } else { throw new IOException(\u0026#34;無法建立目錄：\u0026#34; + currentPath.toString()); } } } } } /** * 安靜地關閉資源 */ private void closeQuietly(Closeable closeable) { if (closeable != null) { try { closeable.close(); } catch (IOException e) { // 忽略關閉時的錯誤 } } } } 檔案資訊實體類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.example.util; import java.util.Calendar; public class FtpFileInfo { private String name; private long size; private boolean isDirectory; private Calendar modifyTime; // Getters and Setters public String getName() { return name; } public void setName(String name) { this.name = name; } public long getSize() { return size; } public void setSize(long size) { this.size = size; } public boolean isDirectory() { return isDirectory; } public void setDirectory(boolean directory) { isDirectory = directory; } public Calendar getModifyTime() { return modifyTime; } public void setModifyTime(Calendar modifyTime) { this.modifyTime = modifyTime; } @Override public String toString() { return String.format(\u0026#34;FtpFileInfo{name=\u0026#39;%s\u0026#39;, size=%d, isDirectory=%s}\u0026#34;, name, size, isDirectory); } } 使用範例 基本使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @Service public class FileService { @Autowired private FtpUtil ftpUtil; /** * 上傳使用者頭像 */ public boolean uploadAvatar(MultipartFile file, String userId) { try { String remotePath = \u0026#34;avatars/\u0026#34; + userId; String fileName = generateFileName(file.getOriginalFilename()); return ftpUtil.uploadFile(file.getInputStream(), remotePath, fileName); } catch (IOException e) { logger.error(\u0026#34;上傳頭像失敗：{}\u0026#34;, e.getMessage()); return false; } } /** * 批量上傳檔案 */ public List\u0026lt;String\u0026gt; batchUpload(List\u0026lt;MultipartFile\u0026gt; files, String category) { List\u0026lt;String\u0026gt; successFiles = new ArrayList\u0026lt;\u0026gt;(); String remotePath = \u0026#34;uploads/\u0026#34; + category + \u0026#34;/\u0026#34; + getCurrentDate(); for (MultipartFile file : files) { try { String fileName = generateFileName(file.getOriginalFilename()); if (ftpUtil.uploadFile(file.getInputStream(), remotePath, fileName)) { successFiles.add(fileName); } } catch (IOException e) { logger.error(\u0026#34;批量上傳檔案失敗：{}\u0026#34;, file.getOriginalFilename()); } } return successFiles; } private String generateFileName(String originalName) { String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\u0026#34;yyyyMMddHHmmss\u0026#34;)); String extension = originalName.substring(originalName.lastIndexOf(\u0026#34;.\u0026#34;)); return timestamp + \u0026#34;_\u0026#34; + UUID.randomUUID().toString().substring(0, 8) + extension; } private String getCurrentDate() { return LocalDateTime.now().format(DateTimeFormatter.ofPattern(\u0026#34;yyyy/MM/dd\u0026#34;)); } } 進階功能：檔案同步 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @Component public class FtpSyncService { @Autowired private FtpUtil ftpUtil; /** * 同步本地目錄到 FTP */ public void syncDirectoryToFtp(String localDirPath, String remotePath) { File localDir = new File(localDirPath); if (!localDir.exists() || !localDir.isDirectory()) { logger.error(\u0026#34;本地目錄不存在：{}\u0026#34;, localDirPath); return; } syncDirectoryRecursive(localDir, remotePath); } private void syncDirectoryRecursive(File localDir, String remotePath) { File[] files = localDir.listFiles(); if (files == null) return; for (File file : files) { if (file.isDirectory()) { // 遞迴處理子目錄 String subRemotePath = remotePath + \u0026#34;/\u0026#34; + file.getName(); syncDirectoryRecursive(file, subRemotePath); } else { // 上傳檔案 if (!ftpUtil.fileExists(remotePath, file.getName())) { ftpUtil.uploadFile(file, remotePath); logger.info(\u0026#34;同步檔案：{} -\u0026gt; {}/{}\u0026#34;, file.getAbsolutePath(), remotePath, file.getName()); } } } } } 安全最佳實踐 1. 配置安全 1 2 3 4 5 # 使用環境變數或加密配置 ftp: host: ${FTP_HOST} username: ${FTP_USERNAME} password: ${FTP_PASSWORD:#{null}} # 可以為空，使用 SSH Key 2. 檔案驗證 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class FileValidator { private static final List\u0026lt;String\u0026gt; ALLOWED_EXTENSIONS = Arrays.asList(\u0026#34;.jpg\u0026#34;, \u0026#34;.png\u0026#34;, \u0026#34;.pdf\u0026#34;, \u0026#34;.doc\u0026#34;, \u0026#34;.docx\u0026#34;, \u0026#34;.xls\u0026#34;, \u0026#34;.xlsx\u0026#34;); private static final long MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB public boolean isValidFile(MultipartFile file) { // 檢查檔案大小 if (file.getSize() \u0026gt; MAX_FILE_SIZE) { return false; } // 檢查檔案副檔名 String fileName = file.getOriginalFilename(); if (fileName == null) return false; String extension = fileName.substring(fileName.lastIndexOf(\u0026#34;.\u0026#34;)).toLowerCase(); return ALLOWED_EXTENSIONS.contains(extension); } } 3. 存取控制 1 2 3 4 5 6 7 8 9 10 11 12 @Component public class FtpAccessControl { /** * 檢查使用者是否有權限存取指定路徑 */ public boolean hasAccess(String userId, String remotePath) { // 實作存取控制邏輯 // 例如：使用者只能存取自己的目錄 return remotePath.startsWith(\u0026#34;users/\u0026#34; + userId + \u0026#34;/\u0026#34;); } } 監控與維護 健康檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class FtpHealthIndicator implements HealthIndicator { @Autowired private FtpConnectionFactory connectionFactory; @Override public Health health() { try { FTPClient ftpClient = connectionFactory.getConnection(); boolean isConnected = ftpClient.isConnected(); connectionFactory.returnConnection(ftpClient); return isConnected ? Health.up().withDetail(\u0026#34;status\u0026#34;, \u0026#34;FTP connection available\u0026#34;).build() : Health.down().withDetail(\u0026#34;status\u0026#34;, \u0026#34;FTP connection failed\u0026#34;).build(); } catch (Exception e) { return Health.down().withDetail(\u0026#34;error\u0026#34;, e.getMessage()).build(); } } } 效能監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Aspect @Component public class FtpPerformanceAspect { private static final Logger logger = LoggerFactory.getLogger(FtpPerformanceAspect.class); @Around(\u0026#34;execution(* com.example.util.FtpUtil.*(..))\u0026#34;) public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable { long startTime = System.currentTimeMillis(); try { Object result = joinPoint.proceed(); long endTime = System.currentTimeMillis(); logger.info(\u0026#34;FTP 操作 {} 執行時間：{}ms\u0026#34;, joinPoint.getSignature().getName(), endTime - startTime); return result; } catch (Exception e) { long endTime = System.currentTimeMillis(); logger.error(\u0026#34;FTP 操作 {} 失敗，執行時間：{}ms，錯誤：{}\u0026#34;, joinPoint.getSignature().getName(), endTime - startTime, e.getMessage()); throw e; } } } 常見問題與解決方案 1. 連線逾時問題 1 2 3 4 5 // 增加重試機制 @Retryable(value = {IOException.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000)) public boolean uploadFileWithRetry(InputStream inputStream, String remotePath, String fileName) { return uploadFile(inputStream, remotePath, fileName); } 2. 中文檔名問題 1 2 3 4 5 // 在 FTP 配置中設定正確的編碼 ftpClient.setControlEncoding(\u0026#34;UTF-8\u0026#34;); // 或者對檔名進行編碼處理 String encodedFileName = new String(fileName.getBytes(\u0026#34;UTF-8\u0026#34;), \u0026#34;ISO-8859-1\u0026#34;); 3. 防火牆問題 1 2 3 # 使用被動模式避免防火牆問題 ftp: passive-mode: true 測試範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @SpringBootTest class FtpUtilTest { @Autowired private FtpUtil ftpUtil; @Test void testUploadFile() { // 建立測試檔案 File testFile = createTestFile(); // 執行上傳 boolean result = ftpUtil.uploadFile(testFile, \u0026#34;test\u0026#34;, \u0026#34;test.txt\u0026#34;); // 驗證結果 assertTrue(result); assertTrue(ftpUtil.fileExists(\u0026#34;test\u0026#34;, \u0026#34;test.txt\u0026#34;)); // 清理 ftpUtil.deleteFile(\u0026#34;test\u0026#34;, \u0026#34;test.txt\u0026#34;); } private File createTestFile() { try { File tempFile = File.createTempFile(\u0026#34;test\u0026#34;, \u0026#34;.txt\u0026#34;); Files.write(tempFile.toPath(), \u0026#34;測試內容\u0026#34;.getBytes()); return tempFile; } catch (IOException e) { throw new RuntimeException(e); } } } 總結 本文提供的 FTP 工具類具備以下優勢：\n安全性：配置外部化，避免硬編碼敏感資訊 可靠性：完整的錯誤處理和重試機制 效能：連線池管理，支援併發操作 可維護性：模組化設計，易於擴展和維護 生產就緒：包含監控、日誌和健康檢查 在實際使用時，請根據具體需求調整配置參數和安全設定，確保符合您的業務場景和安全要求。\n參考資料 Apache Commons Net 官方文檔 Spring Boot Configuration Properties FTP RFC 959 協定規範 Java FTP 最佳實踐 ","permalink":"https://xinqilin.github.io/post/backend/ftputil/","tags":["Java","FTP","FileTransfer","Spring","Commons-Net","Security"],"title":"FTP 工具類實作指南：安全、可靠的檔案傳輸解決方案"},{"content":"概述 在企業級應用程式開發中，Enum（列舉）是表示有限狀態集合的理想選擇，如訂單狀態、使用者角色、審核狀態等。本文深入探討如何在 JPA/Hibernate 中有效處理 Enum 型別，包含各種映射策略、效能考量和實際應用場景。\n基本 Enum 映射 1. @Enumerated 註解 JPA 提供 @Enumerated 註解來處理 Enum 映射，支援兩種策略：\nEnumType.ORDINAL（數字映射） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 定義狀態列舉 public enum OrderStatus { PENDING, // 0 CONFIRMED, // 1 SHIPPED, // 2 DELIVERED, // 3 CANCELLED // 4 } // 實體類使用 @Entity @Table(name = \u0026#34;orders\u0026#34;) public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Enumerated(EnumType.ORDINAL) @Column(name = \u0026#34;status\u0026#34;, nullable = false) private OrderStatus status = OrderStatus.PENDING; // 其他屬性... } 資料庫儲存：\n1 2 3 4 5 6 7 CREATE TABLE orders ( id BIGINT PRIMARY KEY AUTO_INCREMENT, status TINYINT NOT NULL DEFAULT 0, -- 其他欄位 ); -- 儲存的值：0=PENDING, 1=CONFIRMED, 2=SHIPPED, 3=DELIVERED, 4=CANCELLED EnumType.STRING（字串映射） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Entity @Table(name = \u0026#34;orders\u0026#34;) public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Enumerated(EnumType.STRING) @Column(name = \u0026#34;status\u0026#34;, length = 20, nullable = false) private OrderStatus status = OrderStatus.PENDING; // 其他屬性... } 資料庫儲存：\n1 2 3 4 5 6 7 CREATE TABLE orders ( id BIGINT PRIMARY KEY AUTO_INCREMENT, status VARCHAR(20) NOT NULL DEFAULT \u0026#39;PENDING\u0026#39;, -- 其他欄位 ); -- 儲存的值：\u0026#39;PENDING\u0026#39;, \u0026#39;CONFIRMED\u0026#39;, \u0026#39;SHIPPED\u0026#39;, \u0026#39;DELIVERED\u0026#39;, \u0026#39;CANCELLED\u0026#39; 2. 映射策略比較 特性 ORDINAL STRING 儲存空間 小（1-4 bytes） 大（字串長度） 可讀性 差（數字） 好（文字） 順序變更風險 高（破壞性） 無 新增項目 只能追加 任意位置 資料庫查詢 快速 較慢 除錯友善 困難 容易 建議：生產環境通常使用 EnumType.STRING，因為其具備更好的可維護性和可讀性。\n進階 Enum 處理 1. 自訂 Enum 值 當需要更具語意的資料庫值時，可以為 Enum 添加自訂屬性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public enum OrderStatus { PENDING(\u0026#34;PND\u0026#34;, \u0026#34;訂單待處理\u0026#34;), CONFIRMED(\u0026#34;CNF\u0026#34;, \u0026#34;訂單已確認\u0026#34;), SHIPPED(\u0026#34;SHP\u0026#34;, \u0026#34;商品已出貨\u0026#34;), DELIVERED(\u0026#34;DLV\u0026#34;, \u0026#34;商品已送達\u0026#34;), CANCELLED(\u0026#34;CXL\u0026#34;, \u0026#34;訂單已取消\u0026#34;); private final String code; private final String description; OrderStatus(String code, String description) { this.code = code; this.description = description; } public String getCode() { return code; } public String getDescription() { return description; } // 從代碼查找 Enum public static OrderStatus fromCode(String code) { return Arrays.stream(values()) .filter(status -\u0026gt; status.code.equals(code)) .findFirst() .orElseThrow(() -\u0026gt; new IllegalArgumentException(\u0026#34;未知的訂單狀態代碼: \u0026#34; + code)); } // 取得所有代碼 public static List\u0026lt;String\u0026gt; getAllCodes() { return Arrays.stream(values()) .map(OrderStatus::getCode) .collect(Collectors.toList()); } } 2. 自訂 AttributeConverter 使用 JPA 2.1 的 @Converter 註解來實現自訂轉換：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Converter(autoApply = true) public class OrderStatusConverter implements AttributeConverter\u0026lt;OrderStatus, String\u0026gt; { @Override public String convertToDatabaseColumn(OrderStatus orderStatus) { if (orderStatus == null) { return null; } return orderStatus.getCode(); } @Override public OrderStatus convertToEntityAttribute(String code) { if (code == null || code.isEmpty()) { return null; } return OrderStatus.fromCode(code); } } 實體類使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Entity @Table(name = \u0026#34;orders\u0026#34;) public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Convert(converter = OrderStatusConverter.class) @Column(name = \u0026#34;status\u0026#34;, length = 3, nullable = false) private OrderStatus status = OrderStatus.PENDING; // 其他屬性... } 資料庫儲存結果：\n1 2 -- 儲存的值：\u0026#39;PND\u0026#39;, \u0026#39;CNF\u0026#39;, \u0026#39;SHP\u0026#39;, \u0026#39;DLV\u0026#39;, \u0026#39;CXL\u0026#39; INSERT INTO orders (status) VALUES (\u0026#39;PND\u0026#39;); 3. 通用 Enum 轉換器 建立通用的 Enum 轉換器基類：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public interface CodedEnum { String getCode(); static \u0026lt;T extends Enum\u0026lt;T\u0026gt; \u0026amp; CodedEnum\u0026gt; T fromCode(Class\u0026lt;T\u0026gt; enumClass, String code) { return Arrays.stream(enumClass.getEnumConstants()) .filter(e -\u0026gt; e.getCode().equals(code)) .findFirst() .orElseThrow(() -\u0026gt; new IllegalArgumentException( \u0026#34;未知的 \u0026#34; + enumClass.getSimpleName() + \u0026#34; 代碼: \u0026#34; + code)); } } // 通用轉換器基類 public abstract class CodedEnumConverter\u0026lt;T extends Enum\u0026lt;T\u0026gt; \u0026amp; CodedEnum\u0026gt; implements AttributeConverter\u0026lt;T, String\u0026gt; { private final Class\u0026lt;T\u0026gt; enumClass; protected CodedEnumConverter(Class\u0026lt;T\u0026gt; enumClass) { this.enumClass = enumClass; } @Override public String convertToDatabaseColumn(T attribute) { return attribute != null ? attribute.getCode() : null; } @Override public T convertToEntityAttribute(String dbData) { return dbData != null ? CodedEnum.fromCode(enumClass, dbData) : null; } } 具體實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 實作 CodedEnum 介面 public enum Priority implements CodedEnum { LOW(\u0026#34;L\u0026#34;), MEDIUM(\u0026#34;M\u0026#34;), HIGH(\u0026#34;H\u0026#34;), URGENT(\u0026#34;U\u0026#34;); private final String code; Priority(String code) { this.code = code; } @Override public String getCode() { return code; } } // 具體轉換器 @Converter(autoApply = true) public class PriorityConverter extends CodedEnumConverter\u0026lt;Priority\u0026gt; { public PriorityConverter() { super(Priority.class); } } 複雜應用場景 1. 多狀態 Enum 設計 設計包含狀態轉換邏輯的 Enum：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public enum OrderStatus implements CodedEnum { DRAFT(\u0026#34;DFT\u0026#34;, \u0026#34;草稿\u0026#34;, Set.of()), PENDING(\u0026#34;PND\u0026#34;, \u0026#34;待處理\u0026#34;, Set.of(DRAFT)), CONFIRMED(\u0026#34;CNF\u0026#34;, \u0026#34;已確認\u0026#34;, Set.of(PENDING)), PAID(\u0026#34;PAD\u0026#34;, \u0026#34;已付款\u0026#34;, Set.of(CONFIRMED)), SHIPPED(\u0026#34;SHP\u0026#34;, \u0026#34;已出貨\u0026#34;, Set.of(PAID)), DELIVERED(\u0026#34;DLV\u0026#34;, \u0026#34;已送達\u0026#34;, Set.of(SHIPPED)), CANCELLED(\u0026#34;CXL\u0026#34;, \u0026#34;已取消\u0026#34;, Set.of(DRAFT, PENDING, CONFIRMED, PAID)), REFUNDED(\u0026#34;RFD\u0026#34;, \u0026#34;已退款\u0026#34;, Set.of(PAID, SHIPPED, DELIVERED)); private final String code; private final String description; private final Set\u0026lt;OrderStatus\u0026gt; allowedPreviousStatuses; OrderStatus(String code, String description, Set\u0026lt;OrderStatus\u0026gt; allowedPreviousStatuses) { this.code = code; this.description = description; this.allowedPreviousStatuses = allowedPreviousStatuses; } @Override public String getCode() { return code; } public String getDescription() { return description; } // 檢查狀態轉換是否合法 public boolean canTransitionFrom(OrderStatus currentStatus) { return allowedPreviousStatuses.contains(currentStatus); } // 取得可轉換到的狀態 public Set\u0026lt;OrderStatus\u0026gt; getNextPossibleStatuses() { return Arrays.stream(values()) .filter(status -\u0026gt; status.canTransitionFrom(this)) .collect(Collectors.toSet()); } // 檢查是否為終結狀態 public boolean isFinalStatus() { return this == DELIVERED || this == CANCELLED || this == REFUNDED; } // 檢查是否可取消 public boolean isCancellable() { return CANCELLED.canTransitionFrom(this); } } 2. 業務邏輯整合 在 Service 層中整合狀態轉換邏輯：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @Service @Transactional public class OrderService { @Autowired private OrderRepository orderRepository; @Autowired private OrderStatusHistoryService statusHistoryService; public void updateOrderStatus(Long orderId, OrderStatus newStatus, String reason) { Order order = orderRepository.findById(orderId) .orElseThrow(() -\u0026gt; new EntityNotFoundException(\u0026#34;訂單不存在: \u0026#34; + orderId)); OrderStatus currentStatus = order.getStatus(); // 驗證狀態轉換 if (!newStatus.canTransitionFrom(currentStatus)) { throw new IllegalStateException(String.format( \u0026#34;無法從 %s 轉換到 %s\u0026#34;, currentStatus.getDescription(), newStatus.getDescription() )); } // 更新狀態 order.setStatus(newStatus); order.setLastModified(LocalDateTime.now()); // 記錄狀態變更歷史 statusHistoryService.recordStatusChange(orderId, currentStatus, newStatus, reason); // 觸發相關業務邏輯 handleStatusChange(order, currentStatus, newStatus); orderRepository.save(order); } private void handleStatusChange(Order order, OrderStatus from, OrderStatus to) { switch (to) { case CONFIRMED: // 發送確認郵件 emailService.sendOrderConfirmation(order); break; case SHIPPED: // 發送出貨通知 emailService.sendShippingNotification(order); // 減少庫存 inventoryService.decreaseStock(order.getItems()); break; case DELIVERED: // 發送送達通知 emailService.sendDeliveryNotification(order); break; case CANCELLED: // 恢復庫存 inventoryService.restoreStock(order.getItems()); // 處理退款 if (from == OrderStatus.PAID) { paymentService.processRefund(order); } break; } } // 批量狀態查詢 public List\u0026lt;Order\u0026gt; findOrdersByStatuses(Set\u0026lt;OrderStatus\u0026gt; statuses) { return orderRepository.findByStatusIn(statuses); } // 取得可操作的訂單 public List\u0026lt;Order\u0026gt; findOrdersReadyForShipping() { return orderRepository.findByStatus(OrderStatus.PAID); } } 3. 狀態歷史追蹤 建立狀態變更歷史表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Entity @Table(name = \u0026#34;order_status_history\u0026#34;) public class OrderStatusHistory { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = \u0026#34;order_id\u0026#34;, nullable = false) private Long orderId; @Convert(converter = OrderStatusConverter.class) @Column(name = \u0026#34;from_status\u0026#34;, length = 3) private OrderStatus fromStatus; @Convert(converter = OrderStatusConverter.class) @Column(name = \u0026#34;to_status\u0026#34;, length = 3, nullable = false) private OrderStatus toStatus; @Column(name = \u0026#34;reason\u0026#34;, length = 500) private String reason; @Column(name = \u0026#34;changed_by\u0026#34;) private String changedBy; @Column(name = \u0026#34;changed_at\u0026#34;, nullable = false) private LocalDateTime changedAt; // 建構子、Getter、Setter... } 4. Repository 查詢方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Repository public interface OrderRepository extends JpaRepository\u0026lt;Order, Long\u0026gt; { // 基本狀態查詢 List\u0026lt;Order\u0026gt; findByStatus(OrderStatus status); List\u0026lt;Order\u0026gt; findByStatusIn(Collection\u0026lt;OrderStatus\u0026gt; statuses); List\u0026lt;Order\u0026gt; findByStatusNot(OrderStatus status); // 複合查詢 List\u0026lt;Order\u0026gt; findByStatusAndCreatedAtBetween( OrderStatus status, LocalDateTime start, LocalDateTime end ); // 統計查詢 @Query(\u0026#34;SELECT o.status, COUNT(o) FROM Order o GROUP BY o.status\u0026#34;) List\u0026lt;Object[]\u0026gt; countOrdersByStatus(); // 自訂查詢 @Query(\u0026#34;SELECT o FROM Order o WHERE o.status IN :statuses AND o.totalAmount \u0026gt; :minAmount\u0026#34;) List\u0026lt;Order\u0026gt; findHighValueOrdersByStatuses( @Param(\u0026#34;statuses\u0026#34;) Collection\u0026lt;OrderStatus\u0026gt; statuses, @Param(\u0026#34;minAmount\u0026#34;) BigDecimal minAmount ); // 原生 SQL 查詢 @Query(value = \u0026#34;SELECT * FROM orders WHERE status IN :statusCodes AND DATE(created_at) = CURDATE()\u0026#34;, nativeQuery = true) List\u0026lt;Order\u0026gt; findTodayOrdersByStatusCodes(@Param(\u0026#34;statusCodes\u0026#34;) Collection\u0026lt;String\u0026gt; statusCodes); } 效能優化 1. 索引設計 1 2 3 4 5 6 7 8 9 -- 狀態欄位索引 CREATE INDEX idx_orders_status ON orders(status); -- 複合索引 CREATE INDEX idx_orders_status_created ON orders(status, created_at); -- 部分索引（針對特定狀態） CREATE INDEX idx_orders_active_status ON orders(status) WHERE status IN (\u0026#39;PND\u0026#39;, \u0026#39;CNF\u0026#39;, \u0026#39;PAD\u0026#39;, \u0026#39;SHP\u0026#39;); 2. 查詢優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Service public class OrderQueryService { // 使用 Specification 進行動態查詢 public Page\u0026lt;Order\u0026gt; findOrdersWithCriteria(OrderSearchCriteria criteria, Pageable pageable) { return orderRepository.findAll(Specification .where(hasStatus(criteria.getStatuses())) .and(createdBetween(criteria.getStartDate(), criteria.getEndDate())) .and(hasCustomer(criteria.getCustomerId())), pageable); } private static Specification\u0026lt;Order\u0026gt; hasStatus(Set\u0026lt;OrderStatus\u0026gt; statuses) { return (root, query, cb) -\u0026gt; statuses == null || statuses.isEmpty() ? cb.conjunction() : root.get(\u0026#34;status\u0026#34;).in(statuses); } // 快取常用統計 @Cacheable(\u0026#34;orderStatusStats\u0026#34;) public Map\u0026lt;OrderStatus, Long\u0026gt; getOrderStatusStatistics() { List\u0026lt;Object[]\u0026gt; results = orderRepository.countOrdersByStatus(); return results.stream() .collect(Collectors.toMap( row -\u0026gt; (OrderStatus) row[0], row -\u0026gt; (Long) row[1] )); } } 3. 快取策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Service public class OrderStatusCacheService { private final Cache\u0026lt;String, List\u0026lt;Order\u0026gt;\u0026gt; orderCache; public OrderStatusCacheService() { this.orderCache = Caffeine.newBuilder() .maximumSize(1000) .expireAfterWrite(Duration.ofMinutes(5)) .build(); } public List\u0026lt;Order\u0026gt; getCachedOrdersByStatus(OrderStatus status) { return orderCache.get(status.getCode(), code -\u0026gt; orderRepository.findByStatus(status)); } @EventListener public void handleOrderStatusChanged(OrderStatusChangedEvent event) { // 清除相關快取 orderCache.invalidate(event.getOldStatus().getCode()); orderCache.invalidate(event.getNewStatus().getCode()); } } 測試策略 1. 單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @ExtendWith(MockitoExtension.class) class OrderServiceTest { @Mock private OrderRepository orderRepository; @Mock private OrderStatusHistoryService statusHistoryService; @InjectMocks private OrderService orderService; @Test void testValidStatusTransition() { // Given Order order = createOrderWithStatus(OrderStatus.PENDING); when(orderRepository.findById(1L)).thenReturn(Optional.of(order)); // When orderService.updateOrderStatus(1L, OrderStatus.CONFIRMED, \u0026#34;客戶確認\u0026#34;); // Then assertEquals(OrderStatus.CONFIRMED, order.getStatus()); verify(statusHistoryService).recordStatusChange( eq(1L), eq(OrderStatus.PENDING), eq(OrderStatus.CONFIRMED), eq(\u0026#34;客戶確認\u0026#34;)); } @Test void testInvalidStatusTransition() { // Given Order order = createOrderWithStatus(OrderStatus.DELIVERED); when(orderRepository.findById(1L)).thenReturn(Optional.of(order)); // When \u0026amp; Then assertThatThrownBy(() -\u0026gt; orderService.updateOrderStatus(1L, OrderStatus.PENDING, \u0026#34;無效轉換\u0026#34;)) .isInstanceOf(IllegalStateException.class) .hasMessageContaining(\u0026#34;無法從\u0026#34;); } @Test void testOrderStatusEnumProperties() { // 測試狀態轉換邏輯 assertTrue(OrderStatus.CONFIRMED.canTransitionFrom(OrderStatus.PENDING)); assertFalse(OrderStatus.PENDING.canTransitionFrom(OrderStatus.DELIVERED)); // 測試終結狀態 assertTrue(OrderStatus.DELIVERED.isFinalStatus()); assertFalse(OrderStatus.PENDING.isFinalStatus()); // 測試可取消狀態 assertTrue(OrderStatus.PENDING.isCancellable()); assertFalse(OrderStatus.DELIVERED.isCancellable()); } } 2. 整合測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @SpringBootTest @TestPropertySource(properties = \u0026#34;spring.jpa.hibernate.ddl-auto=create-drop\u0026#34;) class OrderStatusIntegrationTest { @Autowired private OrderService orderService; @Autowired private OrderRepository orderRepository; @Test @Transactional void testCompleteOrderWorkflow() { // 建立訂單 Order order = createTestOrder(); order = orderRepository.save(order); // 確認訂單 orderService.updateOrderStatus(order.getId(), OrderStatus.CONFIRMED, \u0026#34;自動確認\u0026#34;); // 付款 orderService.updateOrderStatus(order.getId(), OrderStatus.PAID, \u0026#34;信用卡付款\u0026#34;); // 出貨 orderService.updateOrderStatus(order.getId(), OrderStatus.SHIPPED, \u0026#34;物流出貨\u0026#34;); // 送達 orderService.updateOrderStatus(order.getId(), OrderStatus.DELIVERED, \u0026#34;客戶簽收\u0026#34;); // 驗證最終狀態 Order finalOrder = orderRepository.findById(order.getId()).orElseThrow(); assertEquals(OrderStatus.DELIVERED, finalOrder.getStatus()); } @Test void testDatabaseEnumPersistence() { // 測試 Enum 值正確儲存和讀取 Order order = createTestOrder(); order.setStatus(OrderStatus.CONFIRMED); order = orderRepository.save(order); // 清除 JPA 快取 orderRepository.flush(); entityManager.clear(); // 重新讀取 Order reloadedOrder = orderRepository.findById(order.getId()).orElseThrow(); assertEquals(OrderStatus.CONFIRMED, reloadedOrder.getStatus()); } } 最佳實踐與建議 1. 設計原則 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // ✅ 好的實踐：使用有意義的名稱和描述 public enum UserRole implements CodedEnum { ADMIN(\u0026#34;ADM\u0026#34;, \u0026#34;系統管理員\u0026#34;, Set.of(\u0026#34;*\u0026#34;)), MANAGER(\u0026#34;MGR\u0026#34;, \u0026#34;部門主管\u0026#34;, Set.of(\u0026#34;USER_MANAGE\u0026#34;, \u0026#34;REPORT_VIEW\u0026#34;)), USER(\u0026#34;USR\u0026#34;, \u0026#34;一般使用者\u0026#34;, Set.of(\u0026#34;PROFILE_EDIT\u0026#34;)); private final String code; private final String description; private final Set\u0026lt;String\u0026gt; permissions; // 建構子和方法... } // ❌ 避免：過於簡單或不清楚的列舉 public enum Status { A, B, C, D // 不清楚的含義 } 2. 版本管理策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 支援向後相容的 Enum 設計 public enum OrderStatus implements CodedEnum { // 新版本可以安全添加新狀態 PENDING(\u0026#34;PND\u0026#34;, \u0026#34;待處理\u0026#34;), CONFIRMED(\u0026#34;CNF\u0026#34;, \u0026#34;已確認\u0026#34;), SHIPPED(\u0026#34;SHP\u0026#34;, \u0026#34;已出貨\u0026#34;), DELIVERED(\u0026#34;DLV\u0026#34;, \u0026#34;已送達\u0026#34;), CANCELLED(\u0026#34;CXL\u0026#34;, \u0026#34;已取消\u0026#34;), // 新增狀態（向後相容） PARTIAL_SHIPPED(\u0026#34;PSH\u0026#34;, \u0026#34;部分出貨\u0026#34;), // v2.0 新增 RETURNED(\u0026#34;RET\u0026#34;, \u0026#34;已退貨\u0026#34;); // v2.1 新增 // 處理未知狀態的安全機制 public static OrderStatus fromCodeSafely(String code, OrderStatus defaultValue) { try { return fromCode(code); } catch (IllegalArgumentException e) { logger.warn(\u0026#34;遇到未知的訂單狀態代碼: {}, 使用預設值: {}\u0026#34;, code, defaultValue); return defaultValue; } } } 3. 國際化支援 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Component public class OrderStatusI18nService { @Autowired private MessageSource messageSource; public String getLocalizedDescription(OrderStatus status, Locale locale) { String key = \u0026#34;order.status.\u0026#34; + status.name().toLowerCase(); return messageSource.getMessage(key, null, status.getDescription(), locale); } public Map\u0026lt;OrderStatus, String\u0026gt; getAllLocalizedStatuses(Locale locale) { return Arrays.stream(OrderStatus.values()) .collect(Collectors.toMap( status -\u0026gt; status, status -\u0026gt; getLocalizedDescription(status, locale) )); } } 監控與維護 1. 狀態分佈監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Component public class OrderStatusMetrics { private final MeterRegistry meterRegistry; private final OrderRepository orderRepository; public OrderStatusMetrics(MeterRegistry meterRegistry, OrderRepository orderRepository) { this.meterRegistry = meterRegistry; this.orderRepository = orderRepository; // 註冊度量 Gauge.builder(\u0026#34;orders.by.status\u0026#34;) .description(\u0026#34;訂單狀態分佈\u0026#34;) .tag(\u0026#34;status\u0026#34;, \u0026#34;all\u0026#34;) .register(meterRegistry, this, OrderStatusMetrics::getTotalOrderCount); } @EventListener public void handleOrderStatusChanged(OrderStatusChangedEvent event) { // 記錄狀態轉換次數 Counter.builder(\u0026#34;order.status.transitions\u0026#34;) .description(\u0026#34;訂單狀態轉換次數\u0026#34;) .tag(\u0026#34;from\u0026#34;, event.getOldStatus().getCode()) .tag(\u0026#34;to\u0026#34;, event.getNewStatus().getCode()) .register(meterRegistry) .increment(); } private double getTotalOrderCount() { return orderRepository.count(); } } 2. 效能監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Aspect @Component public class OrderStatusPerformanceAspect { @Around(\u0026#34;execution(* com.example.service.OrderService.updateOrderStatus(..))\u0026#34;) public Object measureStatusUpdate(ProceedingJoinPoint joinPoint) throws Throwable { Timer.Sample sample = Timer.start(meterRegistry); try { return joinPoint.proceed(); } finally { sample.stop(Timer.builder(\u0026#34;order.status.update.duration\u0026#34;) .description(\u0026#34;訂單狀態更新耗時\u0026#34;) .register(meterRegistry)); } } } 總結 JPA 中的 Enum 處理是企業級應用程式開發的重要技能。透過本文的深入探討，我們了解到：\n核心要點 選擇適當的映射策略：生產環境建議使用 EnumType.STRING 或自訂轉換器 設計可擴展的 Enum：考慮未來需求，支援狀態轉換邏輯 效能優化：合理使用索引、快取和查詢優化 測試完整性：涵蓋狀態轉換邏輯和持久化測試 監控維護：建立適當的監控機制 實際應用建議 對於簡單狀態，使用基本的 @Enumerated(EnumType.STRING) 對於複雜業務邏輯，實作 CodedEnum 介面和自訂轉換器 建立狀態轉換規則和歷史追蹤機制 考慮國際化和向後相容性 實施適當的監控和效能優化策略 正確處理 Enum 型別不僅能提升程式碼的可讀性和維護性，還能確保資料的一致性和業務邏輯的正確執行。\n參考資料 JPA 2.2 Specification Hibernate ORM Documentation Spring Data JPA Reference Java Enum Best Practices Database Design Patterns ","permalink":"https://xinqilin.github.io/post/backend/ormenumtype/","tags":["Java","JPA","Hibernate","Enum","ORM","Database","Spring","MySQL"],"title":"JPA Enum 型別處理完整指南：映射策略與最佳實踐"},{"content":"概述 xargs（eXtended ARGuments）是 Unix/Linux 系統中的強大工具，用於從標準輸入讀取資料並將其作為參數傳遞給其他命令。它解決了命令行參數長度限制的問題，並提供了並行處理能力，是管道操作和批次處理的重要工具。\n核心特徵 參數轉換：將輸入流轉換為命令參數 批次處理：支援分批執行大量操作 並行執行：可同時執行多個程序提升效率 安全處理：正確處理包含空格的檔案名稱 靈活控制：豐富的選項控制執行行為 基本語法 1 xargs [選項] [命令 [初始參數]] 工作原理 1 2 3 4 5 # 基本概念 command1 | xargs command2 # 等同於 command2 arg1 arg2 arg3 ... 簡單範例 1 2 3 4 5 6 7 8 9 10 11 # 預設行為（使用 echo） echo \u0026#34;a b c d\u0026#34; | xargs # 輸出: a b c d # 指定命令 echo \u0026#34;file1 file2 file3\u0026#34; | xargs ls -l # 從檔案讀取 cat filelist.txt | xargs rm -f # 與 find 組合 find . -name \u0026#34;*.tmp\u0026#34; | xargs rm -f 核心選項詳解 基本控制選項 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # -t (--verbose) - 顯示執行的命令 echo \u0026#34;a b c\u0026#34; | xargs -t rm # 輸出: rm a b c # 然後執行 rm a b c # -p (--interactive) - 交互式確認 echo \u0026#34;file1 file2\u0026#34; | xargs -p rm # 輸出: rm file1 file2?... # 等待使用者輸入 y/n # -r (--no-run-if-empty) - 空輸入時不執行 echo \u0026#34;\u0026#34; | xargs -r echo \u0026#34;執行了\u0026#34; # 不會執行 echo \u0026#34;\u0026#34; | xargs echo \u0026#34;執行了\u0026#34; # 會執行 # --help - 顯示幫助資訊 xargs --help 參數分組選項 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # -n max-args - 限制每次執行的參數數量 echo \u0026#34;1 2 3 4 5 6\u0026#34; | xargs -n 2 echo # 輸出: # 1 2 # 3 4 # 5 6 # -L max-lines - 限制每次處理的行數 printf \u0026#34;a\\nb\\nc\\nd\\n\u0026#34; | xargs -L 2 echo # 輸出: # a b # c d # -s max-chars - 限制命令行長度 echo \u0026#34;very long arguments here\u0026#34; | xargs -s 20 echo 分隔符處理 1 2 3 4 5 6 7 8 9 # -d delimiter - 自訂分隔符 echo \u0026#34;a,b,c,d\u0026#34; | xargs -d, echo # 輸出: a b c d # -0 (--null) - 使用 null 字元作分隔符 find . -name \u0026#34;*.txt\u0026#34; -print0 | xargs -0 ls -l # 處理包含空格的檔案名 echo -e \u0026#34;file 1.txt\\nfile 2.txt\u0026#34; | xargs -d\u0026#39;\\n\u0026#39; ls -l 替換字串選項 1 2 3 4 5 6 7 8 # -I replace-str - 指定替換字串 echo \u0026#34;file1 file2 file3\u0026#34; | xargs -I {} cp {} {}.backup # -i 或 -I{} - 使用 {} 作為替換字串 ls *.txt | xargs -I{} cp {} backup/{} # 複雜替換範例 find . -name \u0026#34;*.log\u0026#34; | xargs -I{} sh -c \u0026#39;echo \u0026#34;Processing: {}\u0026#34;; gzip {}\u0026#39; 並行處理選項 1 2 3 4 5 6 7 8 9 # -P max-procs - 並行執行 echo \u0026#34;1 2 3 4 5\u0026#34; | xargs -n 1 -P 3 sleep # 同時執行最多 3 個 sleep 命令 # -P 0 - 無限制並行 seq 1 10 | xargs -n 1 -P 0 echo # 實際並行範例 find . -name \u0026#34;*.jpg\u0026#34; | xargs -n 1 -P 4 -I{} convert {} {}.thumb.jpg 實戰應用場景 1. 檔案管理操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 批次刪除檔案 find /tmp -name \u0026#34;*.tmp\u0026#34; -mtime +7 | xargs rm -f # 批次複製檔案 ls *.txt | xargs -I{} cp {} backup/ # 批次移動檔案 find . -name \u0026#34;*.old\u0026#34; | xargs -I{} mv {} archive/ # 批次重命名 ls *.jpeg | xargs -I{} sh -c \u0026#39;mv \u0026#34;$1\u0026#34; \u0026#34;${1%.jpeg}.jpg\u0026#34;\u0026#39; _ {} # 建立多個目錄 echo \u0026#34;dir1 dir2 dir3\u0026#34; | xargs mkdir -p # 修改檔案權限 find /var/www -name \u0026#34;*.php\u0026#34; | xargs chmod 644 find /var/www -type d | xargs chmod 755 # 批次壓縮檔案 find . -name \u0026#34;*.log\u0026#34; -size +100M | xargs -I{} gzip {} 2. 文本處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 批次搜尋文本 find . -name \u0026#34;*.txt\u0026#34; | xargs grep -l \u0026#34;pattern\u0026#34; # 批次替換文本 find . -name \u0026#34;*.conf\u0026#34; | xargs sed -i \u0026#39;s/old/new/g\u0026#39; # 統計行數 find . -name \u0026#34;*.py\u0026#34; | xargs wc -l # 批次編碼轉換 find . -name \u0026#34;*.txt\u0026#34; | xargs -I{} iconv -f gbk -t utf8 {} -o {}.utf8 # 批次格式化程式碼 find . -name \u0026#34;*.js\u0026#34; | xargs prettier --write # 批次檢查語法 find . -name \u0026#34;*.sh\u0026#34; | xargs -I{} bash -n {} 3. 系統管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 批次殺死程序 ps aux | grep \u0026#34;process_name\u0026#34; | awk \u0026#39;{print $2}\u0026#39; | xargs kill # 批次服務重啟 echo \u0026#34;nginx apache2 mysql\u0026#34; | xargs -n 1 systemctl restart # 批次安裝軟體包 cat package_list.txt | xargs apt-get install -y # 磁碟使用統計 find /var/log -name \u0026#34;*.log\u0026#34; | xargs du -sh # 批次下載檔案 cat urls.txt | xargs -n 1 -P 5 wget # 批次備份 echo \u0026#34;/etc /var/log /home\u0026#34; | xargs -I{} tar -czf {//}.tar.gz {} 4. 開發與部署 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 批次編譯 find . -name \u0026#34;*.c\u0026#34; | xargs gcc -o output # 批次測試 find . -name \u0026#34;*_test.py\u0026#34; | xargs -I{} python {} # 批次部署 cat server_list.txt | xargs -I{} scp deploy.sh user@{}:/tmp/ # 批次執行遠程命令 cat servers.txt | xargs -I{} ssh {} \u0026#34;uptime\u0026#34; # 批次 Git 操作 find . -name \u0026#34;.git\u0026#34; -type d | xargs -I{} sh -c \u0026#39;cd {} \u0026amp;\u0026amp; git pull\u0026#39; # 批次建構 Docker 映像 ls */Dockerfile | xargs -I{} sh -c \u0026#39;cd $(dirname {}) \u0026amp;\u0026amp; docker build -t $(basename $(pwd)) .\u0026#39; 5. 監控與日誌 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 批次監控檔案變化 find /var/log -name \u0026#34;*.log\u0026#34; | xargs -I{} tail -f {} # 批次日誌分析 find . -name \u0026#34;access.log*\u0026#34; | xargs zcat | grep \u0026#34;ERROR\u0026#34; # 批次清理日誌 find /var/log -name \u0026#34;*.log\u0026#34; -size +100M | xargs truncate -s 0 # 系統資訊收集 echo \u0026#34;/proc/cpuinfo /proc/meminfo /proc/loadavg\u0026#34; | xargs -I{} sh -c \u0026#39;echo \u0026#34;=== {} ===\u0026#34;; cat {}\u0026#39; # 批次檢查服務狀態 echo \u0026#34;nginx mysql redis\u0026#34; | xargs -I{} systemctl status {} 進階技巧 1. 複雜命令組合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 多命令執行 find . -name \u0026#34;*.log\u0026#34; | xargs -I{} sh -c \u0026#39;echo \u0026#34;Processing {}\u0026#34;; wc -l {}; echo \u0026#34;Done\u0026#34;\u0026#39; # 條件執行 find . -name \u0026#34;*.txt\u0026#34; | xargs -I{} sh -c \u0026#39;if [ -s \u0026#34;{}\u0026#34; ]; then echo \u0026#34;Non-empty: {}\u0026#34;; fi\u0026#39; # 錯誤處理 find . -name \u0026#34;*.sh\u0026#34; | xargs -I{} sh -c \u0026#39;bash -n \u0026#34;{}\u0026#34; || echo \u0026#34;Syntax error in {}\u0026#34;\u0026#39; # 結果收集 find . -name \u0026#34;*.py\u0026#34; | xargs -I{} sh -c \u0026#39;echo \u0026#34;{}: $(wc -l \u0026lt; \u0026#34;{}\u0026#34;)\u0026#34;\u0026#39; | sort -k2 -nr # 管道組合 find . -name \u0026#34;*.log\u0026#34; | xargs -I{} sh -c \u0026#39;cat \u0026#34;{}\u0026#34; | grep ERROR | wc -l\u0026#39; | awk \u0026#39;{sum+=$1} END {print sum}\u0026#39; 2. 並行處理最佳化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # CPU 密集型任務 seq 1 100 | xargs -n 1 -P $(nproc) sh -c \u0026#39;echo \u0026#34;Processing $1\u0026#34;; sleep 1; echo \u0026#34;Done $1\u0026#34;\u0026#39; _ # I/O 密集型任務 cat urls.txt | xargs -n 1 -P 10 -I{} sh -c \u0026#39;echo \u0026#34;Downloading {}\u0026#34;; wget -q {}\u0026#39; # 記憶體管理 find . -name \u0026#34;*.big\u0026#34; | xargs -n 1 -P 2 -I{} process_large_file {} # 並行日誌處理 find /var/log -name \u0026#34;*.log\u0026#34; | xargs -n 1 -P 4 -I{} sh -c \u0026#39;gzip \u0026#34;{}\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;Compressed {}\u0026#34;\u0026#39; # 負載均衡 seq 1 1000 | xargs -n 10 -P 8 -I{} process_batch {} 3. 安全性考慮 1 2 3 4 5 6 7 8 9 10 11 # 處理特殊字元 find . -name \u0026#34;*.txt\u0026#34; -print0 | xargs -0 ls -l # 避免命令注入 echo \u0026#34;file; rm -rf /\u0026#34; | xargs -I{} sh -c \u0026#39;ls \u0026#34;$1\u0026#34;\u0026#39; _ {} # 參數驗證 cat files.txt | xargs -I{} sh -c \u0026#39;if [ -f \u0026#34;$1\u0026#34; ]; then process \u0026#34;$1\u0026#34;; fi\u0026#39; _ {} # 路徑安全 find . -name \u0026#34;*.conf\u0026#34; | xargs -I{} sh -c \u0026#39;realpath \u0026#34;$1\u0026#34; | grep \u0026#34;^/safe/path\u0026#34; \u0026amp;\u0026amp; process \u0026#34;$1\u0026#34;\u0026#39; _ {} 4. 效能優化 1 2 3 4 5 6 7 8 9 10 11 # 批次大小優化 find . -name \u0026#34;*.txt\u0026#34; | xargs -n 100 process_files # 記憶體限制 find . -name \u0026#34;*.log\u0026#34; | xargs -s 4096 process_with_memory_limit # 並行數調整 find . -name \u0026#34;*.jpg\u0026#34; | xargs -n 1 -P $(nproc) optimize_image # 緩衝區優化 find . -name \u0026#34;*.data\u0026#34; | xargs -n 50 -P 4 process_data_batch 錯誤處理與除錯 1. 常見問題 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 問題：參數過長 # 解決：使用 -s 限制或分批處理 find . -name \u0026#34;*.txt\u0026#34; | xargs -s 1000 rm # 問題：檔案名包含空格 # 解決：使用 -0 和 -print0 find . -name \u0026#34;*.txt\u0026#34; -print0 | xargs -0 rm # 問題：空輸入執行 # 解決：使用 -r 選項 echo \u0026#34;\u0026#34; | xargs -r echo \u0026#34;不會執行\u0026#34; # 問題：並行競爭 # 解決：使用適當的鎖機制 find . -name \u0026#34;*.log\u0026#34; | xargs -n 1 -P 4 -I{} flock /tmp/lock process {} 2. 除錯技巧 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 使用 -t 查看執行命令 find . -name \u0026#34;*.txt\u0026#34; | xargs -t rm # 使用 -p 交互式確認 find . -name \u0026#34;*.tmp\u0026#34; | xargs -p rm # 逐步測試 echo \u0026#34;test1 test2\u0026#34; | xargs -n 1 echo # 檢查參數 find . -name \u0026#34;*.txt\u0026#34; | xargs -I{} echo \u0026#34;Will process: {}\u0026#34; # 錯誤日誌 find . -name \u0026#34;*.sh\u0026#34; | xargs -I{} sh -c \u0026#39;bash -n \u0026#34;{}\u0026#34; 2\u0026gt;\u0026gt;error.log || echo \u0026#34;Error in {}\u0026#34;\u0026#39; 3. 效能監控 1 2 3 4 5 6 7 8 9 # 執行時間測量 time find . -name \u0026#34;*.txt\u0026#34; | xargs wc -l # 並行效能比較 time seq 1 100 | xargs -n 1 sleep 0.1 # 串行 time seq 1 100 | xargs -n 1 -P 10 sleep 0.1 # 並行 # 資源使用監控 find . -name \u0026#34;*.big\u0026#34; | xargs -n 1 -P 4 -I{} sh -c \u0026#39;echo \u0026#34;Processing {}\u0026#34;; /usr/bin/time -v process {}\u0026#39; 與其他工具整合 1. 與 find 組合 1 2 3 4 5 6 7 8 9 10 11 # 基本組合 find /path -name \u0026#34;pattern\u0026#34; | xargs command # 安全處理 find /path -name \u0026#34;pattern\u0026#34; -print0 | xargs -0 command # 條件過濾 find /path -name \u0026#34;*.txt\u0026#34; -size +1M | xargs -I{} sh -c \u0026#39;echo \u0026#34;Large file: {}\u0026#34;\u0026#39; # 複雜搜尋 find /path -type f -mtime -7 \\( -name \u0026#34;*.log\u0026#34; -o -name \u0026#34;*.txt\u0026#34; \\) | xargs grep \u0026#34;pattern\u0026#34; 2. 與 grep 組合 1 2 3 4 5 6 7 8 9 10 11 # 檔案內容搜尋 find . -name \u0026#34;*.py\u0026#34; | xargs grep -l \u0026#34;import numpy\u0026#34; # 多模式搜尋 find . -name \u0026#34;*.conf\u0026#34; | xargs grep -E \u0026#34;(error|warning|critical)\u0026#34; # 統計匹配 find . -name \u0026#34;*.log\u0026#34; | xargs grep \u0026#34;ERROR\u0026#34; | wc -l # 結果處理 find . -name \u0026#34;*.txt\u0026#34; | xargs grep -H \u0026#34;pattern\u0026#34; | cut -d: -f1 | sort | uniq 3. 與 ssh 組合 1 2 3 4 5 6 7 8 9 10 11 # 遠程並行執行 cat servers.txt | xargs -n 1 -P 5 -I{} ssh {} \u0026#34;command\u0026#34; # 批次檔案傳輸 cat servers.txt | xargs -I{} scp file.txt user@{}:/tmp/ # 遠程監控 cat servers.txt | xargs -I{} ssh {} \u0026#34;uptime; df -h\u0026#34; # 分布式處理 cat servers.txt | xargs -n 1 -P 10 -I{} ssh {} \u0026#34;process_data input.txt\u0026#34; 實用腳本範例 1. 批次檔案處理腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/bin/bash # batch_process.sh - 批次處理檔案 SCRIPT_DIR=\u0026#34;$(cd \u0026#34;$(dirname \u0026#34;${BASH_SOURCE[0]}\u0026#34;)\u0026#34; \u0026amp;\u0026amp; pwd)\u0026#34; INPUT_DIR=\u0026#34;${1:-./input}\u0026#34; OUTPUT_DIR=\u0026#34;${2:-./output}\u0026#34; MAX_PARALLEL=\u0026#34;${3:-4}\u0026#34; # 建立輸出目錄 mkdir -p \u0026#34;$OUTPUT_DIR\u0026#34; # 批次處理 find \u0026#34;$INPUT_DIR\u0026#34; -name \u0026#34;*.txt\u0026#34; -print0 | \\ xargs -0 -n 1 -P \u0026#34;$MAX_PARALLEL\u0026#34; -I{} \\ sh -c \u0026#39; input_file=\u0026#34;$1\u0026#34; output_file=\u0026#34;\u0026#39;\u0026#34;$OUTPUT_DIR\u0026#34;\u0026#39;/$(basename \u0026#34;$1\u0026#34; .txt).processed.txt\u0026#34; echo \u0026#34;Processing: $input_file\u0026#34; # 處理邏輯 sed \u0026#34;s/old/new/g\u0026#34; \u0026#34;$input_file\u0026#34; \u0026gt; \u0026#34;$output_file\u0026#34; echo \u0026#34;Completed: $output_file\u0026#34; \u0026#39; _ {} echo \u0026#34;批次處理完成\u0026#34; 2. 系統清理腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #!/bin/bash # system_cleanup.sh - 系統清理腳本 LOG_FILE=\u0026#34;/var/log/cleanup.log\u0026#34; DRY_RUN=\u0026#34;${1:-false}\u0026#34; log() { echo \u0026#34;$(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;) - $1\u0026#34; | tee -a \u0026#34;$LOG_FILE\u0026#34; } cleanup_logs() { log \u0026#34;開始清理日誌檔案\u0026#34; if [ \u0026#34;$DRY_RUN\u0026#34; = \u0026#34;true\u0026#34; ]; then find /var/log -name \u0026#34;*.log\u0026#34; -size +100M | xargs -I{} echo \u0026#34;Will compress: {}\u0026#34; else find /var/log -name \u0026#34;*.log\u0026#34; -size +100M | \\ xargs -n 1 -P 4 -I{} sh -c \u0026#39;gzip \u0026#34;$1\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;Compressed: $1\u0026#34;\u0026#39; _ {} | \\ tee -a \u0026#34;$LOG_FILE\u0026#34; fi } cleanup_temp() { log \u0026#34;開始清理臨時檔案\u0026#34; if [ \u0026#34;$DRY_RUN\u0026#34; = \u0026#34;true\u0026#34; ]; then find /tmp -type f -mtime +7 | xargs -I{} echo \u0026#34;Will remove: {}\u0026#34; else find /tmp -type f -mtime +7 | \\ xargs -r rm -f fi } cleanup_cache() { log \u0026#34;開始清理快取檔案\u0026#34; if [ \u0026#34;$DRY_RUN\u0026#34; = \u0026#34;true\u0026#34; ]; then find /var/cache -name \u0026#34;*.cache\u0026#34; -mtime +30 | xargs -I{} echo \u0026#34;Will remove: {}\u0026#34; else find /var/cache -name \u0026#34;*.cache\u0026#34; -mtime +30 | \\ xargs -r rm -f fi } # 主執行 log \u0026#34;開始系統清理 (DRY_RUN: $DRY_RUN)\u0026#34; cleanup_logs cleanup_temp cleanup_cache log \u0026#34;系統清理完成\u0026#34; 3. 並行下載腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #!/bin/bash # parallel_download.sh - 並行下載腳本 URL_FILE=\u0026#34;${1:-urls.txt}\u0026#34; DOWNLOAD_DIR=\u0026#34;${2:-./downloads}\u0026#34; MAX_PARALLEL=\u0026#34;${3:-5}\u0026#34; TIMEOUT=\u0026#34;${4:-30}\u0026#34; # 檢查輸入檔案 if [ ! -f \u0026#34;$URL_FILE\u0026#34; ]; then echo \u0026#34;錯誤：找不到 URL 檔案 $URL_FILE\u0026#34; exit 1 fi # 建立下載目錄 mkdir -p \u0026#34;$DOWNLOAD_DIR\u0026#34; # 並行下載 cat \u0026#34;$URL_FILE\u0026#34; | \\ xargs -n 1 -P \u0026#34;$MAX_PARALLEL\u0026#34; -I{} \\ sh -c \u0026#39; url=\u0026#34;$1\u0026#34; dir=\u0026#34;$2\u0026#34; timeout=\u0026#34;$3\u0026#34; filename=$(basename \u0026#34;$url\u0026#34;) output_path=\u0026#34;$dir/$filename\u0026#34; echo \u0026#34;開始下載: $url\u0026#34; if timeout \u0026#34;$timeout\u0026#34; wget -q -O \u0026#34;$output_path\u0026#34; \u0026#34;$url\u0026#34;; then echo \u0026#34;下載成功: $filename\u0026#34; else echo \u0026#34;下載失敗: $url\u0026#34; rm -f \u0026#34;$output_path\u0026#34; fi \u0026#39; _ {} \u0026#34;$DOWNLOAD_DIR\u0026#34; \u0026#34;$TIMEOUT\u0026#34; echo \u0026#34;下載任務完成\u0026#34; # 統計結果 total_files=$(wc -l \u0026lt; \u0026#34;$URL_FILE\u0026#34;) downloaded_files=$(find \u0026#34;$DOWNLOAD_DIR\u0026#34; -type f | wc -l) echo \u0026#34;總計: $total_files 個檔案，成功下載: $downloaded_files 個檔案\u0026#34; 效能最佳化 1. 並行度調整 1 2 3 4 5 6 7 8 9 10 11 # CPU 綁定任務 CPU_CORES=$(nproc) find . -name \u0026#34;*.c\u0026#34; | xargs -n 1 -P \u0026#34;$CPU_CORES\u0026#34; gcc -c # I/O 綁定任務 IO_PARALLEL=$(($(nproc) * 2)) cat urls.txt | xargs -n 1 -P \u0026#34;$IO_PARALLEL\u0026#34; wget # 混合負載 MIXED_PARALLEL=$(($(nproc) + 2)) find . -name \u0026#34;*.log\u0026#34; | xargs -n 1 -P \u0026#34;$MIXED_PARALLEL\u0026#34; process_log 2. 記憶體管理 1 2 3 4 5 6 7 8 9 10 11 # 限制批次大小 find . -name \u0026#34;*.big\u0026#34; | xargs -n 1 process_large_file # 限制命令行長度 find . -name \u0026#34;*.txt\u0026#34; | xargs -s 4096 process_files # 分段處理 find . -name \u0026#34;*.data\u0026#34; | split -l 1000 - batch_ for batch in batch_*; do cat \u0026#34;$batch\u0026#34; | xargs -n 10 -P 4 process_data done 3. 網路優化 1 2 3 4 5 6 7 8 # 連接池 cat servers.txt | xargs -n 1 -P 10 -I{} ssh -o ControlMaster=auto -o ControlPath=/tmp/ssh-%r@%h:%p {} \u0026#34;command\u0026#34; # 重試機制 cat urls.txt | xargs -n 1 -I{} sh -c \u0026#39;for i in {1..3}; do wget \u0026#34;{}\u0026#34; \u0026amp;\u0026amp; break; sleep 5; done\u0026#39; # 頻寬限制 cat large_files.txt | xargs -n 1 -P 2 -I{} rsync --bwlimit=1000 {} destination/ 總結 核心優勢 參數處理：解決命令行參數長度限制 批次操作：高效處理大量檔案和資料 並行執行：充分利用多核心系統資源 管道友好：與其他 Unix 工具完美整合 靈活控制：豐富的選項滿足各種需求 最佳實踐 安全第一：處理包含空格的檔案名使用 -0 和 -print0 適當並行：根據任務類型調整並行度 錯誤處理：使用 -r 避免空輸入執行 測試先行：使用 -t 和 -p 選項測試命令 效能監控：測量並優化批次大小和並行度 常用模式記憶 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 基本模式 find . -name \u0026#34;pattern\u0026#34; | xargs command # 安全模式 find . -name \u0026#34;pattern\u0026#34; -print0 | xargs -0 command # 並行模式 command | xargs -n 1 -P 4 process # 替換模式 echo \u0026#34;files\u0026#34; | xargs -I{} cp {} backup/{} # 交互模式 find . -name \u0026#34;*.tmp\u0026#34; | xargs -p rm xargs 是命令行批次處理和並行執行的瑞士軍刀，掌握其核心概念和常用技巧，能夠大幅提升 Linux 系統管理和自動化任務的效率。記住：合理使用並行處理能夠顯著提升效能，但要注意資源管理和錯誤處理。\n參考資料 GNU Findutils Manual - xargs Linux man xargs Advanced Bash-Scripting Guide Unix Power Tools ","permalink":"https://xinqilin.github.io/post/tools/xargs/","tags":["Linux","Xargs","Command Line","Parallel Processing","Pipe","Shell","Unix"],"title":"Xargs 命令完整指南：Linux 參數處理與並行執行的強大工具"},{"content":"概述 find 是 Linux/Unix 系統中最強大且最常用的檔案搜尋命令之一。它不僅能夠根據各種條件搜尋檔案和目錄，還能對搜尋結果執行各種操作，是系統管理員和開發者必備的核心工具。\n核心特徵 遞歸搜尋：可深入子目錄進行搜尋 多重條件：支援檔名、類型、大小、時間等多種搜尋條件 動作執行：可對搜尋結果執行各種操作 邏輯組合：支援 AND、OR、NOT 等邏輯運算 高效能：針對大型檔案系統優化 基本語法 1 find [搜尋路徑] [搜尋條件] [動作] 基本使用範例 1 2 3 4 5 6 7 8 9 10 11 # 在當前目錄搜尋檔案 find . -name \u0026#34;test.txt\u0026#34; # 在指定目錄搜尋 find /home/user -name \u0026#34;*.log\u0026#34; # 忽略大小寫搜尋 find . -iname \u0026#34;README.md\u0026#34; # 搜尋多個目錄 find /var/log /tmp -name \u0026#34;*.tmp\u0026#34; 依據檔案名稱搜尋 基本檔名搜尋 1 2 3 4 5 6 7 8 9 10 11 # 精確檔名匹配 find /home -name \u0026#34;config.conf\u0026#34; # 萬用字元搜尋 find . -name \u0026#34;*.txt\u0026#34; # 所有 .txt 檔案 find . -name \u0026#34;test*\u0026#34; # 以 test 開頭的檔案 find . -name \u0026#34;*backup*\u0026#34; # 包含 backup 的檔案 # 忽略大小寫 find . -iname \u0026#34;*.PDF\u0026#34; # 不分大小寫搜尋 PDF 檔案 find . -iname \u0026#34;readme*\u0026#34; # 不分大小寫搜尋 readme 開頭的檔案 進階檔名搜尋 1 2 3 4 5 6 7 8 9 10 11 # 使用正規表達式 find . -regex \u0026#34;.*\\.\\(jpg\\|png\\|gif\\)$\u0026#34; # 搜尋圖片檔案 find . -iregex \u0026#34;.*\\.\\(mp3\\|mp4\\|avi\\)$\u0026#34; # 不分大小寫搜尋媒體檔案 # 排除特定檔案 find . -name \u0026#34;*.txt\u0026#34; ! -name \u0026#34;temp*\u0026#34; # 搜尋 txt 但排除 temp 開頭 find . ! -name \u0026#34;.*\u0026#34; # 排除隱藏檔案 # 多個條件組合 find . \\( -name \u0026#34;*.log\u0026#34; -o -name \u0026#34;*.tmp\u0026#34; \\) # OR 條件 find . -name \u0026#34;*.txt\u0026#34; -a -size +1M # AND 條件 依據檔案類型搜尋 基本檔案類型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 檔案類型參數說明 # f: 一般檔案 d: 目錄 # l: 符號連結 p: 命名管道 (FIFO) # s: socket b: 區塊裝置 # c: 字元裝置 # 搜尋目錄 find /var -type d -name \u0026#34;log*\u0026#34; # 搜尋一般檔案 find . -type f -name \u0026#34;*.sh\u0026#34; # 搜尋符號連結 find /usr/bin -type l # 搜尋空檔案 find /tmp -type f -empty # 搜尋空目錄 find /home -type d -empty 實際應用範例 1 2 3 4 5 6 7 8 # 找出所有 shell 腳本 find /usr/local/bin -type f -name \u0026#34;*.sh\u0026#34; -executable # 找出所有損壞的符號連結 find /usr -type l ! -exec test -e {} \\; -print # 找出包含特定副檔名的目錄 find . -type d -exec sh -c \u0026#39;ls \u0026#34;$1\u0026#34;/*.log \u0026gt;/dev/null 2\u0026gt;\u0026amp;1\u0026#39; _ {} \\; -print 依據檔案大小搜尋 基本大小搜尋 1 2 3 4 5 6 7 8 9 10 # 大小單位說明 # c: bytes k: KB (1024 bytes) # M: MB G: GB # +: 大於 -: 小於 精確值: 等於 # 基本大小搜尋 find . -size 50M # 等於 50MB find . -size +100M # 大於 100MB find . -size -1G # 小於 1GB find /var/log -size +10M -size -100M # 10MB 到 100MB 之間 進階大小操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 找出最大的檔案（前 10 個） find /home -type f -exec ls -la {} \\; | sort -k5 -nr | head -10 # 找出超過 1GB 的檔案並顯示大小 find / -size +1G -type f -exec du -h {} \\; 2\u0026gt;/dev/null # 找出空檔案並刪除 find /tmp -type f -empty -delete # 找出大檔案並詢問是否刪除 find /var/log -size +100M -type f -ok rm {} \\; # 按大小範圍分類顯示 find . -type f -size +10M -size -100M -printf \u0026#34;%s %p\\n\u0026#34; | sort -nr 依據時間搜尋 時間類型說明 1 2 3 4 5 6 7 8 9 10 # 時間類型 # mtime: 修改時間 (modify time) # atime: 存取時間 (access time) # ctime: 狀態改變時間 (change time) # 時間單位 # 預設單位: 天 (24小時) # +n: n天之前 # -n: n天之內 # n: 恰好n天前 基本時間搜尋 1 2 3 4 5 6 7 8 9 10 11 12 # 修改時間搜尋 find . -mtime 3 # 恰好 3 天前修改 find . -mtime -7 # 7 天內修改 find . -mtime +30 # 30 天前修改 find . -mtime +7 -mtime -30 # 7-30 天前修改 # 存取時間搜尋 find /home -atime -1 # 1 天內被存取 find /tmp -atime +7 # 7 天以上未被存取 # 狀態改變時間 find . -ctime -1 # 1 天內狀態改變 精確時間搜尋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 分鐘為單位的時間搜尋 find /var/log -mmin -60 # 60 分鐘內修改 find . -amin +120 # 120 分鐘前存取 find /tmp -cmin -30 # 30 分鐘內狀態改變 # 比較檔案時間 find . -newer reference.txt # 比 reference.txt 新的檔案 find . -cnewer backup.tar # 狀態比 backup.tar 新 # 指定日期範圍 find /var/log -newermt \u0026#34;2023-01-01\u0026#34; ! -newermt \u0026#34;2023-12-31\u0026#34; # 今天修改的檔案 find . -daystart -mtime 0 # 昨天修改的檔案 find . -daystart -mtime 1 依據權限搜尋 基本權限搜尋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 精確權限匹配 find /home -perm 755 # 權限恰好是 755 find . -perm 644 # 權限恰好是 644 # 包含指定權限 find /usr/bin -perm -755 # 至少有 755 權限 find . -perm -u+x # 擁有者有執行權限 # 任一符合權限 find /tmp -perm /222 # 任何人有寫入權限 find . -perm /u+w,g+w,o+w # 任何人有寫入權限 # 可執行檔案 find /usr/local/bin -type f -executable find . -type f -perm -u+x # 擁有者可執行 進階權限搜尋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 找出 SUID 檔案 find /usr -perm -4000 -type f 2\u0026gt;/dev/null # 找出 SGID 檔案 find /usr -perm -2000 -type f 2\u0026gt;/dev/null # 找出 sticky bit 目錄 find /tmp -perm -1000 -type d # 找出可寫的檔案（安全檢查） find /etc -type f -writable 2\u0026gt;/dev/null # 找出無權限讀取的檔案 find /home -type f ! -readable 2\u0026gt;/dev/null 依據擁有者搜尋 基本擁有者搜尋 1 2 3 4 5 6 7 8 9 10 11 12 # 依據使用者搜尋 find /home -user john # 屬於 john 的檔案 find /var -user root # 屬於 root 的檔案 find . -user $(whoami) # 屬於當前使用者的檔案 # 依據群組搜尋 find /home -group developers # 屬於 developers 群組 find /var/www -group www-data # 屬於 www-data 群組 # 依據 UID/GID 搜尋 find /home -uid 1000 # UID 為 1000 的檔案 find /var -gid 100 # GID 為 100 的檔案 進階擁有者搜尋 1 2 3 4 5 6 7 8 9 10 # 找出無主檔案（孤兒檔案） find /home -nouser # 沒有對應使用者的檔案 find /var -nogroup # 沒有對應群組的檔案 # 組合條件搜尋 find /home -user john -group staff # 屬於 john 且群組是 staff find /tmp -user root ! -group root # 屬於 root 但群組不是 root # 找出特定使用者的大檔案 find /home -user john -size +100M -type f 執行動作 (-exec 和 -ok) 基本 -exec 用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 基本語法：-exec command {} \\; # {} 代表找到的檔案 # \\; 表示命令結束 # 刪除找到的檔案 find /tmp -name \u0026#34;*.tmp\u0026#34; -exec rm {} \\; # 複製檔案 find . -name \u0026#34;*.txt\u0026#34; -exec cp {} backup/ \\; # 移動檔案 find . -name \u0026#34;*.log\u0026#34; -exec mv {} /var/log/ \\; # 修改權限 find /var/www -type f -exec chmod 644 {} \\; find /var/www -type d -exec chmod 755 {} \\; 進階 -exec 用法 1 2 3 4 5 6 7 8 9 10 11 12 # 使用 -exec {} + 提高效能（批次處理） find . -name \u0026#34;*.txt\u0026#34; -exec grep \u0026#34;pattern\u0026#34; {} + find /tmp -name \u0026#34;*.tmp\u0026#34; -exec rm {} + # 執行複雜命令 find . -type f -name \u0026#34;*.sh\u0026#34; -exec sh -c \u0026#39;echo \u0026#34;Processing: $1\u0026#34;; chmod +x \u0026#34;$1\u0026#34;\u0026#39; _ {} \\; # 在找到的目錄中執行命令 find /var/log -type d -exec sh -c \u0026#39;echo \u0026#34;Directory: $1\u0026#34;; ls -la \u0026#34;$1\u0026#34;\u0026#39; _ {} \\; # 條件執行 find . -name \u0026#34;*.txt\u0026#34; -exec test -s {} \\; -exec echo \u0026#34;Non-empty: {}\u0026#34; \\; 互動式 -ok 用法 1 2 3 4 5 6 7 8 # -ok 會在執行前詢問確認 find /tmp -name \u0026#34;*.old\u0026#34; -ok rm {} \\; # 互動式移動檔案 find . -name \u0026#34;*.bak\u0026#34; -ok mv {} backup/ \\; # 互動式權限修改 find /home -name \u0026#34;*.sh\u0026#34; -ok chmod +x {} \\; 邏輯運算符 基本邏輯運算 1 2 3 4 5 6 7 8 9 10 11 # AND 運算（預設） find . -name \u0026#34;*.txt\u0026#34; -size +1M # 名稱是 *.txt 且大小 \u0026gt; 1M find . -type f -user john # 是檔案且屬於 john # OR 運算 find . \\( -name \u0026#34;*.txt\u0026#34; -o -name \u0026#34;*.md\u0026#34; \\) # txt 或 md 檔案 find . -type f \\( -name \u0026#34;*.log\u0026#34; -o -name \u0026#34;*.tmp\u0026#34; \\) # NOT 運算 find . -type f ! -name \u0026#34;*.txt\u0026#34; # 不是 txt 的檔案 find . ! -path \u0026#34;*/.*\u0026#34; # 排除隱藏目錄 複雜邏輯組合 1 2 3 4 5 6 7 8 # 複雜條件組合 find . \\( -name \u0026#34;*.txt\u0026#34; -o -name \u0026#34;*.md\u0026#34; \\) -a -size +1k -a ! -path \u0026#34;*/tmp/*\u0026#34; # 多重排除條件 find /var/log \\( ! -name \u0026#34;*.gz\u0026#34; ! -name \u0026#34;*.old\u0026#34; \\) -type f -mtime -7 # 巢狀邏輯條件 find . \\( \\( -name \u0026#34;*.c\u0026#34; -o -name \u0026#34;*.h\u0026#34; \\) -a -mtime -7 \\) -o \\( -name \u0026#34;*.py\u0026#34; -a -size +10k \\) 輸出格式化 使用 -printf 格式化輸出 1 2 3 4 5 6 7 8 9 10 11 # 基本格式化 find . -type f -printf \u0026#34;%f\\n\u0026#34; # 只顯示檔名 find . -type f -printf \u0026#34;%p\\t%s\\n\u0026#34; # 路徑和大小 find . -type f -printf \u0026#34;%M %u %g %s %p\\n\u0026#34; # 權限、擁有者、群組、大小、路徑 # 時間格式化 find . -type f -printf \u0026#34;%TY-%Tm-%Td %TH:%TM %p\\n\u0026#34; # 修改時間和路徑 find . -type f -printf \u0026#34;%Ac %p\\n\u0026#34; # 存取時間 # 大小格式化 find . -type f -printf \u0026#34;%10s %p\\n\u0026#34; | sort -nr # 按大小排序 格式化參數說明 1 2 3 4 5 6 7 8 9 10 # 常用格式化參數 # %p: 檔案路徑 # %f: 檔案名稱 # %s: 檔案大小（bytes） # %M: 檔案權限 # %u: 擁有者名稱 # %g: 群組名稱 # %T: 時間相關（需配合時間格式） # %h: 目錄路徑 # %d: 檔案深度 實戰應用場景 系統清理與維護 1 2 3 4 5 6 7 8 9 # 清理臨時檔案 find /tmp -type f -atime +7 -delete # 刪除 7 天未存取的檔案 find /var/log -name \u0026#34;*.log\u0026#34; -size +100M -delete # 刪除大日誌檔案 # 清理快取檔案 find ~/.cache -type f -atime +30 -delete # 清理舊快取 # 備份前清理 find /backup -name \u0026#34;*.tar.gz\u0026#34; -mtime +30 -delete # 刪除 30 天前的備份 檔案整理與歸檔 1 2 3 4 5 6 7 8 # 按日期歸檔檔案 find /data -type f -name \u0026#34;*.log\u0026#34; -mtime +1 -exec gzip {} \\; # 按大小分類檔案 find /home -type f -size +1G -exec ls -lh {} \\; # 移動舊檔案到歸檔目錄 find /project -type f -mtime +90 -exec mv {} /archive/ \\; 安全檢查 1 2 3 4 5 6 7 8 9 10 11 # 檢查 SUID/SGID 檔案 find /usr -type f \\( -perm -4000 -o -perm -2000 \\) -exec ls -l {} \\; # 檢查可寫檔案 find /etc -type f -writable 2\u0026gt;/dev/null # 檢查無主檔案 find /home -nouser -o -nogroup # 檢查異常權限 find /var/www -type f ! -perm 644 -o -type d ! -perm 755 開發與除錯 1 2 3 4 5 6 7 8 9 10 11 12 # 搜尋程式碼 find . -name \u0026#34;*.java\u0026#34; -exec grep -l \u0026#34;className\u0026#34; {} \\; # 找出編譯產生的檔案 find . \\( -name \u0026#34;*.class\u0026#34; -o -name \u0026#34;*.o\u0026#34; -o -name \u0026#34;*.pyc\u0026#34; \\) -delete # 統計不同類型檔案數量 find . -type f -name \u0026#34;*.java\u0026#34; | wc -l find . -type f -name \u0026#34;*.py\u0026#34; -exec wc -l {} + | tail -1 # 檢查程式碼行數 find . -name \u0026#34;*.py\u0026#34; -exec wc -l {} + | sort -nr | head -10 監控與分析 1 2 3 4 5 6 7 8 9 10 11 # 找出最近修改的檔案 find /var/log -type f -mmin -60 -exec ls -lt {} \\; # 監控檔案系統變化 find /etc -newer /tmp/baseline -type f # 分析磁碟使用 find /home -type f -printf \u0026#34;%s %p\\n\u0026#34; | sort -nr | head -20 # 找出重複檔案（基於大小） find /data -type f -printf \u0026#34;%s %p\\n\u0026#34; | sort | uniq -d -w 10 效能優化技巧 提升搜尋效能 1 2 3 4 5 6 7 8 9 10 11 12 13 # 限制搜尋深度 find /usr -maxdepth 3 -name \u0026#34;*.conf\u0026#34; # 排除不必要的目錄 find / -path /proc -prune -o -path /sys -prune -o -name \u0026#34;*.txt\u0026#34; -print # 使用更具體的路徑 find /var/log -name \u0026#34;*.log\u0026#34; # 好 find / -name \u0026#34;*.log\u0026#34; # 較慢 # 將最具選擇性的條件放在前面 find . -name \u0026#34;*.txt\u0026#34; -size +1M # 好 find . -size +1M -name \u0026#34;*.txt\u0026#34; # 也可以，但順序影響效能 批次處理優化 1 2 3 4 5 6 7 8 9 # 使用 {} + 而非 {} \\; 提升效能 find . -name \u0026#34;*.txt\u0026#34; -exec wc -l {} + # 快 find . -name \u0026#34;*.txt\u0026#34; -exec wc -l {} \\; # 慢 # 使用管道處理大量結果 find /var/log -name \u0026#34;*.log\u0026#34; -print0 | xargs -0 grep \u0026#34;ERROR\u0026#34; # 並行處理 find . -name \u0026#34;*.jpg\u0026#34; -print0 | xargs -0 -P 4 -I {} convert {} {}.thumb.jpg 常見錯誤與解決方案 權限錯誤處理 1 2 3 4 5 6 7 8 # 忽略權限錯誤 find /var -name \u0026#34;*.log\u0026#34; 2\u0026gt;/dev/null # 只搜尋有權限的目錄 find /var -readable -name \u0026#34;*.log\u0026#34; # 使用 sudo 搜尋受保護的目錄 sudo find /root -name \u0026#34;*.conf\u0026#34; 特殊字元處理 1 2 3 4 5 6 # 處理檔名中的空格 find . -name \u0026#34;* *\u0026#34; -print0 | xargs -0 ls -l # 處理特殊字元 find . -name \u0026#34;file[1-3].txt\u0026#34; find . -name \u0026#34;*.txt\u0026#34; -not -name \u0026#34;*\\\u0026amp;*\u0026#34; 記憶體使用優化 1 2 3 4 5 6 7 8 9 10 # 避免一次載入過多結果 find /large_dir -name \u0026#34;*.txt\u0026#34; | head -100 # 使用 -quit 在找到第一個結果後停止 find . -name \u0026#34;target.txt\u0026#34; -quit # 分段處理大目錄 find /huge_dir -maxdepth 1 -type d | while read dir; do find \u0026#34;$dir\u0026#34; -name \u0026#34;*.txt\u0026#34; done 與其他工具組合 與 grep 組合 1 2 3 4 5 6 7 8 9 # 在檔案中搜尋內容 find . -name \u0026#34;*.txt\u0026#34; -exec grep -l \u0026#34;pattern\u0026#34; {} \\; # 搜尋並顯示匹配行 find . -name \u0026#34;*.log\u0026#34; -exec grep -Hn \u0026#34;ERROR\u0026#34; {} \\; # 使用 xargs 提升效能 find . -name \u0026#34;*.txt\u0026#34; | xargs grep \u0026#34;pattern\u0026#34; find . -name \u0026#34;*.txt\u0026#34; -print0 | xargs -0 grep \u0026#34;pattern\u0026#34; 與 tar 組合 1 2 3 4 5 # 備份找到的檔案 find /home -name \u0026#34;*.doc\u0026#34; -print0 | tar -czf backup.tar.gz --null -T - # 歸檔舊檔案 find /data -mtime +30 -print0 | tar -czf old_files.tar.gz --null -T - 與 rsync 組合 1 2 # 同步找到的檔案 find /source -name \u0026#34;*.txt\u0026#34; -print0 | rsync -av --files-from=- --from0 /source/ /destination/ 總結 核心優勢 強大的搜尋能力：支援多種條件組合搜尋 批次操作：可對搜尋結果執行各種動作 高度可配置：豐富的參數和選項 跨平台相容：在各種 Unix-like 系統中一致 最佳實踐 明確搜尋範圍：使用具體的路徑而非根目錄 合理使用條件：將最具選擇性的條件放在前面 善用邏輯運算：合理組合 AND、OR、NOT 條件 注意效能：大目錄搜尋時考慮使用 -maxdepth 限制 安全操作：使用 -ok 而非 -exec 進行危險操作 常用技巧記憶 1 2 3 4 5 6 # 日常最常用的模式 find . -name \u0026#34;*.txt\u0026#34; # 基本檔名搜尋 find . -type f -size +100M # 大檔案搜尋 find . -mtime -7 # 最近修改檔案 find . -name \u0026#34;*.tmp\u0026#34; -delete # 清理臨時檔案 find . -name \u0026#34;*.sh\u0026#34; -exec chmod +x {} \\; # 批次修改權限 find 命令的強大之處在於其靈活性和可組合性。熟練掌握這個工具，能夠大幅提升 Linux 系統管理和日常工作的效率。記住：實務中最重要的是理解各種條件的組合邏輯，並根據實際需求選擇最適合的搜尋策略。\n參考資料 GNU Findutils Manual Linux man find Advanced Bash-Scripting Guide Unix Power Tools ","permalink":"https://xinqilin.github.io/post/tools/find/","tags":["Linux","Find","Command Line","File Search","System Administration","Shell","Unix"],"title":"Find 命令完整指南：Linux 檔案搜尋與管理的瑞士軍刀"},{"content":"概述 Ubuntu 是基於 Debian 的 Linux 發行版，以其穩定性、易用性和豐富的軟體生態系統而聞名。它是雲端運算、伺服器部署和開發環境的首選平台，提供長期支援（LTS）版本和定期更新的標準版本。\n核心特徵 穩定可靠：基於 Debian 穩定分支，經過嚴格測試 套件豐富：APT 套件管理系統，數萬個軟體包 社群支援：活躍的開發者和使用者社群 容器友好：優秀的 Docker 和容器化支援 雲端整合：原生支援各大雲端平台 系統安裝與初始設置 基本安裝 1 2 3 4 5 6 7 8 9 10 11 12 13 # 檢查系統版本 lsb_release -a cat /etc/os-release # 檢查硬體資訊 uname -a lscpu free -h df -h # 檢查網路狀態 ip addr show netstat -tuln 系統更新 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 更新套件列表 sudo apt update # 升級已安裝的套件 sudo apt upgrade -y # 完整系統升級 sudo apt full-upgrade -y # 清理不需要的套件 sudo apt autoremove -y sudo apt autoclean # 檢查可升級的套件 apt list --upgradable 時區和語言設定 1 2 3 4 5 6 7 8 9 10 # 設定時區 sudo timedatectl set-timezone Asia/Taipei timedatectl status # 語言和地區設定 sudo locale-gen zh_TW.UTF-8 sudo update-locale LANG=zh_TW.UTF-8 # 檢查當前語言設定 locale 套件管理系統 APT 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 搜尋套件 apt search keyword apt-cache search keyword # 查看套件資訊 apt show package-name apt-cache show package-name # 安裝套件 sudo apt install package-name sudo apt install package1 package2 package3 # 重新安裝套件 sudo apt reinstall package-name # 移除套件 sudo apt remove package-name # 保留配置檔案 sudo apt purge package-name # 完全移除 # 檢查依賴關係 apt depends package-name apt rdepends package-name # 列出已安裝套件 dpkg -l apt list --installed 套件庫管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 添加 PPA 套件庫 sudo add-apt-repository ppa:user/ppa-name sudo apt update # 移除 PPA sudo add-apt-repository --remove ppa:user/ppa-name # 管理套件庫金鑰 wget -qO - https://example.com/key.gpg | sudo apt-key add - sudo apt-key list sudo apt-key del KEY_ID # 編輯套件來源 sudo nano /etc/apt/sources.list ls /etc/apt/sources.list.d/ DEB 套件處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 安裝本地 DEB 套件 sudo dpkg -i package.deb # 修復依賴問題 sudo apt install -f # 移除 DEB 套件 sudo dpkg -r package-name # 查詢 DEB 套件內容 dpkg -L package-name dpkg -c package.deb # 查詢檔案屬於哪個套件 dpkg -S /path/to/file 必備軟體安裝 開發工具 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 基本開發工具 sudo apt install build-essential git vim curl wget htop tree # 程式語言環境 sudo apt install python3 python3-pip nodejs npm default-jdk # 版本控制 sudo apt install git subversion # 編輯器和 IDE sudo apt install vim neovim emacs code # 資料庫工具 sudo apt install mysql-client postgresql-client redis-tools 系統監控工具 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 系統監控 sudo apt install htop iotop iftop nethogs # 系統資訊 sudo apt install neofetch screenfetch inxi # 網路工具 sudo apt install net-tools traceroute nmap tcpdump wireshark # 效能分析 sudo apt install sysstat dstat glances # 日誌分析 sudo apt install logwatch fail2ban 媒體和辦公軟體 1 2 3 4 5 6 7 8 9 10 11 # 媒體播放 sudo apt install vlc audacity gimp # 辦公軟體 sudo apt install libreoffice thunderbird firefox # 壓縮工具 sudo apt install zip unzip rar unrar 7zip # 文件處理 sudo apt install pandoc texlive-full Docker 環境設置 Docker 安裝與配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 移除舊版本 sudo apt remove docker docker-engine docker.io containerd runc # 安裝依賴 sudo apt update sudo apt install apt-transport-https ca-certificates curl gnupg lsb-release # 添加 Docker 官方 GPG 金鑰 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg # 添加套件庫 echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null # 安裝 Docker Engine sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io docker-compose-plugin # 啟動並啟用 Docker 服務 sudo systemctl start docker sudo systemctl enable docker # 將使用者加入 docker 群組 sudo usermod -aG docker $USER newgrp docker # 驗證安裝 docker --version docker run hello-world Ubuntu Docker 容器設置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # 拉取 Ubuntu 映像 docker pull ubuntu:latest docker pull ubuntu:20.04 docker pull ubuntu:22.04 # 建立 Docker 網路 docker network create ubuntu-network # 啟動 Ubuntu 容器 docker run -dit \\ --name ubuntu-container \\ --network ubuntu-network \\ -p 2222:22 \\ -p 8080:8080 \\ -v $(pwd)/workspace:/workspace \\ ubuntu:latest # 進入容器 docker exec -it ubuntu-container bash # 容器內初始化 apt update \u0026amp;\u0026amp; apt upgrade -y yes | unminimize # 安裝基本工具 apt install -y \\ curl \\ wget \\ git \\ vim \\ nano \\ htop \\ tree \\ less \\ man-db \\ openssh-server \\ sudo \\ zip \\ unzip \\ jq \\ python3 \\ python3-pip \\ nodejs \\ npm # 設定 SSH 服務 echo \u0026#39;PermitRootLogin yes\u0026#39; \u0026gt;\u0026gt; /etc/ssh/sshd_config echo \u0026#39;PasswordAuthentication yes\u0026#39; \u0026gt;\u0026gt; /etc/ssh/sshd_config service ssh start # 建立使用者 useradd -m -s /bin/bash developer echo \u0026#39;developer:password\u0026#39; | chpasswd usermod -aG sudo developer 容器管理腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #!/bin/bash # ubuntu_container_manager.sh - Ubuntu 容器管理腳本 CONTAINER_NAME=\u0026#34;ubuntu-dev\u0026#34; NETWORK_NAME=\u0026#34;ubuntu-network\u0026#34; IMAGE=\u0026#34;ubuntu:22.04\u0026#34; start_container() { echo \u0026#34;Starting Ubuntu development container...\u0026#34; # 檢查網路是否存在 if ! docker network ls | grep -q \u0026#34;$NETWORK_NAME\u0026#34;; then echo \u0026#34;Creating network: $NETWORK_NAME\u0026#34; docker network create \u0026#34;$NETWORK_NAME\u0026#34; fi # 檢查容器是否已存在 if docker ps -a | grep -q \u0026#34;$CONTAINER_NAME\u0026#34;; then echo \u0026#34;Starting existing container...\u0026#34; docker start \u0026#34;$CONTAINER_NAME\u0026#34; else echo \u0026#34;Creating new container...\u0026#34; docker run -dit \\ --name \u0026#34;$CONTAINER_NAME\u0026#34; \\ --network \u0026#34;$NETWORK_NAME\u0026#34; \\ -p 2222:22 \\ -p 8080:8080 \\ -p 3000:3000 \\ -v \u0026#34;$(pwd)/workspace:/workspace\u0026#34; \\ -v \u0026#34;$(pwd)/config:/config\u0026#34; \\ \u0026#34;$IMAGE\u0026#34; # 初始化容器 echo \u0026#34;Initializing container...\u0026#34; docker exec \u0026#34;$CONTAINER_NAME\u0026#34; bash -c \u0026#34; apt update \u0026amp;\u0026amp; apt upgrade -y yes | unminimize apt install -y curl wget git vim htop tree less man-db openssh-server sudo zip unzip jq python3 python3-pip nodejs npm echo \u0026#39;PermitRootLogin yes\u0026#39; \u0026gt;\u0026gt; /etc/ssh/sshd_config echo \u0026#39;PasswordAuthentication yes\u0026#39; \u0026gt;\u0026gt; /etc/ssh/sshd_config service ssh start useradd -m -s /bin/bash developer echo \u0026#39;developer:developer\u0026#39; | chpasswd usermod -aG sudo developer \u0026#34; fi echo \u0026#34;Container started successfully!\u0026#34; echo \u0026#34;SSH: ssh -p 2222 developer@localhost\u0026#34; echo \u0026#34;Enter: docker exec -it $CONTAINER_NAME bash\u0026#34; } stop_container() { echo \u0026#34;Stopping container...\u0026#34; docker stop \u0026#34;$CONTAINER_NAME\u0026#34; } remove_container() { echo \u0026#34;Removing container...\u0026#34; docker stop \u0026#34;$CONTAINER_NAME\u0026#34; 2\u0026gt;/dev/null || true docker rm \u0026#34;$CONTAINER_NAME\u0026#34; 2\u0026gt;/dev/null || true } status_container() { echo \u0026#34;Container status:\u0026#34; docker ps -a | grep \u0026#34;$CONTAINER_NAME\u0026#34; || echo \u0026#34;Container not found\u0026#34; } case \u0026#34;$1\u0026#34; in start) start_container ;; stop) stop_container ;; remove) remove_container ;; status) status_container ;; restart) stop_container sleep 2 start_container ;; *) echo \u0026#34;Usage: $0 {start|stop|remove|status|restart}\u0026#34; exit 1 ;; esac 系統管理與維護 服務管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 檢查服務狀態 sudo systemctl status service-name sudo systemctl list-units --type=service # 啟動/停止/重啟服務 sudo systemctl start service-name sudo systemctl stop service-name sudo systemctl restart service-name sudo systemctl reload service-name # 啟用/停用服務 sudo systemctl enable service-name sudo systemctl disable service-name # 檢查服務日誌 sudo journalctl -u service-name sudo journalctl -u service-name -f # 即時日誌 # 檢查開機啟動的服務 sudo systemctl list-unit-files --state=enabled 使用者和權限管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 使用者管理 sudo useradd -m -s /bin/bash username sudo passwd username sudo userdel username sudo usermod -aG group username # 群組管理 sudo groupadd groupname sudo groupdel groupname groups username # 權限管理 chmod 755 file chmod u+x file chown user:group file sudo chown -R user:group directory/ # 查看使用者資訊 id username who w last 系統監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # CPU 和記憶體使用率 top htop free -h cat /proc/meminfo # 磁碟使用情況 df -h du -sh directory/ lsblk fdisk -l # 網路狀態 netstat -tuln ss -tuln iftop nethogs # 系統負載 uptime cat /proc/loadavg vmstat 1 5 iostat 1 5 日誌管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 系統日誌 sudo journalctl sudo journalctl -f # 即時日誌 sudo journalctl --since \u0026#34;1 hour ago\u0026#34; sudo journalctl --until \u0026#34;2023-01-01\u0026#34; # 日誌大小管理 sudo journalctl --disk-usage sudo journalctl --vacuum-size=100M sudo journalctl --vacuum-time=30d # 傳統日誌檔案 tail -f /var/log/syslog tail -f /var/log/auth.log tail -f /var/log/apache2/access.log # 日誌輪轉 sudo logrotate -d /etc/logrotate.conf sudo logrotate -f /etc/logrotate.conf 網路配置 網路接口管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 檢查網路接口 ip addr show ip link show ifconfig # 網路配置（Netplan） sudo nano /etc/netplan/00-installer-config.yaml # 範例 Netplan 配置 network: version: 2 renderer: networkd ethernets: enp0s3: dhcp4: true enp0s8: addresses: - 192.168.1.100/24 gateway4: 192.168.1.1 nameservers: addresses: [8.8.8.8, 1.1.1.1] # 應用網路配置 sudo netplan try sudo netplan apply # 重啟網路服務 sudo systemctl restart networking sudo systemctl restart systemd-networkd 防火牆設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # UFW 防火牆 sudo ufw status sudo ufw enable sudo ufw disable # 開放連接埠 sudo ufw allow 22/tcp sudo ufw allow 80/tcp sudo ufw allow 443/tcp sudo ufw allow from 192.168.1.0/24 # 拒絕連接 sudo ufw deny 23/tcp sudo ufw deny from 192.168.2.100 # 檢查規則 sudo ufw status numbered sudo ufw delete 1 # 重設防火牆 sudo ufw --force reset SSH 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 安裝和啟動 SSH sudo apt install openssh-server sudo systemctl start ssh sudo systemctl enable ssh # SSH 配置 sudo nano /etc/ssh/sshd_config # 重要 SSH 設定 Port 22 PermitRootLogin no PasswordAuthentication yes PubkeyAuthentication yes AllowUsers username # 重啟 SSH 服務 sudo systemctl restart ssh # SSH 金鑰管理 ssh-keygen -t rsa -b 4096 ssh-copy-id user@host 安全加固 系統安全設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 更新系統 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y # 安裝安全工具 sudo apt install fail2ban ufw rkhunter chkrootkit # 設定 fail2ban sudo nano /etc/fail2ban/jail.local [DEFAULT] bantime = 3600 findtime = 600 maxretry = 3 [sshd] enabled = true port = ssh filter = sshd logpath = /var/log/auth.log sudo systemctl restart fail2ban # 檢查安全狀態 sudo rkhunter --check sudo chkrootkit 檔案系統安全 1 2 3 4 5 6 7 8 9 10 11 12 13 # 設定適當的檔案權限 sudo chmod 644 /etc/passwd sudo chmod 600 /etc/shadow sudo chmod 644 /etc/group # 查找具有特殊權限的檔案 find / -perm -4000 -type f 2\u0026gt;/dev/null # SUID find / -perm -2000 -type f 2\u0026gt;/dev/null # SGID find / -perm -1000 -type d 2\u0026gt;/dev/null # Sticky bit # 檔案系統掃描 sudo find / -nouser -print 2\u0026gt;/dev/null sudo find / -nogroup -print 2\u0026gt;/dev/null 效能調整與最佳化 系統效能監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 系統效能監控腳本 #!/bin/bash # system_monitor.sh echo \u0026#34;=== System Performance Monitor ===\u0026#34; echo \u0026#34;Timestamp: $(date)\u0026#34; echo echo \u0026#34;=== CPU Information ===\u0026#34; echo \u0026#34;CPU Usage:\u0026#34; top -bn1 | grep \u0026#34;Cpu(s)\u0026#34; | awk \u0026#39;{print \u0026#34;CPU Load: \u0026#34; $2}\u0026#39; echo -e \u0026#34;\\nCPU Cores:\u0026#34; nproc echo \u0026#34;=== Memory Information ===\u0026#34; free -h echo -e \u0026#34;\\n=== Disk Usage ===\u0026#34; df -h | grep -E \u0026#39;^/dev/\u0026#39; echo -e \u0026#34;\\n=== Network Statistics ===\u0026#34; ss -tuln | wc -l | awk \u0026#39;{print \u0026#34;Active Connections: \u0026#34; $1}\u0026#39; echo -e \u0026#34;\\n=== System Load ===\u0026#34; uptime echo -e \u0026#34;\\n=== Top Processes by CPU ===\u0026#34; ps aux --sort=-%cpu | head -6 echo -e \u0026#34;\\n=== Top Processes by Memory ===\u0026#34; ps aux --sort=-%mem | head -6 系統清理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/bin/bash # system_cleanup.sh - 系統清理腳本 echo \u0026#34;Starting system cleanup...\u0026#34; # 清理套件快取 echo \u0026#34;Cleaning package cache...\u0026#34; sudo apt autoclean sudo apt autoremove -y # 清理日誌檔案 echo \u0026#34;Cleaning log files...\u0026#34; sudo journalctl --vacuum-time=30d # 清理暫存檔案 echo \u0026#34;Cleaning temporary files...\u0026#34; sudo rm -rf /tmp/* sudo rm -rf /var/tmp/* # 清理使用者暫存 echo \u0026#34;Cleaning user cache...\u0026#34; rm -rf ~/.cache/* rm -rf ~/.local/share/Trash/* # 清理舊核心 echo \u0026#34;Cleaning old kernels...\u0026#34; dpkg -l | grep linux-image | awk \u0026#39;{print $2}\u0026#39; | sort -V | head -n -2 | xargs sudo apt purge -y # 檢查磁碟空間 echo \u0026#34;Disk space after cleanup:\u0026#34; df -h echo \u0026#34;System cleanup completed!\u0026#34; 備份與恢復 系統備份 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #!/bin/bash # backup_system.sh - 系統備份腳本 BACKUP_DIR=\u0026#34;/backup\u0026#34; DATE=$(date +%Y%m%d_%H%M%S) HOSTNAME=$(hostname) mkdir -p \u0026#34;$BACKUP_DIR\u0026#34; echo \u0026#34;Starting system backup...\u0026#34; # 備份重要配置檔案 echo \u0026#34;Backing up configuration files...\u0026#34; tar -czf \u0026#34;$BACKUP_DIR/config_$HOSTNAME_$DATE.tar.gz\u0026#34; \\ /etc \\ /var/log \\ /home \\ --exclude=/home/*/.cache \\ --exclude=/home/*/Downloads # 備份已安裝套件列表 echo \u0026#34;Backing up package list...\u0026#34; dpkg --get-selections \u0026gt; \u0026#34;$BACKUP_DIR/packages_$HOSTNAME_$DATE.txt\u0026#34; apt-mark showmanual \u0026gt; \u0026#34;$BACKUP_DIR/manual_packages_$HOSTNAME_$DATE.txt\u0026#34; # 備份系統資訊 echo \u0026#34;Backing up system information...\u0026#34; { echo \u0026#34;=== System Information ===\u0026#34; uname -a lsb_release -a echo -e \u0026#34;\\n=== Hardware Information ===\u0026#34; lscpu free -h df -h echo -e \u0026#34;\\n=== Network Configuration ===\u0026#34; ip addr show } \u0026gt; \u0026#34;$BACKUP_DIR/system_info_$HOSTNAME_$DATE.txt\u0026#34; echo \u0026#34;Backup completed: $BACKUP_DIR\u0026#34; ls -la \u0026#34;$BACKUP_DIR\u0026#34;/*$DATE* 系統恢復 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/bin/bash # restore_system.sh - 系統恢復腳本 BACKUP_FILE=\u0026#34;$1\u0026#34; if [ -z \u0026#34;$BACKUP_FILE\u0026#34; ]; then echo \u0026#34;Usage: $0 \u0026lt;backup_file.tar.gz\u0026gt;\u0026#34; exit 1 fi if [ ! -f \u0026#34;$BACKUP_FILE\u0026#34; ]; then echo \u0026#34;Backup file not found: $BACKUP_FILE\u0026#34; exit 1 fi echo \u0026#34;WARNING: This will restore system files from backup.\u0026#34; echo \u0026#34;Backup file: $BACKUP_FILE\u0026#34; read -p \u0026#34;Continue? (y/N): \u0026#34; confirm if [[ $confirm != [yY] ]]; then echo \u0026#34;Restore cancelled.\u0026#34; exit 0 fi echo \u0026#34;Starting system restore...\u0026#34; # 備份當前配置 echo \u0026#34;Backing up current configuration...\u0026#34; sudo tar -czf \u0026#34;/tmp/current_config_$(date +%Y%m%d_%H%M%S).tar.gz\u0026#34; /etc # 恢復檔案 echo \u0026#34;Restoring files...\u0026#34; sudo tar -xzf \u0026#34;$BACKUP_FILE\u0026#34; -C / echo \u0026#34;Restore completed. Please reboot the system.\u0026#34; 自動化腳本 系統初始化腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #!/bin/bash # ubuntu_setup.sh - Ubuntu 系統初始化腳本 set -e echo \u0026#34;=== Ubuntu System Setup Script ===\u0026#34; # 更新系統 echo \u0026#34;Updating system...\u0026#34; sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y # 安裝基本工具 echo \u0026#34;Installing essential tools...\u0026#34; sudo apt install -y \\ curl \\ wget \\ git \\ vim \\ htop \\ tree \\ unzip \\ zip \\ jq \\ build-essential \\ software-properties-common \\ apt-transport-https \\ ca-certificates \\ gnupg \\ lsb-release # 安裝開發工具 echo \u0026#34;Installing development tools...\u0026#34; sudo apt install -y \\ python3 \\ python3-pip \\ nodejs \\ npm \\ default-jdk \\ golang-go # 安裝 Docker echo \u0026#34;Installing Docker...\u0026#34; curl -fsSL https://get.docker.com | sh sudo usermod -aG docker $USER # 配置 Git echo \u0026#34;Configuring Git...\u0026#34; read -p \u0026#34;Enter your Git username: \u0026#34; git_username read -p \u0026#34;Enter your Git email: \u0026#34; git_email git config --global user.name \u0026#34;$git_username\u0026#34; git config --global user.email \u0026#34;$git_email\u0026#34; # 設定 SSH echo \u0026#34;Setting up SSH...\u0026#34; sudo systemctl enable ssh sudo systemctl start ssh # 安裝常用軟體 echo \u0026#34;Installing common applications...\u0026#34; sudo apt install -y \\ firefox \\ vlc \\ gimp \\ libreoffice \\ thunderbird # 清理 echo \u0026#34;Cleaning up...\u0026#34; sudo apt autoremove -y sudo apt autoclean echo \u0026#34;=== Setup completed! ===\u0026#34; echo \u0026#34;Please reboot the system to ensure all changes take effect.\u0026#34; 故障排除 常見問題解決 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 套件管理問題 sudo apt update --fix-missing sudo dpkg --configure -a sudo apt install -f # 網路連接問題 sudo systemctl restart networking sudo systemctl restart systemd-resolved sudo dhclient -r \u0026amp;\u0026amp; sudo dhclient # SSH 連接問題 sudo systemctl status ssh sudo systemctl restart ssh sudo tail -f /var/log/auth.log # 磁碟空間不足 sudo du -sh /* | sort -hr sudo find / -type f -size +100M sudo apt autoremove sudo apt autoclean # 記憶體不足 free -h sudo swapoff -a \u0026amp;\u0026amp; sudo swapon -a echo 3 | sudo tee /proc/sys/vm/drop_caches 總結 核心優勢 穩定可靠：企業級穩定性和長期支援 易於使用：友好的使用者介面和豐富的文檔 套件豐富：強大的 APT 套件管理系統 社群支援：活躍的開發者和使用者社群 容器化友好：優秀的 Docker 和雲端支援 最佳實踐 定期更新：保持系統和軟體包的最新狀態 安全加固：配置防火牆、fail2ban 和適當的使用者權限 監控系統：定期檢查系統效能和資源使用情況 備份重要資料：建立定期備份策略 文檔記錄：記錄系統配置和變更 學習路徑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 初學者階段 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade # 系統更新 sudo apt install package-name # 軟體安裝 systemctl status service-name # 服務管理 # 進階階段 docker run -it ubuntu:latest # 容器化應用 sudo ufw allow 80/tcp # 防火牆配置 sudo journalctl -u service-name # 日誌分析 # 專家階段 netplan apply # 網路配置 systemctl edit service-name # 服務自定義 crontab -e # 自動化任務 Ubuntu 是現代 Linux 發行版的代表，掌握其使用技巧能夠大幅提升系統管理和開發效率。記住：理解 Linux 基礎概念是有效使用 Ubuntu 的關鍵，善用社群資源和文檔可以解決大部分問題。\n參考資料 Ubuntu Official Documentation Ubuntu Community Help Wiki APT User\u0026rsquo;s Guide systemd Documentation Docker on Ubuntu ","permalink":"https://xinqilin.github.io/post/tools/ubuntu/","tags":["Ubuntu","Linux","System Administration","Package Management","Docker","Server","Command Line"],"title":"Ubuntu 系統管理完整指南：Linux 入門到進階實戰"},{"content":"Java TreeSet 完整實作指南 簡介 TreeSet 是 Java 集合框架中實現有序集合的核心類別，基於 TreeMap 實現並使用紅黑樹（Red-Black Tree）數據結構。它保證元素的唯一性和有序性，提供了 O(log n) 的時間複雜度進行搜索、插入和刪除操作。本文將深入探討 TreeSet 的內部實現、各種方法使用、效能特性以及在企業級開發中的最佳實踐。\nTreeSet 架構與繼承關係 類別繼承結構 1 2 3 4 5 6 7 8 9 Collection\u0026lt;E\u0026gt; ↑ Set\u0026lt;E\u0026gt; ↑ SortedSet\u0026lt;E\u0026gt; ↑ NavigableSet\u0026lt;E\u0026gt; ↑ TreeSet\u0026lt;E\u0026gt; 核心介面關係 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 基本集合介面 public interface Set\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt; { boolean add(E e); boolean remove(Object o); boolean contains(Object o); int size(); boolean isEmpty(); Iterator\u0026lt;E\u0026gt; iterator(); } // 有序集合介面 public interface SortedSet\u0026lt;E\u0026gt; extends Set\u0026lt;E\u0026gt; { Comparator\u0026lt;? super E\u0026gt; comparator(); SortedSet\u0026lt;E\u0026gt; subSet(E fromElement, E toElement); SortedSet\u0026lt;E\u0026gt; headSet(E toElement); SortedSet\u0026lt;E\u0026gt; tailSet(E fromElement); E first(); E last(); } // 可導航集合介面 public interface NavigableSet\u0026lt;E\u0026gt; extends SortedSet\u0026lt;E\u0026gt; { E lower(E e); E floor(E e); E ceiling(E e); E higher(E e); E pollFirst(); E pollLast(); Iterator\u0026lt;E\u0026gt; iterator(); NavigableSet\u0026lt;E\u0026gt; descendingSet(); Iterator\u0026lt;E\u0026gt; descendingIterator(); NavigableSet\u0026lt;E\u0026gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive); NavigableSet\u0026lt;E\u0026gt; headSet(E toElement, boolean inclusive); NavigableSet\u0026lt;E\u0026gt; tailSet(E fromElement, boolean inclusive); } TreeSet 核心特性 1. 基於 TreeMap 的實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // TreeSet 內部實現 public class TreeSet\u0026lt;E\u0026gt; extends AbstractSet\u0026lt;E\u0026gt; implements NavigableSet\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable { // 內部使用 TreeMap 存儲元素 private transient NavigableMap\u0026lt;E,Object\u0026gt; m; // 虛擬值，用於將 Set 轉換為 Map private static final Object PRESENT = new Object(); // 構造函數 public TreeSet() { this(new TreeMap\u0026lt;E,Object\u0026gt;()); } public TreeSet(Comparator\u0026lt;? super E\u0026gt; comparator) { this(new TreeMap\u0026lt;\u0026gt;(comparator)); } // 基本操作 public boolean add(E e) { return m.put(e, PRESENT) == null; } public boolean remove(Object o) { return m.remove(o) == PRESENT; } public boolean contains(Object o) { return m.containsKey(o); } public int size() { return m.size(); } } 2. 自然排序與自定義比較器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 自然排序 TreeSet TreeSet\u0026lt;String\u0026gt; naturalOrder = new TreeSet\u0026lt;\u0026gt;(); naturalOrder.add(\u0026#34;Charlie\u0026#34;); naturalOrder.add(\u0026#34;Alice\u0026#34;); naturalOrder.add(\u0026#34;Bob\u0026#34;); // 結果：[Alice, Bob, Charlie] // 自定義比較器 - 按長度排序 TreeSet\u0026lt;String\u0026gt; lengthOrder = new TreeSet\u0026lt;\u0026gt;( Comparator.comparing(String::length) .thenComparing(String::compareTo) // 長度相同時按字典序 ); lengthOrder.add(\u0026#34;Java\u0026#34;); lengthOrder.add(\u0026#34;C++\u0026#34;); lengthOrder.add(\u0026#34;Python\u0026#34;); lengthOrder.add(\u0026#34;Go\u0026#34;); // 結果：[Go, C++, Java, Python] // 降序排序 TreeSet\u0026lt;Integer\u0026gt; descendingOrder = new TreeSet\u0026lt;\u0026gt;(Collections.reverseOrder()); descendingOrder.add(5); descendingOrder.add(2); descendingOrder.add(8); descendingOrder.add(1); // 結果：[8, 5, 2, 1] // 複雜對象排序 TreeSet\u0026lt;Person\u0026gt; personSet = new TreeSet\u0026lt;\u0026gt;( Comparator.comparing(Person::getAge) .thenComparing(Person::getName) ); SortedSet 介面詳解 基本方法實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 public class TreeSetSortedExample { public static void main(String[] args) { TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); // 添加元素 treeSet.add(5); treeSet.add(2); treeSet.add(8); treeSet.add(1); treeSet.add(9); treeSet.add(3); demonstrateSortedSetMethods(treeSet); } private static void demonstrateSortedSetMethods(TreeSet\u0026lt;Integer\u0026gt; set) { System.out.println(\u0026#34;Original set: \u0026#34; + set); // [1, 2, 3, 5, 8, 9] // 獲取比較器 Comparator\u0026lt;? super Integer\u0026gt; comparator = set.comparator(); System.out.println(\u0026#34;Comparator: \u0026#34; + comparator); // null (natural ordering) // 第一個和最後一個元素 System.out.println(\u0026#34;First element: \u0026#34; + set.first()); // 1 System.out.println(\u0026#34;Last element: \u0026#34; + set.last()); // 9 // 子集合（含頭不含尾） SortedSet\u0026lt;Integer\u0026gt; subSet = set.subSet(2, 8); System.out.println(\u0026#34;SubSet [2, 8): \u0026#34; + subSet); // [2, 3, 5] // 頭部集合（不包含指定元素） SortedSet\u0026lt;Integer\u0026gt; headSet = set.headSet(5); System.out.println(\u0026#34;HeadSet (\u0026lt; 5): \u0026#34; + headSet); // [1, 2, 3] // 尾部集合（包含指定元素） SortedSet\u0026lt;Integer\u0026gt; tailSet = set.tailSet(5); System.out.println(\u0026#34;TailSet (\u0026gt;= 5): \u0026#34; + tailSet); // [5, 8, 9] // 迭代器 System.out.print(\u0026#34;Forward iteration: \u0026#34;); for (Integer value : set) { System.out.print(value + \u0026#34; \u0026#34;); } System.out.println(); // 降序迭代器 System.out.print(\u0026#34;Descending iteration: \u0026#34;); Iterator\u0026lt;Integer\u0026gt; descendingIterator = set.descendingIterator(); while (descendingIterator.hasNext()) { System.out.print(descendingIterator.next() + \u0026#34; \u0026#34;); } System.out.println(); } } NavigableSet 介面詳解 導航方法實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 public class TreeSetNavigableExample { public static void main(String[] args) { TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); // 添加測試數據 treeSet.add(1); treeSet.add(3); treeSet.add(5); treeSet.add(7); treeSet.add(9); demonstrateNavigableMethods(treeSet); } private static void demonstrateNavigableMethods(TreeSet\u0026lt;Integer\u0026gt; set) { System.out.println(\u0026#34;Original set: \u0026#34; + set); // [1, 3, 5, 7, 9] // Lower 方法：返回嚴格小於指定元素的最大元素 Integer lower = set.lower(5); System.out.println(\u0026#34;Lower (\u0026lt; 5): \u0026#34; + lower); // 3 // Floor 方法：返回小於或等於指定元素的最大元素 Integer floor1 = set.floor(4); Integer floor2 = set.floor(5); System.out.println(\u0026#34;Floor (\u0026lt;= 4): \u0026#34; + floor1); // 3 System.out.println(\u0026#34;Floor (\u0026lt;= 5): \u0026#34; + floor2); // 5 // Ceiling 方法：返回大於或等於指定元素的最小元素 Integer ceiling1 = set.ceiling(4); Integer ceiling2 = set.ceiling(5); System.out.println(\u0026#34;Ceiling (\u0026gt;= 4): \u0026#34; + ceiling1); // 5 System.out.println(\u0026#34;Ceiling (\u0026gt;= 5): \u0026#34; + ceiling2); // 5 // Higher 方法：返回嚴格大於指定元素的最小元素 Integer higher = set.higher(5); System.out.println(\u0026#34;Higher (\u0026gt; 5): \u0026#34; + higher); // 7 // 彈出首尾元素（會刪除元素） TreeSet\u0026lt;Integer\u0026gt; copySet = new TreeSet\u0026lt;\u0026gt;(set); Integer pollFirst = copySet.pollFirst(); Integer pollLast = copySet.pollLast(); System.out.println(\u0026#34;Poll first: \u0026#34; + pollFirst); // 1 System.out.println(\u0026#34;Poll last: \u0026#34; + pollLast); // 9 System.out.println(\u0026#34;After polling: \u0026#34; + copySet); // [3, 5, 7] // 降序視圖 NavigableSet\u0026lt;Integer\u0026gt; descendingSet = set.descendingSet(); System.out.println(\u0026#34;Descending set: \u0026#34; + descendingSet); // [9, 7, 5, 3, 1] // 範圍視圖 NavigableSet\u0026lt;Integer\u0026gt; rangeSet = set.subSet(3, true, 7, false); System.out.println(\u0026#34;Range [3, 7): \u0026#34; + rangeSet); // [3, 5] NavigableSet\u0026lt;Integer\u0026gt; headSet = set.headSet(5, true); System.out.println(\u0026#34;Head set (\u0026lt;= 5): \u0026#34; + headSet); // [1, 3, 5] NavigableSet\u0026lt;Integer\u0026gt; tailSet = set.tailSet(5, false); System.out.println(\u0026#34;Tail set (\u0026gt; 5): \u0026#34; + tailSet); // [7, 9] // 查找操作 demonstrateSearchOperations(set); } private static void demonstrateSearchOperations(TreeSet\u0026lt;Integer\u0026gt; set) { System.out.println(\u0026#34;\\n=== Search Operations ===\u0026#34;); // 測試不存在的元素 int target = 4; System.out.println(\u0026#34;Searching for: \u0026#34; + target); System.out.println(\u0026#34;Contains: \u0026#34; + set.contains(target)); // false System.out.println(\u0026#34;Lower: \u0026#34; + set.lower(target)); // 3 System.out.println(\u0026#34;Floor: \u0026#34; + set.floor(target)); // 3 System.out.println(\u0026#34;Ceiling: \u0026#34; + set.ceiling(target)); // 5 System.out.println(\u0026#34;Higher: \u0026#34; + set.higher(target)); // 5 // 測試邊界情況 System.out.println(\u0026#34;\\n=== Boundary Cases ===\u0026#34;); System.out.println(\u0026#34;Lower than first: \u0026#34; + set.lower(1)); // null System.out.println(\u0026#34;Higher than last: \u0026#34; + set.higher(9)); // null System.out.println(\u0026#34;Floor of first: \u0026#34; + set.floor(1)); // 1 System.out.println(\u0026#34;Ceiling of last: \u0026#34; + set.ceiling(9)); // 9 } } 企業級應用實例 1. 事件調度系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 public class EventScheduler { private final TreeSet\u0026lt;Event\u0026gt; eventQueue; private final ScheduledExecutorService scheduler; private final AtomicBoolean running; public EventScheduler() { // 按時間排序事件 this.eventQueue = new TreeSet\u0026lt;\u0026gt;(Comparator.comparing(Event::getScheduledTime)); this.scheduler = Executors.newScheduledThreadPool(2); this.running = new AtomicBoolean(false); } // 調度事件 public void scheduleEvent(Event event) { synchronized (eventQueue) { eventQueue.add(event); // 如果是最早的事件，重新調度 if (event.equals(eventQueue.first())) { rescheduleNext(); } } } // 取消事件 public boolean cancelEvent(Event event) { synchronized (eventQueue) { boolean removed = eventQueue.remove(event); if (removed \u0026amp;\u0026amp; !eventQueue.isEmpty()) { rescheduleNext(); } return removed; } } // 獲取即將執行的事件 public List\u0026lt;Event\u0026gt; getUpcomingEvents(int count) { synchronized (eventQueue) { return eventQueue.stream() .limit(count) .collect(Collectors.toList()); } } // 獲取指定時間範圍內的事件 public List\u0026lt;Event\u0026gt; getEventsInRange(LocalDateTime start, LocalDateTime end) { synchronized (eventQueue) { Event startEvent = new Event(\u0026#34;\u0026#34;, start, null); Event endEvent = new Event(\u0026#34;\u0026#34;, end, null); return eventQueue.subSet(startEvent, true, endEvent, false) .stream() .collect(Collectors.toList()); } } // 啟動調度器 public void start() { if (running.compareAndSet(false, true)) { rescheduleNext(); } } // 停止調度器 public void stop() { running.set(false); scheduler.shutdown(); } // 重新調度下一個事件 private void rescheduleNext() { if (!running.get()) { return; } synchronized (eventQueue) { if (eventQueue.isEmpty()) { return; } Event nextEvent = eventQueue.first(); LocalDateTime now = LocalDateTime.now(); if (nextEvent.getScheduledTime().isBefore(now)) { // 立即執行過期事件 scheduler.submit(this::processNextEvent); } else { // 計算延遲時間 long delay = Duration.between(now, nextEvent.getScheduledTime()).toMillis(); scheduler.schedule(this::processNextEvent, delay, TimeUnit.MILLISECONDS); } } } // 處理下一個事件 private void processNextEvent() { Event event = null; synchronized (eventQueue) { if (!eventQueue.isEmpty()) { event = eventQueue.pollFirst(); } } if (event != null) { try { event.execute(); } catch (Exception e) { System.err.println(\u0026#34;Event execution failed: \u0026#34; + event.getName()); e.printStackTrace(); } } // 調度下一個事件 rescheduleNext(); } // 清理過期事件 public int cleanupExpiredEvents() { synchronized (eventQueue) { LocalDateTime cutoff = LocalDateTime.now().minusHours(24); Event cutoffEvent = new Event(\u0026#34;\u0026#34;, cutoff, null); NavigableSet\u0026lt;Event\u0026gt; expiredEvents = eventQueue.headSet(cutoffEvent, true); int count = expiredEvents.size(); expiredEvents.clear(); return count; } } // 獲取統計信息 public EventStatistics getStatistics() { synchronized (eventQueue) { LocalDateTime now = LocalDateTime.now(); long pendingEvents = eventQueue.size(); long overdueEvents = eventQueue.stream() .filter(event -\u0026gt; event.getScheduledTime().isBefore(now)) .count(); LocalDateTime nextEventTime = eventQueue.isEmpty() ? null : eventQueue.first().getScheduledTime(); return new EventStatistics(pendingEvents, overdueEvents, nextEventTime); } } // 事件類 public static class Event { private final String name; private final LocalDateTime scheduledTime; private final Runnable action; public Event(String name, LocalDateTime scheduledTime, Runnable action) { this.name = name; this.scheduledTime = scheduledTime; this.action = action; } public void execute() { if (action != null) { action.run(); } } // Getters public String getName() { return name; } public LocalDateTime getScheduledTime() { return scheduledTime; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Event event = (Event) obj; return Objects.equals(name, event.name) \u0026amp;\u0026amp; Objects.equals(scheduledTime, event.scheduledTime); } @Override public int hashCode() { return Objects.hash(name, scheduledTime); } } // 統計信息類 public static class EventStatistics { private final long pendingEvents; private final long overdueEvents; private final LocalDateTime nextEventTime; public EventStatistics(long pendingEvents, long overdueEvents, LocalDateTime nextEventTime) { this.pendingEvents = pendingEvents; this.overdueEvents = overdueEvents; this.nextEventTime = nextEventTime; } // Getters public long getPendingEvents() { return pendingEvents; } public long getOverdueEvents() { return overdueEvents; } public LocalDateTime getNextEventTime() { return nextEventTime; } } } 2. 範圍查詢緩存系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 public class RangeQueryCache\u0026lt;T extends Comparable\u0026lt;T\u0026gt;\u0026gt; { private final TreeSet\u0026lt;CacheEntry\u0026lt;T\u0026gt;\u0026gt; cache; private final int maxSize; private final long ttlMillis; public RangeQueryCache(int maxSize, long ttlMillis) { this.cache = new TreeSet\u0026lt;\u0026gt;(Comparator.comparing(CacheEntry::getKey)); this.maxSize = maxSize; this.ttlMillis = ttlMillis; } // 添加緩存項 public void put(T key, Object value) { synchronized (cache) { // 移除舊值 cache.removeIf(entry -\u0026gt; entry.getKey().equals(key)); // 添加新值 CacheEntry\u0026lt;T\u0026gt; entry = new CacheEntry\u0026lt;\u0026gt;(key, value, System.currentTimeMillis() + ttlMillis); cache.add(entry); // 清理過期項 cleanupExpired(); // 如果超過容量，移除最舊的項 if (cache.size() \u0026gt; maxSize) { cache.pollFirst(); } } } // 獲取單個值 public Object get(T key) { synchronized (cache) { CacheEntry\u0026lt;T\u0026gt; searchEntry = new CacheEntry\u0026lt;\u0026gt;(key, null, 0); CacheEntry\u0026lt;T\u0026gt; found = cache.floor(searchEntry); if (found != null \u0026amp;\u0026amp; found.getKey().equals(key) \u0026amp;\u0026amp; !found.isExpired()) { return found.getValue(); } return null; } } // 範圍查詢 public List\u0026lt;Object\u0026gt; getRangeValues(T fromKey, T toKey) { synchronized (cache) { CacheEntry\u0026lt;T\u0026gt; fromEntry = new CacheEntry\u0026lt;\u0026gt;(fromKey, null, 0); CacheEntry\u0026lt;T\u0026gt; toEntry = new CacheEntry\u0026lt;\u0026gt;(toKey, null, 0); return cache.subSet(fromEntry, true, toEntry, true) .stream() .filter(entry -\u0026gt; !entry.isExpired()) .map(CacheEntry::getValue) .collect(Collectors.toList()); } } // 獲取最接近的值 public Object getClosest(T key) { synchronized (cache) { CacheEntry\u0026lt;T\u0026gt; searchEntry = new CacheEntry\u0026lt;\u0026gt;(key, null, 0); CacheEntry\u0026lt;T\u0026gt; floor = cache.floor(searchEntry); CacheEntry\u0026lt;T\u0026gt; ceiling = cache.ceiling(searchEntry); CacheEntry\u0026lt;T\u0026gt; closest = null; if (floor != null \u0026amp;\u0026amp; !floor.isExpired()) { closest = floor; } if (ceiling != null \u0026amp;\u0026amp; !ceiling.isExpired()) { if (closest == null || key.compareTo(ceiling.getKey()) \u0026lt; closest.getKey().compareTo(key)) { closest = ceiling; } } return closest != null ? closest.getValue() : null; } } // 獲取前 N 個值 public List\u0026lt;Object\u0026gt; getTopN(int n) { synchronized (cache) { return cache.stream() .filter(entry -\u0026gt; !entry.isExpired()) .limit(n) .map(CacheEntry::getValue) .collect(Collectors.toList()); } } // 清理過期項 private void cleanupExpired() { long now = System.currentTimeMillis(); cache.removeIf(entry -\u0026gt; entry.getExpirationTime() \u0026lt; now); } // 清空緩存 public void clear() { synchronized (cache) { cache.clear(); } } // 獲取緩存統計 public CacheStatistics getStatistics() { synchronized (cache) { cleanupExpired(); return new CacheStatistics(cache.size(), maxSize, getHitRatio()); } } private double getHitRatio() { // 簡化實現，實際應用中需要跟蹤命中率 return 0.85; // 示例值 } // 緩存項 private static class CacheEntry\u0026lt;T\u0026gt; { private final T key; private final Object value; private final long expirationTime; public CacheEntry(T key, Object value, long expirationTime) { this.key = key; this.value = value; this.expirationTime = expirationTime; } public boolean isExpired() { return System.currentTimeMillis() \u0026gt; expirationTime; } // Getters public T getKey() { return key; } public Object getValue() { return value; } public long getExpirationTime() { return expirationTime; } } // 統計信息 public static class CacheStatistics { private final int currentSize; private final int maxSize; private final double hitRatio; public CacheStatistics(int currentSize, int maxSize, double hitRatio) { this.currentSize = currentSize; this.maxSize = maxSize; this.hitRatio = hitRatio; } // Getters public int getCurrentSize() { return currentSize; } public int getMaxSize() { return maxSize; } public double getHitRatio() { return hitRatio; } } } 3. 分數排名系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 public class LeaderboardSystem { private final TreeSet\u0026lt;Player\u0026gt; leaderboard; private final Map\u0026lt;String, Player\u0026gt; playerMap; private final int maxSize; public LeaderboardSystem(int maxSize) { // 按分數降序排列，分數相同時按名稱升序 this.leaderboard = new TreeSet\u0026lt;\u0026gt;( Comparator.comparing(Player::getScore, Comparator.reverseOrder()) .thenComparing(Player::getName) ); this.playerMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); this.maxSize = maxSize; } // 更新玩家分數 public void updateScore(String playerName, int score) { synchronized (leaderboard) { // 移除舊記錄 Player oldPlayer = playerMap.get(playerName); if (oldPlayer != null) { leaderboard.remove(oldPlayer); } // 添加新記錄 Player newPlayer = new Player(playerName, score, System.currentTimeMillis()); leaderboard.add(newPlayer); playerMap.put(playerName, newPlayer); // 保持排行榜大小 if (leaderboard.size() \u0026gt; maxSize) { Player removed = leaderboard.pollLast(); playerMap.remove(removed.getName()); } } } // 獲取排行榜 public List\u0026lt;Player\u0026gt; getLeaderboard() { synchronized (leaderboard) { return new ArrayList\u0026lt;\u0026gt;(leaderboard); } } // 獲取前 N 名 public List\u0026lt;Player\u0026gt; getTopN(int n) { synchronized (leaderboard) { return leaderboard.stream() .limit(n) .collect(Collectors.toList()); } } // 獲取玩家排名 public int getPlayerRank(String playerName) { synchronized (leaderboard) { Player player = playerMap.get(playerName); if (player == null) { return -1; } return leaderboard.headSet(player, false).size() + 1; } } // 獲取玩家分數 public int getPlayerScore(String playerName) { Player player = playerMap.get(playerName); return player != null ? player.getScore() : -1; } // 獲取分數範圍內的玩家 public List\u0026lt;Player\u0026gt; getPlayersInScoreRange(int minScore, int maxScore) { synchronized (leaderboard) { // 創建邊界對象 Player minPlayer = new Player(\u0026#34;\u0026#34;, minScore, 0); Player maxPlayer = new Player(\u0026#34;\u0026#34;, maxScore, 0); return leaderboard.subSet(maxPlayer, true, minPlayer, true) .stream() .filter(p -\u0026gt; p.getScore() \u0026gt;= minScore \u0026amp;\u0026amp; p.getScore() \u0026lt;= maxScore) .collect(Collectors.toList()); } } // 獲取玩家周圍的排名 public List\u0026lt;Player\u0026gt; getPlayersAround(String playerName, int radius) { synchronized (leaderboard) { Player player = playerMap.get(playerName); if (player == null) { return new ArrayList\u0026lt;\u0026gt;(); } List\u0026lt;Player\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // 獲取前面的玩家 NavigableSet\u0026lt;Player\u0026gt; before = leaderboard.headSet(player, false); before.descendingSet().stream() .limit(radius) .forEach(result::add); Collections.reverse(result); // 添加當前玩家 result.add(player); // 獲取後面的玩家 NavigableSet\u0026lt;Player\u0026gt; after = leaderboard.tailSet(player, false); after.stream() .limit(radius) .forEach(result::add); return result; } } // 移除玩家 public boolean removePlayer(String playerName) { synchronized (leaderboard) { Player player = playerMap.remove(playerName); if (player != null) { return leaderboard.remove(player); } return false; } } // 清空排行榜 public void clear() { synchronized (leaderboard) { leaderboard.clear(); playerMap.clear(); } } // 獲取統計信息 public LeaderboardStatistics getStatistics() { synchronized (leaderboard) { if (leaderboard.isEmpty()) { return new LeaderboardStatistics(0, 0, 0, 0); } int totalPlayers = leaderboard.size(); int highestScore = leaderboard.first().getScore(); int lowestScore = leaderboard.last().getScore(); double averageScore = leaderboard.stream() .mapToInt(Player::getScore) .average() .orElse(0.0); return new LeaderboardStatistics(totalPlayers, highestScore, lowestScore, averageScore); } } // 玩家類 public static class Player { private final String name; private final int score; private final long timestamp; public Player(String name, int score, long timestamp) { this.name = name; this.score = score; this.timestamp = timestamp; } // Getters public String getName() { return name; } public int getScore() { return score; } public long getTimestamp() { return timestamp; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Player player = (Player) obj; return score == player.score \u0026amp;\u0026amp; Objects.equals(name, player.name); } @Override public int hashCode() { return Objects.hash(name, score); } @Override public String toString() { return String.format(\u0026#34;Player{name=\u0026#39;%s\u0026#39;, score=%d}\u0026#34;, name, score); } } // 統計信息 public static class LeaderboardStatistics { private final int totalPlayers; private final int highestScore; private final int lowestScore; private final double averageScore; public LeaderboardStatistics(int totalPlayers, int highestScore, int lowestScore, double averageScore) { this.totalPlayers = totalPlayers; this.highestScore = highestScore; this.lowestScore = lowestScore; this.averageScore = averageScore; } // Getters public int getTotalPlayers() { return totalPlayers; } public int getHighestScore() { return highestScore; } public int getLowestScore() { return lowestScore; } public double getAverageScore() { return averageScore; } } } 效能分析與優化 1. 時間複雜度分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 public class TreeSetPerformanceAnalysis { public static void main(String[] args) { performanceComparison(); memoryAnalysis(); concurrencyTest(); } // 效能比較 private static void performanceComparison() { int[] sizes = {1000, 10000, 100000, 1000000}; for (int size : sizes) { System.out.println(\u0026#34;Size: \u0026#34; + size); // TreeSet 測試 long startTime = System.nanoTime(); TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; size; i++) { treeSet.add(i); } long treeSetInsertTime = System.nanoTime() - startTime; // 搜索測試 startTime = System.nanoTime(); for (int i = 0; i \u0026lt; 1000; i++) { treeSet.contains(i * size / 1000); } long treeSetSearchTime = System.nanoTime() - startTime; // HashSet 比較 startTime = System.nanoTime(); HashSet\u0026lt;Integer\u0026gt; hashSet = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; size; i++) { hashSet.add(i); } long hashSetInsertTime = System.nanoTime() - startTime; startTime = System.nanoTime(); for (int i = 0; i \u0026lt; 1000; i++) { hashSet.contains(i * size / 1000); } long hashSetSearchTime = System.nanoTime() - startTime; System.out.printf(\u0026#34;TreeSet - Insert: %d ns, Search: %d ns\\n\u0026#34;, treeSetInsertTime, treeSetSearchTime); System.out.printf(\u0026#34;HashSet - Insert: %d ns, Search: %d ns\\n\\n\u0026#34;, hashSetInsertTime, hashSetSearchTime); } } // 記憶體分析 private static void memoryAnalysis() { Runtime runtime = Runtime.getRuntime(); runtime.gc(); long beforeMemory = runtime.totalMemory() - runtime.freeMemory(); TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100000; i++) { treeSet.add(i); } long afterMemory = runtime.totalMemory() - runtime.freeMemory(); System.out.println(\u0026#34;TreeSet memory usage: \u0026#34; + (afterMemory - beforeMemory) + \u0026#34; bytes\u0026#34;); // 對比 HashSet runtime.gc(); beforeMemory = runtime.totalMemory() - runtime.freeMemory(); HashSet\u0026lt;Integer\u0026gt; hashSet = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100000; i++) { hashSet.add(i); } afterMemory = runtime.totalMemory() - runtime.freeMemory(); System.out.println(\u0026#34;HashSet memory usage: \u0026#34; + (afterMemory - beforeMemory) + \u0026#34; bytes\u0026#34;); } // 並發測試 private static void concurrencyTest() { TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); ConcurrentSkipListSet\u0026lt;Integer\u0026gt; concurrentSet = new ConcurrentSkipListSet\u0026lt;\u0026gt;(); // 填充初始數據 for (int i = 0; i \u0026lt; 10000; i++) { treeSet.add(i); concurrentSet.add(i); } // 並發讀取測試 int threadCount = 4; ExecutorService executor = Executors.newFixedThreadPool(threadCount); System.out.println(\u0026#34;Concurrent read test:\u0026#34;); // TreeSet 同步讀取 long startTime = System.nanoTime(); CountDownLatch latch = new CountDownLatch(threadCount); for (int i = 0; i \u0026lt; threadCount; i++) { executor.submit(() -\u0026gt; { try { for (int j = 0; j \u0026lt; 10000; j++) { synchronized (treeSet) { treeSet.contains(j); } } } finally { latch.countDown(); } }); } try { latch.await(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } long treeSetTime = System.nanoTime() - startTime; System.out.println(\u0026#34;TreeSet (synchronized): \u0026#34; + treeSetTime + \u0026#34; ns\u0026#34;); // ConcurrentSkipListSet 測試 startTime = System.nanoTime(); latch = new CountDownLatch(threadCount); for (int i = 0; i \u0026lt; threadCount; i++) { executor.submit(() -\u0026gt; { try { for (int j = 0; j \u0026lt; 10000; j++) { concurrentSet.contains(j); } } finally { latch.countDown(); } }); } try { latch.await(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } long concurrentSetTime = System.nanoTime() - startTime; System.out.println(\u0026#34;ConcurrentSkipListSet: \u0026#34; + concurrentSetTime + \u0026#34; ns\u0026#34;); executor.shutdown(); } } 2. 最佳化建議 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 public class TreeSetOptimizationTips { // 1. 使用適當的比較器 public static void comparatorOptimization() { // 避免在比較器中進行複雜計算 TreeSet\u0026lt;String\u0026gt; badExample = new TreeSet\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { // 壞例子：每次比較都進行昂貴的計算 return expensiveCalculation(s1) - expensiveCalculation(s2); }); // 好例子：預先計算或使用緩存 Map\u0026lt;String, Integer\u0026gt; cache = new ConcurrentHashMap\u0026lt;\u0026gt;(); TreeSet\u0026lt;String\u0026gt; goodExample = new TreeSet\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { int val1 = cache.computeIfAbsent(s1, TreeSetOptimizationTips::expensiveCalculation); int val2 = cache.computeIfAbsent(s2, TreeSetOptimizationTips::expensiveCalculation); return val1 - val2; }); } // 2. 批量操作優化 public static void batchOperationOptimization() { TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); // 批量添加比單個添加效率更高 Collection\u0026lt;Integer\u0026gt; batchData = Arrays.asList(1, 2, 3, 4, 5); treeSet.addAll(batchData); // 使用子集合進行批量操作 NavigableSet\u0026lt;Integer\u0026gt; subSet = treeSet.subSet(2, true, 4, false); subSet.clear(); // 比逐個刪除效率更高 } // 3. 記憶體優化 public static void memoryOptimization() { // 使用原始類型包裝器時注意自動裝箱 TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 避免不必要的對象創建 for (int i = 0; i \u0026lt; 1000; i++) { set.add(i); // 會創建 Integer 對象 } // 考慮使用專門的原始類型集合庫 // 如 Eclipse Collections 的 IntSortedSet } // 4. 並發優化 public static void concurrencyOptimization() { TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); // 使用 ConcurrentSkipListSet 替代同步的 TreeSet ConcurrentSkipListSet\u0026lt;Integer\u0026gt; concurrentSet = new ConcurrentSkipListSet\u0026lt;\u0026gt;(); // 或者使用讀寫鎖 ReadWriteLock lock = new ReentrantReadWriteLock(); ReadLock readLock = lock.readLock(); WriteLock writeLock = lock.writeLock(); // 讀操作 readLock.lock(); try { treeSet.contains(1); } finally { readLock.unlock(); } // 寫操作 writeLock.lock(); try { treeSet.add(1); } finally { writeLock.unlock(); } } private static int expensiveCalculation(String s) { // 模擬昂貴的計算 return s.hashCode() * 31; } } 實際應用場景 1. LeetCode 問題解決 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 public class TreeSetLeetCodeSolutions { // LeetCode 1845: 座位預約管理系統 static class SeatManager { private TreeSet\u0026lt;Integer\u0026gt; availableSeats; public SeatManager(int n) { availableSeats = new TreeSet\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;= n; i++) { availableSeats.add(i); } } public int reserve() { return availableSeats.pollFirst(); } public void unreserve(int seatNumber) { availableSeats.add(seatNumber); } } // LeetCode 855: 考場就座 static class ExamRoom { private TreeSet\u0026lt;Integer\u0026gt; seats; private int n; public ExamRoom(int n) { this.n = n; this.seats = new TreeSet\u0026lt;\u0026gt;(); } public int seat() { int seat = 0; if (!seats.isEmpty()) { int maxDistance = seats.first(); // 檢查中間位置 Integer prev = null; for (Integer s : seats) { if (prev != null) { int distance = (s - prev) / 2; if (distance \u0026gt; maxDistance) { maxDistance = distance; seat = prev + distance; } } prev = s; } // 檢查最後位置 if (n - 1 - seats.last() \u0026gt; maxDistance) { seat = n - 1; } } seats.add(seat); return seat; } public void leave(int p) { seats.remove(p); } } // LeetCode 895: 最大頻率棧 static class FreqStack { private TreeSet\u0026lt;Element\u0026gt; elements; private Map\u0026lt;Integer, Integer\u0026gt; freq; private int timestamp; public FreqStack() { elements = new TreeSet\u0026lt;\u0026gt;((a, b) -\u0026gt; { if (a.frequency != b.frequency) { return b.frequency - a.frequency; // 頻率降序 } return b.timestamp - a.timestamp; // 時間降序 }); freq = new HashMap\u0026lt;\u0026gt;(); timestamp = 0; } public void push(int x) { int oldFreq = freq.getOrDefault(x, 0); int newFreq = oldFreq + 1; if (oldFreq \u0026gt; 0) { elements.remove(new Element(x, oldFreq, -1)); } elements.add(new Element(x, newFreq, timestamp++)); freq.put(x, newFreq); } public int pop() { Element top = elements.pollFirst(); int val = top.value; int newFreq = freq.get(val) - 1; if (newFreq \u0026gt; 0) { freq.put(val, newFreq); elements.add(new Element(val, newFreq, timestamp++)); } else { freq.remove(val); } return val; } static class Element { int value; int frequency; int timestamp; Element(int value, int frequency, int timestamp) { this.value = value; this.frequency = frequency; this.timestamp = timestamp; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Element element = (Element) obj; return value == element.value \u0026amp;\u0026amp; frequency == element.frequency; } @Override public int hashCode() { return Objects.hash(value, frequency); } } } // LeetCode 1499: 滿足不等式的最大值 public int findMaxValueOfEquation(int[][] points, int k) { // 使用 TreeSet 維護滑動窗口 TreeSet\u0026lt;Point\u0026gt; window = new TreeSet\u0026lt;\u0026gt;((a, b) -\u0026gt; { if (a.yMinusX != b.yMinusX) { return b.yMinusX - a.yMinusX; // 按 y-x 降序 } return a.x - b.x; // 按 x 升序 }); int maxValue = Integer.MIN_VALUE; for (int[] point : points) { int x = point[0]; int y = point[1]; // 移除窗口外的點 window.removeIf(p -\u0026gt; x - p.x \u0026gt; k); // 如果窗口不為空，計算最大值 if (!window.isEmpty()) { Point best = window.first(); maxValue = Math.max(maxValue, y + x + best.yMinusX); } // 添加當前點 window.add(new Point(x, y - x)); } return maxValue; } static class Point { int x; int yMinusX; Point(int x, int yMinusX) { this.x = x; this.yMinusX = yMinusX; } } } 2. 數據結構應用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 public class TreeSetDataStructureApplications { // 滑動窗口最大值 public static class SlidingWindowMaximum { private TreeSet\u0026lt;Element\u0026gt; window; private int windowSize; private int index; public SlidingWindowMaximum(int windowSize) { this.window = new TreeSet\u0026lt;\u0026gt;((a, b) -\u0026gt; { if (a.value != b.value) { return b.value - a.value; // 值降序 } return a.index - b.index; // 索引升序 }); this.windowSize = windowSize; this.index = 0; } public void addNumber(int num) { // 添加新元素 window.add(new Element(num, index)); // 移除窗口外的元素 if (index \u0026gt;= windowSize) { window.removeIf(e -\u0026gt; e.index \u0026lt;= index - windowSize); } index++; } public int getMaximum() { return window.isEmpty() ? 0 : window.first().value; } static class Element { int value; int index; Element(int value, int index) { this.value = value; this.index = index; } } } // 動態中位數 public static class DynamicMedian { private TreeSet\u0026lt;Element\u0026gt; elements; private int index; public DynamicMedian() { this.elements = new TreeSet\u0026lt;\u0026gt;((a, b) -\u0026gt; { if (a.value != b.value) { return a.value - b.value; // 值升序 } return a.index - b.index; // 索引升序 }); this.index = 0; } public void addNumber(int num) { elements.add(new Element(num, index++)); } public double getMedian() { int size = elements.size(); if (size == 0) return 0; List\u0026lt;Element\u0026gt; sortedElements = new ArrayList\u0026lt;\u0026gt;(elements); if (size % 2 == 1) { return sortedElements.get(size / 2).value; } else { return (sortedElements.get(size / 2 - 1).value + sortedElements.get(size / 2).value) / 2.0; } } static class Element { int value; int index; Element(int value, int index) { this.value = value; this.index = index; } } } // 區間調度 public static class IntervalScheduler { private TreeSet\u0026lt;Interval\u0026gt; intervals; public IntervalScheduler() { this.intervals = new TreeSet\u0026lt;\u0026gt;(Comparator.comparing(Interval::getStart)); } public boolean canSchedule(int start, int end) { Interval newInterval = new Interval(start, end); // 檢查是否與現有區間重疊 Interval floor = intervals.floor(newInterval); if (floor != null \u0026amp;\u0026amp; floor.getEnd() \u0026gt; start) { return false; } Interval ceiling = intervals.ceiling(newInterval); if (ceiling != null \u0026amp;\u0026amp; ceiling.getStart() \u0026lt; end) { return false; } return true; } public boolean schedule(int start, int end) { if (canSchedule(start, end)) { intervals.add(new Interval(start, end)); return true; } return false; } public List\u0026lt;Interval\u0026gt; getSchedule() { return new ArrayList\u0026lt;\u0026gt;(intervals); } static class Interval { private final int start; private final int end; public Interval(int start, int end) { this.start = start; this.end = end; } public int getStart() { return start; } public int getEnd() { return end; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Interval interval = (Interval) obj; return start == interval.start \u0026amp;\u0026amp; end == interval.end; } @Override public int hashCode() { return Objects.hash(start, end); } } } } 最佳實踐與建議 1. 選擇適當的比較策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 public class TreeSetBestPractices { // 1. 自然排序 vs 自定義比較器 public static void comparatorChoice() { // 對於實現 Comparable 的類型，使用自然排序 TreeSet\u0026lt;String\u0026gt; naturalOrder = new TreeSet\u0026lt;\u0026gt;(); // 對於需要自定義排序的情況，使用比較器 TreeSet\u0026lt;String\u0026gt; customOrder = new TreeSet\u0026lt;\u0026gt;(String.CASE_INSENSITIVE_ORDER); // 複雜對象的多字段排序 TreeSet\u0026lt;Person\u0026gt; personSet = new TreeSet\u0026lt;\u0026gt;( Comparator.comparing(Person::getAge) .thenComparing(Person::getName) ); } // 2. 空值處理 public static void nullHandling() { // TreeSet 不允許 null 元素 TreeSet\u0026lt;String\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // set.add(null); // 會拋出 NullPointerException // 如果需要支持 null 值，使用自定義比較器 TreeSet\u0026lt;String\u0026gt; nullSafeSet = new TreeSet\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { if (s1 == null \u0026amp;\u0026amp; s2 == null) return 0; if (s1 == null) return -1; if (s2 == null) return 1; return s1.compareTo(s2); }); } // 3. 線程安全處理 public static void threadSafety() { TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); // 方法1：使用 Collections.synchronizedSet Set\u0026lt;Integer\u0026gt; syncSet = Collections.synchronizedSet(treeSet); // 方法2：使用 ConcurrentSkipListSet ConcurrentSkipListSet\u0026lt;Integer\u0026gt; concurrentSet = new ConcurrentSkipListSet\u0026lt;\u0026gt;(); // 方法3：使用讀寫鎖 ReadWriteLock lock = new ReentrantReadWriteLock(); // 在讀寫操作時使用相應的鎖 } // 4. 效能考慮 public static void performanceConsiderations() { // 批量添加比單個添加效率更高 Collection\u0026lt;Integer\u0026gt; data = Arrays.asList(1, 2, 3, 4, 5); TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(data); // 避免頻繁的範圍查詢操作 NavigableSet\u0026lt;Integer\u0026gt; subSet = treeSet.subSet(2, true, 4, false); // 對 subSet 的操作會影響原始 set } static class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } } } 2. 常見錯誤避免 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 public class TreeSetCommonMistakes { // 錯誤1：在迭代過程中修改 TreeSet public static void avoidConcurrentModification() { TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 10; i++) { set.add(i); } // 錯誤的做法 // for (Integer value : set) { // if (value % 2 == 0) { // set.remove(value); // ConcurrentModificationException // } // } // 正確的做法1：使用迭代器 Iterator\u0026lt;Integer\u0026gt; iterator = set.iterator(); while (iterator.hasNext()) { if (iterator.next() % 2 == 0) { iterator.remove(); } } // 正確的做法2：收集要刪除的元素 Set\u0026lt;Integer\u0026gt; toRemove = set.stream() .filter(value -\u0026gt; value % 2 == 0) .collect(Collectors.toSet()); set.removeAll(toRemove); } // 錯誤2：比較器不一致 public static void avoidInconsistentComparator() { // 錯誤：比較器與 equals 不一致 TreeSet\u0026lt;String\u0026gt; badSet = new TreeSet\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { return s1.length() - s2.length(); // 只比較長度 }); badSet.add(\u0026#34;abc\u0026#34;); badSet.add(\u0026#34;def\u0026#34;); // 會被忽略，因為長度相同 // 正確：確保比較器一致性 TreeSet\u0026lt;String\u0026gt; goodSet = new TreeSet\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { int lengthCompare = s1.length() - s2.length(); if (lengthCompare != 0) { return lengthCompare; } return s1.compareTo(s2); // 長度相同時比較內容 }); } // 錯誤3：誤用子集合 public static void avoidSubSetMisuse() { TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 10; i++) { set.add(i); } // 錯誤：認為子集合是獨立的 NavigableSet\u0026lt;Integer\u0026gt; subSet = set.subSet(2, true, 8, false); subSet.clear(); // 這會影響原始 set // 正確：如果需要獨立的副本 NavigableSet\u0026lt;Integer\u0026gt; independentCopy = new TreeSet\u0026lt;\u0026gt;(subSet); } } 總結 TreeSet 是 Java 集合框架中功能強大的有序集合實現，基於紅黑樹提供了 O(log n) 的高效操作。通過本文的深入分析，我們了解了：\n核心特性：基於 TreeMap 的有序存儲，支持自然排序和自定義比較器 介面層次：從 Set 到 SortedSet 再到 NavigableSet 的完整功能 實用方法：豐富的範圍查詢、導航操作和視圖方法 企業應用：事件調度、範圍查詢、排名系統等實際場景 效能優化：比較器優化、批量操作、並發處理等最佳實踐 常見陷阱：並發修改、比較器一致性、子集合使用等需要注意的問題 正確使用 TreeSet 可以在需要有序集合的場景中提供高效、可靠的解決方案，是 Java 開發者必須掌握的重要工具之一。\n","permalink":"https://xinqilin.github.io/post/backend/treeset/","tags":["Java","TreeSet","Data Structure","Red-Black Tree","Collections","Sorting","NavigableSet","SortedSet","Binary Search Tree","Performance","Algorithms","Enterprise","Best Practices","Thread Safety","Concurrency"],"title":"Java TreeSet 完整實作指南：紅黑樹有序集合與 NavigableSet 介面詳解"},{"content":"概述 在撰寫 Shell Script 時，我們經常需要對檔案、目錄或字串的狀態進行判斷，例如檢查檔案是否存在、是否可讀，或判斷字串是否為空。這時就需要使用測試表達式 [ ... ] 或 test 指令。本文將詳細介紹這些常用的表達式及其用法。\n檔案測試表達式 檔案測試表達式用於判斷檔案的類型或權限狀態。其回傳值為布林值（true 或 false），可搭配 if 條件式使用。\n語法 1 2 3 if [ -\u0026lt;operator\u0026gt; \u0026lt;filename\u0026gt; ]; then # do something fi 常用運算子 運算子 說明 範例 -e 如果檔案存在 (exist)，則為 true [ -e /etc/hosts ] -d 如果檔案是目錄 (directory)，則為 true [ -d /home/user ] -f 如果檔案是常規檔案 (regular file)，則為 true [ -f /etc/passwd ] -L 如果檔案是符號連結 (symbolic link)，則為 true [ -L /usr/bin/python ] -h 與 -L 相同，如果檔案是符號連結，則為 true [ -h /usr/bin/python ] -r 如果檔案可讀 (readable)，則為 true [ -r /etc/shadow ] -w 如果檔案可寫 (writable)，則為 true [ -w /tmp/test.log ] -x 如果檔案可執行 (executable)，則為 true [ -x ./deploy.sh ] -s 如果檔案大小不為 0，則為 true [ -s /var/log/syslog ] 檔案比較運算子 用於比較兩個檔案的新舊關係。\n運算子 說明 範例 f1 -nt f2 如果檔案 f1 比 f2 新 (newer than)，則為 true [ file1.log -nt file2.log ] f1 -ot f2 如果檔案 f1 比 f2 舊 (older than)，則為 true [ file1.log -ot file2.log ] 字串與數值測試表達式 除了檔案，測試表達式也常用於比較數值或判斷字串狀態。\n數值比較 運算子 說明 等價符號 -eq 等於 (equal) == -ne 不等於 (not equal) != -gt 大於 (greater than) \u0026gt; -ge 大於或等於 (greater or equal) \u0026gt;= -lt 小於 (less than) \u0026lt; -le 小於或等於 (less or equal) \u0026lt;= 字串比較 運算子 說明 範例 -n 如果字串長度不為 0，則為 true [ -n \u0026quot;$my_var\u0026quot; ] -z 如果字串長度為 0 (zero)，則為 true [ -z \u0026quot;$my_var\u0026quot; ] $string 如果字串不為空，則為 true (與 -n 效果相同) [ \u0026quot;$my_var\u0026quot; ] 邏輯運算子 用於組合多個表達式。\n運算子 說明 範例 ! NOT：反轉表達式的結果 [ ! -d /tmp/non_existent ] -a AND：兩個表達式都為 true 時，結果才為 true [ -r \u0026quot;$file\u0026quot; -a -s \u0026quot;$file\u0026quot; ] -o OR：兩個表達式只要有一個為 true，結果就為 true [ -d \u0026quot;$dir\u0026quot; -o -f \u0026quot;$dir\u0026quot; ] 注意：建議使用 \u0026amp;\u0026amp; 和 || 來取代 -a 和 -o，因為它們更符合現代 Shell 的標準且更安全。\n1 2 3 4 5 6 7 8 9 # 使用 \u0026amp;\u0026amp; (AND) if [ -r \u0026#34;$file\u0026#34; ] \u0026amp;\u0026amp; [ -s \u0026#34;$file\u0026#34; ]; then echo \u0026#34;檔案可讀且內容不為空\u0026#34; fi # 使用 || (OR) if [ -d \u0026#34;$path\u0026#34; ] || [ -f \u0026#34;$path\u0026#34; ]; then echo \u0026#34;路徑是一個目錄或檔案\u0026#34; fi 實用範例 範例 1：檢查目錄是否存在，若不存在則建立 1 2 3 4 5 6 7 8 9 10 #!/bin/bash LOG_DIR=\u0026#34;/var/log/myapp\u0026#34; if [ ! -d \u0026#34;$LOG_DIR\u0026#34; ]; then echo \u0026#34;日誌目錄不存在，正在建立: $LOG_DIR\u0026#34; mkdir -p \u0026#34;$LOG_DIR\u0026#34; else echo \u0026#34;日誌目錄已存在。\u0026#34; fi 範例 2：檢查字串變數是否為空 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/bash USERNAME=\u0026#34;\u0026#34; # ... 從某處讀取使用者名稱 ... if [ -z \u0026#34;$USERNAME\u0026#34; ]; then echo \u0026#34;錯誤：使用者名稱不能為空！\u0026#34; exit 1 fi # 另一種寫法 if [ ! \u0026#34;$USERNAME\u0026#34; ]; then echo \u0026#34;錯誤：使用者名稱不能為空！\u0026#34; exit 1 fi 範例 3：結合多個條件 1 2 3 4 5 6 7 8 9 10 #!/bin/bash CONFIG_FILE=\u0026#34;config.conf\u0026#34; if [ -f \u0026#34;$CONFIG_FILE\u0026#34; ] \u0026amp;\u0026amp; [ -r \u0026#34;$CONFIG_FILE\u0026#34; ]; then echo \u0026#34;設定檔存在且可讀取，載入設定...\u0026#34; source \u0026#34;$CONFIG_FILE\u0026#34; else echo \u0026#34;警告：找不到設定檔或無法讀取。\u0026#34; fi ","permalink":"https://xinqilin.github.io/post/tools/fileexpress/","tags":["Shell","Bash","File System","Scripting"],"title":"Shell 檔案與字串表達式詳解"},{"content":"概述 鏈表反轉是數據結構與演算法中的經典問題，要求將單向鏈表的指向關係完全反轉。這個問題看似簡單，但涉及到指標操作的細節，是考驗編程基本功的重要題型。\n問題定義 給定一個單向鏈表，將其反轉並回傳新的頭節點。\n範例：\n1 2 輸入：1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; NULL 輸出：5 -\u0026gt; 4 -\u0026gt; 3 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; NULL 鏈表節點定義 1 2 3 4 5 6 7 8 9 10 11 public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } 解法一：迭代實作 基本思路 使用三個指標 prev、current、next 來逐步改變每個節點的指向關係。\n算法步驟 初始化 prev = null，current = head 當 current != null 時： 保存 current.next 到 next 將 current.next 指向 prev 移動 prev 和 current 指標 回傳 prev（新的頭節點） 實作代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode current = head; while (current != null) { ListNode next = current.next; // 保存下一個節點 current.next = prev; // 反轉指標 prev = current; // 移動 prev current = next; // 移動 current } return prev; // prev 現在是新的頭節點 } } 圖解過程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 初始狀態： prev = null, current = 1 null 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null 第一步： next = 2, current.next = prev null \u0026lt;- 1 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null prev current 第二步： next = 3, current.next = prev null \u0026lt;- 1 \u0026lt;- 2 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null prev current ... 最終狀態： null \u0026lt;- 1 \u0026lt;- 2 \u0026lt;- 3 \u0026lt;- 4 \u0026lt;- 5 null prev current 解法二：遞歸實作 基本思路 使用遞歸的方式，從鏈表尾部開始反轉，利用遞歸回溯的特性來改變指標指向。\n算法步驟 遞歸到鏈表最後一個節點 在回溯過程中，逐步反轉每個節點的指向 回傳原鏈表的尾節點（新的頭節點） 實作代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Solution { public ListNode reverseList(ListNode head) { // 基礎情況：空節點或只有一個節點 if (head == null || head.next == null) { return head; } // 遞歸反轉子鏈表 ListNode newHead = reverseList(head.next); // 反轉當前節點的指向 head.next.next = head; head.next = null; return newHead; } } 遞歸過程分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 原鏈表：1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null 遞歸調用棧： reverseList(1) -\u0026gt; reverseList(2) -\u0026gt; ... -\u0026gt; reverseList(5) 回溯階段： 1. reverseList(5) 回傳 5 2. reverseList(4)： - newHead = 5 - 4.next.next = 4 (即 5.next = 4) - 4.next = null - 回傳 5 3. reverseList(3)： - newHead = 5 - 3.next.next = 3 (即 4.next = 3) - 3.next = null - 回傳 5 ... 最終結果：5 -\u0026gt; 4 -\u0026gt; 3 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; null 時間與空間複雜度分析 方法 時間複雜度 空間複雜度 優點 缺點 迭代 O(n) O(1) 空間效率高，直觀易懂 需要處理多個指標 遞歸 O(n) O(n) 代碼簡潔，邏輯清晰 使用額外堆疊空間 進階應用 1. 反轉鏈表的前 N 個節點 問題：反轉鏈表的前 N 個節點。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Solution { private ListNode successor = null; // 後驅節點 public ListNode reverseN(ListNode head, int n) { if (n == 1) { // 記錄第 n+1 個節點 successor = head.next; return head; } // 以 head.next 為起點，需要反轉前 n-1 個節點 ListNode last = reverseN(head.next, n - 1); head.next.next = head; head.next = successor; // 讓反轉之後的 head 節點和後面的節點連起來 return last; } } 2. 反轉鏈表的指定區間（LeetCode 92） 問題：反轉從位置 m 到 n 的鏈表。請使用一趟掃描完成反轉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { // 創建虛擬頭節點 ListNode dummy = new ListNode(0); dummy.next = head; // 找到 left 的前一個節點 ListNode prev = dummy; for (int i = 0; i \u0026lt; left - 1; i++) { prev = prev.next; } // 開始反轉 ListNode current = prev.next; ListNode next = null; for (int i = 0; i \u0026lt; right - left; i++) { next = current.next; current.next = next.next; next.next = prev.next; prev.next = next; } return dummy.next; } } 3. K 個一組反轉鏈表（LeetCode 25） 問題：給定一個鏈表，每 k 個節點一組進行反轉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class Solution { public ListNode reverseKGroup(ListNode head, int k) { if (head == null) return null; // 檢查剩餘節點是否足夠 k 個 ListNode a = head, b = head; for (int i = 0; i \u0026lt; k; i++) { if (b == null) return head; // 不足 k 個，直接返回 b = b.next; } // 反轉前 k 個元素 ListNode newHead = reverse(a, b); // 遞歸反轉後續的鏈表並連接 a.next = reverseKGroup(b, k); return newHead; } // 反轉 [a, b) 區間的鏈表 private ListNode reverse(ListNode a, ListNode b) { ListNode prev = null; ListNode current = a; while (current != b) { ListNode next = current.next; current.next = prev; prev = current; current = next; } return prev; } } 實作技巧與注意事項 1. 邊界條件處理 1 2 3 4 // 檢查空鏈表和單節點鏈表 if (head == null || head.next == null) { return head; } 2. 使用虛擬頭節點 在處理鏈表頭部變化的問題時，虛擬頭節點可以簡化邏輯：\n1 2 3 4 ListNode dummy = new ListNode(0); dummy.next = head; // ... 操作 return dummy.next; 3. 指標操作的順序 在改變指標指向時，必須先保存下一個節點：\n1 2 ListNode next = current.next; // 先保存 current.next = prev; // 再修改 4. 遞歸終止條件 確保遞歸有明確的終止條件：\n1 2 3 if (head == null || head.next == null) { return head; // 基礎情況 } 常見變體問題 1. 判斷鏈表是否為回文 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public boolean isPalindrome(ListNode head) { if (head == null) return true; // 找到中點 ListNode slow = head, fast = head; while (fast.next != null \u0026amp;\u0026amp; fast.next.next != null) { slow = slow.next; fast = fast.next.next; } // 反轉後半部分 ListNode secondHalf = reverseList(slow.next); // 比較前後兩部分 ListNode p1 = head, p2 = secondHalf; while (p2 != null) { if (p1.val != p2.val) return false; p1 = p1.next; p2 = p2.next; } return true; } 2. 兩兩交換鏈表中的節點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode prev = dummy; while (prev.next != null \u0026amp;\u0026amp; prev.next.next != null) { ListNode first = prev.next; ListNode second = prev.next.next; // 交換 prev.next = second; first.next = second.next; second.next = first; // 移動 prev prev = first; } return dummy.next; } 最佳實踐 選擇合適的方法：對於簡單的鏈表反轉，推薦使用迭代方法 注意空間複雜度：在空間受限的環境下避免使用遞歸 處理邊界情況：始終檢查空鏈表和單節點情況 使用虛擬節點：簡化頭節點的處理邏輯 測試充分：測試各種邊界情況和特殊輸入 總結 鏈表反轉是一個看似簡單但細節豐富的問題。掌握這個問題的關鍵在於：\n理解指標操作：正確處理節點間的指向關係 選擇合適方法：根據場景選擇迭代或遞歸實作 處理邊界情況：確保算法在各種輸入下都能正確運行 靈活應用：將基本技巧應用到更複雜的變體問題中 通過反復練習和理解，鏈表反轉將成為解決更複雜鏈表問題的基礎技能。\n參考資料 LeetCode 206. Reverse Linked List LeetCode 92. Reverse Linked List II LeetCode 25. Reverse Nodes in k-Group LeetCode 234. Palindrome Linked List 演算法導論 - 鏈表操作 ","permalink":"https://xinqilin.github.io/post/algorithm/reverselinkedlist/","tags":["Algorithm","LinkedList","Recursion","Java","Pointer"],"title":"鏈表反轉（Reverse Linked List）完整解析"},{"content":"概述 並查集（Union-Find）又稱為不相交集合（Disjoint Set），是一種用來處理不相交集合的合併和查詢問題的數據結構。它支援兩種主要操作：\nFind：查找元素所屬的集合（返回集合的代表元素） Union：合併兩個不同的集合 並查集在圖論演算法中應用廣泛，特別適用於解決連通性問題。\n基本原理 核心概念 並查集將每個集合表示為一棵樹，樹的根節點作為該集合的代表元素。初始狀態下，每個元素都是獨立的集合（自己是自己的父節點）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 初始狀態： 0 1 2 3 4 ↓ ↓ ↓ ↓ ↓ 0 1 2 3 4 合併 0 和 1 後： 0 2 3 4 ↙ ↓ ↓ ↓ 1 2 3 4 合併 2 和 3 後： 0 2 4 ↙ ↙ ↓ 1 3 4 基本實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 public class UnionFind { private int[] parent; // parent[i] 表示元素 i 的父節點 private int[] rank; // rank[i] 表示以 i 為根的樹的高度 private int components; // 連通分量的數量 public UnionFind(int n) { parent = new int[n]; rank = new int[n]; components = n; // 初始化：每個元素都是獨立的集合 for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; // 自己是自己的父節點 rank[i] = 0; // 初始高度為 0 } } /** * 查找元素 x 所屬集合的代表元素 */ public int find(int x) { if (parent[x] != x) { // 路徑壓縮：將路徑上所有節點直接連接到根節點 parent[x] = find(parent[x]); } return parent[x]; } /** * 合併元素 x 和 y 所屬的集合 */ public boolean union(int x, int y) { int rootX = find(x); int rootY = find(y); // 如果已經在同一個集合中，返回 false if (rootX == rootY) { return false; } // 按秩合併：將較矮的樹合併到較高的樹下 if (rank[rootX] \u0026lt; rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] \u0026gt; rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; // 高度相同時，合併後高度加 1 } components--; // 連通分量減 1 return true; } /** * 檢查兩個元素是否在同一個集合中 */ public boolean connected(int x, int y) { return find(x) == find(y); } /** * 獲取連通分量的數量 */ public int getComponentCount() { return components; } } 優化技巧 1. 路徑壓縮（Path Compression） 在 find 操作中，將查找路徑上的所有節點直接連接到根節點，使樹變得更加扁平。\n1 2 3 4 5 6 public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); // 遞歸壓縮路徑 } return parent[x]; } 2. 按秩合併（Union by Rank） 總是將較矮的樹合併到較高的樹下，避免樹變得過高。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public boolean union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) return false; // 按秩合併 if (rank[rootX] \u0026lt; rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] \u0026gt; rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; } return true; } 3. 按大小合併（Union by Size） 另一種優化策略是將較小的集合合併到較大的集合中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class UnionFindBySize { private int[] parent; private int[] size; // size[i] 表示以 i 為根的集合大小 public UnionFindBySize(int n) { parent = new int[n]; size = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; size[i] = 1; // 初始每個集合大小為 1 } } public boolean union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) return false; // 按大小合併：將小集合合併到大集合 if (size[rootX] \u0026lt; size[rootY]) { parent[rootX] = rootY; size[rootY] += size[rootX]; } else { parent[rootY] = rootX; size[rootX] += size[rootY]; } return true; } } 時間複雜度 操作 時間複雜度 說明 初始化 O(n) 建立 n 個獨立集合 Find（無優化） O(n) 最壞情況下需要遍歷整條鏈 Union（無優化） O(n) 需要調用 Find 操作 Find（路徑壓縮） O(α(n)) α(n) 是阿克曼函數的反函數 Union（按秩合併） O(α(n)) 近似常數時間 其中 α(n) 是阿克曼函數的反函數，在實際應用中可視為常數。\n經典應用題型 1. 等式方程的可滿足性（LeetCode 990） 問題描述：給定一個由表示變數之間關係的字串組成的陣列 equations，每個字串 equations[i] 的長度為 4，有兩種形式：\u0026quot;a==b\u0026quot; 或 \u0026quot;a!=b\u0026quot;。判斷是否所有等式都能同時滿足。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { private int[] parent = new int[26]; // 26 個字母 public boolean equationsPossible(String[] equations) { // 初始化並查集 for (int i = 0; i \u0026lt; 26; i++) { parent[i] = i; } // 第一遍：處理所有等式，合併相等的變數 for (String equation : equations) { if (equation.charAt(1) == \u0026#39;=\u0026#39;) { union(equation.charAt(0) - \u0026#39;a\u0026#39;, equation.charAt(3) - \u0026#39;a\u0026#39;); } } // 第二遍：檢查不等式是否違反了等式的結果 for (String equation : equations) { if (equation.charAt(1) == \u0026#39;!\u0026#39;) { int x = equation.charAt(0) - \u0026#39;a\u0026#39;; int y = equation.charAt(3) - \u0026#39;a\u0026#39;; if (find(x) == find(y)) { return false; // 不等式矛盾 } } } return true; } private int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); } return parent[x]; } private void union(int x, int y) { parent[find(x)] = find(y); } } 2. 朋友圈數量（LeetCode 547） 問題描述：班上有 N 名學生。其中有些人是朋友，有些則不是。他們的友誼具有傳遞性。找出朋友圈的總數。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int findCircleNum(int[][] isConnected) { int n = isConnected.length; UnionFind uf = new UnionFind(n); // 遍歷所有學生對，如果是朋友就合併 for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (isConnected[i][j] == 1) { uf.union(i, j); } } } return uf.getComponentCount(); } } 3. 島嶼數量（LeetCode 200） 問題描述：給定一個由 \u0026lsquo;1\u0026rsquo;（陸地）和 \u0026lsquo;0\u0026rsquo;（水）組成的二維網格，計算島嶼的數量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) return 0; int rows = grid.length; int cols = grid[0].length; UnionFind uf = new UnionFind(rows * cols); int waterCells = 0; // 方向陣列：上、下、左、右 int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; cols; j++) { if (grid[i][j] == \u0026#39;0\u0026#39;) { waterCells++; } else { // 檢查四個方向的相鄰陸地 for (int[] dir : directions) { int newRow = i + dir[0]; int newCol = j + dir[1]; if (newRow \u0026gt;= 0 \u0026amp;\u0026amp; newRow \u0026lt; rows \u0026amp;\u0026amp; newCol \u0026gt;= 0 \u0026amp;\u0026amp; newCol \u0026lt; cols \u0026amp;\u0026amp; grid[newRow][newCol] == \u0026#39;1\u0026#39;) { uf.union(i * cols + j, newRow * cols + newCol); } } } } } return uf.getComponentCount() - waterCells; } } 4. 冗余連接（LeetCode 684） 問題描述：在無向圖中找到一條邊，移除它後圖將變成樹。如果有多個答案，返回最後出現在給定二維陣列中的邊。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int[] findRedundantConnection(int[][] edges) { UnionFind uf = new UnionFind(edges.length + 1); for (int[] edge : edges) { // 如果兩個節點已經連通，這條邊就是冗余的 if (!uf.union(edge[0], edge[1])) { return edge; } } return new int[0]; // 理論上不會到達這裡 } } 5. 賬戶合併（LeetCode 721） 問題描述：給定一個賬戶列表，每個元素 accounts[i] 是一個字串列表，其中第一個元素是名字，其餘元素是 emails。合併屬於同一人的賬戶。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accountsMerge(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accounts) { Map\u0026lt;String, Integer\u0026gt; emailToIndex = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;String, String\u0026gt; emailToName = new HashMap\u0026lt;\u0026gt;(); int emailCount = 0; // 為每個 email 分配唯一索引 for (List\u0026lt;String\u0026gt; account : accounts) { String name = account.get(0); for (int i = 1; i \u0026lt; account.size(); i++) { String email = account.get(i); if (!emailToIndex.containsKey(email)) { emailToIndex.put(email, emailCount++); } emailToName.put(email, name); } } UnionFind uf = new UnionFind(emailCount); // 合併同一賬戶下的所有 email for (List\u0026lt;String\u0026gt; account : accounts) { String firstEmail = account.get(1); for (int i = 2; i \u0026lt; account.size(); i++) { uf.union(emailToIndex.get(firstEmail), emailToIndex.get(account.get(i))); } } // 根據並查集結果分組 email Map\u0026lt;Integer, List\u0026lt;String\u0026gt;\u0026gt; groups = new HashMap\u0026lt;\u0026gt;(); for (String email : emailToIndex.keySet()) { int root = uf.find(emailToIndex.get(email)); groups.computeIfAbsent(root, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(email); } // 構建最終結果 List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (List\u0026lt;String\u0026gt; emails : groups.values()) { Collections.sort(emails); List\u0026lt;String\u0026gt; account = new ArrayList\u0026lt;\u0026gt;(); account.add(emailToName.get(emails.get(0))); account.addAll(emails); result.add(account); } return result; } } 高級應用 動態連通性問題 並查集特別適用於處理動態連通性問題，即在線回答「兩個節點是否連通」的查詢。\n最小生成樹（Kruskal 演算法） Kruskal 演算法使用並查集來檢測環的存在：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class KruskalMST { public int kruskalMST(int n, int[][] edges) { // 按權重排序邊 Arrays.sort(edges, (a, b) -\u0026gt; a[2] - b[2]); UnionFind uf = new UnionFind(n); int mstWeight = 0; int edgesUsed = 0; for (int[] edge : edges) { int u = edge[0], v = edge[1], weight = edge[2]; // 如果不會形成環，加入 MST if (uf.union(u, v)) { mstWeight += weight; edgesUsed++; // MST 有 n-1 條邊 if (edgesUsed == n - 1) { break; } } } return mstWeight; } } 實作技巧與注意事項 路徑壓縮：在 find 操作中使用路徑壓縮可以顯著提升性能 按秩合併：避免樹變得過高，保持操作的高效性 元素映射：當元素不是連續整數時，需要建立映射關係 連通分量計數：維護連通分量的數量可以快速回答相關查詢 總結 並查集是解決動態連通性問題的高效數據結構，在圖論、網路分析、集合劃分等領域有廣泛應用。掌握並查集的關鍵在於：\n理解基本原理：樹形結構表示集合，根節點作為代表元素 掌握優化技巧：路徑壓縮和按秩/按大小合併 靈活應用：根據問題特點選擇合適的實作方式 注意細節：邊界條件處理和元素映射 參考資料 LeetCode 990. Satisfiability of Equality Equations LeetCode 547. Number of Provinces LeetCode 200. Number of Islands LeetCode 684. Redundant Connection LeetCode 721. Accounts Merge 演算法導論 - 不相交集合的數據結構 ","permalink":"https://xinqilin.github.io/post/algorithm/unionfind/","tags":["Algorithm","UnionFind","DisjointSet","Graph","Java"],"title":"並查集（Union-Find）演算法完整指南"},{"content":"Snowflake - Distribution Key 單體式 ID 一般單體式 UUID(Universally Unique identifier) 8-4-4-4-12 總共 32 個 16 進位\n1 UUID.randomUUID() // 80e06459-942d-4a63-9fd4-81691b127363 優點 性能高 本地生成 無網路延遲 缺點 無順序性 字串不適合存 db 當 index or PK 且 32 長度太長 因無序 所以對 b+ Tree 來說 插入時效能低 極小機會但 會重複 =\u0026gt; ＤＢ 解法: replace into 跟insert功能類似, 但 replace into 會檢查是否存在, 如存在則先刪除, 再插入, 否则直接插入 分佈式 ID twitter 開發的 雪花算法 - snowflake 總共 64 bit\n1bit 不用，因為二進制中最高位是符號位，1表示負數，0表示正數。 生成的id一般都是用整數，所以最高位固定為0。\n41bit-時間戳，用來記錄時間戳，亳秒級。 41位可以表示 2^41-1個數字， 如果只用來表示正整數(計算機中正數包含0)，可以表示的數值範圍是: 0 至 2^41 - 1， 減1是因為可表示的數值範圍是從0開始算的，而不是1.也就是說41位可以表示 2^41 - 1 個毫秒的值，轉化成單位年則是( 2^41 - 1 )/ (1000* 60 * 60 * 24 *365)= 69年\n10bit-工作機器id,用來記錄工作機器id. 可以部署在 2^10 = 1024 個節點，包括5位 dataCenterId 和 15 位 workerId 5位(bit) 可以表示的最大正整數是 2^5-1 = 31，即可以用 0, 1, 2, 3\u0026hellip; 這 32 個數字來表示不同的 dataCenterId 或 workerId\n12bit, 序列號，序列號，用來記錄同毫秒內產生的不同id. 12位(bit) 可以表示的最大正整數是 2^12 - 1 = 4095，即可以用 0, 1, 2, 3\u0026hellip; 4094 這 4095 個數字, 來表示同一機器同一時間截(毫秒)內產生的 4095 個ID序號。\n優點 全局唯一性 递增性, 確保生成 ID 對於用户或業務是递增的。 高可用性, 確保任何時候都能生成正確的 ID 高性能, 在高併發下依然 ok 亳秒数在高位，自增序列在低位，整個 ID 都是遞增的。 缺點 依賴機器時鐘，如果機器時鐘回撥，會導致重複 ID 生成 在單機上是遞增的，但是由於設計到分佈式環境，每台機器上的時鐘不可能完全同步，有時候會出現不是全局遞增的情況(此缺點可以認為無所謂，- .般分佈式ID只要求趨勢遞增，並不會嚴格要求遞增，90%的需求都只要求趨勢遞增) additional 解決機器時鐘回撥問題 Leaf - 美團點評分佈式ID生成系統 百度 open source - UidGenerator java sample code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 public class SnowflakeIdWorker { /** * 开始时间截 (2015-01-01) */ private final long twepoch = 1420041600000L; /** * 机器id所占的位数 */ private final long workerIdBits = 5L; /** * 数据标识id所占的位数 */ private final long datacenterIdBits = 5L; /** * 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */ private final long maxWorkerId = -1L ^ (-1L \u0026lt;\u0026lt; workerIdBits); /** * 支持的最大数据标识id，结果是31 */ private final long maxDatacenterId = -1L ^ (-1L \u0026lt;\u0026lt; datacenterIdBits); /** * 序列在id中占的位数 */ private final long sequenceBits = 12L; /** * 机器ID向左移12位 */ private final long workerIdShift = sequenceBits; /** * 数据标识id向左移17位(12+5) */ private final long datacenterIdShift = sequenceBits + workerIdBits; /** * 时间截向左移22位(5+5+12) */ private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; /** * 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */ private final long sequenceMask = -1L ^ (-1L \u0026lt;\u0026lt; sequenceBits); /** * 工作机器ID(0~31) */ private long workerId; /** * 数据中心ID(0~31) */ private long datacenterId; /** * 毫秒内序列(0~4095) */ private long sequence = 0L; /** * 上次生成ID的时间截 */ private long lastTimestamp = -1L; /** * 构造函数 * @param workerId 工作ID (0~31) * @param datacenterId 数据中心ID (0~31) */ public SnowflakeIdWorker(long workerId, long datacenterId) { if (workerId \u0026gt; maxWorkerId || workerId \u0026lt; 0) { throw new IllegalArgumentException(String.format(\u0026#34;worker Id can\u0026#39;t be greater than %d or less than 0\u0026#34;, maxWorkerId)); } if (datacenterId \u0026gt; maxDatacenterId || datacenterId \u0026lt; 0) { throw new IllegalArgumentException(String.format(\u0026#34;datacenter Id can\u0026#39;t be greater than %d or less than 0\u0026#34;, maxDatacenterId)); } this.workerId = workerId; this.datacenterId = datacenterId; } /** * 获得下一个ID (该方法是线程安全的) * @return SnowflakeId */ public synchronized long nextId() { long timestamp = timeGen(); // 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常 if (timestamp \u0026lt; lastTimestamp) { throw new RuntimeException( String.format(\u0026#34;Clock moved backwards. Refusing to generate id for %d milliseconds\u0026#34;, lastTimestamp - timestamp)); } // 如果是同一时间生成的，则进行毫秒内序列 if (lastTimestamp == timestamp) { sequence = (sequence + 1) \u0026amp; sequenceMask; // 毫秒内序列溢出 if (sequence == 0) { //阻塞到下一个毫秒,获得新的时间戳 timestamp = tilNextMillis(lastTimestamp); } } // 时间戳改变，毫秒内序列重置 else { sequence = 0L; } // 上次生成ID的时间截 lastTimestamp = timestamp; // 移位并通过或运算拼到一起组成64位的ID return ((timestamp - twepoch) \u0026lt;\u0026lt; timestampLeftShift) // | (datacenterId \u0026lt;\u0026lt; datacenterIdShift) // | (workerId \u0026lt;\u0026lt; workerIdShift) // | sequence; } /** * 阻塞到下一个毫秒，直到获得新的时间戳 * @param lastTimestamp 上次生成ID的时间截 * @return 当前时间戳 */ protected long tilNextMillis(long lastTimestamp) { long timestamp = timeGen(); while (timestamp \u0026lt;= lastTimestamp) { timestamp = timeGen(); } return timestamp; } /** * 返回以毫秒为单位的当前时间 * @return 当前时间(毫秒) */ protected long timeGen() { return System.currentTimeMillis(); } public static void main(String[] args) throws InterruptedException { SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0); for (int i = 0; i \u0026lt; 10; i++) { long id = idWorker.nextId(); Thread.sleep(1); System.out.println(id); } } } reference: https://github.com/twitter-archive/snowflake https://github.com/beyondfengyu/SnowFlake/blob/master/SnowFlake.java https://blog.csdn.net/qq_45408390/article/details/119793810 ","permalink":"https://xinqilin.github.io/post/architecture/snowflake-distributionkey/","tags":[],"title":"SnowFlake DistributionKey"},{"content":"概述 回溯演算法（Backtracking）是一種透過試錯來尋找問題解決方案的算法策略。它系統性地搜尋所有可能的候選解，當發現候選解不可能完成有效解時，會放棄該候選解並「回溯」到上一步。\n基本原理 回溯演算法遵循三個核心步驟：\n選擇（Choose）：從當前狀態的可選項中做出選擇 探索（Explore）：Recursion地探索這個選擇的後果 撤銷（Un-choose）：撤銷選擇，恢復到選擇前的狀態 演算法模板 1 2 3 4 5 6 7 8 9 10 11 12 void backtrack(路徑, 選擇列表) { if (滿足結束條件) { result.add(路徑); return; } for (選擇 : 選擇列表) { 做選擇; // Choose backtrack(路徑, 選擇列表); // Explore 撤銷選擇; // Un-choose } } 時間複雜度 一般情況下，回溯演算法的時間複雜度為 O(b^d)，其中：\nb 是分支因子（每個節點的平均子節點數） d 是搜尋深度 經典應用題型 1. 子集問題（Subsets） 問題描述：給定一個整數陣列 nums，回傳該陣列所有可能的子集（冪集合）。\n解題思路：\n對於每個元素，我們都有「選擇」或「不選擇」兩種決策 使用回溯法遍歷所有可能的組合 每次Recursion都將當前路徑加入結果集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); // 排序便於處理 backtrack(result, new ArrayList\u0026lt;\u0026gt;(), nums, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] nums, int startIndex) { // 每個狀態都是一個有效的子集 result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); // 從 startIndex 開始遍歷，避免重複組合 for (int i = startIndex; i \u0026lt; nums.length; i++) { // 做選擇：將當前元素加入路徑 currentPath.add(nums[i]); // Recursion探索：繼續選擇下一個元素 backtrack(result, currentPath, nums, i + 1); // 撤銷選擇：移除當前元素，回溯 currentPath.remove(currentPath.size() - 1); } } 時間複雜度：O(2^n)，其中 n 是陣列長度，因為每個元素都有選或不選兩種狀態。\n2. 子集問題 II（Subsets II - 含重複元素） 問題描述：給定一個可能包含重複整數的陣列 nums，回傳該陣列所有可能的子集（不包含重複的子集）。\n解題思路：\n基於子集問題的解法，但需要處理重複元素 先排序陣列，讓相同元素相鄰 透過跳過重複元素來避免產生重複的子集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); // 排序是關鍵，讓重複元素相鄰 backtrack(result, new ArrayList\u0026lt;\u0026gt;(), nums, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] nums, int startIndex) { // 每個狀態都是一個有效的子集 result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); for (int i = startIndex; i \u0026lt; nums.length; i++) { // 跳過重複元素：當前元素與前一個元素相同，且不是起始位置 if (i \u0026gt; startIndex \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; // 跳過重複元素避免產生重複子集 } // 做選擇 currentPath.add(nums[i]); // Recursion探索 backtrack(result, currentPath, nums, i + 1); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); } } 去重關鍵：i \u0026gt; startIndex \u0026amp;\u0026amp; nums[i] == nums[i-1] 這個條件確保在同一層Recursion中跳過重複元素。\n3. 全排列（Permutations） 問題描述：給定一個不含重複數字的陣列 nums，回傳其所有可能的全排列。\n解題思路：\n全排列需要用到陣列中的每一個元素，且順序不同結果不同 使用 contains 檢查避免重複使用同一個元素 當路徑長度等於陣列長度時，找到一個完整的排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); backtrack(result, new ArrayList\u0026lt;\u0026gt;(), nums); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] nums) { // 達到目標長度，找到一個完整的排列 if (currentPath.size() == nums.length) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } // 嘗試添加每一個元素 for (int i = 0; i \u0026lt; nums.length; i++) { // 跳過已經使用的元素 if (currentPath.contains(nums[i])) { continue; // 該元素已在當前路徑中，跳過 } // 做選擇 currentPath.add(nums[i]); // Recursion探索 backtrack(result, currentPath, nums); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); } } 效能優化：使用 boolean[] used 陣列取代 contains 方法可以提升效能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private void backtrackOptimized(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] nums, boolean[] used) { if (currentPath.size() == nums.length) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) continue; // O(1) 時間檢查 used[i] = true; currentPath.add(nums[i]); backtrackOptimized(result, currentPath, nums, used); currentPath.remove(currentPath.size() - 1); used[i] = false; } } 時間複雜度：O(n × n!)，其中 n! 是排列的數量，n 是複製每個排列所需的時間。\n4. 全排列 II（Permutations II - 含重複元素） 問題描述：給定一個可包含重複數字的序列 nums，按任意順序回傳所有不重複的全排列。\n解題思路：\n在全排列的基礎上增加去重邏輯 先排序讓相同元素相鄰 使用剪枝條件避免產生重複的排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); // 排序是去重的關鍵 boolean[] used = new boolean[nums.length]; backtrack(result, new ArrayList\u0026lt;\u0026gt;(), nums, used); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] nums, boolean[] used) { // 達到目標長度，找到一個完整的排列 if (currentPath.size() == nums.length) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { // 跳過已使用的元素 if (used[i]) continue; // 去重關鍵：跳過重複元素 // 當前元素與前一個元素相同，且前一個元素未被使用 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !used[i - 1]) { continue; } // 做選擇 used[i] = true; currentPath.add(nums[i]); // Recursion探索 backtrack(result, currentPath, nums, used); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); used[i] = false; } } 去重原理：!used[i-1] 確保在同一層Recursion中，相同的元素只會被選擇一次，從而避免重複排列。\n5. 組合總和（Combination Sum - 可重複使用元素） 問題描述：給定一個無重複元素的陣列 candidates 和一個目標數 target，找出所有使元素和為 target 的組合。同一個數字可以被重複選擇。\n解題思路：\n每個元素都可以被無限次重複使用 使用 startIndex 避免產生重複組合（如 [2,3] 和 [3,2]） 當剩餘目標值為 0 時找到一個有效組合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(candidates); // 排序便於剪枝 backtrack(result, new ArrayList\u0026lt;\u0026gt;(), candidates, target, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] candidates, int remainingTarget, int startIndex) { // 剪枝：剩餘目標值小於 0，無效路徑 if (remainingTarget \u0026lt; 0) { return; } // 找到一個有效組合 if (remainingTarget == 0) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } for (int i = startIndex; i \u0026lt; candidates.length; i++) { // 剪枝優化：如果當前元素已經大於剩餘目標值，後面的元素也會更大 if (candidates[i] \u0026gt; remainingTarget) { break; } // 做選擇 currentPath.add(candidates[i]); // Recursion探索：注意這裡傳入 i 而不是 i+1，因為可以重複使用同一元素 backtrack(result, currentPath, candidates, remainingTarget - candidates[i], i); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); } } 關鍵點：\nRecursion時傳入 i 而非 i+1，允許重複使用當前元素 排序後可以進行剪枝優化，提早終止無效分支 6. 組合總和 II（Combination Sum II - 含重複元素但不可重複使用） 問題描述：給定一個陣列 candidates 和一個目標數 target，找出所有使元素和為 target 的組合。陣列中每個元素只能使用一次，但陣列中可能包含重複元素。\n解題思路：\n每個元素只能使用一次，需要跳過重複元素避免重複組合 排序後使用去重邏輯 Recursion時傳入 i+1 確保每個位置的元素只能使用一次 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(candidates); // 排序是去重的前提 backtrack(result, new ArrayList\u0026lt;\u0026gt;(), candidates, target, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] candidates, int remainingTarget, int startIndex) { // 剪枝：剩餘目標值小於 0 if (remainingTarget \u0026lt; 0) { return; } // 找到一個有效組合 if (remainingTarget == 0) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } for (int i = startIndex; i \u0026lt; candidates.length; i++) { // 跳過重複元素：避免在同一層Recursion中使用相同的元素 if (i \u0026gt; startIndex \u0026amp;\u0026amp; candidates[i] == candidates[i - 1]) { continue; // 跳過重複元素 } // 剪枝優化 if (candidates[i] \u0026gt; remainingTarget) { break; } // 做選擇 currentPath.add(candidates[i]); // Recursion探索：傳入 i+1 確保每個元素只使用一次 backtrack(result, currentPath, candidates, remainingTarget - candidates[i], i + 1); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); } } 與 Combination Sum 的差異：\nRecursion時傳入 i+1 而非 i，每個元素只能使用一次 增加去重邏輯處理陣列中的重複元素 7. 回文字串分割（Palindrome Partitioning） 問題描述：給定一個字串 s，將 s 分割成一些子字串，使得每個子字串都是回文字串。回傳所有可能的分割方案。\n解題思路：\n透過回溯法嘗試所有可能的分割點 對於每個分割點，檢查子字串是否為回文 只有當子字串是回文時，才繼續Recursion分割 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; partition(String s) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); backtrack(result, new ArrayList\u0026lt;\u0026gt;(), s, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; result, List\u0026lt;String\u0026gt; currentPath, String s, int startIndex) { // 達到字串結尾，找到一個完整的分割方案 if (startIndex == s.length()) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } // 嘗試所有可能的分割點 for (int endIndex = startIndex; endIndex \u0026lt; s.length(); endIndex++) { // 檢查當前子字串是否為回文 if (isPalindrome(s, startIndex, endIndex)) { // 做選擇：將回文子字串加入路徑 currentPath.add(s.substring(startIndex, endIndex + 1)); // Recursion探索：繼續分割剩餘部分 backtrack(result, currentPath, s, endIndex + 1); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); } } } /** * 檢查字串的指定範圍是否為回文 */ private boolean isPalindrome(String s, int left, int right) { while (left \u0026lt; right) { if (s.charAt(left) != s.charAt(right)) { return false; } left++; right--; } return true; } 優化技巧：可以預處理回文判斷結果，使用動態規劃建立回文查詢表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 預處理優化版本 private boolean[][] precomputePalindromes(String s) { int n = s.length(); boolean[][] isPalin = new boolean[n][n]; // 單個字元都是回文 for (int i = 0; i \u0026lt; n; i++) { isPalin[i][i] = true; } // 檢查長度為 2 的子字串 for (int i = 0; i \u0026lt; n - 1; i++) { isPalin[i][i + 1] = (s.charAt(i) == s.charAt(i + 1)); } // 檢查長度大於 2 的子字串 for (int len = 3; len \u0026lt;= n; len++) { for (int i = 0; i \u0026lt;= n - len; i++) { int j = i + len - 1; isPalin[i][j] = (s.charAt(i) == s.charAt(j)) \u0026amp;\u0026amp; isPalin[i + 1][j - 1]; } } return isPalin; } 最佳實踐與技巧 1. 剪枝優化 提早終止：當發現當前路徑不可能產生有效解時，立即返回 排序優化：對輸入進行排序，便於跳過重複元素和進行範圍剪枝 邊界檢查：在Recursion前檢查邊界條件，避免無效Recursion 2. 去重技巧 回溯問題中的去重通常有兩種情況：\n樹枝去重：避免在同一條路徑上重複使用同一個元素 樹層去重：避免在同一層Recursion中產生重複的選擇 1 2 3 4 5 // 樹層去重（適用於有重複元素的組合問題） if (i \u0026gt; startIndex \u0026amp;\u0026amp; nums[i] == nums[i-1]) continue; // 樹枝去重（適用於排列問題） if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1]) continue; 3. 效能優化 使用 boolean[] 取代 List.contains() 進行元素查找 預處理計算結果（如回文判斷表） 合理選擇資料結構（如使用 StringBuilder 處理字串） 常見錯誤與陷阱 忘記撤銷選擇：這是回溯演算法最常見的錯誤 重複解處理不當：沒有正確實現去重邏輯 邊界條件錯誤：Recursion終止條件設置不正確 索引使用錯誤：在組合和排列問題中混淆 i 和 i+1 的使用 總結 回溯演算法是解決組合、排列、分割等問題的重要工具。掌握以下要點：\n理解模板：Choose → Explore → Un-choose 三步驟 識別問題類型：子集、排列、組合、分割等不同類型有不同的處理方式 掌握去重技巧：樹層去重和樹枝去重的區別和應用 善用剪枝：透過剪枝大幅提升演算法效能 細心實作：注意邊界條件和索引使用 透過大量練習和理解這些經典題型，能夠幫助我們更好地掌握回溯演算法的精髓。\n","permalink":"https://xinqilin.github.io/post/algorithm/backtracking/","tags":["Algorithm","Backtracking","Recursion"],"title":"回溯演算法（Backtracking）完整指南"},{"content":"代碼壞味道 (Code Smells) 完整識別與重構指南 概述 代碼壞味道是指代碼中存在的設計缺陷和結構問題，雖然不會導致程序功能錯誤，但會影響代碼的可讀性、可維護性和可擴展性。本文將深入探討各種代碼壞味道的識別方法、重構技巧和預防策略。\n經典四大軟體設計問題 1. Rigidity (僵化性) - 難以變更 問題描述： 系統中存在過多的相依性，導致任何小的變更都需要修改大量相關代碼。\n症狀：\n修改一個小功能需要改動多個模組 開發人員害怕進行代碼變更 估算工作量困難，因為變更範圍難以預測 壞味道示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 僵化的訂單處理系統 public class OrderService { private DatabaseConnection dbConnection; private EmailService emailService; private InventoryService inventoryService; private PaymentService paymentService; private LoggingService loggingService; public void processOrder(Order order) { // 直接依賴具體實現，難以變更 dbConnection.connect(\u0026#34;jdbc:mysql://localhost:3306/orders\u0026#34;); // 硬編碼的業務邏輯 if (order.getType().equals(\u0026#34;PREMIUM\u0026#34;)) { order.setDiscount(0.1); } else if (order.getType().equals(\u0026#34;STANDARD\u0026#34;)) { order.setDiscount(0.05); } // 緊密耦合的操作順序 inventoryService.reserveItems(order.getItems()); paymentService.processPayment(order.getPayment()); dbConnection.saveOrder(order); emailService.sendConfirmationEmail(order.getCustomer()); loggingService.log(\u0026#34;Order processed: \u0026#34; + order.getId()); } } 重構解決方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // 使用依賴注入和策略模式解決僵化性 public class OrderService { private final OrderRepository orderRepository; private final NotificationService notificationService; private final InventoryService inventoryService; private final PaymentService paymentService; private final AuditService auditService; private final DiscountCalculator discountCalculator; public OrderService(OrderRepository orderRepository, NotificationService notificationService, InventoryService inventoryService, PaymentService paymentService, AuditService auditService, DiscountCalculator discountCalculator) { this.orderRepository = orderRepository; this.notificationService = notificationService; this.inventoryService = inventoryService; this.paymentService = paymentService; this.auditService = auditService; this.discountCalculator = discountCalculator; } public void processOrder(Order order) { // 使用策略模式計算折扣 order.setDiscount(discountCalculator.calculateDiscount(order)); // 解耦的操作流程 inventoryService.reserveItems(order.getItems()); paymentService.processPayment(order.getPayment()); orderRepository.save(order); notificationService.sendNotification(order.getCustomer(), createConfirmationMessage(order)); auditService.logOrderProcessed(order); } private String createConfirmationMessage(Order order) { return \u0026#34;訂單 \u0026#34; + order.getId() + \u0026#34; 已成功處理\u0026#34;; } } // 策略模式實現折扣計算 public interface DiscountCalculator { double calculateDiscount(Order order); } @Component public class CustomerTypeDiscountCalculator implements DiscountCalculator { private final Map\u0026lt;String, Double\u0026gt; discountRates; public CustomerTypeDiscountCalculator() { this.discountRates = Map.of( \u0026#34;PREMIUM\u0026#34;, 0.1, \u0026#34;STANDARD\u0026#34;, 0.05, \u0026#34;BASIC\u0026#34;, 0.0 ); } @Override public double calculateDiscount(Order order) { return discountRates.getOrDefault(order.getCustomerType(), 0.0); } } 2. Fragility (脆弱性) - 容易壞掉 問題描述： 系統中一個地方的變更會在意外的地方引起問題，特別是在邏輯上不相關的部分。\n症狀：\n修復一個bug會引起其他地方的問題 測試經常失敗，且失敗原因不明顯 生產環境經常出現意外問題 壞味道示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 脆弱的用戶管理系統 public class UserManager { private static List\u0026lt;User\u0026gt; users = new ArrayList\u0026lt;\u0026gt;(); private static int nextId = 1; public static User createUser(String name, String email) { User user = new User(nextId++, name, email); users.add(user); // 脆弱的副作用：修改全局狀態 System.setProperty(\u0026#34;last.user.created\u0026#34;, user.getName()); // 脆弱的依賴：直接操作文件系統 try (FileWriter writer = new FileWriter(\u0026#34;users.log\u0026#34;, true)) { writer.write(user.toString() + \u0026#34;\\n\u0026#34;); } catch (IOException e) { // 靜默處理異常，隱藏問題 } return user; } public static void deleteUser(int id) { users.removeIf(user -\u0026gt; user.getId() == id); // 脆弱的邏輯：假設總是存在用戶 User lastUser = users.get(users.size() - 1); System.setProperty(\u0026#34;last.user.created\u0026#34;, lastUser.getName()); } public static List\u0026lt;User\u0026gt; getUsers() { // 返回可變引用，允許外部修改 return users; } } 重構解決方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // 使用封裝和不可變性解決脆弱性 @Service public class UserService { private final UserRepository userRepository; private final UserAuditService auditService; private final EventPublisher eventPublisher; public UserService(UserRepository userRepository, UserAuditService auditService, EventPublisher eventPublisher) { this.userRepository = userRepository; this.auditService = auditService; this.eventPublisher = eventPublisher; } @Transactional public User createUser(CreateUserRequest request) { validateUserRequest(request); User user = User.builder() .name(request.getName()) .email(request.getEmail()) .createdAt(LocalDateTime.now()) .build(); User savedUser = userRepository.save(user); // 使用事件發布解耦副作用 eventPublisher.publish(new UserCreatedEvent(savedUser)); return savedUser; } @Transactional public void deleteUser(Long id) { User user = userRepository.findById(id) .orElseThrow(() -\u0026gt; new UserNotFoundException(\u0026#34;用戶不存在: \u0026#34; + id)); userRepository.delete(user); eventPublisher.publish(new UserDeletedEvent(user)); } public List\u0026lt;User\u0026gt; getUsers() { // 返回不可變副本 return Collections.unmodifiableList(userRepository.findAll()); } private void validateUserRequest(CreateUserRequest request) { if (request.getName() == null || request.getName().trim().isEmpty()) { throw new ValidationException(\u0026#34;用戶名不能為空\u0026#34;); } if (request.getEmail() == null || !isValidEmail(request.getEmail())) { throw new ValidationException(\u0026#34;無效的電子郵件地址\u0026#34;); } } private boolean isValidEmail(String email) { return email.contains(\u0026#34;@\u0026#34;) \u0026amp;\u0026amp; email.contains(\u0026#34;.\u0026#34;); } } // 事件處理器處理副作用 @Component public class UserEventHandler { private final UserAuditService auditService; public UserEventHandler(UserAuditService auditService) { this.auditService = auditService; } @EventListener public void handleUserCreated(UserCreatedEvent event) { auditService.logUserCreated(event.getUser()); } @EventListener public void handleUserDeleted(UserDeletedEvent event) { auditService.logUserDeleted(event.getUser()); } } 3. Immobility (不可移植性) - 難以複用 問題描述： 系統中的代碼與其環境過度耦合，難以在其他項目或模組中重複使用。\n症狀：\n相似的代碼在多個地方重複出現 提取共用邏輯的成本很高 代碼與具體實現細節綁定 壞味道示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // 不可移植的報告生成器 public class SalesReportGenerator { public void generateDailySalesReport() { // 硬編碼的數據庫查詢 Connection conn = DriverManager.getConnection( \u0026#34;jdbc:mysql://localhost:3306/sales_db\u0026#34;, \u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;); PreparedStatement stmt = conn.prepareStatement( \u0026#34;SELECT product_id, SUM(quantity), SUM(amount) FROM orders WHERE date = ?\u0026#34;); stmt.setDate(1, Date.valueOf(LocalDate.now())); ResultSet rs = stmt.executeQuery(); // 硬編碼的輸出格式 System.out.println(\u0026#34;=== 每日銷售報告 ===\u0026#34;); while (rs.next()) { System.out.printf(\u0026#34;產品ID: %d, 數量: %d, 金額: %.2f%n\u0026#34;, rs.getInt(1), rs.getInt(2), rs.getDouble(3)); } // 硬編碼的文件保存 try (FileWriter writer = new FileWriter(\u0026#34;/tmp/daily_sales.txt\u0026#34;)) { writer.write(\u0026#34;報告生成時間: \u0026#34; + LocalDateTime.now()); } } public void generateWeeklySalesReport() { // 大量重複的代碼 Connection conn = DriverManager.getConnection( \u0026#34;jdbc:mysql://localhost:3306/sales_db\u0026#34;, \u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;); PreparedStatement stmt = conn.prepareStatement( \u0026#34;SELECT product_id, SUM(quantity), SUM(amount) FROM orders WHERE date \u0026gt;= ?\u0026#34;); stmt.setDate(1, Date.valueOf(LocalDate.now().minusDays(7))); ResultSet rs = stmt.executeQuery(); System.out.println(\u0026#34;=== 每週銷售報告 ===\u0026#34;); while (rs.next()) { System.out.printf(\u0026#34;產品ID: %d, 數量: %d, 金額: %.2f%n\u0026#34;, rs.getInt(1), rs.getInt(2), rs.getDouble(3)); } } } 重構解決方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 // 可複用的報告生成框架 public interface ReportDataSource { List\u0026lt;SalesData\u0026gt; getSalesData(DateRange dateRange); } public interface ReportFormatter { String format(List\u0026lt;SalesData\u0026gt; data, ReportMetadata metadata); } public interface ReportOutput { void output(String formattedReport, ReportMetadata metadata); } @Service public class ReportService { private final ReportDataSource dataSource; private final ReportFormatter formatter; private final List\u0026lt;ReportOutput\u0026gt; outputs; public ReportService(ReportDataSource dataSource, ReportFormatter formatter, List\u0026lt;ReportOutput\u0026gt; outputs) { this.dataSource = dataSource; this.formatter = formatter; this.outputs = outputs; } public void generateReport(ReportRequest request) { List\u0026lt;SalesData\u0026gt; data = dataSource.getSalesData(request.getDateRange()); ReportMetadata metadata = ReportMetadata.builder() .title(request.getTitle()) .generatedAt(LocalDateTime.now()) .dateRange(request.getDateRange()) .build(); String formattedReport = formatter.format(data, metadata); outputs.forEach(output -\u0026gt; output.output(formattedReport, metadata)); } } // 具體實現 @Component public class DatabaseReportDataSource implements ReportDataSource { private final SalesRepository salesRepository; public DatabaseReportDataSource(SalesRepository salesRepository) { this.salesRepository = salesRepository; } @Override public List\u0026lt;SalesData\u0026gt; getSalesData(DateRange dateRange) { return salesRepository.findSalesByDateRange( dateRange.getStartDate(), dateRange.getEndDate() ); } } @Component public class TextReportFormatter implements ReportFormatter { @Override public String format(List\u0026lt;SalesData\u0026gt; data, ReportMetadata metadata) { StringBuilder sb = new StringBuilder(); sb.append(\u0026#34;=== \u0026#34;).append(metadata.getTitle()).append(\u0026#34; ===\\n\u0026#34;); sb.append(\u0026#34;生成時間: \u0026#34;).append(metadata.getGeneratedAt()).append(\u0026#34;\\n\u0026#34;); sb.append(\u0026#34;報告期間: \u0026#34;).append(metadata.getDateRange()).append(\u0026#34;\\n\\n\u0026#34;); data.forEach(item -\u0026gt; sb.append(String.format(\u0026#34;產品ID: %d, 數量: %d, 金額: %.2f%n\u0026#34;, item.getProductId(), item.getQuantity(), item.getAmount())) ); return sb.toString(); } } @Component public class ConsoleReportOutput implements ReportOutput { @Override public void output(String formattedReport, ReportMetadata metadata) { System.out.println(formattedReport); } } @Component public class FileReportOutput implements ReportOutput { @Value(\u0026#34;${report.output.directory:/tmp}\u0026#34;) private String outputDirectory; @Override public void output(String formattedReport, ReportMetadata metadata) { String filename = String.format(\u0026#34;%s_%s.txt\u0026#34;, metadata.getTitle().toLowerCase().replace(\u0026#34; \u0026#34;, \u0026#34;_\u0026#34;), metadata.getGeneratedAt().format(DateTimeFormatter.ofPattern(\u0026#34;yyyyMMdd_HHmmss\u0026#34;)) ); Path filePath = Paths.get(outputDirectory, filename); try { Files.write(filePath, formattedReport.getBytes()); } catch (IOException e) { throw new ReportOutputException(\u0026#34;無法寫入報告文件\u0026#34;, e); } } } 4. Viscosity (黏性) - 難以正確修改 問題描述： 正確的修改比錯誤的修改更困難，開發人員傾向於使用臨時解決方案而非正確的設計。\n症狀：\n開發人員選擇快速修復而非正確解決方案 系統中充滿了臨時解決方案和\u0026quot;hack\u0026quot; 正確的修改需要很長時間或很多步驟 壞味道示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // 高黏性的配置管理系統 public class ConfigManager { private static Properties props = new Properties(); private static boolean initialized = false; static { try { props.load(new FileInputStream(\u0026#34;config.properties\u0026#34;)); initialized = true; } catch (IOException e) { // 臨時解決方案：使用硬編碼默認值 props.setProperty(\u0026#34;db.host\u0026#34;, \u0026#34;localhost\u0026#34;); props.setProperty(\u0026#34;db.port\u0026#34;, \u0026#34;3306\u0026#34;); props.setProperty(\u0026#34;db.timeout\u0026#34;, \u0026#34;30\u0026#34;); initialized = true; } } public static String getProperty(String key) { if (!initialized) { throw new RuntimeException(\u0026#34;配置未初始化\u0026#34;); } return props.getProperty(key); } public static void setProperty(String key, String value) { // 臨時解決方案：運行時修改配置 props.setProperty(key, value); // 更多臨時解決方案：立即保存到文件 try (FileOutputStream out = new FileOutputStream(\u0026#34;config.properties\u0026#34;)) { props.store(out, \u0026#34;Updated at \u0026#34; + new Date()); } catch (IOException e) { // 忽略錯誤，繼續執行 } } // 臨時解決方案：添加專門的方法來處理特殊情況 public static int getDatabaseTimeout() { String timeout = getProperty(\u0026#34;db.timeout\u0026#34;); try { return Integer.parseInt(timeout); } catch (NumberFormatException e) { // 又一個臨時解決方案 return 30; } } } 重構解決方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 // 低黏性的配置管理系統 public interface ConfigurationSource { Optional\u0026lt;String\u0026gt; getProperty(String key); Map\u0026lt;String, String\u0026gt; getAllProperties(); void reload(); } public interface ConfigurationValidator { void validate(Map\u0026lt;String, String\u0026gt; properties) throws ValidationException; } @Component public class ConfigurationService { private final List\u0026lt;ConfigurationSource\u0026gt; sources; private final ConfigurationValidator validator; private final ConfigurationCache cache; public ConfigurationService(List\u0026lt;ConfigurationSource\u0026gt; sources, ConfigurationValidator validator, ConfigurationCache cache) { this.sources = sources; this.validator = validator; this.cache = cache; } public \u0026lt;T\u0026gt; T getProperty(String key, Class\u0026lt;T\u0026gt; type, T defaultValue) { return cache.get(key, type) .orElseGet(() -\u0026gt; loadProperty(key, type, defaultValue)); } public \u0026lt;T\u0026gt; T getRequiredProperty(String key, Class\u0026lt;T\u0026gt; type) { return getProperty(key, type, null) .orElseThrow(() -\u0026gt; new ConfigurationException(\u0026#34;Required property not found: \u0026#34; + key)); } private \u0026lt;T\u0026gt; T loadProperty(String key, Class\u0026lt;T\u0026gt; type, T defaultValue) { for (ConfigurationSource source : sources) { Optional\u0026lt;String\u0026gt; value = source.getProperty(key); if (value.isPresent()) { T convertedValue = convertValue(value.get(), type); cache.put(key, convertedValue); return convertedValue; } } return defaultValue; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private \u0026lt;T\u0026gt; T convertValue(String value, Class\u0026lt;T\u0026gt; type) { if (type == String.class) { return (T) value; } else if (type == Integer.class) { return (T) Integer.valueOf(value); } else if (type == Boolean.class) { return (T) Boolean.valueOf(value); } else if (type == Duration.class) { return (T) Duration.parse(value); } throw new ConfigurationException(\u0026#34;Unsupported type: \u0026#34; + type); } public void reload() { sources.forEach(ConfigurationSource::reload); cache.clear(); // 重新加載後驗證配置 Map\u0026lt;String, String\u0026gt; allProperties = getAllProperties(); validator.validate(allProperties); } private Map\u0026lt;String, String\u0026gt; getAllProperties() { Map\u0026lt;String, String\u0026gt; allProperties = new HashMap\u0026lt;\u0026gt;(); sources.forEach(source -\u0026gt; allProperties.putAll(source.getAllProperties())); return allProperties; } } // 具體實現 @Component @Order(1) public class FileConfigurationSource implements ConfigurationSource { private final String configFile; private Properties properties; public FileConfigurationSource(@Value(\u0026#34;${config.file:config.properties}\u0026#34;) String configFile) { this.configFile = configFile; this.properties = new Properties(); reload(); } @Override public Optional\u0026lt;String\u0026gt; getProperty(String key) { return Optional.ofNullable(properties.getProperty(key)); } @Override public Map\u0026lt;String, String\u0026gt; getAllProperties() { return properties.entrySet().stream() .collect(Collectors.toMap( e -\u0026gt; e.getKey().toString(), e -\u0026gt; e.getValue().toString() )); } @Override public void reload() { try (InputStream is = new FileInputStream(configFile)) { properties.load(is); } catch (IOException e) { throw new ConfigurationException(\u0026#34;Failed to load configuration from \u0026#34; + configFile, e); } } } @Component @Order(2) public class EnvironmentConfigurationSource implements ConfigurationSource { @Override public Optional\u0026lt;String\u0026gt; getProperty(String key) { return Optional.ofNullable(System.getenv(key.toUpperCase().replace(\u0026#39;.\u0026#39;, \u0026#39;_\u0026#39;))); } @Override public Map\u0026lt;String, String\u0026gt; getAllProperties() { return System.getenv(); } @Override public void reload() { // 環境變量不需要重新加載 } } 常見代碼壞味道類型與重構技巧 1. Long Method (冗長方法) 問題描述： 方法過長，難以理解和維護。\n識別標準：\n方法超過20-30行 方法有多個職責 方法有多層嵌套 重構技巧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 // 壞味道：冗長的訂單處理方法 public class OrderProcessor { public void processOrder(Order order) { // 驗證訂單 if (order == null) { throw new IllegalArgumentException(\u0026#34;訂單不能為空\u0026#34;); } if (order.getItems() == null || order.getItems().isEmpty()) { throw new IllegalArgumentException(\u0026#34;訂單項目不能為空\u0026#34;); } for (OrderItem item : order.getItems()) { if (item.getQuantity() \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;訂單項目數量必須大於0\u0026#34;); } if (item.getPrice() \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;訂單項目價格必須大於0\u0026#34;); } } // 計算總金額 double totalAmount = 0; for (OrderItem item : order.getItems()) { totalAmount += item.getQuantity() * item.getPrice(); } // 計算折扣 double discount = 0; if (order.getCustomer().getType() == CustomerType.VIP) { discount = totalAmount * 0.1; } else if (order.getCustomer().getType() == CustomerType.PREMIUM) { discount = totalAmount * 0.05; } // 計算稅費 double tax = (totalAmount - discount) * 0.08; // 設置訂單金額 order.setSubtotal(totalAmount); order.setDiscount(discount); order.setTax(tax); order.setTotal(totalAmount - discount + tax); // 保存訂單 Connection conn = null; try { conn = DriverManager.getConnection(\u0026#34;jdbc:mysql://localhost:3306/orders\u0026#34;); PreparedStatement stmt = conn.prepareStatement( \u0026#34;INSERT INTO orders (customer_id, subtotal, discount, tax, total) VALUES (?, ?, ?, ?, ?)\u0026#34;); stmt.setLong(1, order.getCustomer().getId()); stmt.setDouble(2, order.getSubtotal()); stmt.setDouble(3, order.getDiscount()); stmt.setDouble(4, order.getTax()); stmt.setDouble(5, order.getTotal()); stmt.executeUpdate(); } catch (SQLException e) { throw new RuntimeException(\u0026#34;保存訂單失敗\u0026#34;, e); } finally { if (conn != null) { try { conn.close(); } catch (SQLException e) { // 忽略 } } } // 發送確認郵件 try { String subject = \u0026#34;訂單確認 - \u0026#34; + order.getId(); String body = \u0026#34;您的訂單已成功處理。訂單總金額: \u0026#34; + order.getTotal(); sendEmail(order.getCustomer().getEmail(), subject, body); } catch (Exception e) { // 記錄錯誤但不影響訂單處理 System.err.println(\u0026#34;發送確認郵件失敗: \u0026#34; + e.getMessage()); } } } 重構後：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 // 重構後：職責分離，方法簡潔 @Service public class OrderProcessor { private final OrderValidator orderValidator; private final OrderCalculator orderCalculator; private final OrderRepository orderRepository; private final NotificationService notificationService; public OrderProcessor(OrderValidator orderValidator, OrderCalculator orderCalculator, OrderRepository orderRepository, NotificationService notificationService) { this.orderValidator = orderValidator; this.orderCalculator = orderCalculator; this.orderRepository = orderRepository; this.notificationService = notificationService; } @Transactional public void processOrder(Order order) { orderValidator.validate(order); orderCalculator.calculateAmounts(order); orderRepository.save(order); notificationService.sendOrderConfirmation(order); } } @Component public class OrderValidator { public void validate(Order order) { validateOrderNotNull(order); validateOrderItems(order.getItems()); } private void validateOrderNotNull(Order order) { if (order == null) { throw new IllegalArgumentException(\u0026#34;訂單不能為空\u0026#34;); } } private void validateOrderItems(List\u0026lt;OrderItem\u0026gt; items) { if (items == null || items.isEmpty()) { throw new IllegalArgumentException(\u0026#34;訂單項目不能為空\u0026#34;); } items.forEach(this::validateOrderItem); } private void validateOrderItem(OrderItem item) { if (item.getQuantity() \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;訂單項目數量必須大於0\u0026#34;); } if (item.getPrice() \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;訂單項目價格必須大於0\u0026#34;); } } } @Component public class OrderCalculator { private final DiscountService discountService; private final TaxService taxService; public OrderCalculator(DiscountService discountService, TaxService taxService) { this.discountService = discountService; this.taxService = taxService; } public void calculateAmounts(Order order) { double subtotal = calculateSubtotal(order.getItems()); double discount = discountService.calculateDiscount(order); double tax = taxService.calculateTax(subtotal - discount); double total = subtotal - discount + tax; order.setSubtotal(subtotal); order.setDiscount(discount); order.setTax(tax); order.setTotal(total); } private double calculateSubtotal(List\u0026lt;OrderItem\u0026gt; items) { return items.stream() .mapToDouble(item -\u0026gt; item.getQuantity() * item.getPrice()) .sum(); } } 2. Large Class (巨大類) 問題描述： 類過大，承擔過多職責。\n識別標準：\n類超過200-300行 類有太多實例變量 類有太多方法 重構技巧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // 壞味道：巨大的用戶管理類 public class UserManager { private Connection dbConnection; private EmailService emailService; private Logger logger; private PasswordEncoder passwordEncoder; private UserValidator userValidator; private UserCache userCache; private SecurityService securityService; private AuditService auditService; private NotificationService notificationService; // 用戶CRUD操作 public User createUser(UserRequest request) { /* ... */ } public User updateUser(Long id, UserRequest request) { /* ... */ } public void deleteUser(Long id) { /* ... */ } public User findUserById(Long id) { /* ... */ } public List\u0026lt;User\u0026gt; findAllUsers() { /* ... */ } public List\u0026lt;User\u0026gt; findUsersByEmail(String email) { /* ... */ } // 用戶認證 public boolean authenticate(String username, String password) { /* ... */ } public String generateToken(User user) { /* ... */ } public boolean validateToken(String token) { /* ... */ } public void logout(String token) { /* ... */ } // 密碼管理 public void changePassword(Long userId, String oldPassword, String newPassword) { /* ... */ } public void resetPassword(String email) { /* ... */ } public boolean isPasswordExpired(User user) { /* ... */ } // 用戶權限 public void assignRole(Long userId, String role) { /* ... */ } public void removeRole(Long userId, String role) { /* ... */ } public Set\u0026lt;String\u0026gt; getUserRoles(Long userId) { /* ... */ } public boolean hasPermission(Long userId, String permission) { /* ... */ } // 用戶通知 public void sendWelcomeEmail(User user) { /* ... */ } public void sendPasswordResetEmail(User user) { /* ... */ } public void sendAccountLockedNotification(User user) { /* ... */ } // 用戶統計 public int getTotalUserCount() { /* ... */ } public int getActiveUserCount() { /* ... */ } public List\u0026lt;User\u0026gt; getRecentlyRegisteredUsers() { /* ... */ } // 用戶審計 public void logUserActivity(Long userId, String activity) { /* ... */ } public List\u0026lt;AuditRecord\u0026gt; getUserAuditHistory(Long userId) { /* ... */ } } 重構後：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 // 重構後：按職責分離為多個專門的類 @Service public class UserService { private final UserRepository userRepository; private final UserValidator userValidator; private final UserMapper userMapper; private final ApplicationEventPublisher eventPublisher; public UserService(UserRepository userRepository, UserValidator userValidator, UserMapper userMapper, ApplicationEventPublisher eventPublisher) { this.userRepository = userRepository; this.userValidator = userValidator; this.userMapper = userMapper; this.eventPublisher = eventPublisher; } @Transactional public User createUser(CreateUserRequest request) { userValidator.validate(request); User user = userMapper.toEntity(request); User savedUser = userRepository.save(user); eventPublisher.publishEvent(new UserCreatedEvent(savedUser)); return savedUser; } @Transactional public User updateUser(Long id, UpdateUserRequest request) { User existingUser = userRepository.findById(id) .orElseThrow(() -\u0026gt; new UserNotFoundException(\u0026#34;用戶不存在: \u0026#34; + id)); userValidator.validate(request); userMapper.updateEntity(existingUser, request); User updatedUser = userRepository.save(existingUser); eventPublisher.publishEvent(new UserUpdatedEvent(updatedUser)); return updatedUser; } @Transactional public void deleteUser(Long id) { User user = userRepository.findById(id) .orElseThrow(() -\u0026gt; new UserNotFoundException(\u0026#34;用戶不存在: \u0026#34; + id)); userRepository.delete(user); eventPublisher.publishEvent(new UserDeletedEvent(user)); } public User findUserById(Long id) { return userRepository.findById(id) .orElseThrow(() -\u0026gt; new UserNotFoundException(\u0026#34;用戶不存在: \u0026#34; + id)); } public List\u0026lt;User\u0026gt; findAllUsers() { return userRepository.findAll(); } public List\u0026lt;User\u0026gt; findUsersByEmail(String email) { return userRepository.findByEmailContaining(email); } } @Service public class UserAuthenticationService { private final UserRepository userRepository; private final PasswordEncoder passwordEncoder; private final JwtTokenProvider tokenProvider; private final AuthenticationEventPublisher eventPublisher; public UserAuthenticationService(UserRepository userRepository, PasswordEncoder passwordEncoder, JwtTokenProvider tokenProvider, AuthenticationEventPublisher eventPublisher) { this.userRepository = userRepository; this.passwordEncoder = passwordEncoder; this.tokenProvider = tokenProvider; this.eventPublisher = eventPublisher; } public AuthenticationResult authenticate(String username, String password) { User user = userRepository.findByUsername(username) .orElseThrow(() -\u0026gt; new AuthenticationException(\u0026#34;用戶名或密碼錯誤\u0026#34;)); if (!passwordEncoder.matches(password, user.getPassword())) { eventPublisher.publishEvent(new AuthenticationFailedEvent(user)); throw new AuthenticationException(\u0026#34;用戶名或密碼錯誤\u0026#34;); } String token = tokenProvider.generateToken(user); eventPublisher.publishEvent(new AuthenticationSuccessEvent(user)); return AuthenticationResult.success(user, token); } public boolean validateToken(String token) { return tokenProvider.validateToken(token); } public void logout(String token) { tokenProvider.invalidateToken(token); } } @Service public class UserPasswordService { private final UserRepository userRepository; private final PasswordEncoder passwordEncoder; private final PasswordValidator passwordValidator; private final ApplicationEventPublisher eventPublisher; public UserPasswordService(UserRepository userRepository, PasswordEncoder passwordEncoder, PasswordValidator passwordValidator, ApplicationEventPublisher eventPublisher) { this.userRepository = userRepository; this.passwordEncoder = passwordEncoder; this.passwordValidator = passwordValidator; this.eventPublisher = eventPublisher; } @Transactional public void changePassword(Long userId, String oldPassword, String newPassword) { User user = userRepository.findById(userId) .orElseThrow(() -\u0026gt; new UserNotFoundException(\u0026#34;用戶不存在: \u0026#34; + userId)); if (!passwordEncoder.matches(oldPassword, user.getPassword())) { throw new InvalidPasswordException(\u0026#34;舊密碼不正確\u0026#34;); } passwordValidator.validate(newPassword); user.setPassword(passwordEncoder.encode(newPassword)); user.setPasswordChangedAt(LocalDateTime.now()); userRepository.save(user); eventPublisher.publishEvent(new PasswordChangedEvent(user)); } @Transactional public void resetPassword(String email) { User user = userRepository.findByEmail(email) .orElseThrow(() -\u0026gt; new UserNotFoundException(\u0026#34;用戶不存在: \u0026#34; + email)); String resetToken = generateResetToken(); user.setPasswordResetToken(resetToken); user.setPasswordResetTokenExpiresAt(LocalDateTime.now().plusHours(24)); userRepository.save(user); eventPublisher.publishEvent(new PasswordResetRequestedEvent(user, resetToken)); } private String generateResetToken() { return UUID.randomUUID().toString(); } } 3. Duplicate Code (重複代碼) 問題描述： 相同或相似的代碼在多個地方重複出現。\n重構技巧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // 壞味道：重複的驗證邏輯 public class UserController { @PostMapping(\u0026#34;/users\u0026#34;) public ResponseEntity\u0026lt;User\u0026gt; createUser(@RequestBody CreateUserRequest request) { // 重複的驗證邏輯 if (request.getEmail() == null || request.getEmail().trim().isEmpty()) { throw new ValidationException(\u0026#34;電子郵件不能為空\u0026#34;); } if (!request.getEmail().contains(\u0026#34;@\u0026#34;)) { throw new ValidationException(\u0026#34;電子郵件格式不正確\u0026#34;); } if (request.getPassword() == null || request.getPassword().length() \u0026lt; 8) { throw new ValidationException(\u0026#34;密碼長度至少8位\u0026#34;); } // 業務邏輯 User user = userService.createUser(request); return ResponseEntity.ok(user); } @PutMapping(\u0026#34;/users/{id}\u0026#34;) public ResponseEntity\u0026lt;User\u0026gt; updateUser(@PathVariable Long id, @RequestBody UpdateUserRequest request) { // 重複的驗證邏輯 if (request.getEmail() == null || request.getEmail().trim().isEmpty()) { throw new ValidationException(\u0026#34;電子郵件不能為空\u0026#34;); } if (!request.getEmail().contains(\u0026#34;@\u0026#34;)) { throw new ValidationException(\u0026#34;電子郵件格式不正確\u0026#34;); } // 業務邏輯 User user = userService.updateUser(id, request); return ResponseEntity.ok(user); } } public class AdminController { @PostMapping(\u0026#34;/admin/users\u0026#34;) public ResponseEntity\u0026lt;User\u0026gt; createAdminUser(@RequestBody CreateUserRequest request) { // 又一次重複的驗證邏輯 if (request.getEmail() == null || request.getEmail().trim().isEmpty()) { throw new ValidationException(\u0026#34;電子郵件不能為空\u0026#34;); } if (!request.getEmail().contains(\u0026#34;@\u0026#34;)) { throw new ValidationException(\u0026#34;電子郵件格式不正確\u0026#34;); } if (request.getPassword() == null || request.getPassword().length() \u0026lt; 8) { throw new ValidationException(\u0026#34;密碼長度至少8位\u0026#34;); } // 業務邏輯 User user = adminService.createAdminUser(request); return ResponseEntity.ok(user); } } 重構後：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 // 重構後：提取共用驗證邏輯 @Component public class UserRequestValidator { private final EmailValidator emailValidator; private final PasswordValidator passwordValidator; public UserRequestValidator(EmailValidator emailValidator, PasswordValidator passwordValidator) { this.emailValidator = emailValidator; this.passwordValidator = passwordValidator; } public void validate(CreateUserRequest request) { validateEmail(request.getEmail()); validatePassword(request.getPassword()); validateName(request.getName()); } public void validate(UpdateUserRequest request) { validateEmail(request.getEmail()); validateName(request.getName()); } private void validateEmail(String email) { if (email == null || email.trim().isEmpty()) { throw new ValidationException(\u0026#34;電子郵件不能為空\u0026#34;); } if (!emailValidator.isValid(email)) { throw new ValidationException(\u0026#34;電子郵件格式不正確\u0026#34;); } } private void validatePassword(String password) { if (password == null || password.length() \u0026lt; 8) { throw new ValidationException(\u0026#34;密碼長度至少8位\u0026#34;); } if (!passwordValidator.isValid(password)) { throw new ValidationException(\u0026#34;密碼強度不足\u0026#34;); } } private void validateName(String name) { if (name == null || name.trim().isEmpty()) { throw new ValidationException(\u0026#34;姓名不能為空\u0026#34;); } if (name.length() \u0026gt; 50) { throw new ValidationException(\u0026#34;姓名長度不能超過50個字符\u0026#34;); } } } @RestController @RequestMapping(\u0026#34;/api\u0026#34;) public class UserController { private final UserService userService; private final UserRequestValidator validator; public UserController(UserService userService, UserRequestValidator validator) { this.userService = userService; this.validator = validator; } @PostMapping(\u0026#34;/users\u0026#34;) public ResponseEntity\u0026lt;User\u0026gt; createUser(@RequestBody CreateUserRequest request) { validator.validate(request); User user = userService.createUser(request); return ResponseEntity.ok(user); } @PutMapping(\u0026#34;/users/{id}\u0026#34;) public ResponseEntity\u0026lt;User\u0026gt; updateUser(@PathVariable Long id, @RequestBody UpdateUserRequest request) { validator.validate(request); User user = userService.updateUser(id, request); return ResponseEntity.ok(user); } } @RestController @RequestMapping(\u0026#34;/api/admin\u0026#34;) public class AdminController { private final AdminService adminService; private final UserRequestValidator validator; public AdminController(AdminService adminService, UserRequestValidator validator) { this.adminService = adminService; this.validator = validator; } @PostMapping(\u0026#34;/users\u0026#34;) public ResponseEntity\u0026lt;User\u0026gt; createAdminUser(@RequestBody CreateUserRequest request) { validator.validate(request); User user = adminService.createAdminUser(request); return ResponseEntity.ok(user); } } 代碼壞味道檢測工具 1. SonarQube 整合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!-- pom.xml --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.sonarsource.scanner.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sonar-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.9.1.2184\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.jacoco\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jacoco-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.8.7\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;prepare-agent\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;report\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;test\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;report\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; 2. PMD 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!-- pmd-ruleset.xml --\u0026gt; \u0026lt;ruleset name=\u0026#34;Custom PMD Rules\u0026#34; xmlns=\u0026#34;http://pmd.sourceforge.net/ruleset/2.0.0\u0026#34;\u0026gt; \u0026lt;rule ref=\u0026#34;category/java/bestpractices.xml/AvoidReassigningParameters\u0026#34; /\u0026gt; \u0026lt;rule ref=\u0026#34;category/java/bestpractices.xml/SwitchStmtsShouldHaveDefault\u0026#34; /\u0026gt; \u0026lt;rule ref=\u0026#34;category/java/codestyle.xml/LongVariable\u0026#34; /\u0026gt; \u0026lt;rule ref=\u0026#34;category/java/design.xml/ExcessiveMethodLength\u0026#34;\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;property name=\u0026#34;minimum\u0026#34; value=\u0026#34;30\u0026#34; /\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;rule ref=\u0026#34;category/java/design.xml/TooManyMethods\u0026#34;\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;property name=\u0026#34;maxmethods\u0026#34; value=\u0026#34;15\u0026#34; /\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/ruleset\u0026gt; 3. CheckStyle 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;!-- checkstyle.xml --\u0026gt; \u0026lt;module name=\u0026#34;Checker\u0026#34;\u0026gt; \u0026lt;module name=\u0026#34;TreeWalker\u0026#34;\u0026gt; \u0026lt;module name=\u0026#34;MethodLength\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;tokens\u0026#34; value=\u0026#34;METHOD_DEF\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;max\u0026#34; value=\u0026#34;30\u0026#34;/\u0026gt; \u0026lt;/module\u0026gt; \u0026lt;module name=\u0026#34;ParameterNumber\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;max\u0026#34; value=\u0026#34;5\u0026#34;/\u0026gt; \u0026lt;/module\u0026gt; \u0026lt;module name=\u0026#34;CyclomaticComplexity\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;max\u0026#34; value=\u0026#34;10\u0026#34;/\u0026gt; \u0026lt;/module\u0026gt; \u0026lt;module name=\u0026#34;ClassDataAbstractionCoupling\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;max\u0026#34; value=\u0026#34;10\u0026#34;/\u0026gt; \u0026lt;/module\u0026gt; \u0026lt;module name=\u0026#34;ClassFanOutComplexity\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;max\u0026#34; value=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;/module\u0026gt; \u0026lt;/module\u0026gt; \u0026lt;/module\u0026gt; 代碼品質監控 1. 代碼品質指標 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Component public class CodeQualityMetrics { private final MeterRegistry meterRegistry; public CodeQualityMetrics(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; } public void recordMethodComplexity(String className, String methodName, int complexity) { Gauge.builder(\u0026#34;code.complexity.cyclomatic\u0026#34;) .tag(\u0026#34;class\u0026#34;, className) .tag(\u0026#34;method\u0026#34;, methodName) .register(meterRegistry, complexity); } public void recordCodeDuplication(String className, double duplicationPercentage) { Gauge.builder(\u0026#34;code.duplication.percentage\u0026#34;) .tag(\u0026#34;class\u0026#34;, className) .register(meterRegistry, duplicationPercentage); } public void recordTestCoverage(String className, double coveragePercentage) { Gauge.builder(\u0026#34;code.coverage.percentage\u0026#34;) .tag(\u0026#34;class\u0026#34;, className) .register(meterRegistry, coveragePercentage); } } 2. 自動化代碼檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 @Component public class CodeQualityChecker { private final CodeQualityMetrics metrics; private final NotificationService notificationService; public CodeQualityChecker(CodeQualityMetrics metrics, NotificationService notificationService) { this.metrics = metrics; this.notificationService = notificationService; } @EventListener public void onCodeCommit(CodeCommitEvent event) { CodeQualityReport report = analyzeCode(event.getChangedFiles()); if (report.hasQualityIssues()) { notificationService.sendQualityAlert(report); } updateMetrics(report); } private CodeQualityReport analyzeCode(List\u0026lt;String\u0026gt; changedFiles) { CodeQualityReport report = new CodeQualityReport(); for (String file : changedFiles) { if (file.endsWith(\u0026#34;.java\u0026#34;)) { analyzeJavaFile(file, report); } } return report; } private void analyzeJavaFile(String filePath, CodeQualityReport report) { // 分析代碼複雜度 int complexity = calculateCyclomaticComplexity(filePath); if (complexity \u0026gt; 10) { report.addIssue(new QualityIssue(filePath, \u0026#34;高複雜度\u0026#34;, \u0026#34;圈複雜度: \u0026#34; + complexity)); } // 分析方法長度 int methodLength = calculateAverageMethodLength(filePath); if (methodLength \u0026gt; 30) { report.addIssue(new QualityIssue(filePath, \u0026#34;方法過長\u0026#34;, \u0026#34;平均方法長度: \u0026#34; + methodLength)); } // 分析重複代碼 double duplication = calculateDuplication(filePath); if (duplication \u0026gt; 0.1) { report.addIssue(new QualityIssue(filePath, \u0026#34;代碼重複\u0026#34;, \u0026#34;重複率: \u0026#34; + (duplication * 100) + \u0026#34;%\u0026#34;)); } } private int calculateCyclomaticComplexity(String filePath) { // 實現複雜度計算邏輯 return 0; } private int calculateAverageMethodLength(String filePath) { // 實現方法長度計算邏輯 return 0; } private double calculateDuplication(String filePath) { // 實現重複度計算邏輯 return 0.0; } private void updateMetrics(CodeQualityReport report) { report.getIssues().forEach(issue -\u0026gt; { String className = extractClassName(issue.getFilePath()); switch (issue.getType()) { case \u0026#34;高複雜度\u0026#34;: metrics.recordMethodComplexity(className, \u0026#34;unknown\u0026#34;, extractComplexityValue(issue.getDescription())); break; case \u0026#34;代碼重複\u0026#34;: metrics.recordCodeDuplication(className, extractDuplicationValue(issue.getDescription())); break; } }); } private String extractClassName(String filePath) { return filePath.substring(filePath.lastIndexOf(\u0026#39;/\u0026#39;) + 1, filePath.lastIndexOf(\u0026#39;.\u0026#39;)); } private int extractComplexityValue(String description) { // 從描述中提取複雜度值 return 0; } private double extractDuplicationValue(String description) { // 從描述中提取重複度值 return 0.0; } } 總結 代碼壞味道的識別與重構是提升軟體品質的重要手段：\n關鍵最佳實踐 持續監控：使用自動化工具持續監控代碼品質 漸進式重構：小步驟、高頻率的重構比大規模重構更安全 測試保護：在重構前確保有充分的測試覆蓋 團隊標準：建立統一的代碼品質標準和評審流程 教育培訓：定期培訓開發人員識別和避免代碼壞味道 預防策略 設計階段：在設計階段就考慮代碼品質 編碼標準：制定並遵循編碼標準 代碼評審：實施嚴格的代碼評審流程 自動化檢查：集成自動化代碼品質檢查工具 重構文化：培養持續重構的文化 通過系統性的代碼壞味道識別與重構，可以大幅提升代碼品質，降低維護成本，提高開發效率。\n","permalink":"https://xinqilin.github.io/post/architecture/badsmell/","tags":["Code Smells","Code Quality","Refactoring","Clean Code","Software Architecture","Best Practices","Technical Debt","Software Maintenance","Code Review","Design Patterns","SOLID Principles","Java","Enterprise Development"],"title":"代碼壞味道 (Code Smells) 完整識別與重構指南：軟體品質改善最佳實踐"},{"content":"GitHub SSH Setting 1 2 3 4 5 6 7 8 9 10 11 12 cd ~/ mkdir .ssh ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; (是否要用預設檔名) enter \u0026gt;\u0026gt; (密碼) enter \u0026gt;\u0026gt; (密碼確認) enter cat .ssh/id_ed25519.pub \u0026gt;\u0026gt; 跑出公鑰 貼到 github 上 ssh -T git@github.com \u0026gt;\u0026gt; 測試連線 \u0026gt;\u0026gt; \u0026#34;Hi xinqilin! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access.\u0026#34; 重設 remote url =\u0026gt; https 改 ssh 1 2 git remote rm origin git remote add origin [url] 應用程式要用的 token setting -\u0026gt; developer setting -\u0026gt; personal access token -\u0026gt; generate new token\nGitHub 教學 ","permalink":"https://xinqilin.github.io/post/tools/github-ssh/","tags":[],"title":"Github Ssh"},{"content":"概述 在現代開發流程中，使用 Docker 部署資料庫已成為主流。將 MySQL 運行在 Docker 容器中，可以帶來許多好處：環境隔離、快速部署、版本控制、以及方便的遷移。這篇文章將引導您如何在 Docker 中設定和管理 MySQL 容器。\n啟動 MySQL 容器 使用 docker run 指令可以快速啟動一個 MySQL 容器。以下是一個常用的範例，包含了密碼設定、埠映射和字元集設定。\n1 2 3 4 5 6 7 8 9 docker run \\ --name mysql-server \\ -e MYSQL_ROOT_PASSWORD=your_strong_password \\ -p 3306:3306 \\ -d \\ mysql/mysql-server \\ --character-set-server=utf8mb4 \\ --collation-server=utf8mb4_unicode_ci \\ --skip-character-set-client-handshake 指令參數說明 --name mysql-server: 為容器指定一個易於識別的名稱，這裡命名為 mysql-server。 -e MYSQL_ROOT_PASSWORD=your_strong_password: 設定 MySQL root 使用者的密碼。請務必將 your_strong_password 替換為您自己的強密碼。 -p 3306:3306: 將主機的 3306 埠映射到容器的 3306 埠。這樣您就可以從主機透過 3306 埠連接到容器內的 MySQL 服務。 -d: 以背景模式 (detached mode) 運行容器，讓容器在背景執行。 mysql/mysql-server: 指定要使用的 Docker 映像檔。mysql/mysql-server 是 MySQL 官方提供的映像檔。 --character-set-server=utf8mb4: 設定 MySQL 伺服器的預設字元集為 utf8mb4，以支援更廣泛的字元，包括表情符號。 --collation-server=utf8mb4_unicode_ci: 設定伺服器的預設排序規則為 utf8mb4_unicode_ci，這是一種不區分大小寫和重音的排序規則。 --skip-character-set-client-handshake: 禁用客戶端字元集握手。這有助於確保客戶端和伺服器之間的字元集一致性，避免亂碼問題。 字元集設定的等效配置 上述字元集相關的 docker run 參數，在 MySQL 的配置檔 (my.cnf) 中，等效於以下設定：\n1 2 3 4 5 6 7 8 9 [client] default-character-set=utf8mb4 [mysql] default-character-set=utf8mb4 [mysqld] collation-server = utf8mb4_unicode_ci character-set-server = utf8mb4 資料持久化 (Data Persistence) 對於資料庫容器，資料持久化是至關重要的。如果沒有將資料儲存到主機上，一旦容器被移除，所有資料都將丟失。Docker 提供了兩種主要方式來實現資料持久化：綁定掛載 (Bind Mounts) 和 具名儲存卷 (Named Volumes)。\n使用具名儲存卷 (推薦) 具名儲存卷由 Docker 管理，是持久化資料的最佳方式。\n1 2 3 4 5 6 7 8 9 10 docker run \\ --name mysql-server \\ -e MYSQL_ROOT_PASSWORD=your_strong_password \\ -p 3306:3306 \\ -d \\ -v mysql_data:/var/lib/mysql \\ mysql/mysql-server \\ --character-set-server=utf8mb4 \\ --collation-server=utf8mb4_unicode_ci \\ --skip-character-set-client-handshake -v mysql_data:/var/lib/mysql: 這裡 mysql_data 是一個具名儲存卷。Docker 會自動創建並管理這個儲存卷，將容器內 /var/lib/mysql (MySQL 資料預設儲存路徑) 的資料持久化到這個儲存卷中。 您可以透過 docker volume ls 查看所有具名儲存卷，並透過 docker volume inspect mysql_data 查看其詳細資訊。\n使用綁定掛載 綁定掛載允許您將主機上的任意目錄直接掛載到容器中。\n1 2 3 4 5 6 7 8 9 10 docker run \\ --name mysql-server \\ -e MYSQL_ROOT_PASSWORD=your_strong_password \\ -p 3306:3306 \\ -d \\ -v /path/to/your/mysql_data:/var/lib/mysql \\ mysql/mysql-server \\ --character-set-server=utf8mb4 \\ --collation-server=utf8mb4_unicode_ci \\ --skip-character-set-client-handshake -v /path/to/your/mysql_data:/var/lib/mysql: 將主機上的 /path/to/your/mysql_data 目錄掛載到容器內的 /var/lib/mysql。請將 /path/to/your/mysql_data 替換為您主機上的實際路徑。 連接到 MySQL 容器 一旦 MySQL 容器運行起來，您有多種方式可以連接到它。\n從主機連接 如果您的主機上安裝了 MySQL 客戶端，可以直接透過 localhost 和映射的埠連接：\n1 mysql -h 127.0.0.1 -P 3306 -u root -p 然後輸入您在 docker run 指令中設定的 MYSQL_ROOT_PASSWORD。\n進入容器內部連接 您可以使用 docker exec 指令進入運行中的容器，然後在容器內部使用 MySQL 客戶端：\n1 2 3 4 5 # 進入容器的 bash shell docker exec -it mysql-server /bin/bash # 在容器內部執行 MySQL 客戶端 mysql -u root -p 然後輸入密碼。\n最佳實踐與考量 密碼安全：在生產環境中，請勿將密碼直接寫在 docker run 指令中。考慮使用 Docker Secrets 或環境變數檔案 (.env) 來管理敏感資訊。 資源限制：對於生產環境，建議為 MySQL 容器設定 CPU 和記憶體限制，以避免其佔用過多主機資源。 日誌管理：監控 MySQL 容器的日誌 (docker logs mysql-server) 對於故障排除非常重要。 Docker Compose：對於多服務應用程式，強烈建議使用 Docker Compose 來定義和管理 MySQL 服務，這會讓整個應用程式的部署和管理更加便捷。 透過 Docker 容器化部署 MySQL，您可以更高效、更靈活地管理您的資料庫環境。\n","permalink":"https://xinqilin.github.io/post/devops/docker-mysql/","tags":["Docker","MySQL","DevOps","Database","Containerization"],"title":"Docker MySQL：容器化部署與設定"},{"content":"Basic u: All Users +: add permission x: execute chmod u+x *.sh\nHomebrew /usr/bin/ruby -e \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026quot; brew install cask brew install wget\nSDKMAN curl -s \u0026quot;https://get.sdkman.io\u0026quot; | bash source \u0026quot;$HOME/.sdkman/bin/sdkman-init.sh\u0026quot;\nOPENJDK /Library/Java/JavaVirtualMachines/ 下面 /usr/libexec/java_home --verbose\nremove\n1 2 cd /Library/Java/JavaVirtualMachines/ sudo rm -rf amazon-corretto-11.jdk MAVEN \u0026amp; GRADLE 1 2 3 4 5 6 7 8 9 10 sdk list java sdk current java sdk list java sdk list gradle sdk install gradle \u0026#39;version\u0026#39; sdk list maven sdk list java history| grep sdk sdk list maven sdk install maven \u0026#39;version\u0026#39; NVM curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash\nCheatSheet Fig brew install --cask fig\nleave end of file to change userName 1 2 3 4 5 prompt_context() { if [[ \u0026#34;$USER\u0026#34; != \u0026#34;$DEFAULT_USER\u0026#34; || -n \u0026#34;$SSH_CLIENT\u0026#34; ]]; then prompt_segment black default \u0026#34;%(!.%{%F{yellow}%}.)Bill\u0026#34; fi } zsh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 # Fig pre block. Keep at the top of this file. [[ -f \u0026#34;$HOME/.fig/shell/zshrc.pre.zsh\u0026#34; ]] \u0026amp;\u0026amp; builtin source \u0026#34;$HOME/.fig/shell/zshrc.pre.zsh\u0026#34; # Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc. # Initialization code that may require console input (password prompts, [y/n] # confirmations, etc.) must go above this block; everything else may go below. if [[ -r \u0026#34;${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh\u0026#34; ]]; then source \u0026#34;${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh\u0026#34; fi # 懶人指令 alias hist=\u0026#39;history\u0026#39; alias d=\u0026#39;docker\u0026#39; alias gs=\u0026#39;git status\u0026#39; alias g=\u0026#39;git\u0026#39; # JDK # JAVA_HOME=/Library/Java/JavaVirtualMachines/amazon-corretto-11.jdk/Contents/Home JAVA_HOME=/Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home # JAVA_HOME=/Library/Java/JavaVirtualMachines/graalvm-ce-lts-java11-20.3.4/Contents/Home # JAVA_HOME=/Library/Java/JavaVirtualMachines/graalvm-ce-java17-22.1.0/Contents/Home PATH=$JAVA_HOME/bin:$PATH:. CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:. export JAVA_HOME export PATH export CLASSPATH #THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!! export SDKMAN_DIR=\u0026#34;$HOME/.sdkman\u0026#34; [[ -s \u0026#34;$HOME/.sdkman/bin/sdkman-init.sh\u0026#34; ]] \u0026amp;\u0026amp; source \u0026#34;$HOME/.sdkman/bin/sdkman-init.sh\u0026#34; # homebrew # x86_64 version brew path # 這邊會把舊版本取為 brow (o for old) export PATH=/opt/homebrew/bin:$PATH alias brow=\u0026#39;arch --x86_64 /usr/local/Homebrew/bin/brew\u0026#39; # nvm export NVM_DIR=\u0026#34;$([ -z \u0026#34;${XDG_CONFIG_HOME-}\u0026#34; ] \u0026amp;\u0026amp; printf %s \u0026#34;${HOME}/.nvm\u0026#34; || printf %s \u0026#34;${XDG_CONFIG_HOME}/nvm\u0026#34;)\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm # If you come from bash you might have to change your $PATH. # export PATH=$HOME/bin:/usr/local/bin:$PATH # Path to your oh-my-zsh installation. export ZSH=\u0026#34;$HOME/.oh-my-zsh\u0026#34; # Set name of the theme to load --- if set to \u0026#34;random\u0026#34;, it will # load a random theme each time oh-my-zsh is loaded, in which case, # to know which specific one was loaded, run: echo $RANDOM_THEME # See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes ZSH_THEME=\u0026#34;agnoster\u0026#34; # ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; # Set list of themes to pick from when loading at random # Setting this variable when ZSH_THEME=random will cause zsh to load # a theme from this variable instead of looking in $ZSH/themes/ # If set to an empty array, this variable will have no effect. # ZSH_THEME_RANDOM_CANDIDATES=( \u0026#34;robbyrussell\u0026#34; \u0026#34;agnoster\u0026#34; ) # Uncomment the following line to use case-sensitive completion. # CASE_SENSITIVE=\u0026#34;true\u0026#34; # Uncomment the following line to use hyphen-insensitive completion. # Case-sensitive completion must be off. _ and - will be interchangeable. # HYPHEN_INSENSITIVE=\u0026#34;true\u0026#34; # Uncomment one of the following lines to change the auto-update behavior # zstyle \u0026#39;:omz:update\u0026#39; mode disabled # disable automatic updates # zstyle \u0026#39;:omz:update\u0026#39; mode auto # update automatically without asking # zstyle \u0026#39;:omz:update\u0026#39; mode reminder # just remind me to update when it\u0026#39;s time # Uncomment the following line to change how often to auto-update (in days). # zstyle \u0026#39;:omz:update\u0026#39; frequency 13 # Uncomment the following line if pasting URLs and other text is messed up. # DISABLE_MAGIC_FUNCTIONS=\u0026#34;true\u0026#34; # Uncomment the following line to disable colors in ls. # DISABLE_LS_COLORS=\u0026#34;true\u0026#34; # Uncomment the following line to disable auto-setting terminal title. # DISABLE_AUTO_TITLE=\u0026#34;true\u0026#34; # Uncomment the following line to enable command auto-correction. # ENABLE_CORRECTION=\u0026#34;true\u0026#34; # Uncomment the following line to display red dots whilst waiting for completion. # You can also set it to another string to have that shown instead of the default red dots. # e.g. COMPLETION_WAITING_DOTS=\u0026#34;%F{yellow}waiting...%f\u0026#34; # Caution: this setting can cause issues with multiline prompts in zsh \u0026lt; 5.7.1 (see #5765) # COMPLETION_WAITING_DOTS=\u0026#34;true\u0026#34; # Uncomment the following line if you want to disable marking untracked files # under VCS as dirty. This makes repository status check for large repositories # much, much faster. # DISABLE_UNTRACKED_FILES_DIRTY=\u0026#34;true\u0026#34; # Uncomment the following line if you want to change the command execution time # stamp shown in the history command output. # You can set one of the optional three formats: # \u0026#34;mm/dd/yyyy\u0026#34;|\u0026#34;dd.mm.yyyy\u0026#34;|\u0026#34;yyyy-mm-dd\u0026#34; # or set a custom format using the strftime function format specifications, # see \u0026#39;man strftime\u0026#39; for details. # HIST_STAMPS=\u0026#34;mm/dd/yyyy\u0026#34; # Would you like to use another custom folder than $ZSH/custom? # ZSH_CUSTOM=/path/to/new-custom-folder # Which plugins would you like to load? # Standard plugins can be found in $ZSH/plugins/ # Custom plugins may be added to $ZSH_CUSTOM/plugins/ # Example format: plugins=(rails git textmate ruby lighthouse) # Add wisely, as too many plugins slow down shell startup. plugins=(git) source $ZSH/oh-my-zsh.sh # User configuration # export MANPATH=\u0026#34;/usr/local/man:$MANPATH\u0026#34; # You may need to manually set your language environment # export LANG=en_US.UTF-8 # Preferred editor for local and remote sessions # if [[ -n $SSH_CONNECTION ]]; then # export EDITOR=\u0026#39;vim\u0026#39; # else # export EDITOR=\u0026#39;mvim\u0026#39; # fi # Compilation flags # export ARCHFLAGS=\u0026#34;-arch x86_64\u0026#34; # Set personal aliases, overriding those provided by oh-my-zsh libs, # plugins, and themes. Aliases can be placed here, though oh-my-zsh # users are encouraged to define aliases within the ZSH_CUSTOM folder. # For a full list of active aliases, run `alias`. # # Example aliases # alias zshconfig=\u0026#34;mate ~/.zshrc\u0026#34; # alias ohmyzsh=\u0026#34;mate ~/.oh-my-zsh\u0026#34; code () { VSCODE_CWD=\u0026#34;$PWD\u0026#34; open -n -b \u0026#34;com.microsoft.VSCode\u0026#34; --args $* ;} plugins=( git zsh-syntax-highlighting zsh-autosuggestions ) # To customize prompt, run `p10k configure` or edit ~/.p10k.zsh. [[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh # 這行控制 userName prompt_context() { if [[ \u0026#34;$USER\u0026#34; != \u0026#34;$DEFAULT_USER\u0026#34; || -n \u0026#34;$SSH_CLIENT\u0026#34; ]]; then prompt_segment black default \u0026#34;%(!.%{%F{yellow}%}.)Bill\u0026#34; fi } # Fig post block. Keep at the bottom of this file. [[ -f \u0026#34;$HOME/.fig/shell/zshrc.post.zsh\u0026#34; ]] \u0026amp;\u0026amp; builtin source \u0026#34;$HOME/.fig/shell/zshrc.post.zsh\u0026#34; ","permalink":"https://xinqilin.github.io/post/tools/env/","tags":[],"title":"Env"},{"content":"概述 拓撲排序（Topological Sort）是對**有向無環圖（DAG, Directed Acyclic Graph）**進行排序的演算法。排序結果是一個線性序列，使得對於圖中任意有向邊 (u, v)，在排序結果中 u 都出現在 v 之前。\n基本概念 應用場景 課程排課：某些課程有先修課程的要求 編譯依賴：程式模組間的編譯順序 任務調度：有依賴關係的任務執行順序 Makefile 建構：檔案間的依賴關係 前提條件 圖必須是有向無環圖（DAG） 如果圖中存在環，則無法進行拓撲排序 演算法實作 方法一：Kahn 演算法（BFS 基礎） 基本思路 計算所有節點的入度 將入度為 0 的節點加入佇列 不斷從佇列中取出節點，並減少其相鄰節點的入度 如果相鄰節點的入度變為 0，則加入佇列 重複直到佇列為空 實作代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public class TopologicalSort { public List\u0026lt;Integer\u0026gt; topologicalSort(int numNodes, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; edges) { // 建立鄰接表和入度陣列 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] indegree = new int[numNodes]; for (int i = 0; i \u0026lt; numNodes; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } // 建構圖並計算入度 for (List\u0026lt;Integer\u0026gt; edge : edges) { int from = edge.get(0); int to = edge.get(1); graph.get(from).add(to); indegree[to]++; } // 將入度為 0 的節點加入佇列 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numNodes; i++) { if (indegree[i] == 0) { queue.offer(i); } } List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // BFS 處理 while (!queue.isEmpty()) { int node = queue.poll(); result.add(node); // 減少相鄰節點的入度 for (int neighbor : graph.get(node)) { indegree[neighbor]--; if (indegree[neighbor] == 0) { queue.offer(neighbor); } } } // 檢查是否存在環 if (result.size() != numNodes) { return new ArrayList\u0026lt;\u0026gt;(); // 存在環，無法拓撲排序 } return result; } } 方法二：DFS 基礎 基本思路 對每個未訪問的節點進行 DFS 在 DFS 回溯時將節點加入結果 反轉結果得到拓撲排序 實作代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 public class TopologicalSortDFS { private static final int WHITE = 0; // 未訪問 private static final int GRAY = 1; // 正在訪問 private static final int BLACK = 2; // 已完成 public List\u0026lt;Integer\u0026gt; topologicalSort(int numNodes, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; edges) { // 建立鄰接表 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numNodes; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (List\u0026lt;Integer\u0026gt; edge : edges) { graph.get(edge.get(0)).add(edge.get(1)); } int[] color = new int[numNodes]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 對每個未訪問的節點進行 DFS for (int i = 0; i \u0026lt; numNodes; i++) { if (color[i] == WHITE) { if (!dfs(graph, i, color, stack)) { return new ArrayList\u0026lt;\u0026gt;(); // 存在環 } } } // 反轉結果 List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); while (!stack.isEmpty()) { result.add(stack.pop()); } return result; } private boolean dfs(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph, int node, int[] color, Stack\u0026lt;Integer\u0026gt; stack) { color[node] = GRAY; // 標記為正在訪問 for (int neighbor : graph.get(node)) { if (color[neighbor] == GRAY) { return false; // 發現後向邊，存在環 } if (color[neighbor] == WHITE \u0026amp;\u0026amp; !dfs(graph, neighbor, color, stack)) { return false; } } color[node] = BLACK; // 標記為已完成 stack.push(node); // 後序遍歷順序 return true; } } 實際應用題型 1. 課程安排（LeetCode 207 \u0026amp; 210） 問題 207：判斷是否可以完成所有課程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public boolean canFinish(int numCourses, int[][] prerequisites) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] indegree = new int[numCourses]; // 初始化圖 for (int i = 0; i \u0026lt; numCourses; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } // 建構圖 for (int[] prereq : prerequisites) { graph.get(prereq[1]).add(prereq[0]); indegree[prereq[0]]++; } // Kahn 演算法 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } int completedCourses = 0; while (!queue.isEmpty()) { int course = queue.poll(); completedCourses++; for (int nextCourse : graph.get(course)) { indegree[nextCourse]--; if (indegree[nextCourse] == 0) { queue.offer(nextCourse); } } } return completedCourses == numCourses; } 問題 210：返回課程安排的順序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public int[] findOrder(int numCourses, int[][] prerequisites) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] indegree = new int[numCourses]; // 建構圖（同上） for (int i = 0; i \u0026lt; numCourses; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] prereq : prerequisites) { graph.get(prereq[1]).add(prereq[0]); indegree[prereq[0]]++; } Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } int[] result = new int[numCourses]; int index = 0; while (!queue.isEmpty()) { int course = queue.poll(); result[index++] = course; for (int nextCourse : graph.get(course)) { indegree[nextCourse]--; if (indegree[nextCourse] == 0) { queue.offer(nextCourse); } } } return index == numCourses ? result : new int[0]; } 2. 所有可能的菜譜（LeetCode 2115） 問題描述：給定可製作的菜譜、所需原料以及現有原料，找出所有可能製作的菜譜。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Solution { private static final int NOT_VISITED = 0; private static final int VISITING = 1; private static final int VISITED = 2; public List\u0026lt;String\u0026gt; findAllRecipes(String[] recipes, List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; ingredients, String[] supplies) { Map\u0026lt;String, Integer\u0026gt; status = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; prereqs = new HashMap\u0026lt;\u0026gt;(); // 初始化食譜和其所需原料 for (int i = 0; i \u0026lt; recipes.length; i++) { status.put(recipes[i], NOT_VISITED); prereqs.put(recipes[i], ingredients.get(i)); } // 將現有原料標記為已訪問 for (String supply : supplies) { status.put(supply, VISITED); } List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // 對每個食譜進行 DFS for (String recipe : recipes) { dfs(recipe, prereqs, status, result); } return result; } private boolean dfs(String item, Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; prereqs, Map\u0026lt;String, Integer\u0026gt; status, List\u0026lt;String\u0026gt; result) { if (!status.containsKey(item)) { return false; // 不存在此原料或食譜 } if (status.get(item) == VISITING) { return false; // 發現環，無法製作 } if (status.get(item) == VISITED) { return true; // 已經可以製作 } // 標記為正在訪問 status.put(item, VISITING); // 檢查所有前置條件 if (prereqs.containsKey(item)) { for (String ingredient : prereqs.get(item)) { if (!dfs(ingredient, prereqs, status, result)) { return false; } } } // 標記為已完成 status.put(item, VISITED); result.add(item); return true; } } 複雜度分析 演算法 時間複雜度 空間複雜度 優點 缺點 Kahn (BFS) O(V + E) O(V) 實作簡單，易於理解 需要額外的入度陣列 DFS O(V + E) O(V) 可以檢測環，記憶體使用較少 實作稍複雜 其中 V 是節點數，E 是邊數。\n實作技巧 1. 環的檢測 1 2 3 4 5 6 7 8 9 10 // Kahn 演算法：如果處理的節點數不等於總節點數，則存在環 if (processedNodes != totalNodes) { // 存在環 } // DFS：使用三色標記法檢測後向邊 if (color[neighbor] == GRAY) { // 發現後向邊，存在環 return false; } 2. 多個拓撲排序解 如果需要找出所有可能的拓撲排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public void findAllTopologicalSorts(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph, int[] indegree, List\u0026lt;Integer\u0026gt; current, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; allResults) { Queue\u0026lt;Integer\u0026gt; available = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; indegree.length; i++) { if (indegree[i] == 0) { available.offer(i); } } if (available.isEmpty()) { if (current.size() == indegree.length) { allResults.add(new ArrayList\u0026lt;\u0026gt;(current)); } return; } // 嘗試所有可能的下一個節點 for (int node : available) { // 選擇 current.add(node); int[] newIndegree = indegree.clone(); newIndegree[node] = -1; // 標記為已使用 for (int neighbor : graph.get(node)) { newIndegree[neighbor]--; } // 遞歸 findAllTopologicalSorts(graph, newIndegree, current, allResults); // 撤銷選擇 current.remove(current.size() - 1); } } 總結 拓撲排序是處理有依賴關係問題的重要演算法。掌握要點：\n適用條件：只能用於有向無環圖 兩種方法：Kahn 演算法（BFS）和 DFS 方法 環的檢測：兩種方法都能檢測圖中是否存在環 實際應用：課程安排、任務調度、編譯依賴等 選擇演算法時：\nKahn 演算法：邏輯直觀，適合初學者 DFS 方法：更靈活，能提供更多信息（如完成時間） 參考資料 LeetCode 207. Course Schedule LeetCode 210. Course Schedule II LeetCode 2115. Find All Possible Recipes from Given Supplies 演算法導論 - 圖的拓撲排序 ","permalink":"https://xinqilin.github.io/post/algorithm/topologicalsort/","tags":["Algorithm","Graph","TopologicalSort","DFS","BFS","Java"],"title":"拓撲排序（Topological Sort）演算法詳解"},{"content":"概述 Reactive Programming（響應式程式設計）是一種基於資料流和變化傳播的程式設計模式。在 Java 生態系統中，Project Reactor 是實現響應式程式設計的核心函式庫，而 Spring WebFlux 則建立在其之上，提供非阻塞式的 Web 應用程式開發能力。\n核心概念 什麼是 Reactive Programming？ 響應式程式設計的核心特徵：\n非阻塞（Non-blocking）：執行緒不會被 I/O 操作阻塞 事件驅動（Event-driven）：基於事件流處理資料 背壓支援（Backpressure）：自動處理生產者和消費者之間的速度差異 彈性（Resilient）：具備錯誤處理和恢復能力 響應性（Responsive）：快速回應使用者請求 Reactive Streams 規範 Reactive Streams 定義了四個核心介面：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public interface Publisher\u0026lt;T\u0026gt; { void subscribe(Subscriber\u0026lt;? super T\u0026gt; s); } public interface Subscriber\u0026lt;T\u0026gt; { void onSubscribe(Subscription s); void onNext(T t); void onError(Throwable t); void onComplete(); } public interface Subscription { void request(long n); void cancel(); } public interface Processor\u0026lt;T, R\u0026gt; extends Subscriber\u0026lt;T\u0026gt;, Publisher\u0026lt;R\u0026gt; { } Project Reactor 基礎 Mono 與 Flux Project Reactor 提供兩個核心類型：\nMono：發出 0 或 1 個元素的響應式流 Flux：發出 0 到 N 個元素的響應式流 創建響應式流 Mono 創建方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 創建包含單一值的 Mono Mono\u0026lt;String\u0026gt; mono1 = Mono.just(\u0026#34;Hello Reactive\u0026#34;); // 創建空的 Mono Mono\u0026lt;String\u0026gt; empty = Mono.empty(); // 從 Optional 創建 Mono\u0026lt;String\u0026gt; mono2 = Mono.justOrEmpty(Optional.of(\u0026#34;Optional Value\u0026#34;)); // 延遲創建 Mono\u0026lt;String\u0026gt; lazy = Mono.fromSupplier(() -\u0026gt; { // 複雜的計算邏輯 return \u0026#34;Computed Value\u0026#34;; }); // 從 Callable 創建 Mono\u0026lt;String\u0026gt; callable = Mono.fromCallable(() -\u0026gt; { Thread.sleep(1000); // 模擬耗時操作 return \u0026#34;Delayed Value\u0026#34;; }); // 錯誤 Mono Mono\u0026lt;String\u0026gt; error = Mono.error(new RuntimeException(\u0026#34;Something went wrong\u0026#34;)); Flux 創建方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 從可變參數創建 Flux\u0026lt;String\u0026gt; flux1 = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;); // 從集合創建 List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Cherry\u0026#34;); Flux\u0026lt;String\u0026gt; flux2 = Flux.fromIterable(list); // 創建數字範圍 Flux\u0026lt;Integer\u0026gt; range = Flux.range(1, 10); // 1 到 10 // 定時發射 Flux\u0026lt;Long\u0026gt; interval = Flux.interval(Duration.ofSeconds(1)); // 每秒發射一個遞增數字 // 從陣列創建 String[] array = {\u0026#34;X\u0026#34;, \u0026#34;Y\u0026#34;, \u0026#34;Z\u0026#34;}; Flux\u0026lt;String\u0026gt; flux3 = Flux.fromArray(array); // 從 Stream 創建 Flux\u0026lt;String\u0026gt; flux4 = Flux.fromStream(Stream.of(\u0026#34;Stream1\u0026#34;, \u0026#34;Stream2\u0026#34;)); 訂閱與消費 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 基本訂閱 Flux\u0026lt;Integer\u0026gt; numbers = Flux.range(1, 5); // 只處理數據 numbers.subscribe(System.out::println); // 處理數據和錯誤 numbers.subscribe( data -\u0026gt; System.out.println(\u0026#34;Data: \u0026#34; + data), error -\u0026gt; System.err.println(\u0026#34;Error: \u0026#34; + error) ); // 完整的訂閱處理 numbers.subscribe( data -\u0026gt; System.out.println(\u0026#34;Next: \u0026#34; + data), // onNext error -\u0026gt; System.err.println(\u0026#34;Error: \u0026#34; + error), // onError () -\u0026gt; System.out.println(\u0026#34;Completed!\u0026#34;) // onComplete ); // 使用自訂 Subscriber numbers.subscribe(new BaseSubscriber\u0026lt;Integer\u0026gt;() { @Override protected void hookOnSubscribe(Subscription subscription) { System.out.println(\u0026#34;Subscribed\u0026#34;); request(1); // 請求第一個元素 } @Override protected void hookOnNext(Integer value) { System.out.println(\u0026#34;Value: \u0026#34; + value); if (value \u0026lt; 3) { request(1); // 繼續請求下一個 } else { cancel(); // 取消訂閱 } } }); 核心操作符詳解 轉換操作符 map - 元素轉換 1 2 3 4 5 6 7 8 9 Flux\u0026lt;String\u0026gt; names = Flux.just(\u0026#34;alice\u0026#34;, \u0026#34;bob\u0026#34;, \u0026#34;charlie\u0026#34;); // 轉換為大寫 Flux\u0026lt;String\u0026gt; upperNames = names.map(String::toUpperCase); upperNames.subscribe(System.out::println); // ALICE, BOB, CHARLIE // 轉換為長度 Flux\u0026lt;Integer\u0026gt; lengths = names.map(String::length); lengths.subscribe(System.out::println); // 5, 3, 7 flatMap - 扁平化處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Flux\u0026lt;String\u0026gt; sentences = Flux.just(\u0026#34;Hello World\u0026#34;, \u0026#34;Reactive Programming\u0026#34;); // 將每個句子拆分為單詞 Flux\u0026lt;String\u0026gt; words = sentences.flatMap(sentence -\u0026gt; Flux.fromArray(sentence.split(\u0026#34; \u0026#34;)) ); words.subscribe(System.out::println); // Hello, World, Reactive, Programming // 非同步處理 Flux\u0026lt;String\u0026gt; urls = Flux.just(\u0026#34;url1\u0026#34;, \u0026#34;url2\u0026#34;, \u0026#34;url3\u0026#34;); Flux\u0026lt;String\u0026gt; responses = urls.flatMap(url -\u0026gt; Mono.fromCallable(() -\u0026gt; { // 模擬 HTTP 請求 Thread.sleep(100); return \u0026#34;Response from \u0026#34; + url; }).subscribeOn(Schedulers.boundedElastic()) ); concatMap - 順序處理 1 2 3 4 5 // 與 flatMap 不同，concatMap 保持順序 Flux\u0026lt;String\u0026gt; ordered = urls.concatMap(url -\u0026gt; Mono.fromCallable(() -\u0026gt; \u0026#34;Response from \u0026#34; + url) .subscribeOn(Schedulers.boundedElastic()) ); 過濾操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Flux\u0026lt;Integer\u0026gt; numbers = Flux.range(1, 10); // 過濾偶數 Flux\u0026lt;Integer\u0026gt; evenNumbers = numbers.filter(n -\u0026gt; n % 2 == 0); // 取前 3 個元素 Flux\u0026lt;Integer\u0026gt; first3 = numbers.take(3); // 跳過前 5 個元素 Flux\u0026lt;Integer\u0026gt; skip5 = numbers.skip(5); // 去重 Flux\u0026lt;String\u0026gt; duplicates = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;B\u0026#34;); Flux\u0026lt;String\u0026gt; distinct = duplicates.distinct(); // 取不重複元素直到遇到重複 Flux\u0026lt;String\u0026gt; distinctUntilChanged = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .distinctUntilChanged(); 組合操作符 merge - 合併多個流 1 2 3 4 5 6 7 8 9 Flux\u0026lt;String\u0026gt; flux1 = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;).delayElements(Duration.ofMillis(100)); Flux\u0026lt;String\u0026gt; flux2 = Flux.just(\u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;).delayElements(Duration.ofMillis(150)); // 合併（順序不保證） Flux\u0026lt;String\u0026gt; merged = Flux.merge(flux1, flux2); merged.subscribe(System.out::println); // 可能輸出: A, C, B, D // 使用 mergeWith Flux\u0026lt;String\u0026gt; merged2 = flux1.mergeWith(flux2); concat - 連接流 1 2 3 4 5 6 // 連接（保持順序） Flux\u0026lt;String\u0026gt; concatenated = Flux.concat(flux1, flux2); concatenated.subscribe(System.out::println); // 輸出: A, B, C, D // 使用 concatWith Flux\u0026lt;String\u0026gt; concatenated2 = flux1.concatWith(flux2); zip - 配對元素 1 2 3 4 5 6 7 8 9 10 11 Flux\u0026lt;String\u0026gt; names = Flux.just(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;); Flux\u0026lt;Integer\u0026gt; ages = Flux.just(25, 30, 35); // 配對元素 Flux\u0026lt;String\u0026gt; people = Flux.zip(names, ages, (name, age) -\u0026gt; name + \u0026#34; is \u0026#34; + age + \u0026#34; years old\u0026#34; ); people.subscribe(System.out::println); // Alice is 25 years old // Bob is 30 years old // Charlie is 35 years old 錯誤處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Flux\u0026lt;String\u0026gt; source = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .map(s -\u0026gt; { if (\u0026#34;B\u0026#34;.equals(s)) { throw new RuntimeException(\u0026#34;Error on B\u0026#34;); } return s; }); // 提供預設值 Flux\u0026lt;String\u0026gt; withDefault = source.onErrorReturn(\u0026#34;DEFAULT\u0026#34;); // 繼續其他流 Flux\u0026lt;String\u0026gt; fallback = source.onErrorResume(error -\u0026gt; Flux.just(\u0026#34;FALLBACK1\u0026#34;, \u0026#34;FALLBACK2\u0026#34;) ); // 重試 Flux\u0026lt;String\u0026gt; withRetry = source.retry(3); // 重試且延遲 Flux\u0026lt;String\u0026gt; withRetryDelay = source.retryWhen( Retry.backoff(3, Duration.ofSeconds(1)) ); // 捕獲錯誤並繼續 Flux\u0026lt;String\u0026gt; continueOnError = source.onErrorContinue((error, item) -\u0026gt; { System.err.println(\u0026#34;Error on item \u0026#34; + item + \u0026#34;: \u0026#34; + error.getMessage()); }); 背壓（Backpressure）處理 背壓是響應式程式設計中的重要概念，用於處理生產者速度超過消費者處理能力的情況：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 背壓策略示例 Flux\u0026lt;Integer\u0026gt; fastProducer = Flux.range(1, 1000) .delayElements(Duration.ofMillis(1)); // 消費者處理較慢 fastProducer .onBackpressureBuffer(10) // 緩衝區大小為 10 .subscribe(new BaseSubscriber\u0026lt;Integer\u0026gt;() { @Override protected void hookOnSubscribe(Subscription subscription) { request(1); } @Override protected void hookOnNext(Integer value) { try { Thread.sleep(100); // 模擬慢處理 System.out.println(\u0026#34;Processed: \u0026#34; + value); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } request(1); } }); // 其他背壓策略 Flux\u0026lt;Integer\u0026gt; dropped = fastProducer.onBackpressureDrop(); Flux\u0026lt;Integer\u0026gt; latest = fastProducer.onBackpressureLatest(); Flux\u0026lt;Integer\u0026gt; error = fastProducer.onBackpressureError(); 排程器（Scheduler） Reactor 提供多種排程器來控制執行上下文：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 不同類型的排程器 Scheduler single = Schedulers.single(); // 單執行緒 Scheduler parallel = Schedulers.parallel(); // 並行處理（CPU 密集） Scheduler boundedElastic = Schedulers.boundedElastic(); // 彈性執行緒池（I/O 密集） Scheduler immediate = Schedulers.immediate(); // 當前執行緒 // 使用排程器 Flux\u0026lt;String\u0026gt; source = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;); // 在指定排程器上發布 Flux\u0026lt;String\u0026gt; published = source.publishOn(Schedulers.parallel()); // 在指定排程器上訂閱 Flux\u0026lt;String\u0026gt; subscribed = source.subscribeOn(Schedulers.boundedElastic()); // 組合使用 source .subscribeOn(Schedulers.boundedElastic()) // 訂閱在彈性執行緒池 .map(s -\u0026gt; s.toLowerCase()) // 轉換操作 .publishOn(Schedulers.parallel()) // 後續操作在並行排程器 .map(s -\u0026gt; s.toUpperCase()) .subscribe(System.out::println); Spring WebFlux 實戰 依賴配置 1 2 3 4 5 6 7 8 9 10 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-webflux\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-r2dbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 響應式 REST Controller 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { private final UserService userService; public UserController(UserService userService) { this.userService = userService; } @GetMapping public Flux\u0026lt;User\u0026gt; getAllUsers() { return userService.findAll(); } @GetMapping(\u0026#34;/{id}\u0026#34;) public Mono\u0026lt;ResponseEntity\u0026lt;User\u0026gt;\u0026gt; getUserById(@PathVariable String id) { return userService.findById(id) .map(user -\u0026gt; ResponseEntity.ok(user)) .defaultIfEmpty(ResponseEntity.notFound().build()); } @PostMapping public Mono\u0026lt;User\u0026gt; createUser(@RequestBody User user) { return userService.save(user); } @PutMapping(\u0026#34;/{id}\u0026#34;) public Mono\u0026lt;ResponseEntity\u0026lt;User\u0026gt;\u0026gt; updateUser(@PathVariable String id, @RequestBody User user) { return userService.update(id, user) .map(updatedUser -\u0026gt; ResponseEntity.ok(updatedUser)) .defaultIfEmpty(ResponseEntity.notFound().build()); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) public Mono\u0026lt;ResponseEntity\u0026lt;Void\u0026gt;\u0026gt; deleteUser(@PathVariable String id) { return userService.deleteById(id) .then(Mono.just(ResponseEntity.noContent().\u0026lt;Void\u0026gt;build())) .defaultIfEmpty(ResponseEntity.notFound().build()); } // 串流端點 @GetMapping(value = \u0026#34;/stream\u0026#34;, produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux\u0026lt;User\u0026gt; getUserStream() { return userService.findAll() .delayElements(Duration.ofSeconds(1)); // 每秒發送一個用戶 } } 響應式 Service 層 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @Service public class UserService { private final UserRepository userRepository; private final WebClient webClient; public UserService(UserRepository userRepository, WebClient.Builder webClientBuilder) { this.userRepository = userRepository; this.webClient = webClientBuilder.baseUrl(\u0026#34;https://api.external.com\u0026#34;).build(); } public Flux\u0026lt;User\u0026gt; findAll() { return userRepository.findAll(); } public Mono\u0026lt;User\u0026gt; findById(String id) { return userRepository.findById(id); } public Mono\u0026lt;User\u0026gt; save(User user) { return userRepository.save(user); } public Mono\u0026lt;User\u0026gt; update(String id, User user) { return userRepository.findById(id) .flatMap(existingUser -\u0026gt; { existingUser.setName(user.getName()); existingUser.setEmail(user.getEmail()); return userRepository.save(existingUser); }); } public Mono\u0026lt;Void\u0026gt; deleteById(String id) { return userRepository.deleteById(id); } // 組合多個非同步操作 public Mono\u0026lt;UserProfile\u0026gt; getUserProfile(String userId) { Mono\u0026lt;User\u0026gt; userMono = findById(userId); Mono\u0026lt;List\u0026lt;Order\u0026gt;\u0026gt; ordersMono = getOrdersByUserId(userId); Mono\u0026lt;UserPreferences\u0026gt; preferencesMono = getUserPreferences(userId); return Mono.zip(userMono, ordersMono, preferencesMono) .map(tuple -\u0026gt; new UserProfile( tuple.getT1(), // User tuple.getT2(), // Orders tuple.getT3() // Preferences )); } // 外部 API 呼叫 private Mono\u0026lt;List\u0026lt;Order\u0026gt;\u0026gt; getOrdersByUserId(String userId) { return webClient.get() .uri(\u0026#34;/orders?userId={userId}\u0026#34;, userId) .retrieve() .bodyToFlux(Order.class) .collectList() .timeout(Duration.ofSeconds(5)) // 5 秒逾時 .onErrorReturn(Collections.emptyList()); // 錯誤時返回空列表 } private Mono\u0026lt;UserPreferences\u0026gt; getUserPreferences(String userId) { return webClient.get() .uri(\u0026#34;/preferences/{userId}\u0026#34;, userId) .retrieve() .bodyToMono(UserPreferences.class) .onErrorReturn(new UserPreferences()); // 預設偏好設定 } } 響應式資料庫存取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // R2DBC Repository @Repository public interface UserRepository extends ReactiveCrudRepository\u0026lt;User, String\u0026gt; { Flux\u0026lt;User\u0026gt; findByNameContaining(String name); Flux\u0026lt;User\u0026gt; findByEmailDomain(String domain); @Query(\u0026#34;SELECT * FROM users WHERE created_at \u0026gt; :date\u0026#34;) Flux\u0026lt;User\u0026gt; findUsersCreatedAfter(LocalDateTime date); @Modifying @Query(\u0026#34;UPDATE users SET last_login = :loginTime WHERE id = :userId\u0026#34;) Mono\u0026lt;Integer\u0026gt; updateLastLogin(String userId, LocalDateTime loginTime); } // 自訂 Repository 實作 @Component public class CustomUserRepository { private final DatabaseClient databaseClient; public CustomUserRepository(DatabaseClient databaseClient) { this.databaseClient = databaseClient; } public Flux\u0026lt;User\u0026gt; findUsersByComplexCriteria(UserSearchCriteria criteria) { return databaseClient.sql(\u0026#34;\u0026#34;\u0026#34; SELECT * FROM users WHERE (:name IS NULL OR name LIKE :name) AND (:email IS NULL OR email = :email) AND (:minAge IS NULL OR age \u0026gt;= :minAge) ORDER BY created_at DESC \u0026#34;\u0026#34;\u0026#34;) .bind(\u0026#34;name\u0026#34;, criteria.getName() != null ? \u0026#34;%\u0026#34; + criteria.getName() + \u0026#34;%\u0026#34; : null) .bind(\u0026#34;email\u0026#34;, criteria.getEmail()) .bind(\u0026#34;minAge\u0026#34;, criteria.getMinAge()) .map((row, metadata) -\u0026gt; User.builder() .id(row.get(\u0026#34;id\u0026#34;, String.class)) .name(row.get(\u0026#34;name\u0026#34;, String.class)) .email(row.get(\u0026#34;email\u0026#34;, String.class)) .age(row.get(\u0026#34;age\u0026#34;, Integer.class)) .createdAt(row.get(\u0026#34;created_at\u0026#34;, LocalDateTime.class)) .build()) .all(); } } WebClient 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @Component public class ExternalApiClient { private final WebClient webClient; public ExternalApiClient(WebClient.Builder webClientBuilder) { this.webClient = webClientBuilder .baseUrl(\u0026#34;https://jsonplaceholder.typicode.com\u0026#34;) .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .build(); } // GET 請求 public Mono\u0026lt;Post\u0026gt; getPost(Long id) { return webClient.get() .uri(\u0026#34;/posts/{id}\u0026#34;, id) .retrieve() .onStatus(HttpStatus::is4xxClientError, response -\u0026gt; Mono.error(new NotFoundException(\u0026#34;Post not found\u0026#34;))) .onStatus(HttpStatus::is5xxServerError, response -\u0026gt; Mono.error(new ServiceException(\u0026#34;Server error\u0026#34;))) .bodyToMono(Post.class) .timeout(Duration.ofSeconds(10)) .retry(3); } // POST 請求 public Mono\u0026lt;Post\u0026gt; createPost(Post post) { return webClient.post() .uri(\u0026#34;/posts\u0026#34;) .bodyValue(post) .retrieve() .bodyToMono(Post.class); } // 批量請求 public Flux\u0026lt;Post\u0026gt; getAllPosts() { return webClient.get() .uri(\u0026#34;/posts\u0026#34;) .retrieve() .bodyToFlux(Post.class) .onBackpressureBuffer(100); // 緩衝處理 } // 並行請求 public Mono\u0026lt;List\u0026lt;PostWithComments\u0026gt;\u0026gt; getPostsWithComments(List\u0026lt;Long\u0026gt; postIds) { return Flux.fromIterable(postIds) .flatMap(this::getPostWithComments, 5) // 最多 5 個並行請求 .collectList(); } private Mono\u0026lt;PostWithComments\u0026gt; getPostWithComments(Long postId) { Mono\u0026lt;Post\u0026gt; postMono = getPost(postId); Mono\u0026lt;List\u0026lt;Comment\u0026gt;\u0026gt; commentsMono = getCommentsByPostId(postId); return Mono.zip(postMono, commentsMono, PostWithComments::new); } private Mono\u0026lt;List\u0026lt;Comment\u0026gt;\u0026gt; getCommentsByPostId(Long postId) { return webClient.get() .uri(\u0026#34;/posts/{postId}/comments\u0026#34;, postId) .retrieve() .bodyToFlux(Comment.class) .collectList(); } } 測試響應式程式碼 測試配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 @ExtendWith(MockitoExtension.class) class UserServiceTest { @Mock private UserRepository userRepository; @Mock private WebClient webClient; @Mock private WebClient.RequestHeadersUriSpec requestHeadersUriSpec; @Mock private WebClient.ResponseSpec responseSpec; @InjectMocks private UserService userService; @Test void testFindById() { // Given String userId = \u0026#34;123\u0026#34;; User expectedUser = new User(userId, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); when(userRepository.findById(userId)).thenReturn(Mono.just(expectedUser)); // When Mono\u0026lt;User\u0026gt; result = userService.findById(userId); // Then StepVerifier.create(result) .expectNext(expectedUser) .verifyComplete(); verify(userRepository).findById(userId); } @Test void testFindByIdNotFound() { // Given String userId = \u0026#34;999\u0026#34;; when(userRepository.findById(userId)).thenReturn(Mono.empty()); // When Mono\u0026lt;User\u0026gt; result = userService.findById(userId); // Then StepVerifier.create(result) .verifyComplete(); // 期望空結果 } @Test void testGetAllUsers() { // Given List\u0026lt;User\u0026gt; users = Arrays.asList( new User(\u0026#34;1\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;), new User(\u0026#34;2\u0026#34;, \u0026#34;Jane\u0026#34;, \u0026#34;jane@example.com\u0026#34;) ); when(userRepository.findAll()).thenReturn(Flux.fromIterable(users)); // When Flux\u0026lt;User\u0026gt; result = userService.findAll(); // Then StepVerifier.create(result) .expectNext(users.get(0)) .expectNext(users.get(1)) .verifyComplete(); } @Test void testSaveUser() { // Given User userToSave = new User(null, \u0026#34;New User\u0026#34;, \u0026#34;new@example.com\u0026#34;); User savedUser = new User(\u0026#34;123\u0026#34;, \u0026#34;New User\u0026#34;, \u0026#34;new@example.com\u0026#34;); when(userRepository.save(userToSave)).thenReturn(Mono.just(savedUser)); // When Mono\u0026lt;User\u0026gt; result = userService.save(userToSave); // Then StepVerifier.create(result) .expectNext(savedUser) .verifyComplete(); } @Test void testErrorHandling() { // Given String userId = \u0026#34;123\u0026#34;; when(userRepository.findById(userId)) .thenReturn(Mono.error(new RuntimeException(\u0026#34;Database error\u0026#34;))); // When Mono\u0026lt;User\u0026gt; result = userService.findById(userId); // Then StepVerifier.create(result) .expectError(RuntimeException.class) .verify(); } } 整合測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) class UserControllerIntegrationTest { @Autowired private WebTestClient webTestClient; @MockBean private UserService userService; @Test void testGetAllUsers() { // Given List\u0026lt;User\u0026gt; users = Arrays.asList( new User(\u0026#34;1\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;), new User(\u0026#34;2\u0026#34;, \u0026#34;Jane\u0026#34;, \u0026#34;jane@example.com\u0026#34;) ); when(userService.findAll()).thenReturn(Flux.fromIterable(users)); // When \u0026amp; Then webTestClient.get() .uri(\u0026#34;/api/users\u0026#34;) .exchange() .expectStatus().isOk() .expectBodyList(User.class) .hasSize(2) .contains(users.toArray(new User[0])); } @Test void testGetUserById() { // Given String userId = \u0026#34;123\u0026#34;; User user = new User(userId, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); when(userService.findById(userId)).thenReturn(Mono.just(user)); // When \u0026amp; Then webTestClient.get() .uri(\u0026#34;/api/users/{id}\u0026#34;, userId) .exchange() .expectStatus().isOk() .expectBody(User.class) .isEqualTo(user); } @Test void testGetUserByIdNotFound() { // Given String userId = \u0026#34;999\u0026#34;; when(userService.findById(userId)).thenReturn(Mono.empty()); // When \u0026amp; Then webTestClient.get() .uri(\u0026#34;/api/users/{id}\u0026#34;, userId) .exchange() .expectStatus().isNotFound(); } @Test void testCreateUser() { // Given User userToCreate = new User(null, \u0026#34;New User\u0026#34;, \u0026#34;new@example.com\u0026#34;); User createdUser = new User(\u0026#34;123\u0026#34;, \u0026#34;New User\u0026#34;, \u0026#34;new@example.com\u0026#34;); when(userService.save(any(User.class))).thenReturn(Mono.just(createdUser)); // When \u0026amp; Then webTestClient.post() .uri(\u0026#34;/api/users\u0026#34;) .bodyValue(userToCreate) .exchange() .expectStatus().isOk() .expectBody(User.class) .isEqualTo(createdUser); } } 效能優化與最佳實踐 1. 適當的背壓策略 1 2 3 4 5 6 7 8 9 // 根據情況選擇合適的背壓策略 public Flux\u0026lt;ProcessedData\u0026gt; processLargeDataset(Flux\u0026lt;RawData\u0026gt; input) { return input .onBackpressureBuffer(1000) // 適度緩衝 .flatMap(this::processData, 10) // 限制並行度 .onErrorContinue((error, item) -\u0026gt; { log.warn(\u0026#34;處理項目 {} 時發生錯誤: {}\u0026#34;, item, error.getMessage()); }); } 2. 合理使用排程器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Service public class OptimizedService { // CPU 密集型操作使用 parallel() public Mono\u0026lt;String\u0026gt; cpuIntensiveTask(String input) { return Mono.fromCallable(() -\u0026gt; { // 複雜計算 return performComplexCalculation(input); }).subscribeOn(Schedulers.parallel()); } // I/O 操作使用 boundedElastic() public Mono\u0026lt;String\u0026gt; ioTask(String filename) { return Mono.fromCallable(() -\u0026gt; { // 檔案讀取 return readFromFile(filename); }).subscribeOn(Schedulers.boundedElastic()); } } 3. 資源管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 使用 using() 確保資源正確釋放 public Mono\u0026lt;String\u0026gt; processFileWithProperCleanup(String filename) { return Mono.using( () -\u0026gt; Files.newBufferedReader(Paths.get(filename)), // 資源供應商 reader -\u0026gt; Mono.fromCallable(() -\u0026gt; { // 使用資源 return reader.lines().collect(Collectors.joining(\u0026#34;\\n\u0026#34;)); }).subscribeOn(Schedulers.boundedElastic()), reader -\u0026gt; { // 清理資源 try { reader.close(); } catch (IOException e) { log.warn(\u0026#34;關閉檔案時發生錯誤\u0026#34;, e); } } ); } 4. 快取策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Service public class CachedUserService { private final Cache\u0026lt;String, User\u0026gt; userCache = Caffeine.newBuilder() .maximumSize(1000) .expireAfterWrite(Duration.ofMinutes(10)) .build(); public Mono\u0026lt;User\u0026gt; getUserWithCache(String userId) { User cachedUser = userCache.getIfPresent(userId); if (cachedUser != null) { return Mono.just(cachedUser); } return userRepository.findById(userId) .doOnNext(user -\u0026gt; userCache.put(userId, user)) .cache(Duration.ofMinutes(5)); // Reactor 層級快取 } } 監控與除錯 1. 日誌記錄 1 2 3 4 5 6 7 8 public Flux\u0026lt;User\u0026gt; processUsers() { return userRepository.findAll() .doOnSubscribe(subscription -\u0026gt; log.info(\u0026#34;開始處理用戶\u0026#34;)) .doOnNext(user -\u0026gt; log.debug(\u0026#34;處理用戶: {}\u0026#34;, user.getId())) .doOnError(error -\u0026gt; log.error(\u0026#34;處理過程中發生錯誤\u0026#34;, error)) .doOnComplete(() -\u0026gt; log.info(\u0026#34;用戶處理完成\u0026#34;)) .doFinally(signalType -\u0026gt; log.info(\u0026#34;處理結束，信號類型: {}\u0026#34;, signalType)); } 2. 度量收集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Component public class MetricsService { private final MeterRegistry meterRegistry; private final Counter userProcessedCounter; private final Timer userProcessingTimer; public MetricsService(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; this.userProcessedCounter = Counter.builder(\u0026#34;users.processed\u0026#34;) .description(\u0026#34;處理的用戶數量\u0026#34;) .register(meterRegistry); this.userProcessingTimer = Timer.builder(\u0026#34;users.processing.time\u0026#34;) .description(\u0026#34;用戶處理時間\u0026#34;) .register(meterRegistry); } public Mono\u0026lt;User\u0026gt; processUserWithMetrics(User user) { return Mono.fromCallable(() -\u0026gt; { // 處理邏輯 return processUser(user); }) .doOnNext(u -\u0026gt; userProcessedCounter.increment()) .doOnSuccess(u -\u0026gt; userProcessingTimer.recordCallable(() -\u0026gt; { // 計時邏輯 return u; })) .subscribeOn(Schedulers.boundedElastic()); } } 總結 Reactive Programming 為 Java 開發者提供了處理非同步、非阻塞程式設計的強大工具。透過 Project Reactor 和 Spring WebFlux，我們可以：\n核心優勢 高效能：非阻塞 I/O 提升系統吞吐量 可擴展性：更好地利用系統資源 彈性：內建錯誤處理和恢復機制 組合性：豐富的操作符支援複雜的資料流處理 最佳實踐要點 適當場景：I/O 密集型應用程式最適合 操作符選擇：理解不同操作符的特性和適用場景 錯誤處理：設計完善的錯誤處理策略 測試：使用 StepVerifier 進行完整測試 監控：建立適當的日誌和度量機制 響應式程式設計雖然學習曲線較陡，但掌握後能顯著提升應用程式的效能和可維護性，特別適合現代微服務架構和雲端環境。\n參考資料 Project Reactor 官方文檔 Spring WebFlux 參考指南 Reactive Streams 規範 R2DBC 響應式資料庫存取 Reactor 3 Reference Guide ","permalink":"https://xinqilin.github.io/post/backend/reactivejava/","tags":["Java","Spring","WebFlux","Reactor","Reactive","Async","Mono","Flux"],"title":"Reactive Programming 完整指南：Spring WebFlux 與 Project Reactor"},{"content":"#721 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Input: accounts = [ [\u0026#34;John\u0026#34;,\u0026#34;johnsmith@mail.com\u0026#34;,\u0026#34;john_newyork@mail.com\u0026#34;], [\u0026#34;John\u0026#34;,\u0026#34;johnsmith@mail.com\u0026#34;,\u0026#34;john00@mail.com\u0026#34;], [\u0026#34;Mary\u0026#34;,\u0026#34;mary@mail.com\u0026#34;], [\u0026#34;John\u0026#34;,\u0026#34;johnnybravo@mail.com\u0026#34;] ] Output: [ [\u0026#34;John\u0026#34;,\u0026#34;john00@mail.com\u0026#34;,\u0026#34;john_newyork@mail.com\u0026#34;,\u0026#34;johnsmith@mail.com\u0026#34;], [\u0026#34;Mary\u0026#34;,\u0026#34;mary@mail.com\u0026#34;], [\u0026#34;John\u0026#34;,\u0026#34;johnnybravo@mail.com\u0026#34;] ] Explanation: The first and second John\u0026#39;s are the same person as they have the common email \u0026#34;johnsmith@mail.com\u0026#34;. The third John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [[\u0026#39;Mary\u0026#39;, \u0026#39;mary@mail.com\u0026#39;], [\u0026#39;John\u0026#39;, \u0026#39;johnnybravo@mail.com\u0026#39;], [\u0026#39;John\u0026#39;, \u0026#39;john00@mail.com\u0026#39;, \u0026#39;john_newyork@mail.com\u0026#39;, \u0026#39;johnsmith@mail.com\u0026#39;]] would still be accepted. Sol: Graph + DFS ref: click me!\n1 2 3 4 5 6 7 Use these edges to build some components. Common email addresses are like the intersections that connect each single component for each account. Because each component represents a merged account, do DFS search for each components and add into a list. Before add the name into this list, sort the emails. Then add name string into it. Examples: Assume we have three accounts, we connect them like this in order to use DFS. {Name, 1, 2, 3} =\u0026gt; Name -- 1 -- 2 -- 3 {Name, 2, 4, 5} =\u0026gt; Name -- 2 -- 4 -- 5 (The same graph node 2 appears) {Name, 6, 7, 8} =\u0026gt; Name -- 6 -- 7 -- 8 (Where numbers represent email addresses). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accountsMerge(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accounts) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if(accounts==null || accounts.size()==0) return result; Map\u0026lt;String, String\u0026gt; names = new HashMap\u0026lt;String, String\u0026gt;(); //email - username Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt;(); //email - neighbors Set\u0026lt;String\u0026gt; emails = new HashSet\u0026lt;String\u0026gt;(); for(List\u0026lt;String\u0026gt; list : accounts){ String name = list.get(0); for(int i=1; i\u0026lt;list.size(); i++){ String email = list.get(i); emails.add( email ); names.put( email, name ); map.putIfAbsent( email, new HashSet\u0026lt;String\u0026gt;() ); if(i==1) continue; //build the \u0026#34;edge\u0026#34; between two adjacent email-nodes map.get( list.get(i-1) ).add( email ); map.get( email ).add( list.get(i-1) ); } } Set\u0026lt;String\u0026gt; visited = new HashSet\u0026lt;String\u0026gt;(); for(String s : emails) if( !visited.contains(s) ){ visited.add(s); List\u0026lt;String\u0026gt; buffer = new ArrayList\u0026lt;String\u0026gt;(); buffer.add(s); helper(s, map, visited, buffer); Collections.sort(buffer); buffer.add(0, names.get(s)); result.add(buffer); } return result; } private void helper(String s, Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; map, Set\u0026lt;String\u0026gt; visited, List\u0026lt;String\u0026gt; buffer){ for(String node : map.get(s)) if( !visited.contains(node) ){ visited.add(node); buffer.add(node); helper(node, map, visited, buffer); } } } BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accountsMerge(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accounts) { HashMap\u0026lt;String,String\u0026gt; emailName = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; graph = new HashMap\u0026lt;\u0026gt;(); for(List\u0026lt;String\u0026gt; account: accounts){ String name = account.get(0); graph.putIfAbsent(account.get(1), new LinkedList\u0026lt;\u0026gt;()); emailName.put(account.get(1), name); for(int i = 2; i \u0026lt; account.size(); i++){ emailName.put(account.get(i), name); graph.putIfAbsent(account.get(i), new LinkedList\u0026lt;\u0026gt;()); graph.get(account.get(i)).add(account.get(1)); graph.get(account.get(1)).add(account.get(i)); } } List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); HashSet\u0026lt;String\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); for(String email: graph.keySet()){ if(visited.contains(email)) continue; visited.add(email); String name = emailName.get(email); List\u0026lt;String\u0026gt; emails = new LinkedList\u0026lt;\u0026gt;(); Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(email); while(!queue.isEmpty()){ String cur = queue.poll(); emails.add(cur); for(String next: graph.get(cur)){ if(!visited.contains(next)){ queue.offer(next); visited.add(next); } } } Collections.sort(emails); emails.add(0,name); res.add(emails); } return res; } ","permalink":"https://xinqilin.github.io/post/algorithm/graphaccountmerge/","tags":["Algorithm"],"title":"GraphAccountMerge"},{"content":"概述 二元樹遍歷是資料結構與演算法中的基本概念，主要有三種遍歷方式：前序遍歷（PreOrder）、中序遍歷（InOrder）、後序遍歷（PostOrder）。每種遍歷方式都有其特定的應用場景和優勢。\n基本概念 考慮以下二元樹結構：\n1 2 3 4 5 4 / \\ 2 6 / \\ / \\ 1 3 5 7 三種遍歷方式的順序 前序遍歷（PreOrder）：中 → 左 → 右\n遍歷順序：4 → 2 → 1 → 3 → 6 → 5 → 7 中序遍歷（InOrder）：左 → 中 → 右\n遍歷順序：1 → 2 → 3 → 4 → 5 → 6 → 7 對於二元搜尋樹，中序遍歷可得到有序序列 後序遍歷（PostOrder）：左 → 右 → 中\n遍歷順序：1 → 3 → 2 → 5 → 7 → 6 → 4 遍歷實作 1. 中序遍歷（InOrder Traversal） 中序遍歷在二元搜尋樹中特別有用，因為它會按升序訪問所有節點。\n遞歸實作 1 2 3 4 5 6 7 public void inorderTraversal(TreeNode root) { if (root == null) return; inorderTraversal(root.left); // 遍歷左子樹 System.out.print(root.val + \u0026#34; \u0026#34;); // 處理根節點 inorderTraversal(root.right); // 遍歷右子樹 } 迭代實作（使用堆疊） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode current = root; while (current != null || !stack.isEmpty()) { // 將所有左子節點推入堆疊 while (current != null) { stack.push(current); current = current.left; } // 處理堆疊頂部節點 current = stack.pop(); result.add(current.val); // 移動到右子樹 current = current.right; } return result; } 2. 前序遍歷（PreOrder Traversal） 前序遍歷適用於複製樹結構或建立表達式樹等場景。\n遞歸實作 1 2 3 4 5 6 7 public void preorderTraversal(TreeNode root) { if (root == null) return; System.out.print(root.val + \u0026#34; \u0026#34;); // 處理根節點 preorderTraversal(root.left); // 遍歷左子樹 preorderTraversal(root.right); // 遍歷右子樹 } 迭代實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return result; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode current = stack.pop(); result.add(current.val); // 注意：先推入右子節點，再推入左子節點 // 這樣確保左子節點先被處理 if (current.right != null) { stack.push(current.right); } if (current.left != null) { stack.push(current.left); } } return result; } 3. 後序遍歷（PostOrder Traversal） 後序遍歷適用於計算樹的大小、刪除節點或計算表達式值等場景。\n遞歸實作 1 2 3 4 5 6 7 public void postorderTraversal(TreeNode root) { if (root == null) return; postorderTraversal(root.left); // 遍歷左子樹 postorderTraversal(root.right); // 遍歷右子樹 System.out.print(root.val + \u0026#34; \u0026#34;); // 處理根節點 } 迭代實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return result; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode lastVisited = null; TreeNode current = root; while (current != null || !stack.isEmpty()) { if (current != null) { stack.push(current); current = current.left; } else { TreeNode peekNode = stack.peek(); // 如果右子節點存在且未被訪問過 if (peekNode.right != null \u0026amp;\u0026amp; lastVisited != peekNode.right) { current = peekNode.right; } else { result.add(peekNode.val); lastVisited = stack.pop(); } } } return result; } 實際應用：從遍歷序列重建二元樹 1. 從中序與後序遍歷重建二元樹 LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class Solution { public TreeNode buildTree(int[] inorder, int[] postorder) { if (inorder == null || inorder.length == 0 || postorder == null || postorder.length == 0) { return null; } return helper(postorder, postorder.length - 1, inorder, 0, inorder.length - 1); } private TreeNode helper(int[] postorder, int postIndex, int[] inorder, int inStart, int inEnd) { if (inStart \u0026gt; inEnd || postIndex \u0026lt; 0) { return null; } // 後序遍歷的最後一個元素是根節點 TreeNode root = new TreeNode(postorder[postIndex]); // 在中序遍歷中找到根節點的位置 int rootIndex = 0; for (int i = inStart; i \u0026lt;= inEnd; i++) { if (inorder[i] == root.val) { rootIndex = i; break; } } // 遞歸建構左右子樹 // 注意：先建構右子樹，因為後序遍歷是左-右-根 root.right = helper(postorder, postIndex - 1, inorder, rootIndex + 1, inEnd); root.left = helper(postorder, postIndex - (inEnd - rootIndex + 1), inorder, inStart, rootIndex - 1); return root; } } 2. 從前序與中序遍歷重建二元樹 LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { return helper(preorder, inorder, 0, 0, inorder.length - 1); } private TreeNode helper(int[] preorder, int[] inorder, int preStart, int inStart, int inEnd) { if (preStart \u0026gt; preorder.length - 1 || inStart \u0026gt; inEnd) { return null; } // 前序遍歷的第一個元素是根節點 TreeNode root = new TreeNode(preorder[preStart]); // 在中序遍歷中找到根節點的位置 int rootIndex = 0; for (int i = inStart; i \u0026lt;= inEnd; i++) { if (inorder[i] == preorder[preStart]) { rootIndex = i; break; } } // 遞歸建構左右子樹 root.left = helper(preorder, inorder, preStart + 1, inStart, rootIndex - 1); root.right = helper(preorder, inorder, preStart + rootIndex - inStart + 1, rootIndex + 1, inEnd); return root; } } 時間與空間複雜度 遍歷方式 時間複雜度 空間複雜度（遞歸） 空間複雜度（迭代） 前序遍歷 O(n) O(h) O(h) 中序遍歷 O(n) O(h) O(h) 後序遍歷 O(n) O(h) O(h) 其中 n 是節點數量，h 是樹的高度（最壞情況下 h = n，最佳情況下 h = log n）。\n應用場景總結 前序遍歷：複製樹、序列化樹結構、建立表達式樹 中序遍歷：二元搜尋樹的有序輸出、驗證二元搜尋樹 後序遍歷：計算樹的大小、刪除樹、計算表達式值、釋放記憶體 參考資料 LeetCode 94. Binary Tree Inorder Traversal LeetCode 144. Binary Tree Preorder Traversal LeetCode 145. Binary Tree Postorder Traversal 演算法導論 - 二元樹的基本操作 ","permalink":"https://xinqilin.github.io/post/algorithm/treetraversal/","tags":["Algorithm","Tree","遞歸","Java"],"title":"二元樹遍歷（Binary Tree Traversal）完整指南"},{"content":"Java TreeMap 完整實作指南 簡介 TreeMap 是 Java 集合框架中實現有序映射的核心類別，基於紅黑樹（Red-Black Tree）數據結構實現。它提供了 O(log n) 的時間複雜度進行搜索、插入和刪除操作，並保證鍵的有序性。本文將深入探討 TreeMap 的內部實現、各種方法使用、效能特性以及在企業級開發中的最佳實踐。\nTreeMap 架構與繼承關係 類別繼承結構 1 2 3 4 5 6 7 Map\u0026lt;K,V\u0026gt; ↑ SortedMap\u0026lt;K,V\u0026gt; ↑ NavigableMap\u0026lt;K,V\u0026gt; ↑ TreeMap\u0026lt;K,V\u0026gt; 核心介面關係 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 基本映射介面 public interface Map\u0026lt;K,V\u0026gt; { V put(K key, V value); V get(Object key); V remove(Object key); boolean containsKey(Object key); Set\u0026lt;K\u0026gt; keySet(); Collection\u0026lt;V\u0026gt; values(); Set\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; entrySet(); } // 有序映射介面 public interface SortedMap\u0026lt;K,V\u0026gt; extends Map\u0026lt;K,V\u0026gt; { Comparator\u0026lt;? super K\u0026gt; comparator(); SortedMap\u0026lt;K,V\u0026gt; subMap(K fromKey, K toKey); SortedMap\u0026lt;K,V\u0026gt; headMap(K toKey); SortedMap\u0026lt;K,V\u0026gt; tailMap(K fromKey); K firstKey(); K lastKey(); } // 可導航映射介面 public interface NavigableMap\u0026lt;K,V\u0026gt; extends SortedMap\u0026lt;K,V\u0026gt; { Map.Entry\u0026lt;K,V\u0026gt; lowerEntry(K key); K lowerKey(K key); Map.Entry\u0026lt;K,V\u0026gt; floorEntry(K key); K floorKey(K key); Map.Entry\u0026lt;K,V\u0026gt; ceilingEntry(K key); K ceilingKey(K key); Map.Entry\u0026lt;K,V\u0026gt; higherEntry(K key); K higherKey(K key); Map.Entry\u0026lt;K,V\u0026gt; firstEntry(); Map.Entry\u0026lt;K,V\u0026gt; lastEntry(); Map.Entry\u0026lt;K,V\u0026gt; pollFirstEntry(); Map.Entry\u0026lt;K,V\u0026gt; pollLastEntry(); NavigableMap\u0026lt;K,V\u0026gt; descendingMap(); NavigableSet\u0026lt;K\u0026gt; navigableKeySet(); NavigableSet\u0026lt;K\u0026gt; descendingKeySet(); } TreeMap 核心特性 1. 紅黑樹實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // TreeMap 內部節點結構 static final class Entry\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { K key; V value; Entry\u0026lt;K,V\u0026gt; left; Entry\u0026lt;K,V\u0026gt; right; Entry\u0026lt;K,V\u0026gt; parent; boolean color = BLACK; Entry(K key, V value, Entry\u0026lt;K,V\u0026gt; parent) { this.key = key; this.value = value; this.parent = parent; } } // 紅黑樹顏色常量 private static final boolean RED = false; private static final boolean BLACK = true; // 根節點和大小 private transient Entry\u0026lt;K,V\u0026gt; root; private transient int size = 0; private transient int modCount = 0; // 比較器 private final Comparator\u0026lt;? super K\u0026gt; comparator; 2. 自然排序與自定義比較器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 自然排序 TreeMap TreeMap\u0026lt;String, Integer\u0026gt; naturalOrder = new TreeMap\u0026lt;\u0026gt;(); naturalOrder.put(\u0026#34;Charlie\u0026#34;, 3); naturalOrder.put(\u0026#34;Alice\u0026#34;, 1); naturalOrder.put(\u0026#34;Bob\u0026#34;, 2); // 結果：{Alice=1, Bob=2, Charlie=3} // 自定義比較器 TreeMap\u0026lt;String, Integer\u0026gt; customOrder = new TreeMap\u0026lt;\u0026gt;( (s1, s2) -\u0026gt; s2.compareTo(s1) // 降序 ); customOrder.put(\u0026#34;Charlie\u0026#34;, 3); customOrder.put(\u0026#34;Alice\u0026#34;, 1); customOrder.put(\u0026#34;Bob\u0026#34;, 2); // 結果：{Charlie=3, Bob=2, Alice=1} // 複雜對象比較器 TreeMap\u0026lt;Student, String\u0026gt; studentMap = new TreeMap\u0026lt;\u0026gt;( Comparator.comparing(Student::getGrade) .thenComparing(Student::getName) ); SortedMap 介面詳解 基本方法實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class TreeMapSortedExample { public static void main(String[] args) { TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); // 添加元素 treeMap.put(5, \u0026#34;Five\u0026#34;); treeMap.put(2, \u0026#34;Two\u0026#34;); treeMap.put(8, \u0026#34;Eight\u0026#34;); treeMap.put(1, \u0026#34;One\u0026#34;); treeMap.put(9, \u0026#34;Nine\u0026#34;); // 基本排序方法 demonstrateSortedMapMethods(treeMap); } private static void demonstrateSortedMapMethods(TreeMap\u0026lt;Integer, String\u0026gt; map) { System.out.println(\u0026#34;Original map: \u0026#34; + map); // 獲取比較器 Comparator\u0026lt;? super Integer\u0026gt; comparator = map.comparator(); System.out.println(\u0026#34;Comparator: \u0026#34; + comparator); // null (natural ordering) // 第一個和最後一個鍵 System.out.println(\u0026#34;First key: \u0026#34; + map.firstKey()); // 1 System.out.println(\u0026#34;Last key: \u0026#34; + map.lastKey()); // 9 // 子映射（含頭不含尾） SortedMap\u0026lt;Integer, String\u0026gt; subMap = map.subMap(2, 8); System.out.println(\u0026#34;SubMap [2, 8): \u0026#34; + subMap); // {2=Two, 5=Five} // 頭部映射（不包含指定鍵） SortedMap\u0026lt;Integer, String\u0026gt; headMap = map.headMap(5); System.out.println(\u0026#34;HeadMap (\u0026lt; 5): \u0026#34; + headMap); // {1=One, 2=Two} // 尾部映射（包含指定鍵） SortedMap\u0026lt;Integer, String\u0026gt; tailMap = map.tailMap(5); System.out.println(\u0026#34;TailMap (\u0026gt;= 5): \u0026#34; + tailMap); // {5=Five, 8=Eight, 9=Nine} // 鍵集合、值集合、條目集合 System.out.println(\u0026#34;Keys: \u0026#34; + map.keySet()); System.out.println(\u0026#34;Values: \u0026#34; + map.values()); System.out.println(\u0026#34;Entries: \u0026#34; + map.entrySet()); } } NavigableMap 介面詳解 導航方法實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 public class TreeMapNavigableExample { public static void main(String[] args) { TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); // 添加測試數據 treeMap.put(1, \u0026#34;One\u0026#34;); treeMap.put(3, \u0026#34;Three\u0026#34;); treeMap.put(5, \u0026#34;Five\u0026#34;); treeMap.put(7, \u0026#34;Seven\u0026#34;); treeMap.put(9, \u0026#34;Nine\u0026#34;); demonstrateNavigableMethods(treeMap); } private static void demonstrateNavigableMethods(TreeMap\u0026lt;Integer, String\u0026gt; map) { System.out.println(\u0026#34;Original map: \u0026#34; + map); // Lower 方法：返回嚴格小於指定鍵的最大鍵 Map.Entry\u0026lt;Integer, String\u0026gt; lowerEntry = map.lowerEntry(5); System.out.println(\u0026#34;Lower entry (\u0026lt; 5): \u0026#34; + lowerEntry); // 3=Three Integer lowerKey = map.lowerKey(5); System.out.println(\u0026#34;Lower key (\u0026lt; 5): \u0026#34; + lowerKey); // 3 // Floor 方法：返回小於或等於指定鍵的最大鍵 Map.Entry\u0026lt;Integer, String\u0026gt; floorEntry = map.floorEntry(4); System.out.println(\u0026#34;Floor entry (\u0026lt;= 4): \u0026#34; + floorEntry); // 3=Three Map.Entry\u0026lt;Integer, String\u0026gt; floorEntry2 = map.floorEntry(5); System.out.println(\u0026#34;Floor entry (\u0026lt;= 5): \u0026#34; + floorEntry2); // 5=Five // Ceiling 方法：返回大於或等於指定鍵的最小鍵 Map.Entry\u0026lt;Integer, String\u0026gt; ceilingEntry = map.ceilingEntry(4); System.out.println(\u0026#34;Ceiling entry (\u0026gt;= 4): \u0026#34; + ceilingEntry); // 5=Five Map.Entry\u0026lt;Integer, String\u0026gt; ceilingEntry2 = map.ceilingEntry(5); System.out.println(\u0026#34;Ceiling entry (\u0026gt;= 5): \u0026#34; + ceilingEntry2); // 5=Five // Higher 方法：返回嚴格大於指定鍵的最小鍵 Map.Entry\u0026lt;Integer, String\u0026gt; higherEntry = map.higherEntry(5); System.out.println(\u0026#34;Higher entry (\u0026gt; 5): \u0026#34; + higherEntry); // 7=Seven // 首尾條目 Map.Entry\u0026lt;Integer, String\u0026gt; firstEntry = map.firstEntry(); Map.Entry\u0026lt;Integer, String\u0026gt; lastEntry = map.lastEntry(); System.out.println(\u0026#34;First entry: \u0026#34; + firstEntry); // 1=One System.out.println(\u0026#34;Last entry: \u0026#34; + lastEntry); // 9=Nine // 彈出首尾條目（會刪除元素） TreeMap\u0026lt;Integer, String\u0026gt; copyMap = new TreeMap\u0026lt;\u0026gt;(map); Map.Entry\u0026lt;Integer, String\u0026gt; pollFirst = copyMap.pollFirstEntry(); Map.Entry\u0026lt;Integer, String\u0026gt; pollLast = copyMap.pollLastEntry(); System.out.println(\u0026#34;Poll first: \u0026#34; + pollFirst); // 1=One System.out.println(\u0026#34;Poll last: \u0026#34; + pollLast); // 9=Nine System.out.println(\u0026#34;After polling: \u0026#34; + copyMap); // {3=Three, 5=Five, 7=Seven} // 降序視圖 NavigableMap\u0026lt;Integer, String\u0026gt; descendingMap = map.descendingMap(); System.out.println(\u0026#34;Descending map: \u0026#34; + descendingMap); // 導航鍵集合 NavigableSet\u0026lt;Integer\u0026gt; navigableKeySet = map.navigableKeySet(); NavigableSet\u0026lt;Integer\u0026gt; descendingKeySet = map.descendingKeySet(); System.out.println(\u0026#34;Navigable key set: \u0026#34; + navigableKeySet); System.out.println(\u0026#34;Descending key set: \u0026#34; + descendingKeySet); // 範圍視圖 NavigableMap\u0026lt;Integer, String\u0026gt; rangeMap = map.subMap(3, true, 7, false); System.out.println(\u0026#34;Range [3, 7): \u0026#34; + rangeMap); // {3=Three, 5=Five} NavigableMap\u0026lt;Integer, String\u0026gt; headMap = map.headMap(5, true); System.out.println(\u0026#34;Head map (\u0026lt;= 5): \u0026#34; + headMap); // {1=One, 3=Three, 5=Five} NavigableMap\u0026lt;Integer, String\u0026gt; tailMap = map.tailMap(5, false); System.out.println(\u0026#34;Tail map (\u0026gt; 5): \u0026#34; + tailMap); // {7=Seven, 9=Nine} } } 企業級應用實例 1. 時間序列數據管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 public class TimeSeriesDataManager { private final TreeMap\u0026lt;LocalDateTime, Double\u0026gt; timeSeriesData; public TimeSeriesDataManager() { this.timeSeriesData = new TreeMap\u0026lt;\u0026gt;(); } // 添加數據點 public void addDataPoint(LocalDateTime timestamp, Double value) { timeSeriesData.put(timestamp, value); } // 獲取指定時間範圍的數據 public NavigableMap\u0026lt;LocalDateTime, Double\u0026gt; getDataInRange( LocalDateTime startTime, LocalDateTime endTime) { return timeSeriesData.subMap(startTime, true, endTime, true); } // 獲取最新數據 public Map.Entry\u0026lt;LocalDateTime, Double\u0026gt; getLatestData() { return timeSeriesData.lastEntry(); } // 獲取指定時間之前的最新數據 public Map.Entry\u0026lt;LocalDateTime, Double\u0026gt; getLatestDataBefore(LocalDateTime time) { return timeSeriesData.lowerEntry(time); } // 獲取指定時間之後的最早數據 public Map.Entry\u0026lt;LocalDateTime, Double\u0026gt; getEarliestDataAfter(LocalDateTime time) { return timeSeriesData.higherEntry(time); } // 計算時間範圍內的平均值 public double getAverageInRange(LocalDateTime startTime, LocalDateTime endTime) { NavigableMap\u0026lt;LocalDateTime, Double\u0026gt; rangeData = getDataInRange(startTime, endTime); return rangeData.values().stream() .mapToDouble(Double::doubleValue) .average() .orElse(0.0); } // 清理舊數據 public void cleanupOldData(LocalDateTime cutoffTime) { timeSeriesData.headMap(cutoffTime, false).clear(); } // 獲取數據統計信息 public DataStatistics getStatistics() { if (timeSeriesData.isEmpty()) { return new DataStatistics(); } DoubleSummaryStatistics stats = timeSeriesData.values().stream() .mapToDouble(Double::doubleValue) .summaryStatistics(); return new DataStatistics( timeSeriesData.firstKey(), timeSeriesData.lastKey(), stats.getCount(), stats.getMin(), stats.getMax(), stats.getAverage() ); } public static class DataStatistics { private final LocalDateTime earliestTime; private final LocalDateTime latestTime; private final long count; private final double min; private final double max; private final double average; public DataStatistics() { this(null, null, 0, 0, 0, 0); } public DataStatistics(LocalDateTime earliestTime, LocalDateTime latestTime, long count, double min, double max, double average) { this.earliestTime = earliestTime; this.latestTime = latestTime; this.count = count; this.min = min; this.max = max; this.average = average; } // Getters public LocalDateTime getEarliestTime() { return earliestTime; } public LocalDateTime getLatestTime() { return latestTime; } public long getCount() { return count; } public double getMin() { return min; } public double getMax() { return max; } public double getAverage() { return average; } } } 2. 範圍查詢系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 public class RangeQuerySystem\u0026lt;T extends Comparable\u0026lt;T\u0026gt;, V\u0026gt; { private final TreeMap\u0026lt;T, V\u0026gt; dataMap; private final ReentrantReadWriteLock lock; private final ReadLock readLock; private final WriteLock writeLock; public RangeQuerySystem() { this.dataMap = new TreeMap\u0026lt;\u0026gt;(); this.lock = new ReentrantReadWriteLock(); this.readLock = lock.readLock(); this.writeLock = lock.writeLock(); } // 線程安全的插入操作 public void put(T key, V value) { writeLock.lock(); try { dataMap.put(key, value); } finally { writeLock.unlock(); } } // 線程安全的獲取操作 public V get(T key) { readLock.lock(); try { return dataMap.get(key); } finally { readLock.unlock(); } } // 範圍查詢 public List\u0026lt;Map.Entry\u0026lt;T, V\u0026gt;\u0026gt; rangeQuery(T start, T end) { readLock.lock(); try { return new ArrayList\u0026lt;\u0026gt;(dataMap.subMap(start, true, end, true).entrySet()); } finally { readLock.unlock(); } } // 前綴查詢 public List\u0026lt;Map.Entry\u0026lt;T, V\u0026gt;\u0026gt; prefixQuery(T prefix) { readLock.lock(); try { NavigableMap\u0026lt;T, V\u0026gt; tailMap = dataMap.tailMap(prefix, true); List\u0026lt;Map.Entry\u0026lt;T, V\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;T, V\u0026gt; entry : tailMap.entrySet()) { if (entry.getKey().toString().startsWith(prefix.toString())) { result.add(entry); } else { break; } } return result; } finally { readLock.unlock(); } } // 獲取最接近的值 public Map.Entry\u0026lt;T, V\u0026gt; getClosest(T target) { readLock.lock(); try { Map.Entry\u0026lt;T, V\u0026gt; floor = dataMap.floorEntry(target); Map.Entry\u0026lt;T, V\u0026gt; ceiling = dataMap.ceilingEntry(target); if (floor == null) return ceiling; if (ceiling == null) return floor; // 比較距離 if (target.compareTo(floor.getKey()) \u0026lt;= ceiling.getKey().compareTo(target)) { return floor; } else { return ceiling; } } finally { readLock.unlock(); } } // 批量插入 public void putAll(Map\u0026lt;T, V\u0026gt; map) { writeLock.lock(); try { dataMap.putAll(map); } finally { writeLock.unlock(); } } // 條件刪除 public int removeIf(Predicate\u0026lt;Map.Entry\u0026lt;T, V\u0026gt;\u0026gt; condition) { writeLock.lock(); try { List\u0026lt;T\u0026gt; keysToRemove = dataMap.entrySet().stream() .filter(condition) .map(Map.Entry::getKey) .collect(Collectors.toList()); keysToRemove.forEach(dataMap::remove); return keysToRemove.size(); } finally { writeLock.unlock(); } } // 獲取統計信息 public RangeStatistics getStatistics() { readLock.lock(); try { return new RangeStatistics( dataMap.size(), dataMap.isEmpty() ? null : dataMap.firstKey(), dataMap.isEmpty() ? null : dataMap.lastKey() ); } finally { readLock.unlock(); } } public static class RangeStatistics { private final int size; private final Object minKey; private final Object maxKey; public RangeStatistics(int size, Object minKey, Object maxKey) { this.size = size; this.minKey = minKey; this.maxKey = maxKey; } // Getters public int getSize() { return size; } public Object getMinKey() { return minKey; } public Object getMaxKey() { return maxKey; } } } 3. 優先級任務調度器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 public class PriorityTaskScheduler { private final TreeMap\u0026lt;Priority, Queue\u0026lt;Task\u0026gt;\u0026gt; taskQueues; private final ExecutorService executor; private final ScheduledExecutorService scheduler; private final AtomicBoolean running; public PriorityTaskScheduler(int threadPoolSize) { this.taskQueues = new TreeMap\u0026lt;\u0026gt;(); this.executor = Executors.newFixedThreadPool(threadPoolSize); this.scheduler = Executors.newScheduledThreadPool(2); this.running = new AtomicBoolean(true); // 初始化優先級隊列 for (Priority priority : Priority.values()) { taskQueues.put(priority, new ConcurrentLinkedQueue\u0026lt;\u0026gt;()); } // 啟動任務調度 startTaskScheduling(); } // 提交任務 public void submitTask(Task task) { if (!running.get()) { throw new IllegalStateException(\u0026#34;Scheduler is shutdown\u0026#34;); } taskQueues.get(task.getPriority()).offer(task); } // 提交延遲任務 public void submitDelayedTask(Task task, long delay, TimeUnit unit) { scheduler.schedule(() -\u0026gt; submitTask(task), delay, unit); } // 提交週期性任務 public void submitPeriodicTask(Task task, long initialDelay, long period, TimeUnit unit) { scheduler.scheduleAtFixedRate(() -\u0026gt; { if (running.get()) { submitTask(task); } }, initialDelay, period, unit); } // 啟動任務調度 private void startTaskScheduling() { scheduler.scheduleAtFixedRate(this::processNextTask, 0, 10, TimeUnit.MILLISECONDS); } // 處理下一個任務 private void processNextTask() { if (!running.get()) { return; } // 從最高優先級開始查找任務 NavigableMap\u0026lt;Priority, Queue\u0026lt;Task\u0026gt;\u0026gt; descendingMap = taskQueues.descendingMap(); for (Map.Entry\u0026lt;Priority, Queue\u0026lt;Task\u0026gt;\u0026gt; entry : descendingMap.entrySet()) { Queue\u0026lt;Task\u0026gt; queue = entry.getValue(); Task task = queue.poll(); if (task != null) { executor.submit(new TaskRunner(task)); return; } } } // 獲取隊列統計信息 public QueueStatistics getQueueStatistics() { Map\u0026lt;Priority, Integer\u0026gt; queueSizes = new EnumMap\u0026lt;\u0026gt;(Priority.class); int totalTasks = 0; for (Map.Entry\u0026lt;Priority, Queue\u0026lt;Task\u0026gt;\u0026gt; entry : taskQueues.entrySet()) { int size = entry.getValue().size(); queueSizes.put(entry.getKey(), size); totalTasks += size; } return new QueueStatistics(queueSizes, totalTasks); } // 清空指定優先級的任務 public int clearTasks(Priority priority) { Queue\u0026lt;Task\u0026gt; queue = taskQueues.get(priority); int size = queue.size(); queue.clear(); return size; } // 關閉調度器 public void shutdown() { running.set(false); executor.shutdown(); scheduler.shutdown(); try { if (!executor.awaitTermination(30, TimeUnit.SECONDS)) { executor.shutdownNow(); } if (!scheduler.awaitTermination(30, TimeUnit.SECONDS)) { scheduler.shutdownNow(); } } catch (InterruptedException e) { executor.shutdownNow(); scheduler.shutdownNow(); Thread.currentThread().interrupt(); } } // 優先級枚舉 public enum Priority { LOW(1), NORMAL(2), HIGH(3), CRITICAL(4); private final int value; Priority(int value) { this.value = value; } public int getValue() { return value; } } // 任務介面 public interface Task { void execute(); Priority getPriority(); String getName(); } // 任務運行器 private static class TaskRunner implements Runnable { private final Task task; public TaskRunner(Task task) { this.task = task; } @Override public void run() { try { task.execute(); } catch (Exception e) { System.err.println(\u0026#34;Task execution failed: \u0026#34; + task.getName()); e.printStackTrace(); } } } // 隊列統計信息 public static class QueueStatistics { private final Map\u0026lt;Priority, Integer\u0026gt; queueSizes; private final int totalTasks; public QueueStatistics(Map\u0026lt;Priority, Integer\u0026gt; queueSizes, int totalTasks) { this.queueSizes = queueSizes; this.totalTasks = totalTasks; } public Map\u0026lt;Priority, Integer\u0026gt; getQueueSizes() { return queueSizes; } public int getTotalTasks() { return totalTasks; } } } 效能分析與優化 1. 時間複雜度分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 public class TreeMapPerformanceAnalysis { public static void main(String[] args) { performanceComparison(); memoryAnalysis(); concurrencyTest(); } // 效能比較 private static void performanceComparison() { int[] sizes = {1000, 10000, 100000, 1000000}; for (int size : sizes) { System.out.println(\u0026#34;Size: \u0026#34; + size); // TreeMap 測試 long startTime = System.nanoTime(); TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; size; i++) { treeMap.put(i, \u0026#34;value\u0026#34; + i); } long treeMapInsertTime = System.nanoTime() - startTime; // 搜索測試 startTime = System.nanoTime(); for (int i = 0; i \u0026lt; 1000; i++) { treeMap.get(i * size / 1000); } long treeMapSearchTime = System.nanoTime() - startTime; // HashMap 比較 startTime = System.nanoTime(); HashMap\u0026lt;Integer, String\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; size; i++) { hashMap.put(i, \u0026#34;value\u0026#34; + i); } long hashMapInsertTime = System.nanoTime() - startTime; startTime = System.nanoTime(); for (int i = 0; i \u0026lt; 1000; i++) { hashMap.get(i * size / 1000); } long hashMapSearchTime = System.nanoTime() - startTime; System.out.printf(\u0026#34;TreeMap - Insert: %d ns, Search: %d ns\\n\u0026#34;, treeMapInsertTime, treeMapSearchTime); System.out.printf(\u0026#34;HashMap - Insert: %d ns, Search: %d ns\\n\\n\u0026#34;, hashMapInsertTime, hashMapSearchTime); } } // 記憶體分析 private static void memoryAnalysis() { Runtime runtime = Runtime.getRuntime(); runtime.gc(); long beforeMemory = runtime.totalMemory() - runtime.freeMemory(); TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100000; i++) { treeMap.put(i, \u0026#34;value\u0026#34; + i); } long afterMemory = runtime.totalMemory() - runtime.freeMemory(); System.out.println(\u0026#34;TreeMap memory usage: \u0026#34; + (afterMemory - beforeMemory) + \u0026#34; bytes\u0026#34;); // 對比 HashMap runtime.gc(); beforeMemory = runtime.totalMemory() - runtime.freeMemory(); HashMap\u0026lt;Integer, String\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100000; i++) { hashMap.put(i, \u0026#34;value\u0026#34; + i); } afterMemory = runtime.totalMemory() - runtime.freeMemory(); System.out.println(\u0026#34;HashMap memory usage: \u0026#34; + (afterMemory - beforeMemory) + \u0026#34; bytes\u0026#34;); } // 並發測試 private static void concurrencyTest() { TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); ConcurrentSkipListMap\u0026lt;Integer, String\u0026gt; concurrentMap = new ConcurrentSkipListMap\u0026lt;\u0026gt;(); // 填充初始數據 for (int i = 0; i \u0026lt; 10000; i++) { treeMap.put(i, \u0026#34;value\u0026#34; + i); concurrentMap.put(i, \u0026#34;value\u0026#34; + i); } // 並發讀取測試 int threadCount = 4; ExecutorService executor = Executors.newFixedThreadPool(threadCount); System.out.println(\u0026#34;Concurrent read test:\u0026#34;); // TreeMap 同步讀取 long startTime = System.nanoTime(); CountDownLatch latch = new CountDownLatch(threadCount); for (int i = 0; i \u0026lt; threadCount; i++) { executor.submit(() -\u0026gt; { try { for (int j = 0; j \u0026lt; 10000; j++) { synchronized (treeMap) { treeMap.get(j); } } } finally { latch.countDown(); } }); } try { latch.await(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } long treeMapTime = System.nanoTime() - startTime; System.out.println(\u0026#34;TreeMap (synchronized): \u0026#34; + treeMapTime + \u0026#34; ns\u0026#34;); // ConcurrentSkipListMap 測試 startTime = System.nanoTime(); latch = new CountDownLatch(threadCount); for (int i = 0; i \u0026lt; threadCount; i++) { executor.submit(() -\u0026gt; { try { for (int j = 0; j \u0026lt; 10000; j++) { concurrentMap.get(j); } } finally { latch.countDown(); } }); } try { latch.await(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } long concurrentMapTime = System.nanoTime() - startTime; System.out.println(\u0026#34;ConcurrentSkipListMap: \u0026#34; + concurrentMapTime + \u0026#34; ns\u0026#34;); executor.shutdown(); } } 2. 最佳化建議 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 public class TreeMapOptimizationTips { // 1. 使用適當的比較器 public static void comparatorOptimization() { // 避免在比較器中進行複雜計算 TreeMap\u0026lt;String, Integer\u0026gt; badExample = new TreeMap\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { // 壞例子：每次比較都進行昂貴的計算 return expensiveCalculation(s1) - expensiveCalculation(s2); }); // 好例子：預先計算或使用緩存 Map\u0026lt;String, Integer\u0026gt; cache = new ConcurrentHashMap\u0026lt;\u0026gt;(); TreeMap\u0026lt;String, Integer\u0026gt; goodExample = new TreeMap\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { int val1 = cache.computeIfAbsent(s1, TreeMapOptimizationTips::expensiveCalculation); int val2 = cache.computeIfAbsent(s2, TreeMapOptimizationTips::expensiveCalculation); return val1 - val2; }); } // 2. 批量操作優化 public static void batchOperationOptimization() { TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); // 批量插入比單個插入效率更高 Map\u0026lt;Integer, String\u0026gt; batchData = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 1000; i++) { batchData.put(i, \u0026#34;value\u0026#34; + i); } treeMap.putAll(batchData); // 使用子映射進行批量操作 NavigableMap\u0026lt;Integer, String\u0026gt; subMap = treeMap.subMap(100, true, 200, false); subMap.clear(); // 比逐個刪除效率更高 } // 3. 記憶體優化 public static void memoryOptimization() { // 使用原始類型包裝器時注意自動裝箱 TreeMap\u0026lt;Integer, Integer\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); // 避免不必要的對象創建 for (int i = 0; i \u0026lt; 1000; i++) { map.put(i, i * 2); // 會創建 Integer 對象 } // 考慮使用專門的原始類型集合庫（如 Eclipse Collections） // 或者使用 TIntIntMap 等原始類型映射 } // 4. 並發優化 public static void concurrencyOptimization() { TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); // 使用 ConcurrentSkipListMap 替代同步的 TreeMap ConcurrentSkipListMap\u0026lt;Integer, String\u0026gt; concurrentMap = new ConcurrentSkipListMap\u0026lt;\u0026gt;(); // 或者使用讀寫鎖 ReadWriteLock lock = new ReentrantReadWriteLock(); ReadLock readLock = lock.readLock(); WriteLock writeLock = lock.writeLock(); // 讀操作 readLock.lock(); try { treeMap.get(1); } finally { readLock.unlock(); } // 寫操作 writeLock.lock(); try { treeMap.put(1, \u0026#34;value\u0026#34;); } finally { writeLock.unlock(); } } private static int expensiveCalculation(String s) { // 模擬昂貴的計算 return s.hashCode() * 31; } } 實際應用場景 1. LeetCode 問題解決 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 public class TreeMapLeetCodeSolutions { // LeetCode 2055: 蠟燭之間的盤子 public int[] platesBetweenCandles(String s, int[][] queries) { TreeMap\u0026lt;Integer, Integer\u0026gt; candlePositions = new TreeMap\u0026lt;\u0026gt;(); // 記錄蠟燭位置 for (int i = 0; i \u0026lt; s.length(); i++) { if (s.charAt(i) == \u0026#39;|\u0026#39;) { candlePositions.put(i, i); } } int[] result = new int[queries.length]; for (int i = 0; i \u0026lt; queries.length; i++) { int left = queries[i][0]; int right = queries[i][1]; // 找到範圍內的第一個和最後一個蠟燭 Integer firstCandle = candlePositions.ceilingKey(left); Integer lastCandle = candlePositions.floorKey(right); if (firstCandle != null \u0026amp;\u0026amp; lastCandle != null \u0026amp;\u0026amp; firstCandle \u0026lt;= lastCandle) { // 計算蠟燭之間的盤子數量 int totalLength = lastCandle - firstCandle + 1; int candleCount = candlePositions.subMap(firstCandle, true, lastCandle, true).size(); result[i] = totalLength - candleCount; } else { result[i] = 0; } } return result; } // LeetCode 220: 存在重複元素 III public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) { TreeMap\u0026lt;Integer, Integer\u0026gt; window = new TreeMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int num = nums[i]; // 查找是否存在差值小於等於 t 的數字 Integer floor = window.floorKey(num); Integer ceiling = window.ceilingKey(num); if ((floor != null \u0026amp;\u0026amp; (long) num - floor \u0026lt;= t) || (ceiling != null \u0026amp;\u0026amp; (long) ceiling - num \u0026lt;= t)) { return true; } // 添加當前數字到窗口 window.put(num, window.getOrDefault(num, 0) + 1); // 維護窗口大小 if (i \u0026gt;= k) { int oldNum = nums[i - k]; window.put(oldNum, window.get(oldNum) - 1); if (window.get(oldNum) == 0) { window.remove(oldNum); } } } return false; } // LeetCode 732: 我的日程安排表 III static class MyCalendarThree { private TreeMap\u0026lt;Integer, Integer\u0026gt; timeline; public MyCalendarThree() { timeline = new TreeMap\u0026lt;\u0026gt;(); } public int book(int start, int end) { timeline.put(start, timeline.getOrDefault(start, 0) + 1); timeline.put(end, timeline.getOrDefault(end, 0) - 1); int activeEvents = 0; int maxEvents = 0; for (int count : timeline.values()) { activeEvents += count; maxEvents = Math.max(maxEvents, activeEvents); } return maxEvents; } } } 2. 分佈式系統中的應用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 public class DistributedSystemApplications { // 一致性哈希環 public static class ConsistentHashRing { private final TreeMap\u0026lt;Long, String\u0026gt; ring; private final int virtualNodes; public ConsistentHashRing(int virtualNodes) { this.ring = new TreeMap\u0026lt;\u0026gt;(); this.virtualNodes = virtualNodes; } public void addNode(String node) { for (int i = 0; i \u0026lt; virtualNodes; i++) { long hash = hash(node + \u0026#34;:\u0026#34; + i); ring.put(hash, node); } } public void removeNode(String node) { for (int i = 0; i \u0026lt; virtualNodes; i++) { long hash = hash(node + \u0026#34;:\u0026#34; + i); ring.remove(hash); } } public String getNode(String key) { if (ring.isEmpty()) { return null; } long hash = hash(key); Map.Entry\u0026lt;Long, String\u0026gt; entry = ring.ceilingEntry(hash); if (entry == null) { entry = ring.firstEntry(); } return entry.getValue(); } private long hash(String key) { return key.hashCode() \u0026amp; 0xFFFFFFFFL; } } // 負載平衡器 public static class LoadBalancer { private final TreeMap\u0026lt;Integer, List\u0026lt;String\u0026gt;\u0026gt; weightedServers; private final AtomicInteger currentWeight; public LoadBalancer() { this.weightedServers = new TreeMap\u0026lt;\u0026gt;(); this.currentWeight = new AtomicInteger(0); } public void addServer(String server, int weight) { weightedServers.computeIfAbsent(weight, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(server); } public String selectServer() { if (weightedServers.isEmpty()) { return null; } // 加權輪詢算法 int totalWeight = weightedServers.lastKey(); int current = currentWeight.updateAndGet(w -\u0026gt; (w + 1) % totalWeight); for (Map.Entry\u0026lt;Integer, List\u0026lt;String\u0026gt;\u0026gt; entry : weightedServers.descendingMap().entrySet()) { if (current \u0026lt; entry.getKey()) { List\u0026lt;String\u0026gt; servers = entry.getValue(); return servers.get(current % servers.size()); } } return null; } } } 最佳實踐與建議 1. 選擇適當的比較策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 public class TreeMapBestPractices { // 1. 自然排序 vs 自定義比較器 public static void comparatorChoice() { // 對於實現 Comparable 的類型，使用自然排序 TreeMap\u0026lt;String, Integer\u0026gt; naturalOrder = new TreeMap\u0026lt;\u0026gt;(); // 對於需要自定義排序的情況，使用比較器 TreeMap\u0026lt;String, Integer\u0026gt; customOrder = new TreeMap\u0026lt;\u0026gt;(String.CASE_INSENSITIVE_ORDER); // 複雜對象的多字段排序 TreeMap\u0026lt;Person, String\u0026gt; personMap = new TreeMap\u0026lt;\u0026gt;( Comparator.comparing(Person::getAge) .thenComparing(Person::getName) ); } // 2. 空值處理 public static void nullHandling() { // TreeMap 不允許 null 鍵 TreeMap\u0026lt;String, Integer\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); // map.put(null, 1); // 會拋出 NullPointerException // 但允許 null 值 map.put(\u0026#34;key\u0026#34;, null); // 如果需要支持 null 鍵，使用自定義比較器 TreeMap\u0026lt;String, Integer\u0026gt; nullSafeMap = new TreeMap\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { if (s1 == null \u0026amp;\u0026amp; s2 == null) return 0; if (s1 == null) return -1; if (s2 == null) return 1; return s1.compareTo(s2); }); } // 3. 線程安全處理 public static void threadSafety() { TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); // 方法1：使用 Collections.synchronizedMap Map\u0026lt;Integer, String\u0026gt; syncMap = Collections.synchronizedMap(treeMap); // 方法2：使用 ConcurrentSkipListMap ConcurrentSkipListMap\u0026lt;Integer, String\u0026gt; concurrentMap = new ConcurrentSkipListMap\u0026lt;\u0026gt;(); // 方法3：使用讀寫鎖 ReadWriteLock lock = new ReentrantReadWriteLock(); // 在讀寫操作時使用相應的鎖 } // 4. 效能考慮 public static void performanceConsiderations() { // 預先指定初始容量（TreeMap 沒有初始容量概念，但可以批量插入） Map\u0026lt;Integer, String\u0026gt; initialData = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 1000; i++) { initialData.put(i, \u0026#34;value\u0026#34; + i); } TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(initialData); // 避免頻繁的範圍查詢操作 NavigableMap\u0026lt;Integer, String\u0026gt; subMap = treeMap.subMap(100, true, 200, false); // 對 subMap 的操作會影響原始 map } static class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } } } 2. 常見錯誤避免 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 public class TreeMapCommonMistakes { // 錯誤1：在迭代過程中修改 TreeMap public static void avoidConcurrentModification() { TreeMap\u0026lt;Integer, String\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 10; i++) { map.put(i, \u0026#34;value\u0026#34; + i); } // 錯誤的做法 // for (Integer key : map.keySet()) { // if (key % 2 == 0) { // map.remove(key); // ConcurrentModificationException // } // } // 正確的做法1：使用迭代器 Iterator\u0026lt;Integer\u0026gt; iterator = map.keySet().iterator(); while (iterator.hasNext()) { if (iterator.next() % 2 == 0) { iterator.remove(); } } // 正確的做法2：收集要刪除的鍵 List\u0026lt;Integer\u0026gt; keysToRemove = map.keySet().stream() .filter(key -\u0026gt; key % 2 == 0) .collect(Collectors.toList()); keysToRemove.forEach(map::remove); } // 錯誤2：比較器不一致 public static void avoidInconsistentComparator() { // 錯誤：比較器與 equals 不一致 TreeMap\u0026lt;String, Integer\u0026gt; badMap = new TreeMap\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { return s1.length() - s2.length(); // 只比較長度 }); badMap.put(\u0026#34;abc\u0026#34;, 1); badMap.put(\u0026#34;def\u0026#34;, 2); // 會覆蓋 \u0026#34;abc\u0026#34;，因為長度相同 // 正確：確保比較器一致性 TreeMap\u0026lt;String, Integer\u0026gt; goodMap = new TreeMap\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { int lengthCompare = s1.length() - s2.length(); if (lengthCompare != 0) { return lengthCompare; } return s1.compareTo(s2); // 長度相同時比較內容 }); } // 錯誤3：誤用子映射 public static void avoidSubMapMisuse() { TreeMap\u0026lt;Integer, String\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 10; i++) { map.put(i, \u0026#34;value\u0026#34; + i); } // 錯誤：認為子映射是獨立的 NavigableMap\u0026lt;Integer, String\u0026gt; subMap = map.subMap(2, true, 8, false); subMap.clear(); // 這會影響原始 map // 正確：如果需要獨立的副本 NavigableMap\u0026lt;Integer, String\u0026gt; independentCopy = new TreeMap\u0026lt;\u0026gt;(subMap); } } 總結 TreeMap 是 Java 集合框架中功能強大的有序映射實現，基於紅黑樹提供了 O(log n) 的高效操作。通過本文的深入分析，我們了解了：\n核心特性：基於紅黑樹的有序存儲，支持自然排序和自定義比較器 介面層次：從 Map 到 SortedMap 再到 NavigableMap 的完整功能 實用方法：豐富的範圍查詢、導航操作和視圖方法 企業應用：時間序列數據、範圍查詢、任務調度等實際場景 效能優化：比較器優化、批量操作、並發處理等最佳實踐 常見陷阱：並發修改、比較器一致性、子映射使用等需要注意的問題 正確使用 TreeMap 可以在需要有序映射的場景中提供高效、可靠的解決方案，是 Java 開發者必須掌握的重要工具之一。\n","permalink":"https://xinqilin.github.io/post/backend/treemap/","tags":["Java","TreeMap","NavigableMap","Red-Black Tree","Data Structure","Sorting","SortedMap","Binary Search Tree","Performance","Algorithms","Collections","Enterprise","Best Practices","Thread Safety","Concurrency"],"title":"Java TreeMap 完整實作指南：紅黑樹有序映射與 NavigableMap 介面詳解"},{"content":"概述 QueryDSL 是一個強大的 Java 查詢框架，提供類型安全的 SQL 查詢建構功能。它通過代碼生成技術創建查詢類型，在編譯時期就能發現查詢錯誤，大幅提升開發效率和代碼質量。本文將深入介紹 QueryDSL 的各種用法和最佳實踐。\n核心優勢 類型安全：編譯時檢查，避免執行期錯誤 IDE 支援：完整的自動完成和重構功能 統一 API：支援 JPA、SQL、MongoDB 等多種數據源 動態查詢：靈活的條件組合和查詢建構 效能優化：生成高效的 SQL 查詢 支援的技術棧 JPA/Hibernate：最常用的 ORM 整合 Spring Data JPA：與 Spring 生態完美整合 SQL 數據庫：MySQL、PostgreSQL、Oracle 等 NoSQL 數據庫：MongoDB、Lucene 等 環境配置與設定 1. Maven 依賴配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 \u0026lt;properties\u0026gt; \u0026lt;querydsl.version\u0026gt;5.0.0\u0026lt;/querydsl.version\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- Spring Boot Starter Data JPA --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- QueryDSL JPA --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.querydsl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;querydsl-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${querydsl.version}\u0026lt;/version\u0026gt; \u0026lt;classifier\u0026gt;jakarta\u0026lt;/classifier\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- QueryDSL APT (Annotation Processing Tool) --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.querydsl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;querydsl-apt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${querydsl.version}\u0026lt;/version\u0026gt; \u0026lt;classifier\u0026gt;jakarta\u0026lt;/classifier\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Database Driver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Validation --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- Maven Compiler Plugin --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.11.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;17\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;17\u0026lt;/target\u0026gt; \u0026lt;annotationProcessorPaths\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;com.querydsl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;querydsl-apt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${querydsl.version}\u0026lt;/version\u0026gt; \u0026lt;classifier\u0026gt;jakarta\u0026lt;/classifier\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;jakarta.persistence\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jakarta.persistence-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;jakarta.annotation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jakarta.annotation-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.1\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;/annotationProcessorPaths\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- Generate Sources Plugin --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.codehaus.mojo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;build-helper-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.0\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;generate-sources\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;add-source\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;sources\u0026gt; \u0026lt;source\u0026gt;target/generated-sources/annotations\u0026lt;/source\u0026gt; \u0026lt;/sources\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 2. Gradle 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 plugins { id \u0026#39;org.springframework.boot\u0026#39; version \u0026#39;3.1.0\u0026#39; id \u0026#39;io.spring.dependency-management\u0026#39; version \u0026#39;1.1.0\u0026#39; id \u0026#39;java\u0026#39; } dependencies { implementation \u0026#39;org.springframework.boot:spring-boot-starter-data-jpa\u0026#39; implementation \u0026#39;org.springframework.boot:spring-boot-starter-web\u0026#39; implementation \u0026#39;org.springframework.boot:spring-boot-starter-validation\u0026#39; // QueryDSL implementation \u0026#39;com.querydsl:querydsl-jpa:5.0.0:jakarta\u0026#39; annotationProcessor \u0026#39;com.querydsl:querydsl-apt:5.0.0:jakarta\u0026#39; annotationProcessor \u0026#39;jakarta.persistence:jakarta.persistence-api\u0026#39; annotationProcessor \u0026#39;jakarta.annotation:jakarta.annotation-api\u0026#39; runtimeOnly \u0026#39;mysql:mysql-connector-java\u0026#39; testImplementation \u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39; } // QueryDSL 配置 def queryDslDir = \u0026#34;$buildDir/generated/querydsl\u0026#34; querydsl { jpa = true querydslSourcesDir = queryDslDir } sourceSets { main.java.srcDir queryDslDir } configurations { querydsl.extendsFrom compileClasspath } compileQuerydsl { options.annotationProcessorPath = configurations.querydsl } 3. Spring Boot 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.example.querydsl.config; import com.querydsl.jpa.impl.JPAQueryFactory; import jakarta.persistence.EntityManager; import jakarta.persistence.PersistenceContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class QueryDSLConfig { @PersistenceContext private EntityManager entityManager; @Bean public JPAQueryFactory jpaQueryFactory() { return new JPAQueryFactory(entityManager); } } 實體類定義與 Q 類生成 1. 實體類定義 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 package com.example.querydsl.entity; import jakarta.persistence.*; import jakarta.validation.constraints.NotBlank; import jakarta.validation.constraints.Email; import org.hibernate.annotations.CreationTimestamp; import org.hibernate.annotations.UpdateTimestamp; import java.time.LocalDateTime; import java.util.Set; @Entity @Table(name = \u0026#34;users\u0026#34;, indexes = { @Index(name = \u0026#34;idx_username\u0026#34;, columnList = \u0026#34;username\u0026#34;), @Index(name = \u0026#34;idx_email\u0026#34;, columnList = \u0026#34;email\u0026#34;), @Index(name = \u0026#34;idx_department_id\u0026#34;, columnList = \u0026#34;department_id\u0026#34;), @Index(name = \u0026#34;idx_status\u0026#34;, columnList = \u0026#34;status\u0026#34;) }) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotBlank @Column(unique = true, nullable = false, length = 50) private String username; @NotBlank @Email @Column(unique = true, nullable = false, length = 100) private String email; @Column(name = \u0026#34;first_name\u0026#34;, length = 50) private String firstName; @Column(name = \u0026#34;last_name\u0026#34;, length = 50) private String lastName; @Column(nullable = false) private Integer age; @Column(length = 20) private String phone; @Enumerated(EnumType.STRING) @Column(nullable = false) private UserStatus status = UserStatus.ACTIVE; @Column(precision = 10, scale = 2) private Double salary; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;department_id\u0026#34;) private Department department; @OneToMany(mappedBy = \u0026#34;user\u0026#34;, cascade = CascadeType.ALL, fetch = FetchType.LAZY) private Set\u0026lt;UserRole\u0026gt; userRoles; @OneToMany(mappedBy = \u0026#34;assignee\u0026#34;, fetch = FetchType.LAZY) private Set\u0026lt;Project\u0026gt; assignedProjects; @CreationTimestamp @Column(name = \u0026#34;created_at\u0026#34;, nullable = false, updatable = false) private LocalDateTime createdAt; @UpdateTimestamp @Column(name = \u0026#34;updated_at\u0026#34;, nullable = false) private LocalDateTime updatedAt; // 建構子、getter、setter 和 toString 方法 public User() {} public User(String username, String email, String firstName, String lastName, Integer age) { this.username = username; this.email = email; this.firstName = firstName; this.lastName = lastName; this.age = age; } // 完整的 getter 和 setter 方法 public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } public UserStatus getStatus() { return status; } public void setStatus(UserStatus status) { this.status = status; } public Double getSalary() { return salary; } public void setSalary(Double salary) { this.salary = salary; } public Department getDepartment() { return department; } public void setDepartment(Department department) { this.department = department; } public Set\u0026lt;UserRole\u0026gt; getUserRoles() { return userRoles; } public void setUserRoles(Set\u0026lt;UserRole\u0026gt; userRoles) { this.userRoles = userRoles; } public Set\u0026lt;Project\u0026gt; getAssignedProjects() { return assignedProjects; } public void setAssignedProjects(Set\u0026lt;Project\u0026gt; assignedProjects) { this.assignedProjects = assignedProjects; } public LocalDateTime getCreatedAt() { return createdAt; } public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; } public LocalDateTime getUpdatedAt() { return updatedAt; } public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; } } // 枚舉類型 enum UserStatus { ACTIVE, INACTIVE, SUSPENDED, DELETED } 2. 相關實體類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 // Department 實體 @Entity @Table(name = \u0026#34;departments\u0026#34;) public class Department { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotBlank @Column(unique = true, nullable = false, length = 100) private String name; @Column(length = 500) private String description; @Column(name = \u0026#34;budget\u0026#34;, precision = 15, scale = 2) private Double budget; @OneToMany(mappedBy = \u0026#34;department\u0026#34;, fetch = FetchType.LAZY) private Set\u0026lt;User\u0026gt; employees; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;manager_id\u0026#34;) private User manager; @CreationTimestamp @Column(name = \u0026#34;created_at\u0026#34;, nullable = false, updatable = false) private LocalDateTime createdAt; // 建構子、getter、setter 方法 public Department() {} public Department(String name, String description, Double budget) { this.name = name; this.description = description; this.budget = budget; } // getter 和 setter 方法省略... } // Project 實體 @Entity @Table(name = \u0026#34;projects\u0026#34;) public class Project { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotBlank @Column(nullable = false, length = 200) private String title; @Column(length = 1000) private String description; @Column(name = \u0026#34;start_date\u0026#34;) private LocalDateTime startDate; @Column(name = \u0026#34;end_date\u0026#34;) private LocalDateTime endDate; @Enumerated(EnumType.STRING) @Column(nullable = false) private ProjectStatus status = ProjectStatus.PLANNING; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;assignee_id\u0026#34;) private User assignee; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;department_id\u0026#34;) private Department department; // getter 和 setter 方法省略... } enum ProjectStatus { PLANNING, IN_PROGRESS, COMPLETED, CANCELLED, ON_HOLD } // UserRole 實體（多對多關聯表） @Entity @Table(name = \u0026#34;user_roles\u0026#34;) public class UserRole { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;user_id\u0026#34;, nullable = false) private User user; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;role_id\u0026#34;, nullable = false) private Role role; @CreationTimestamp @Column(name = \u0026#34;assigned_at\u0026#34;, nullable = false, updatable = false) private LocalDateTime assignedAt; // getter 和 setter 方法省略... } @Entity @Table(name = \u0026#34;roles\u0026#34;) public class Role { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotBlank @Column(unique = true, nullable = false, length = 50) private String name; @Column(length = 200) private String description; @OneToMany(mappedBy = \u0026#34;role\u0026#34;, fetch = FetchType.LAZY) private Set\u0026lt;UserRole\u0026gt; userRoles; // getter 和 setter 方法省略... } 3. Q 類生成 執行以下命令生成 Q 類：\n1 2 3 4 5 # Maven 項目 mvn clean compile # Gradle 項目 ./gradlew compileQuerydsl 生成的 Q 類將位於 target/generated-sources/annotations (Maven) 或 build/generated/querydsl (Gradle) 目錄中。\n基礎查詢操作 1. Repository 介面定義 1 2 3 4 5 6 7 8 9 10 11 12 package com.example.querydsl.repository; import com.example.querydsl.entity.User; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.querydsl.QuerydslPredicateExecutor; import org.springframework.stereotype.Repository; @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt;, QuerydslPredicateExecutor\u0026lt;User\u0026gt; { // 基本的 CRUD 操作由 JpaRepository 提供 // QuerydslPredicateExecutor 提供 QueryDSL 查詢支援 } 2. Service 層實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 package com.example.querydsl.service; import com.example.querydsl.entity.*; import com.example.querydsl.repository.UserRepository; import com.querydsl.core.BooleanBuilder; import com.querydsl.core.types.OrderSpecifier; import com.querydsl.core.types.Predicate; import com.querydsl.core.types.Projections; import com.querydsl.core.types.dsl.BooleanExpression; import com.querydsl.jpa.impl.JPAQueryFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import java.time.LocalDateTime; import java.util.List; import java.util.Optional; @Service @Transactional(readOnly = true) public class UserService { @Autowired private JPAQueryFactory queryFactory; @Autowired private UserRepository userRepository; // Q 類實例 private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; private final QProject qProject = QProject.project; private final QUserRole qUserRole = QUserRole.userRole; private final QRole qRole = QRole.role; /** * 基礎查詢：根據用戶名查找用戶 */ public Optional\u0026lt;User\u0026gt; findByUsername(String username) { User user = queryFactory.selectFrom(qUser) .where(qUser.username.eq(username)) .fetchOne(); return Optional.ofNullable(user); } /** * 條件查詢：根據多個條件查找用戶 */ public List\u0026lt;User\u0026gt; findUsersByConditions(String username, String email, Integer minAge, Integer maxAge, UserStatus status) { BooleanBuilder builder = new BooleanBuilder(); if (username != null \u0026amp;\u0026amp; !username.trim().isEmpty()) { builder.and(qUser.username.containsIgnoreCase(username)); } if (email != null \u0026amp;\u0026amp; !email.trim().isEmpty()) { builder.and(qUser.email.containsIgnoreCase(email)); } if (minAge != null) { builder.and(qUser.age.goe(minAge)); } if (maxAge != null) { builder.and(qUser.age.loe(maxAge)); } if (status != null) { builder.and(qUser.status.eq(status)); } return queryFactory.selectFrom(qUser) .where(builder) .orderBy(qUser.createdAt.desc()) .fetch(); } /** * 分頁查詢：使用 Spring Data 的分頁支援 */ public Page\u0026lt;User\u0026gt; findUsersWithPagination(String keyword, UserStatus status, Pageable pageable) { BooleanBuilder builder = new BooleanBuilder(); if (keyword != null \u0026amp;\u0026amp; !keyword.trim().isEmpty()) { BooleanExpression keywordCondition = qUser.username.containsIgnoreCase(keyword) .or(qUser.firstName.containsIgnoreCase(keyword)) .or(qUser.lastName.containsIgnoreCase(keyword)) .or(qUser.email.containsIgnoreCase(keyword)); builder.and(keywordCondition); } if (status != null) { builder.and(qUser.status.eq(status)); } return userRepository.findAll(builder, pageable); } } 高級查詢功能 1. Join 查詢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 /** * Join 查詢範例 */ @Service @Transactional(readOnly = true) public class AdvancedQueryService { @Autowired private JPAQueryFactory queryFactory; private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; private final QProject qProject = QProject.project; private final QUserRole qUserRole = QUserRole.userRole; private final QRole qRole = QRole.role; /** * Inner Join：查詢用戶及其部門資訊 */ public List\u0026lt;User\u0026gt; findUsersWithDepartment() { return queryFactory.selectFrom(qUser) .innerJoin(qUser.department, qDepartment).fetchJoin() .where(qDepartment.name.isNotNull()) .orderBy(qDepartment.name.asc(), qUser.username.asc()) .fetch(); } /** * Left Join：查詢所有用戶（包含沒有部門的用戶） */ public List\u0026lt;User\u0026gt; findAllUsersWithOptionalDepartment() { return queryFactory.selectFrom(qUser) .leftJoin(qUser.department, qDepartment).fetchJoin() .orderBy(qUser.username.asc()) .fetch(); } /** * 複雜 Join：查詢用戶、部門和專案資訊 */ public List\u0026lt;User\u0026gt; findUsersWithDepartmentAndProjects() { return queryFactory.selectFrom(qUser) .leftJoin(qUser.department, qDepartment).fetchJoin() .leftJoin(qUser.assignedProjects, qProject).fetchJoin() .where(qUser.status.eq(UserStatus.ACTIVE)) .orderBy(qDepartment.name.asc(), qUser.username.asc()) .fetch(); } /** * 條件 Join：根據部門預算查詢用戶 */ public List\u0026lt;User\u0026gt; findUsersByDepartmentBudget(Double minBudget) { return queryFactory.selectFrom(qUser) .innerJoin(qUser.department, qDepartment) .where(qDepartment.budget.goe(minBudget)) .orderBy(qDepartment.budget.desc(), qUser.username.asc()) .fetch(); } /** * 多層 Join：查詢用戶角色資訊 */ public List\u0026lt;User\u0026gt; findUsersWithRoles(String roleName) { return queryFactory.selectFrom(qUser) .innerJoin(qUser.userRoles, qUserRole) .innerJoin(qUserRole.role, qRole) .where(qRole.name.eq(roleName)) .orderBy(qUser.username.asc()) .fetch(); } } 2. 子查詢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 /** * 子查詢範例 */ public class SubQueryService { @Autowired private JPAQueryFactory queryFactory; private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; private final QProject qProject = QProject.project; /** * EXISTS 子查詢：查詢有專案的用戶 */ public List\u0026lt;User\u0026gt; findUsersWithProjects() { QProject subProject = new QProject(\u0026#34;subProject\u0026#34;); return queryFactory.selectFrom(qUser) .where(JPAExpressions.selectOne() .from(subProject) .where(subProject.assignee.eq(qUser)) .exists()) .orderBy(qUser.username.asc()) .fetch(); } /** * NOT EXISTS 子查詢：查詢沒有專案的用戶 */ public List\u0026lt;User\u0026gt; findUsersWithoutProjects() { QProject subProject = new QProject(\u0026#34;subProject\u0026#34;); return queryFactory.selectFrom(qUser) .where(JPAExpressions.selectOne() .from(subProject) .where(subProject.assignee.eq(qUser)) .notExists()) .orderBy(qUser.username.asc()) .fetch(); } /** * IN 子查詢：查詢特定部門的用戶 */ public List\u0026lt;User\u0026gt; findUsersByDepartmentNames(List\u0026lt;String\u0026gt; departmentNames) { QDepartment subDepartment = new QDepartment(\u0026#34;subDepartment\u0026#34;); return queryFactory.selectFrom(qUser) .where(qUser.department.id.in( JPAExpressions.select(subDepartment.id) .from(subDepartment) .where(subDepartment.name.in(departmentNames)) )) .orderBy(qUser.username.asc()) .fetch(); } /** * 比較子查詢：查詢薪資高於平均薪資的用戶 */ public List\u0026lt;User\u0026gt; findUsersWithAboveAverageSalary() { QUser subUser = new QUser(\u0026#34;subUser\u0026#34;); return queryFactory.selectFrom(qUser) .where(qUser.salary.gt( JPAExpressions.select(subUser.salary.avg()) .from(subUser) .where(subUser.salary.isNotNull()) )) .orderBy(qUser.salary.desc()) .fetch(); } /** * 相關子查詢：查詢部門內薪資最高的用戶 */ public List\u0026lt;User\u0026gt; findTopSalaryUsersByDepartment() { QUser subUser = new QUser(\u0026#34;subUser\u0026#34;); return queryFactory.selectFrom(qUser) .where(qUser.salary.eq( JPAExpressions.select(subUser.salary.max()) .from(subUser) .where(subUser.department.eq(qUser.department) .and(subUser.salary.isNotNull())) )) .orderBy(qUser.department.name.asc(), qUser.username.asc()) .fetch(); } } 3. 聚合查詢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 /** * 聚合查詢範例 */ public class AggregationService { @Autowired private JPAQueryFactory queryFactory; private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; private final QProject qProject = QProject.project; /** * 基礎聚合：統計用戶數量 */ public Long countActiveUsers() { return queryFactory.select(qUser.count()) .from(qUser) .where(qUser.status.eq(UserStatus.ACTIVE)) .fetchOne(); } /** * GROUP BY：按部門統計用戶數量 */ public List\u0026lt;DepartmentUserCount\u0026gt; countUsersByDepartment() { return queryFactory.select(Projections.constructor(DepartmentUserCount.class, qDepartment.id, qDepartment.name, qUser.count())) .from(qUser) .innerJoin(qUser.department, qDepartment) .where(qUser.status.eq(UserStatus.ACTIVE)) .groupBy(qDepartment.id, qDepartment.name) .orderBy(qUser.count().desc()) .fetch(); } /** * HAVING：查詢用戶數量大於指定數量的部門 */ public List\u0026lt;DepartmentUserCount\u0026gt; findDepartmentsWithMinUsers(Long minUserCount) { return queryFactory.select(Projections.constructor(DepartmentUserCount.class, qDepartment.id, qDepartment.name, qUser.count())) .from(qUser) .innerJoin(qUser.department, qDepartment) .where(qUser.status.eq(UserStatus.ACTIVE)) .groupBy(qDepartment.id, qDepartment.name) .having(qUser.count().goe(minUserCount)) .orderBy(qUser.count().desc()) .fetch(); } /** * 多欄位聚合：部門薪資統計 */ public List\u0026lt;DepartmentSalaryStats\u0026gt; calculateDepartmentSalaryStats() { return queryFactory.select(Projections.constructor(DepartmentSalaryStats.class, qDepartment.id, qDepartment.name, qUser.salary.sum(), qUser.salary.avg(), qUser.salary.min(), qUser.salary.max(), qUser.count())) .from(qUser) .innerJoin(qUser.department, qDepartment) .where(qUser.status.eq(UserStatus.ACTIVE) .and(qUser.salary.isNotNull())) .groupBy(qDepartment.id, qDepartment.name) .orderBy(qUser.salary.avg().desc()) .fetch(); } /** * 時間聚合：按月統計用戶註冊數量 */ public List\u0026lt;MonthlyUserRegistration\u0026gt; getUserRegistrationByMonth(int year) { return queryFactory.select(Projections.constructor(MonthlyUserRegistration.class, qUser.createdAt.month(), qUser.count())) .from(qUser) .where(qUser.createdAt.year().eq(year)) .groupBy(qUser.createdAt.month()) .orderBy(qUser.createdAt.month().asc()) .fetch(); } // DTO 類別定義 public static class DepartmentUserCount { private Long departmentId; private String departmentName; private Long userCount; public DepartmentUserCount(Long departmentId, String departmentName, Long userCount) { this.departmentId = departmentId; this.departmentName = departmentName; this.userCount = userCount; } // getter 和 setter 方法省略... } public static class DepartmentSalaryStats { private Long departmentId; private String departmentName; private Double totalSalary; private Double averageSalary; private Double minSalary; private Double maxSalary; private Long employeeCount; public DepartmentSalaryStats(Long departmentId, String departmentName, Double totalSalary, Double averageSalary, Double minSalary, Double maxSalary, Long employeeCount) { this.departmentId = departmentId; this.departmentName = departmentName; this.totalSalary = totalSalary; this.averageSalary = averageSalary; this.minSalary = minSalary; this.maxSalary = maxSalary; this.employeeCount = employeeCount; } // getter 和 setter 方法省略... } public static class MonthlyUserRegistration { private Integer month; private Long registrationCount; public MonthlyUserRegistration(Integer month, Long registrationCount) { this.month = month; this.registrationCount = registrationCount; } // getter 和 setter 方法省略... } } 動態查詢建構 1. Predicate 建構器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 /** * 動態查詢建構器 */ @Component public class UserPredicateBuilder { private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; /** * 建構用戶查詢條件 */ public BooleanBuilder buildUserPredicate(UserSearchCriteria criteria) { BooleanBuilder builder = new BooleanBuilder(); // 基本欄位條件 addStringCondition(builder, qUser.username, criteria.getUsername(), StringMatchType.CONTAINS); addStringCondition(builder, qUser.email, criteria.getEmail(), StringMatchType.CONTAINS); addStringCondition(builder, qUser.firstName, criteria.getFirstName(), StringMatchType.CONTAINS); addStringCondition(builder, qUser.lastName, criteria.getLastName(), StringMatchType.CONTAINS); addStringCondition(builder, qUser.phone, criteria.getPhone(), StringMatchType.EXACT); // 數值範圍條件 addRangeCondition(builder, qUser.age, criteria.getMinAge(), criteria.getMaxAge()); addRangeCondition(builder, qUser.salary, criteria.getMinSalary(), criteria.getMaxSalary()); // 枚舉條件 addEnumCondition(builder, qUser.status, criteria.getStatuses()); // 日期範圍條件 addDateRangeCondition(builder, qUser.createdAt, criteria.getCreatedAfter(), criteria.getCreatedBefore()); addDateRangeCondition(builder, qUser.updatedAt, criteria.getUpdatedAfter(), criteria.getUpdatedBefore()); // 關聯條件 addDepartmentConditions(builder, criteria); return builder; } /** * 字串條件處理 */ private void addStringCondition(BooleanBuilder builder, StringPath path, String value, StringMatchType matchType) { if (value != null \u0026amp;\u0026amp; !value.trim().isEmpty()) { switch (matchType) { case EXACT: builder.and(path.eq(value)); break; case CONTAINS: builder.and(path.containsIgnoreCase(value.trim())); break; case STARTS_WITH: builder.and(path.startsWithIgnoreCase(value.trim())); break; case ENDS_WITH: builder.and(path.endsWithIgnoreCase(value.trim())); break; } } } /** * 數值範圍條件處理 */ private \u0026lt;T extends Number \u0026amp; Comparable\u0026lt;T\u0026gt;\u0026gt; void addRangeCondition( BooleanBuilder builder, NumberPath\u0026lt;T\u0026gt; path, T minValue, T maxValue) { if (minValue != null) { builder.and(path.goe(minValue)); } if (maxValue != null) { builder.and(path.loe(maxValue)); } } /** * 枚舉條件處理 */ private \u0026lt;T extends Enum\u0026lt;T\u0026gt;\u0026gt; void addEnumCondition( BooleanBuilder builder, EnumPath\u0026lt;T\u0026gt; path, List\u0026lt;T\u0026gt; values) { if (values != null \u0026amp;\u0026amp; !values.isEmpty()) { builder.and(path.in(values)); } } /** * 日期範圍條件處理 */ private void addDateRangeCondition(BooleanBuilder builder, DateTimePath\u0026lt;LocalDateTime\u0026gt; path, LocalDateTime after, LocalDateTime before) { if (after != null) { builder.and(path.goe(after)); } if (before != null) { builder.and(path.loe(before)); } } /** * 部門相關條件處理 */ private void addDepartmentConditions(BooleanBuilder builder, UserSearchCriteria criteria) { if (criteria.getDepartmentIds() != null \u0026amp;\u0026amp; !criteria.getDepartmentIds().isEmpty()) { builder.and(qUser.department.id.in(criteria.getDepartmentIds())); } if (criteria.getDepartmentName() != null \u0026amp;\u0026amp; !criteria.getDepartmentName().trim().isEmpty()) { builder.and(qUser.department.name.containsIgnoreCase(criteria.getDepartmentName().trim())); } if (criteria.getMinDepartmentBudget() != null) { builder.and(qUser.department.budget.goe(criteria.getMinDepartmentBudget())); } if (criteria.getMaxDepartmentBudget() != null) { builder.and(qUser.department.budget.loe(criteria.getMaxDepartmentBudget())); } } /** * 字串匹配類型枚舉 */ public enum StringMatchType { EXACT, CONTAINS, STARTS_WITH, ENDS_WITH } } /** * 用戶搜尋條件 DTO */ public class UserSearchCriteria { private String username; private String email; private String firstName; private String lastName; private String phone; private Integer minAge; private Integer maxAge; private Double minSalary; private Double maxSalary; private List\u0026lt;UserStatus\u0026gt; statuses; private LocalDateTime createdAfter; private LocalDateTime createdBefore; private LocalDateTime updatedAfter; private LocalDateTime updatedBefore; private List\u0026lt;Long\u0026gt; departmentIds; private String departmentName; private Double minDepartmentBudget; private Double maxDepartmentBudget; // 建構子、getter 和 setter 方法省略... } 2. 查詢規格建構器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 /** * 查詢規格建構器 */ @Component public class QuerySpecificationBuilder { private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; private final QProject qProject = QProject.project; /** * 建構複雜查詢規格 */ public JPAQuery\u0026lt;User\u0026gt; buildComplexUserQuery(JPAQueryFactory queryFactory, ComplexSearchCriteria criteria) { JPAQuery\u0026lt;User\u0026gt; query = queryFactory.selectFrom(qUser); // 添加 Join addJoins(query, criteria); // 添加 Where 條件 addWhereConditions(query, criteria); // 添加排序 addOrderBy(query, criteria); return query; } /** * 添加 Join 條件 */ private void addJoins(JPAQuery\u0026lt;User\u0026gt; query, ComplexSearchCriteria criteria) { if (criteria.isIncludeDepartment() || criteria.hasDepartmentConditions()) { query.leftJoin(qUser.department, qDepartment); if (criteria.isFetchDepartment()) { query.fetchJoin(); } } if (criteria.isIncludeProjects() || criteria.hasProjectConditions()) { query.leftJoin(qUser.assignedProjects, qProject); if (criteria.isFetchProjects()) { query.fetchJoin(); } } } /** * 添加 Where 條件 */ private void addWhereConditions(JPAQuery\u0026lt;User\u0026gt; query, ComplexSearchCriteria criteria) { BooleanBuilder builder = new BooleanBuilder(); // 用戶基本條件 addUserConditions(builder, criteria); // 部門條件 addDepartmentConditions(builder, criteria); // 專案條件 addProjectConditions(builder, criteria); // 自訂條件 addCustomConditions(builder, criteria); if (builder.hasValue()) { query.where(builder); } } /** * 添加排序條件 */ private void addOrderBy(JPAQuery\u0026lt;User\u0026gt; query, ComplexSearchCriteria criteria) { List\u0026lt;OrderSpecifier\u0026lt;?\u0026gt;\u0026gt; orderSpecifiers = new ArrayList\u0026lt;\u0026gt;(); if (criteria.getSortFields() != null \u0026amp;\u0026amp; !criteria.getSortFields().isEmpty()) { for (SortField sortField : criteria.getSortFields()) { OrderSpecifier\u0026lt;?\u0026gt; orderSpecifier = createOrderSpecifier(sortField); if (orderSpecifier != null) { orderSpecifiers.add(orderSpecifier); } } } // 預設排序 if (orderSpecifiers.isEmpty()) { orderSpecifiers.add(qUser.createdAt.desc()); } query.orderBy(orderSpecifiers.toArray(new OrderSpecifier[0])); } /** * 創建排序規格 */ private OrderSpecifier\u0026lt;?\u0026gt; createOrderSpecifier(SortField sortField) { boolean isAsc = sortField.getDirection() == SortDirection.ASC; switch (sortField.getField()) { case \u0026#34;username\u0026#34;: return isAsc ? qUser.username.asc() : qUser.username.desc(); case \u0026#34;email\u0026#34;: return isAsc ? qUser.email.asc() : qUser.email.desc(); case \u0026#34;age\u0026#34;: return isAsc ? qUser.age.asc() : qUser.age.desc(); case \u0026#34;salary\u0026#34;: return isAsc ? qUser.salary.asc() : qUser.salary.desc(); case \u0026#34;createdAt\u0026#34;: return isAsc ? qUser.createdAt.asc() : qUser.createdAt.desc(); case \u0026#34;departmentName\u0026#34;: return isAsc ? qDepartment.name.asc() : qDepartment.name.desc(); default: return null; } } // 輔助方法省略... } 更新和刪除操作 1. 批量更新 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /** * 更新和刪除操作服務 */ @Service @Transactional public class UserUpdateService { @Autowired private JPAQueryFactory queryFactory; private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; /** * 批量更新用戶狀態 */ public long updateUserStatus(List\u0026lt;Long\u0026gt; userIds, UserStatus newStatus) { return queryFactory.update(qUser) .set(qUser.status, newStatus) .set(qUser.updatedAt, LocalDateTime.now()) .where(qUser.id.in(userIds)) .execute(); } /** * 批量更新用戶薪資 */ public long updateSalaryByDepartment(Long departmentId, Double salaryIncrease) { return queryFactory.update(qUser) .set(qUser.salary, qUser.salary.add(salaryIncrease)) .set(qUser.updatedAt, LocalDateTime.now()) .where(qUser.department.id.eq(departmentId) .and(qUser.status.eq(UserStatus.ACTIVE)) .and(qUser.salary.isNotNull())) .execute(); } /** * 條件式更新：根據年齡調整薪資 */ public long adjustSalaryByAge() { // 為年齡大於 30 的員工增加 10% 薪資 return queryFactory.update(qUser) .set(qUser.salary, qUser.salary.multiply(1.1)) .set(qUser.updatedAt, LocalDateTime.now()) .where(qUser.age.gt(30) .and(qUser.status.eq(UserStatus.ACTIVE)) .and(qUser.salary.isNotNull())) .execute(); } /** * Join 更新：根據部門預算更新員工狀態 */ public long updateStatusByDepartmentBudget(Double minBudget, UserStatus newStatus) { return queryFactory.update(qUser) .set(qUser.status, newStatus) .set(qUser.updatedAt, LocalDateTime.now()) .where(qUser.department.budget.lt(minBudget)) .execute(); } } 2. 批量刪除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /** * 刪除操作服務 */ @Service @Transactional public class UserDeleteService { @Autowired private JPAQueryFactory queryFactory; private final QUser qUser = QUser.user; /** * 軟刪除：標記為已刪除狀態 */ public long softDeleteUsers(List\u0026lt;Long\u0026gt; userIds) { return queryFactory.update(qUser) .set(qUser.status, UserStatus.DELETED) .set(qUser.updatedAt, LocalDateTime.now()) .where(qUser.id.in(userIds)) .execute(); } /** * 硬刪除：物理刪除記錄 */ public long hardDeleteInactiveUsers(LocalDateTime before) { return queryFactory.delete(qUser) .where(qUser.status.eq(UserStatus.DELETED) .and(qUser.updatedAt.before(before))) .execute(); } /** * 條件刪除：刪除特定條件的用戶 */ public long deleteUsersByCondition(UserStatus status, Integer maxAge) { BooleanBuilder builder = new BooleanBuilder(); if (status != null) { builder.and(qUser.status.eq(status)); } if (maxAge != null) { builder.and(qUser.age.loe(maxAge)); } return queryFactory.delete(qUser) .where(builder) .execute(); } /** * 清理孤立記錄：刪除沒有部門的用戶 */ public long deleteUsersWithoutDepartment() { return queryFactory.delete(qUser) .where(qUser.department.isNull() .and(qUser.status.eq(UserStatus.INACTIVE))) .execute(); } } 效能優化技巧 1. 查詢優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 /** * 效能優化服務 */ @Service @Transactional(readOnly = true) public class QueryOptimizationService { @Autowired private JPAQueryFactory queryFactory; private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; /** * 使用投影減少資料傳輸 */ public List\u0026lt;UserSummaryDTO\u0026gt; getUserSummaries() { return queryFactory.select(Projections.constructor(UserSummaryDTO.class, qUser.id, qUser.username, qUser.email, qUser.status, qDepartment.name)) .from(qUser) .leftJoin(qUser.department, qDepartment) .where(qUser.status.eq(UserStatus.ACTIVE)) .orderBy(qUser.username.asc()) .fetch(); } /** * 使用 Fetch Join 避免 N+1 問題 */ public List\u0026lt;User\u0026gt; getUsersWithDepartmentOptimized() { return queryFactory.selectFrom(qUser) .leftJoin(qUser.department, qDepartment).fetchJoin() .where(qUser.status.eq(UserStatus.ACTIVE)) .orderBy(qUser.username.asc()) .fetch(); } /** * 分頁查詢優化 */ public Page\u0026lt;User\u0026gt; getUsersWithOptimizedPaging(Pageable pageable) { // 先查詢總數 Long total = queryFactory.select(qUser.count()) .from(qUser) .where(qUser.status.eq(UserStatus.ACTIVE)) .fetchOne(); // 如果總數為 0，直接返回空頁面 if (total == 0) { return new PageImpl\u0026lt;\u0026gt;(Collections.emptyList(), pageable, 0); } // 查詢分頁資料 List\u0026lt;User\u0026gt; users = queryFactory.selectFrom(qUser) .where(qUser.status.eq(UserStatus.ACTIVE)) .orderBy(qUser.username.asc()) .offset(pageable.getOffset()) .limit(pageable.getPageSize()) .fetch(); return new PageImpl\u0026lt;\u0026gt;(users, pageable, total); } /** * 使用索引提示優化查詢 */ public List\u0026lt;User\u0026gt; findUsersByIndexedFields(String username, String email) { BooleanBuilder builder = new BooleanBuilder(); // 優先使用有索引的欄位 if (username != null \u0026amp;\u0026amp; !username.trim().isEmpty()) { builder.and(qUser.username.eq(username)); // username 有唯一索引 } else if (email != null \u0026amp;\u0026amp; !email.trim().isEmpty()) { builder.and(qUser.email.eq(email)); // email 有唯一索引 } return queryFactory.selectFrom(qUser) .where(builder) .fetch(); } /** * 批量查詢優化 */ public Map\u0026lt;Long, User\u0026gt; getUsersByIdsOptimized(List\u0026lt;Long\u0026gt; userIds) { if (userIds.isEmpty()) { return Collections.emptyMap(); } List\u0026lt;User\u0026gt; users = queryFactory.selectFrom(qUser) .where(qUser.id.in(userIds)) .fetch(); return users.stream() .collect(Collectors.toMap(User::getId, Function.identity())); } } /** * 用戶摘要 DTO */ public class UserSummaryDTO { private Long id; private String username; private String email; private UserStatus status; private String departmentName; public UserSummaryDTO(Long id, String username, String email, UserStatus status, String departmentName) { this.id = id; this.username = username; this.email = email; this.status = status; this.departmentName = departmentName; } // getter 和 setter 方法省略... } 2. 快取策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 /** * 快取優化服務 */ @Service @Transactional(readOnly = true) public class CachedQueryService { @Autowired private JPAQueryFactory queryFactory; @Autowired private CacheManager cacheManager; private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; /** * 快取用戶基本資訊 */ @Cacheable(value = \u0026#34;userCache\u0026#34;, key = \u0026#34;#userId\u0026#34;) public Optional\u0026lt;User\u0026gt; getCachedUser(Long userId) { User user = queryFactory.selectFrom(qUser) .where(qUser.id.eq(userId)) .fetchOne(); return Optional.ofNullable(user); } /** * 快取部門用戶列表 */ @Cacheable(value = \u0026#34;departmentUsersCache\u0026#34;, key = \u0026#34;#departmentId\u0026#34;) public List\u0026lt;User\u0026gt; getCachedDepartmentUsers(Long departmentId) { return queryFactory.selectFrom(qUser) .where(qUser.department.id.eq(departmentId) .and(qUser.status.eq(UserStatus.ACTIVE))) .orderBy(qUser.username.asc()) .fetch(); } /** * 快取用戶統計資訊 */ @Cacheable(value = \u0026#34;userStatsCache\u0026#34;, key = \u0026#34;\u0026#39;userStats\u0026#39;\u0026#34;) public UserStatistics getCachedUserStatistics() { Long totalUsers = queryFactory.select(qUser.count()) .from(qUser) .fetchOne(); Long activeUsers = queryFactory.select(qUser.count()) .from(qUser) .where(qUser.status.eq(UserStatus.ACTIVE)) .fetchOne(); Double averageSalary = queryFactory.select(qUser.salary.avg()) .from(qUser) .where(qUser.salary.isNotNull() .and(qUser.status.eq(UserStatus.ACTIVE))) .fetchOne(); return new UserStatistics(totalUsers, activeUsers, averageSalary); } /** * 更新時清除快取 */ @CacheEvict(value = {\u0026#34;userCache\u0026#34;, \u0026#34;departmentUsersCache\u0026#34;, \u0026#34;userStatsCache\u0026#34;}, allEntries = true) public void evictAllCaches() { // 清除所有相關快取 } /** * 清除特定用戶快取 */ @CacheEvict(value = \u0026#34;userCache\u0026#34;, key = \u0026#34;#userId\u0026#34;) public void evictUserCache(Long userId) { // 清除特定用戶快取 } } 測試策略 1. 單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 /** * QueryDSL 單元測試 */ @DataJpaTest @TestPropertySource(locations = \u0026#34;classpath:application-test.properties\u0026#34;) class QueryDSLServiceTest { @Autowired private TestEntityManager entityManager; @Autowired private UserRepository userRepository; private JPAQueryFactory queryFactory; private UserService userService; @BeforeEach void setUp() { queryFactory = new JPAQueryFactory(entityManager.getEntityManager()); userService = new UserService(); ReflectionTestUtils.setField(userService, \u0026#34;queryFactory\u0026#34;, queryFactory); ReflectionTestUtils.setField(userService, \u0026#34;userRepository\u0026#34;, userRepository); } @Test @DisplayName(\u0026#34;根據用戶名查找用戶\u0026#34;) void testFindByUsername() { // Given User user = new User(\u0026#34;testuser\u0026#34;, \u0026#34;test@example.com\u0026#34;, \u0026#34;Test\u0026#34;, \u0026#34;User\u0026#34;, 25); user.setStatus(UserStatus.ACTIVE); entityManager.persistAndFlush(user); // When Optional\u0026lt;User\u0026gt; result = userService.findByUsername(\u0026#34;testuser\u0026#34;); // Then assertThat(result).isPresent(); assertThat(result.get().getUsername()).isEqualTo(\u0026#34;testuser\u0026#34;); assertThat(result.get().getEmail()).isEqualTo(\u0026#34;test@example.com\u0026#34;); } @Test @DisplayName(\u0026#34;多條件查詢用戶\u0026#34;) void testFindUsersByConditions() { // Given Department department = new Department(\u0026#34;IT\u0026#34;, \u0026#34;Information Technology\u0026#34;, 100000.0); entityManager.persistAndFlush(department); User user1 = new User(\u0026#34;john\u0026#34;, \u0026#34;john@example.com\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;, 30); user1.setStatus(UserStatus.ACTIVE); user1.setDepartment(department); User user2 = new User(\u0026#34;jane\u0026#34;, \u0026#34;jane@example.com\u0026#34;, \u0026#34;Jane\u0026#34;, \u0026#34;Smith\u0026#34;, 25); user2.setStatus(UserStatus.INACTIVE); user2.setDepartment(department); entityManager.persistAndFlush(user1); entityManager.persistAndFlush(user2); // When List\u0026lt;User\u0026gt; activeUsers = userService.findUsersByConditions( null, null, 20, 35, UserStatus.ACTIVE); // Then assertThat(activeUsers).hasSize(1); assertThat(activeUsers.get(0).getUsername()).isEqualTo(\u0026#34;john\u0026#34;); } @Test @DisplayName(\u0026#34;測試 Join 查詢\u0026#34;) void testJoinQuery() { // Given Department department = new Department(\u0026#34;HR\u0026#34;, \u0026#34;Human Resources\u0026#34;, 80000.0); entityManager.persistAndFlush(department); User user = new User(\u0026#34;hr_user\u0026#34;, \u0026#34;hr@example.com\u0026#34;, \u0026#34;HR\u0026#34;, \u0026#34;Manager\u0026#34;, 35); user.setStatus(UserStatus.ACTIVE); user.setDepartment(department); entityManager.persistAndFlush(user); // When QUser qUser = QUser.user; QDepartment qDepartment = QDepartment.department; List\u0026lt;User\u0026gt; users = queryFactory.selectFrom(qUser) .innerJoin(qUser.department, qDepartment).fetchJoin() .where(qDepartment.name.eq(\u0026#34;HR\u0026#34;)) .fetch(); // Then assertThat(users).hasSize(1); assertThat(users.get(0).getDepartment().getName()).isEqualTo(\u0026#34;HR\u0026#34;); } @Test @DisplayName(\u0026#34;測試聚合查詢\u0026#34;) void testAggregationQuery() { // Given Department department = new Department(\u0026#34;Sales\u0026#34;, \u0026#34;Sales Department\u0026#34;, 120000.0); entityManager.persistAndFlush(department); User user1 = new User(\u0026#34;sales1\u0026#34;, \u0026#34;sales1@example.com\u0026#34;, \u0026#34;Sales\u0026#34;, \u0026#34;Rep1\u0026#34;, 28); user1.setStatus(UserStatus.ACTIVE); user1.setDepartment(department); user1.setSalary(50000.0); User user2 = new User(\u0026#34;sales2\u0026#34;, \u0026#34;sales2@example.com\u0026#34;, \u0026#34;Sales\u0026#34;, \u0026#34;Rep2\u0026#34;, 32); user2.setStatus(UserStatus.ACTIVE); user2.setDepartment(department); user2.setSalary(60000.0); entityManager.persistAndFlush(user1); entityManager.persistAndFlush(user2); // When QUser qUser = QUser.user; QDepartment qDepartment = QDepartment.department; Tuple result = queryFactory.select( qDepartment.name, qUser.count(), qUser.salary.avg()) .from(qUser) .innerJoin(qUser.department, qDepartment) .where(qDepartment.name.eq(\u0026#34;Sales\u0026#34;)) .groupBy(qDepartment.name) .fetchOne(); // Then assertThat(result).isNotNull(); assertThat(result.get(qDepartment.name)).isEqualTo(\u0026#34;Sales\u0026#34;); assertThat(result.get(qUser.count())).isEqualTo(2L); assertThat(result.get(qUser.salary.avg())).isEqualTo(55000.0); } } 2. 整合測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /** * QueryDSL 整合測試 */ @SpringBootTest @Transactional @TestPropertySource(locations = \u0026#34;classpath:application-integration-test.properties\u0026#34;) class QueryDSLIntegrationTest { @Autowired private UserService userService; @Autowired private UserRepository userRepository; @Autowired private DepartmentRepository departmentRepository; @Test @DisplayName(\u0026#34;完整的用戶管理流程測試\u0026#34;) void testCompleteUserManagementFlow() { // 1. 創建部門 Department department = new Department(\u0026#34;Engineering\u0026#34;, \u0026#34;Software Engineering\u0026#34;, 200000.0); department = departmentRepository.save(department); // 2. 創建用戶 User user1 = new User(\u0026#34;engineer1\u0026#34;, \u0026#34;eng1@example.com\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Engineer\u0026#34;, 30); user1.setStatus(UserStatus.ACTIVE); user1.setSalary(80000.0); user1.setDepartment(department); User user2 = new User(\u0026#34;engineer2\u0026#34;, \u0026#34;eng2@example.com\u0026#34;, \u0026#34;Jane\u0026#34;, \u0026#34;Developer\u0026#34;, 28); user2.setStatus(UserStatus.ACTIVE); user2.setSalary(75000.0); user2.setDepartment(department); userRepository.saveAll(Arrays.asList(user1, user2)); // 3. 測試查詢 List\u0026lt;User\u0026gt; engineers = userService.findUsersByConditions( null, null, 25, 35, UserStatus.ACTIVE); assertThat(engineers).hasSize(2); // 4. 測試更新 UserUpdateService updateService = new UserUpdateService(); // 設定 queryFactory... long updatedCount = updateService.updateSalaryByDepartment( department.getId(), 5000.0); assertThat(updatedCount).isEqualTo(2); // 5. 驗證更新結果 List\u0026lt;User\u0026gt; updatedUsers = userRepository.findAll(); assertThat(updatedUsers.stream() .mapToDouble(User::getSalary) .average() .orElse(0.0)) .isEqualTo(82500.0); // (85000 + 80000) / 2 } } 最佳實踐與建議 1. 查詢優化建議 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 /** * QueryDSL 最佳實踐指南 */ @Component public class QueryDSLBestPractices { /** * 1. 使用適當的 Fetch 策略 */ public void demonstrateFetchStrategies() { // ✅ 推薦：使用 fetchJoin 避免 N+1 問題 List\u0026lt;User\u0026gt; usersWithDepartment = queryFactory.selectFrom(qUser) .leftJoin(qUser.department, qDepartment).fetchJoin() .fetch(); // ❌ 避免：不使用 fetchJoin 會導致 N+1 問題 List\u0026lt;User\u0026gt; users = queryFactory.selectFrom(qUser).fetch(); // 後續存取 user.getDepartment() 會觸發額外查詢 } /** * 2. 使用投影減少記憶體使用 */ public void demonstrateProjections() { // ✅ 推薦：只選擇需要的欄位 List\u0026lt;UserSummaryDTO\u0026gt; summaries = queryFactory .select(Projections.constructor(UserSummaryDTO.class, qUser.id, qUser.username, qUser.email)) .from(qUser) .fetch(); // ❌ 避免：選擇整個實體但只使用部分欄位 List\u0026lt;User\u0026gt; allUsers = queryFactory.selectFrom(qUser).fetch(); } /** * 3. 合理使用索引 */ public void demonstrateIndexUsage() { // ✅ 推薦：查詢條件使用有索引的欄位 List\u0026lt;User\u0026gt; usersByUsername = queryFactory.selectFrom(qUser) .where(qUser.username.eq(\u0026#34;john\u0026#34;)) // username 有索引 .fetch(); // ❌ 避免：在沒有索引的欄位上使用 LIKE 查詢 List\u0026lt;User\u0026gt; usersByDescription = queryFactory.selectFrom(qUser) .where(qUser.email.contains(\u0026#34;@gmail\u0026#34;)) // 可能效能較差 .fetch(); } /** * 4. 批量操作優化 */ public void demonstrateBatchOperations() { // ✅ 推薦：使用批量更新 long updated = queryFactory.update(qUser) .set(qUser.status, UserStatus.ACTIVE) .where(qUser.id.in(Arrays.asList(1L, 2L, 3L))) .execute(); // ❌ 避免：迴圈中進行單個更新 for (Long id : Arrays.asList(1L, 2L, 3L)) { queryFactory.update(qUser) .set(qUser.status, UserStatus.ACTIVE) .where(qUser.id.eq(id)) .execute(); // 多次資料庫往返 } } /** * 5. 分頁查詢優化 */ public void demonstratePaginationOptimization() { // ✅ 推薦：先查總數，再查分頁資料 Long total = queryFactory.select(qUser.count()) .from(qUser) .where(qUser.status.eq(UserStatus.ACTIVE)) .fetchOne(); if (total \u0026gt; 0) { List\u0026lt;User\u0026gt; users = queryFactory.selectFrom(qUser) .where(qUser.status.eq(UserStatus.ACTIVE)) .offset(0) .limit(20) .fetch(); } // ❌ 避免：使用複雜的子查詢進行分頁 } } 2. 錯誤處理與除錯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 /** * QueryDSL 錯誤處理指南 */ @Component public class QueryDSLErrorHandling { private static final Logger logger = LoggerFactory.getLogger(QueryDSLErrorHandling.class); /** * 安全的查詢執行 */ public Optional\u0026lt;User\u0026gt; safeQueryExecution(Long userId) { try { User user = queryFactory.selectFrom(qUser) .where(qUser.id.eq(userId)) .fetchOne(); return Optional.ofNullable(user); } catch (DataAccessException e) { logger.error(\u0026#34;Database error while fetching user with id: {}\u0026#34;, userId, e); return Optional.empty(); } catch (Exception e) { logger.error(\u0026#34;Unexpected error while fetching user with id: {}\u0026#34;, userId, e); throw new ServiceException(\u0026#34;Failed to fetch user\u0026#34;, e); } } /** * 查詢除錯輔助方法 */ public void debugQuery() { // 開啟 SQL 日誌記錄 JPAQuery\u0026lt;User\u0026gt; query = queryFactory.selectFrom(qUser) .where(qUser.status.eq(UserStatus.ACTIVE)); // 印出生成的 SQL logger.debug(\u0026#34;Generated SQL: {}\u0026#34;, query.toString()); // 執行查詢 List\u0026lt;User\u0026gt; results = query.fetch(); logger.debug(\u0026#34;Query returned {} results\u0026#34;, results.size()); } /** * 驗證查詢參數 */ public List\u0026lt;User\u0026gt; validateAndQuery(UserSearchCriteria criteria) { // 參數驗證 if (criteria == null) { throw new IllegalArgumentException(\u0026#34;Search criteria cannot be null\u0026#34;); } BooleanBuilder builder = new BooleanBuilder(); // 安全的字串處理 if (criteria.getUsername() != null) { String cleanUsername = criteria.getUsername().trim(); if (!cleanUsername.isEmpty()) { builder.and(qUser.username.containsIgnoreCase(cleanUsername)); } } // 數值範圍驗證 if (criteria.getMinAge() != null \u0026amp;\u0026amp; criteria.getMaxAge() != null) { if (criteria.getMinAge() \u0026gt; criteria.getMaxAge()) { throw new IllegalArgumentException(\u0026#34;Min age cannot be greater than max age\u0026#34;); } } return queryFactory.selectFrom(qUser) .where(builder) .fetch(); } } 總結 QueryDSL 是一個功能強大的類型安全查詢框架，為 Java 開發者提供了高效的動態查詢解決方案：\n主要優勢 類型安全：編譯時檢查，減少執行期錯誤 IDE 友好：完整的自動完成和重構支援 統一 API：支援多種資料源的一致查詢介面 效能優化：生成高效的 SQL 查詢語句 動態查詢：靈活的條件組合和查詢建構 適用場景 複雜動態查詢：多條件組合查詢 報表系統：複雜的聚合和統計查詢 搜尋功能：靈活的搜尋條件組合 資料分析：大量的資料處理和分析 API 開發：RESTful API 的查詢參數處理 最佳實踐要點 效能優化：合理使用 Fetch Join 和投影 索引利用：查詢條件對應適當的資料庫索引 批量操作：使用批量更新和刪除操作 錯誤處理：完善的異常處理和日誌記錄 測試覆蓋：充分的單元測試和整合測試 通過掌握 QueryDSL 的使用技巧和最佳實踐，可以大幅提升 Java 應用程式的查詢效率和開發體驗，建構出高效能、可維護的資料存取層。\n","permalink":"https://xinqilin.github.io/post/backend/querydsl/","tags":["QueryDSL","JPA","Spring Data","Database","Query Builder","Type Safety","Criteria API","Dynamic Query","Performance"],"title":"QueryDSL 完整實戰指南：類型安全的動態查詢解決方案"},{"content":"Kotlin lateinit 完整實作指南 簡介 在 Kotlin 開發中，lateinit 關鍵字提供了一種延遲初始化屬性的優雅方式，特別適用於依賴注入、Android 開發和 Spring Boot 應用。本文將深入探討 lateinit 的工作原理、使用場景、與 lazy 的比較，以及在企業級開發中的最佳實踐。\nlateinit 基本概念 核心特性 lateinit 是 Kotlin 提供的延遲初始化修飾符，允許開發者聲明非空屬性而不需要立即初始化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class UserService { // 延遲初始化，避免空值檢查 lateinit var userRepository: UserRepository lateinit var cacheManager: CacheManager fun initializeServices() { userRepository = UserRepositoryImpl() cacheManager = RedisCacheManager() } fun findUser(id: Long): User { // 直接使用，無需空值檢查 return userRepository.findById(id) ?: throw UserNotFoundException(id) } } 語法規則與限制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class PropertyRules { // ✅ 正確：var 屬性 lateinit var validProperty: String // ❌ 錯誤：lateinit 不能用於 val // lateinit val invalidProperty: String // 編譯錯誤 // ❌ 錯誤：原始類型不支援 // lateinit var invalidInt: Int // 編譯錯誤 // ❌ 錯誤：可空類型不支援 // lateinit var invalidNullable: String? // 編譯錯誤 // ✅ 正確：自定義類別 lateinit var database: Database // ✅ 正確：介面類型 lateinit var service: ServiceInterface } lateinit 詳細機制 內部實現原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Kotlin 編譯後的 Java 等效代碼 public class UserService { private String name; public final String getName() { String var1 = this.name; if (var1 == null) { Intrinsics.throwUninitializedPropertyAccessException(\u0026#34;name\u0026#34;); } return var1; } public final void setName(String value) { Intrinsics.checkNotNullParameter(value, \u0026#34;value\u0026#34;); this.name = value; } } 初始化檢查機制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class InitializationChecker { lateinit var database: Database lateinit var config: AppConfig fun checkInitialization() { // 檢查是否已初始化 if (::database.isInitialized) { println(\u0026#34;Database is ready\u0026#34;) } else { println(\u0026#34;Database not initialized\u0026#34;) } // 安全初始化模式 if (!::config.isInitialized) { config = loadDefaultConfig() } } fun safeAccess(): String { return if (::database.isInitialized) { database.getConnectionInfo() } else { \u0026#34;Database not available\u0026#34; } } } 企業級應用場景 1. Spring Boot 依賴注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @Service class UserManagementService { @Autowired lateinit var userRepository: UserRepository @Autowired lateinit var emailService: EmailService @Autowired lateinit var auditService: AuditService @Value(\u0026#34;\\${app.user.max-login-attempts}\u0026#34;) lateinit var maxLoginAttempts: String @PostConstruct fun validateDependencies() { require(::userRepository.isInitialized) { \u0026#34;UserRepository not injected\u0026#34; } require(::emailService.isInitialized) { \u0026#34;EmailService not injected\u0026#34; } require(::auditService.isInitialized) { \u0026#34;AuditService not injected\u0026#34; } logger.info(\u0026#34;All dependencies initialized successfully\u0026#34;) } fun createUser(userData: UserCreateRequest): User { val user = User( email = userData.email, username = userData.username, hashedPassword = hashPassword(userData.password) ) val savedUser = userRepository.save(user) // 發送歡迎郵件 emailService.sendWelcomeEmail(savedUser) // 記錄審計日誌 auditService.logUserCreation(savedUser) return savedUser } companion object { private val logger = LoggerFactory.getLogger(UserManagementService::class.java) } } 2. Android 開發中的應用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class MainActivity : AppCompatActivity() { // View 元件延遲初始化 lateinit var recyclerView: RecyclerView lateinit var adapter: UserAdapter lateinit var viewModel: UserViewModel // 網路元件 lateinit var apiService: ApiService lateinit var networkManager: NetworkManager override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initializeViews() initializeNetwork() initializeViewModel() setupObservers() } private fun initializeViews() { recyclerView = findViewById(R.id.recyclerView) adapter = UserAdapter { user -\u0026gt; onUserClicked(user) } recyclerView.adapter = adapter recyclerView.layoutManager = LinearLayoutManager(this) } private fun initializeNetwork() { apiService = RetrofitBuilder.createApiService() networkManager = NetworkManager(this) } private fun initializeViewModel() { viewModel = ViewModelProvider(this)[UserViewModel::class.java] } private fun setupObservers() { // 確保所有元件都已初始化 require(::viewModel.isInitialized) { \u0026#34;ViewModel not initialized\u0026#34; } require(::adapter.isInitialized) { \u0026#34;Adapter not initialized\u0026#34; } viewModel.users.observe(this) { users -\u0026gt; adapter.submitList(users) } viewModel.loading.observe(this) { isLoading -\u0026gt; // 處理載入狀態 } } private fun onUserClicked(user: User) { if (::networkManager.isInitialized \u0026amp;\u0026amp; networkManager.isConnected()) { // 處理用戶點擊事件 viewModel.loadUserDetails(user.id) } else { showNoNetworkError() } } } 3. 配置管理系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @Component class ConfigurationManager { @Value(\u0026#34;\\${database.url}\u0026#34;) lateinit var databaseUrl: String @Value(\u0026#34;\\${database.username}\u0026#34;) lateinit var databaseUsername: String @Value(\u0026#34;\\${redis.host}\u0026#34;) lateinit var redisHost: String @Value(\u0026#34;\\${jwt.secret}\u0026#34;) lateinit var jwtSecret: String lateinit var databaseConfig: DatabaseConfig lateinit var redisConfig: RedisConfig lateinit var securityConfig: SecurityConfig @PostConstruct fun initializeConfigurations() { validateRequiredProperties() buildConfigurations() logConfigurationStatus() } private fun validateRequiredProperties() { val errors = mutableListOf\u0026lt;String\u0026gt;() if (!::databaseUrl.isInitialized || databaseUrl.isBlank()) { errors.add(\u0026#34;Database URL not configured\u0026#34;) } if (!::databaseUsername.isInitialized || databaseUsername.isBlank()) { errors.add(\u0026#34;Database username not configured\u0026#34;) } if (!::redisHost.isInitialized || redisHost.isBlank()) { errors.add(\u0026#34;Redis host not configured\u0026#34;) } if (!::jwtSecret.isInitialized || jwtSecret.isBlank()) { errors.add(\u0026#34;JWT secret not configured\u0026#34;) } if (errors.isNotEmpty()) { throw ConfigurationException(\u0026#34;Configuration errors: ${errors.joinToString(\u0026#34;, \u0026#34;)}\u0026#34;) } } private fun buildConfigurations() { databaseConfig = DatabaseConfig( url = databaseUrl, username = databaseUsername, maxPoolSize = 20, connectionTimeout = Duration.ofSeconds(30) ) redisConfig = RedisConfig( host = redisHost, port = 6379, timeout = Duration.ofSeconds(10) ) securityConfig = SecurityConfig( jwtSecret = jwtSecret, tokenExpiration = Duration.ofHours(24), refreshTokenExpiration = Duration.ofDays(7) ) } private fun logConfigurationStatus() { logger.info(\u0026#34;Configuration initialized successfully:\u0026#34;) logger.info(\u0026#34;- Database: ${databaseConfig.url}\u0026#34;) logger.info(\u0026#34;- Redis: ${redisConfig.host}:${redisConfig.port}\u0026#34;) logger.info(\u0026#34;- Security: JWT configured with ${securityConfig.tokenExpiration} expiration\u0026#34;) } fun getDatabaseConfig(): DatabaseConfig { require(::databaseConfig.isInitialized) { \u0026#34;Database configuration not initialized\u0026#34; } return databaseConfig } fun getRedisConfig(): RedisConfig { require(::redisConfig.isInitialized) { \u0026#34;Redis configuration not initialized\u0026#34; } return redisConfig } fun getSecurityConfig(): SecurityConfig { require(::securityConfig.isInitialized) { \u0026#34;Security configuration not initialized\u0026#34; } return securityConfig } companion object { private val logger = LoggerFactory.getLogger(ConfigurationManager::class.java) } } lateinit vs lazy 詳細比較 特性對比表 特性 lateinit lazy 初始化時機 手動控制 首次訪問時 線程安全 否 是（預設） 可變性 var（可重新賦值） val（不可變） 初始化檢查 ::property.isInitialized 無需檢查 記憶體開銷 低 略高（Lazy包裝） 適用場景 依賴注入、外部初始化 延遲計算、高開銷操作 使用場景比較 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class ComparisonExample { // lateinit：適合依賴注入 @Autowired lateinit var repository: UserRepository // lazy：適合計算密集型初始化 private val expensiveResource: DatabaseConnection by lazy { createDatabaseConnection() // 僅在首次使用時執行 } // lateinit：可重新賦值 lateinit var currentUser: User fun switchUser(newUser: User) { currentUser = newUser // 可以重新賦值 } // lazy：線程安全的單例初始化 private val singleton: ServiceManager by lazy(LazyThreadSafetyMode.SYNCHRONIZED) { ServiceManager.create() } // lateinit：手動控制初始化時機 lateinit var testDatabase: TestDatabase @BeforeEach fun setupTest() { testDatabase = createTestDatabase() } @AfterEach fun cleanupTest() { if (::testDatabase.isInitialized) { testDatabase.cleanup() } } } 進階使用模式 1. 條件初始化模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class ConditionalInitialization { lateinit var primaryDatabase: Database lateinit var secondaryDatabase: Database fun initializeDatabases(config: DatabaseConfig) { // 主資料庫總是初始化 primaryDatabase = createDatabase(config.primary) // 次要資料庫僅在啟用時初始化 if (config.enableSecondary) { secondaryDatabase = createDatabase(config.secondary) } } fun executeQuery(query: String): QueryResult { val result = primaryDatabase.execute(query) // 安全地使用次要資料庫 if (::secondaryDatabase.isInitialized) { secondaryDatabase.logQuery(query, result) } return result } } 2. 初始化鏈模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class InitializationChain { lateinit var configService: ConfigService lateinit var databaseService: DatabaseService lateinit var cacheService: CacheService lateinit var businessService: BusinessService fun initializeAll() { initializeConfig() initializeDatabase() initializeCache() initializeBusiness() validateInitialization() } private fun initializeConfig() { configService = ConfigService() logger.info(\u0026#34;Config service initialized\u0026#34;) } private fun initializeDatabase() { require(::configService.isInitialized) { \u0026#34;Config service must be initialized first\u0026#34; } databaseService = DatabaseService(configService.getDatabaseConfig()) logger.info(\u0026#34;Database service initialized\u0026#34;) } private fun initializeCache() { require(::configService.isInitialized) { \u0026#34;Config service must be initialized first\u0026#34; } cacheService = CacheService(configService.getCacheConfig()) logger.info(\u0026#34;Cache service initialized\u0026#34;) } private fun initializeBusiness() { require(::databaseService.isInitialized) { \u0026#34;Database service must be initialized first\u0026#34; } require(::cacheService.isInitialized) { \u0026#34;Cache service must be initialized first\u0026#34; } businessService = BusinessService(databaseService, cacheService) logger.info(\u0026#34;Business service initialized\u0026#34;) } private fun validateInitialization() { val errors = mutableListOf\u0026lt;String\u0026gt;() if (!::configService.isInitialized) errors.add(\u0026#34;ConfigService\u0026#34;) if (!::databaseService.isInitialized) errors.add(\u0026#34;DatabaseService\u0026#34;) if (!::cacheService.isInitialized) errors.add(\u0026#34;CacheService\u0026#34;) if (!::businessService.isInitialized) errors.add(\u0026#34;BusinessService\u0026#34;) if (errors.isNotEmpty()) { throw InitializationException(\u0026#34;未初始化的服務: ${errors.joinToString(\u0026#34;, \u0026#34;)}\u0026#34;) } logger.info(\u0026#34;所有服務初始化完成\u0026#34;) } companion object { private val logger = LoggerFactory.getLogger(InitializationChain::class.java) } } 3. 資源管理模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class ResourceManager : AutoCloseable { lateinit var connectionPool: ConnectionPool lateinit var cacheManager: CacheManager lateinit var fileManager: FileManager private val initializedResources = mutableSetOf\u0026lt;String\u0026gt;() fun initializeConnectionPool(config: ConnectionConfig) { connectionPool = ConnectionPool.create(config) initializedResources.add(\u0026#34;connectionPool\u0026#34;) logger.info(\u0026#34;Connection pool initialized with ${config.maxConnections} connections\u0026#34;) } fun initializeCacheManager(config: CacheConfig) { cacheManager = CacheManager.create(config) initializedResources.add(\u0026#34;cacheManager\u0026#34;) logger.info(\u0026#34;Cache manager initialized with ${config.maxSize} max size\u0026#34;) } fun initializeFileManager(config: FileConfig) { fileManager = FileManager.create(config) initializedResources.add(\u0026#34;fileManager\u0026#34;) logger.info(\u0026#34;File manager initialized with root: ${config.rootPath}\u0026#34;) } fun getResourceStatus(): Map\u0026lt;String, Boolean\u0026gt; { return mapOf( \u0026#34;connectionPool\u0026#34; to ::connectionPool.isInitialized, \u0026#34;cacheManager\u0026#34; to ::cacheManager.isInitialized, \u0026#34;fileManager\u0026#34; to ::fileManager.isInitialized ) } override fun close() { logger.info(\u0026#34;開始關閉資源管理器\u0026#34;) // 按相反順序關閉資源 if (::fileManager.isInitialized) { try { fileManager.close() logger.info(\u0026#34;File manager closed\u0026#34;) } catch (e: Exception) { logger.error(\u0026#34;Error closing file manager\u0026#34;, e) } } if (::cacheManager.isInitialized) { try { cacheManager.close() logger.info(\u0026#34;Cache manager closed\u0026#34;) } catch (e: Exception) { logger.error(\u0026#34;Error closing cache manager\u0026#34;, e) } } if (::connectionPool.isInitialized) { try { connectionPool.close() logger.info(\u0026#34;Connection pool closed\u0026#34;) } catch (e: Exception) { logger.error(\u0026#34;Error closing connection pool\u0026#34;, e) } } initializedResources.clear() logger.info(\u0026#34;資源管理器關閉完成\u0026#34;) } companion object { private val logger = LoggerFactory.getLogger(ResourceManager::class.java) } } 測試策略 1. 單元測試模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class UserServiceTest { @Mock lateinit var userRepository: UserRepository @Mock lateinit var emailService: EmailService @InjectMocks lateinit var userService: UserService @BeforeEach fun setup() { MockitoAnnotations.openMocks(this) // 驗證依賴注入是否成功 assertTrue(::userRepository.isInitialized, \u0026#34;UserRepository should be initialized\u0026#34;) assertTrue(::emailService.isInitialized, \u0026#34;EmailService should be initialized\u0026#34;) assertTrue(::userService.isInitialized, \u0026#34;UserService should be initialized\u0026#34;) } @Test fun `should create user successfully`() { // Given val userData = UserCreateRequest( email = \u0026#34;test@example.com\u0026#34;, username = \u0026#34;testuser\u0026#34; ) val expectedUser = User(1L, \u0026#34;test@example.com\u0026#34;, \u0026#34;testuser\u0026#34;) `when`(userRepository.save(any())).thenReturn(expectedUser) doNothing().`when`(emailService).sendWelcomeEmail(any()) // When val result = userService.createUser(userData) // Then assertEquals(expectedUser, result) verify(userRepository).save(any()) verify(emailService).sendWelcomeEmail(expectedUser) } @Test fun `should handle uninitialized dependencies gracefully`() { // 測試未初始化的情況 val service = UserService() assertFalse(service::userRepository.isInitialized) assertFalse(service::emailService.isInitialized) assertThrows\u0026lt;UninitializedPropertyAccessException\u0026gt; { service.createUser(UserCreateRequest(\u0026#34;test@example.com\u0026#34;, \u0026#34;test\u0026#34;)) } } } 2. 整合測試模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @SpringBootTest @TestPropertySource(properties = [ \u0026#34;spring.datasource.url=jdbc:h2:mem:testdb\u0026#34;, \u0026#34;spring.jpa.hibernate.ddl-auto=create-drop\u0026#34; ]) class UserServiceIntegrationTest { @Autowired lateinit var userService: UserService @Autowired lateinit var userRepository: UserRepository @TestConfiguration class TestConfig { @Bean @Primary fun mockEmailService(): EmailService = mockk(relaxed = true) } @Test fun `should initialize all dependencies in Spring context`() { // 驗證 Spring 上下文中的依賴注入 assertTrue(userService::userRepository.isInitialized) assertTrue(userService::emailService.isInitialized) // 執行實際的業務邏輯測試 val userData = UserCreateRequest(\u0026#34;integration@test.com\u0026#34;, \u0026#34;integrationuser\u0026#34;) val result = userService.createUser(userData) assertNotNull(result.id) assertEquals(\u0026#34;integration@test.com\u0026#34;, result.email) assertEquals(\u0026#34;integrationuser\u0026#34;, result.username) // 驗證資料實際儲存 val savedUser = userRepository.findById(result.id!!) assertTrue(savedUser.isPresent) assertEquals(result.email, savedUser.get().email) } } 效能優化與最佳實踐 1. 記憶體管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class MemoryOptimizedService { // 大型物件使用 lateinit 延遲初始化 lateinit var largeDataSet: LargeDataSet lateinit var heavyProcessor: HeavyProcessor // 小型配置物件可以直接初始化 private val config = ServiceConfig() fun initializeHeavyResources() { if (!::largeDataSet.isInitialized) { largeDataSet = LargeDataSet.loadFromDatabase() logger.info(\u0026#34;Large dataset loaded: ${largeDataSet.size} records\u0026#34;) } if (!::heavyProcessor.isInitialized) { heavyProcessor = HeavyProcessor(largeDataSet) logger.info(\u0026#34;Heavy processor initialized\u0026#34;) } } fun processDataIfReady(input: String): String? { return if (::heavyProcessor.isInitialized) { heavyProcessor.process(input) } else { logger.warn(\u0026#34;Heavy processor not initialized, skipping processing\u0026#34;) null } } // 清理資源 fun cleanup() { if (::heavyProcessor.isInitialized) { heavyProcessor.cleanup() } if (::largeDataSet.isInitialized) { largeDataSet.cleanup() } } companion object { private val logger = LoggerFactory.getLogger(MemoryOptimizedService::class.java) } } 2. 線程安全考量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class ThreadSafeService { @Volatile lateinit var sharedResource: SharedResource private val initializationLock = ReentrantLock() private val condition = initializationLock.newCondition() fun initializeSharedResource(config: ResourceConfig) { initializationLock.withLock { if (!::sharedResource.isInitialized) { sharedResource = SharedResource.create(config) condition.signalAll() // 通知等待的線程 logger.info(\u0026#34;Shared resource initialized\u0026#34;) } } } fun accessSharedResource(): String { // 等待初始化完成 initializationLock.withLock { while (!::sharedResource.isInitialized) { condition.await(5, TimeUnit.SECONDS) if (!::sharedResource.isInitialized) { throw TimeoutException(\u0026#34;Shared resource initialization timeout\u0026#34;) } } } return sharedResource.getData() } fun isResourceReady(): Boolean { return ::sharedResource.isInitialized } companion object { private val logger = LoggerFactory.getLogger(ThreadSafeService::class.java) } } 常見陷阱與錯誤處理 1. 常見錯誤模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class CommonMistakes { lateinit var service: SomeService // ❌ 錯誤：在初始化前訪問 fun badExample1() { service.doSomething() // UninitializedPropertyAccessException } // ❌ 錯誤：忘記檢查初始化狀態 fun badExample2() { val result = service.getData() // 可能未初始化 return result } // ✅ 正確：檢查後訪問 fun goodExample1() { if (::service.isInitialized) { service.doSomething() } else { logger.warn(\u0026#34;Service not initialized\u0026#34;) } } // ✅ 正確：防禦性初始化 fun goodExample2(): String { if (!::service.isInitialized) { service = SomeService.createDefault() } return service.getData() } } 2. 錯誤處理策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ErrorHandlingService { lateinit var primaryService: PrimaryService lateinit var backupService: BackupService fun processRequest(request: Request): Response { return try { // 嘗試使用主要服務 if (::primaryService.isInitialized) { primaryService.process(request) } else { throw ServiceNotInitializedException(\u0026#34;Primary service not available\u0026#34;) } } catch (e: ServiceNotInitializedException) { logger.warn(\u0026#34;Primary service unavailable, falling back to backup\u0026#34;, e) // 備援服務處理 if (::backupService.isInitialized) { backupService.process(request) } else { throw ServiceUnavailableException(\u0026#34;No services available\u0026#34;) } } catch (e: Exception) { logger.error(\u0026#34;Unexpected error processing request\u0026#34;, e) throw ProcessingException(\u0026#34;Failed to process request\u0026#34;, e) } } fun healthCheck(): HealthStatus { val status = HealthStatus() status.primaryServiceAvailable = ::primaryService.isInitialized status.backupServiceAvailable = ::backupService.isInitialized status.overallStatus = when { status.primaryServiceAvailable -\u0026gt; HealthStatus.Status.HEALTHY status.backupServiceAvailable -\u0026gt; HealthStatus.Status.DEGRADED else -\u0026gt; HealthStatus.Status.UNHEALTHY } return status } companion object { private val logger = LoggerFactory.getLogger(ErrorHandlingService::class.java) } } 企業級最佳實踐 1. 初始化驗證框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @Component class InitializationValidator { fun validateObject(obj: Any): ValidationResult { val result = ValidationResult() val clazz = obj::class // 使用反射檢查所有 lateinit 屬性 clazz.memberProperties .filterIsInstance\u0026lt;KMutableProperty1\u0026lt;Any, Any\u0026gt;\u0026gt;() .filter { it.isLateinit } .forEach { property -\u0026gt; try { if (!property.isInitialized(obj)) { result.addError(\u0026#34;Property \u0026#39;${property.name}\u0026#39; is not initialized\u0026#34;) } else { result.addSuccess(\u0026#34;Property \u0026#39;${property.name}\u0026#39; is initialized\u0026#34;) } } catch (e: Exception) { result.addError(\u0026#34;Error checking property \u0026#39;${property.name}\u0026#39;: ${e.message}\u0026#34;) } } return result } @EventListener fun onApplicationReady(event: ApplicationReadyEvent) { logger.info(\u0026#34;開始驗證應用程式初始化狀態\u0026#34;) val context = event.applicationContext val beanNames = context.beanDefinitionNames var totalBeans = 0 var validatedBeans = 0 var errorCount = 0 beanNames.forEach { beanName -\u0026gt; try { val bean = context.getBean(beanName) totalBeans++ val result = validateObject(bean) if (result.hasErrors()) { logger.warn(\u0026#34;Bean \u0026#39;$beanName\u0026#39; has initialization issues: ${result.getErrors()}\u0026#34;) errorCount += result.getErrorCount() } else { validatedBeans++ } } catch (e: Exception) { logger.debug(\u0026#34;Skipped validation for bean \u0026#39;$beanName\u0026#39;: ${e.message}\u0026#34;) } } logger.info(\u0026#34;初始化驗證完成: $validatedBeans/$totalBeans beans validated, $errorCount errors found\u0026#34;) } companion object { private val logger = LoggerFactory.getLogger(InitializationValidator::class.java) } } data class ValidationResult( private val errors: MutableList\u0026lt;String\u0026gt; = mutableListOf(), private val successes: MutableList\u0026lt;String\u0026gt; = mutableListOf() ) { fun addError(error: String) = errors.add(error) fun addSuccess(success: String) = successes.add(success) fun hasErrors() = errors.isNotEmpty() fun getErrors() = errors.toList() fun getSuccesses() = successes.toList() fun getErrorCount() = errors.size } 2. 監控與診斷 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @Component class LateinitMonitor { private val meterRegistry: MeterRegistry = Metrics.globalRegistry private val initializationTimer = Timer.builder(\u0026#34;lateinit.initialization.time\u0026#34;) .description(\u0026#34;Time taken to initialize lateinit properties\u0026#34;) .register(meterRegistry) fun \u0026lt;T\u0026gt; monitorInitialization( propertyName: String, initializer: () -\u0026gt; T ): T { return Timer.Sample.start(meterRegistry).use { sample -\u0026gt; try { val result = initializer() // 記錄成功的初始化 Counter.builder(\u0026#34;lateinit.initialization.success\u0026#34;) .tag(\u0026#34;property\u0026#34;, propertyName) .register(meterRegistry) .increment() sample.stop(initializationTimer.withTag(\u0026#34;property\u0026#34;, propertyName)) logger.info(\u0026#34;Successfully initialized property: $propertyName\u0026#34;) result } catch (e: Exception) { // 記錄失敗的初始化 Counter.builder(\u0026#34;lateinit.initialization.failure\u0026#34;) .tag(\u0026#34;property\u0026#34;, propertyName) .tag(\u0026#34;error\u0026#34;, e.javaClass.simpleName) .register(meterRegistry) .increment() logger.error(\u0026#34;Failed to initialize property: $propertyName\u0026#34;, e) throw e } } } @Scheduled(fixedRate = 60000) // 每分鐘檢查一次 fun reportInitializationStatus() { val successCount = meterRegistry.counter(\u0026#34;lateinit.initialization.success\u0026#34;).count() val failureCount = meterRegistry.counter(\u0026#34;lateinit.initialization.failure\u0026#34;).count() val totalCount = successCount + failureCount if (totalCount \u0026gt; 0) { val successRate = (successCount / totalCount) * 100 logger.info(\u0026#34;Lateinit initialization statistics - Success rate: ${\u0026#34;%.2f\u0026#34;.format(successRate)}% ($successCount/$totalCount)\u0026#34;) } } companion object { private val logger = LoggerFactory.getLogger(LateinitMonitor::class.java) } } 效能基準測試 初始化效能比較 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) @State(Scope.Benchmark) class LateinitPerformanceBenchmark { // 測試類別 class LateinitExample { lateinit var service: ExpensiveService fun initializeService() { service = ExpensiveService() } } class LazyExample { private val service: ExpensiveService by lazy { ExpensiveService() } fun getService(): ExpensiveService = service } class EagerExample { private val service: ExpensiveService = ExpensiveService() fun getService(): ExpensiveService = service } @Benchmark fun lateinitInitialization(): ExpensiveService { val example = LateinitExample() example.initializeService() return example.service } @Benchmark fun lazyInitialization(): ExpensiveService { val example = LazyExample() return example.getService() } @Benchmark fun eagerInitialization(): ExpensiveService { val example = EagerExample() return example.getService() } @Benchmark fun lateinitAccessAfterInit(): String { val example = LateinitExample() example.initializeService() return example.service.getData() // 訪問已初始化的屬性 } @Benchmark fun lazyAccess(): String { val example = LazyExample() example.getService() // 首次訪問，觸發初始化 return example.getService().getData() // 再次訪問，使用快取值 } } 總結 lateinit 是 Kotlin 中強大的延遲初始化機制，特別適用於：\n依賴注入場景：Spring Boot、Android 等框架的依賴注入 外部初始化：需要在物件創建後由外部代碼初始化的屬性 測試場景：Mock 物件和測試設置 條件初始化：根據運行時條件決定是否初始化的屬性 關鍵最佳實踐 總是檢查初始化狀態：使用 ::property.isInitialized 進行安全檢查 提供錯誤處理：妥善處理 UninitializedPropertyAccessException 文檔化初始化需求：清楚說明何時和如何初始化屬性 考慮線程安全：在多線程環境中使用適當的同步機制 監控和診斷：在生產環境中監控初始化狀態和效能 選擇 lateinit 還是 lazy 取決於具體需求：使用 lateinit 進行手動控制的延遲初始化，使用 lazy 進行自動的懶加載。正確使用這些機制可以顯著改善應用程式的效能和記憶體使用效率。\n","permalink":"https://xinqilin.github.io/post/backend/lateinit/","tags":["Kotlin","lateinit","lazy","Property Initialization","Android","Spring Boot","Dependency Injection","Performance","Memory Management","Best Practices","Enterprise","Thread Safety","Reflection","Testing"],"title":"Kotlin lateinit 完整實作指南：延遲初始化與企業級開發最佳實踐"},{"content":"概述 cURL（Client URL）是一個功能強大的命令行工具和函式庫，用於傳輸各種網路協定的資料。它支援 HTTP、HTTPS、FTP、SFTP、TELNET 等多種協定，是開發者進行 API 測試、網路除錯和自動化腳本的必備工具。\n核心特徵 多協定支援：HTTP/HTTPS、FTP、SFTP、SMTP、POP3 等 豐富的選項：支援各種 HTTP 方法、標頭、認證方式 跨平台：適用於 Linux、macOS、Windows 等系統 腳本友好：輸出格式化，適合自動化處理 安全性：支援 SSL/TLS、各種認證機制 基本語法 1 curl [選項] [URL] 簡單範例 1 2 3 4 5 6 7 8 9 10 11 # 基本 GET 請求 curl https://httpbin.org/get # 查看 HTTP 響應標頭 curl -I https://google.com # 下載檔案 curl -o filename.html https://example.com # 靜默模式 curl -s https://api.github.com/users/octocat 核心選項詳解 基本操作選項 1 2 3 4 5 6 7 8 9 10 11 12 13 # 輸出控制 -o, --output \u0026lt;file\u0026gt; # 將輸出寫入檔案 -O, --remote-name # 使用遠程檔案名稱儲存 -s, --silent # 靜默模式，不顯示進度 -S, --show-error # 顯示錯誤訊息 -v, --verbose # 詳細輸出模式 -w, --write-out \u0026lt;format\u0026gt; # 自訂輸出格式 # 基本範例 curl -o index.html https://example.com curl -O https://example.com/file.zip curl -s https://api.example.com/data curl -v https://httpbin.org/get HTTP 方法選項 1 2 3 4 5 6 7 8 9 10 11 # 請求方法 -X, --request \u0026lt;method\u0026gt; # 指定 HTTP 方法 -G, --get # 強制使用 GET 方法 -I, --head # 只獲取 HTTP 標頭 (HEAD 方法) # 範例 curl -X POST https://httpbin.org/post curl -X PUT https://httpbin.org/put curl -X DELETE https://httpbin.org/delete curl -X PATCH https://httpbin.org/patch curl -I https://httpbin.org/headers 資料傳送選項 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 資料傳送 -d, --data \u0026lt;data\u0026gt; # 發送 POST 資料 -d @filename # 從檔案讀取資料 -F, --form \u0026lt;name=content\u0026gt; # 表單資料 (multipart/form-data) -T, --upload-file \u0026lt;file\u0026gt; # 上傳檔案 # JSON 資料範例 curl -X POST https://httpbin.org/post \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 30}\u0026#39; # 表單資料範例 curl -X POST https://httpbin.org/post \\ -F \u0026#34;name=John\u0026#34; \\ -F \u0026#34;file=@upload.txt\u0026#34; # 從檔案讀取資料 curl -X POST https://httpbin.org/post \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d @data.json HTTP 標頭選項 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 標頭設定 -H, --header \u0026lt;header\u0026gt; # 添加自訂標頭 -A, --user-agent \u0026lt;agent\u0026gt; # 設定 User-Agent -e, --referer \u0026lt;URL\u0026gt; # 設定 Referer -i, --include # 在輸出中包含響應標頭 # 範例 curl -H \u0026#34;Authorization: Bearer token123\u0026#34; https://api.example.com curl -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;Accept: application/json\u0026#34; \\ https://api.example.com curl -A \u0026#34;MyApp/1.0\u0026#34; https://httpbin.org/user-agent curl -e \u0026#34;https://google.com\u0026#34; https://httpbin.org/headers curl -i https://httpbin.org/get HTTP 方法應用 GET 請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 基本 GET 請求 curl https://jsonplaceholder.typicode.com/posts # 帶查詢參數的 GET curl \u0026#34;https://jsonplaceholder.typicode.com/posts?userId=1\u0026#34; # 使用 -G 和 -d 構建查詢字串 curl -G -d \u0026#34;userId=1\u0026#34; -d \u0026#34;id=1\u0026#34; https://jsonplaceholder.typicode.com/posts # 帶認證的 GET curl -H \u0026#34;Authorization: Bearer your-token\u0026#34; https://api.example.com/user # 自訂 User-Agent curl -A \u0026#34;Mozilla/5.0 (Custom Agent)\u0026#34; https://httpbin.org/user-agent POST 請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # JSON 資料 POST curl -X POST https://jsonplaceholder.typicode.com/posts \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;title\u0026#34;: \u0026#34;New Post\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;This is the content\u0026#34;, \u0026#34;userId\u0026#34;: 1 }\u0026#39; # 表單資料 POST curl -X POST https://httpbin.org/post \\ -d \u0026#34;username=john\u0026#34; \\ -d \u0026#34;password=secret\u0026#34; # 檔案上傳 POST curl -X POST https://httpbin.org/post \\ -F \u0026#34;file=@document.pdf\u0026#34; \\ -F \u0026#34;description=Important document\u0026#34; # URL 編碼資料 curl -X POST https://httpbin.org/post \\ -H \u0026#34;Content-Type: application/x-www-form-urlencoded\u0026#34; \\ -d \u0026#34;name=John%20Doe\u0026amp;email=john%40example.com\u0026#34; PUT 和 PATCH 請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # PUT 更新資源 curl -X PUT https://jsonplaceholder.typicode.com/posts/1 \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;Updated Title\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Updated content\u0026#34;, \u0026#34;userId\u0026#34;: 1 }\u0026#39; # PATCH 部分更新 curl -X PATCH https://jsonplaceholder.typicode.com/posts/1 \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;title\u0026#34;: \u0026#34;Partially Updated Title\u0026#34;}\u0026#39; # 檔案替換上傳 curl -X PUT https://api.example.com/files/document.pdf \\ -T document.pdf \\ -H \u0026#34;Authorization: Bearer token\u0026#34; DELETE 請求 1 2 3 4 5 6 7 8 9 10 11 # 基本 DELETE curl -X DELETE https://jsonplaceholder.typicode.com/posts/1 # 帶認證的 DELETE curl -X DELETE https://api.example.com/users/123 \\ -H \u0026#34;Authorization: Bearer your-token\u0026#34; # 帶確認資料的 DELETE curl -X DELETE https://api.example.com/dangerous-action \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;confirm\u0026#34;: true, \u0026#34;reason\u0026#34;: \u0026#34;No longer needed\u0026#34;}\u0026#39; 認證與安全 基本認證 1 2 3 4 5 6 7 8 9 # HTTP Basic Authentication curl -u username:password https://httpbin.org/basic-auth/username/password # 從提示輸入密碼 curl -u username https://httpbin.org/basic-auth/username/password # 使用 Base64 編碼 curl -H \u0026#34;Authorization: Basic $(echo -n username:password | base64)\u0026#34; \\ https://httpbin.org/basic-auth/username/password Bearer Token 認證 1 2 3 4 5 6 7 8 9 # JWT Token curl -H \u0026#34;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\u0026#34; \\ https://api.example.com/protected # API Key in Header curl -H \u0026#34;X-API-Key: your-api-key\u0026#34; https://api.example.com/data # API Key in Query curl \u0026#34;https://api.example.com/data?api_key=your-api-key\u0026#34; OAuth 2.0 1 2 3 4 5 6 7 8 9 10 # 獲取存取令牌 curl -X POST https://oauth.example.com/token \\ -H \u0026#34;Content-Type: application/x-www-form-urlencoded\u0026#34; \\ -d \u0026#34;grant_type=client_credentials\u0026#34; \\ -d \u0026#34;client_id=your-client-id\u0026#34; \\ -d \u0026#34;client_secret=your-client-secret\u0026#34; # 使用存取令牌 curl -H \u0026#34;Authorization: Bearer access-token\u0026#34; \\ https://api.example.com/protected-resource SSL/TLS 選項 1 2 3 4 5 6 7 8 9 10 # SSL 相關選項 -k, --insecure # 允許不安全的 SSL 連接 --cert \u0026lt;certificate\u0026gt; # 客戶端證書 --key \u0026lt;private-key\u0026gt; # 私鑰檔案 --cacert \u0026lt;CA-certificate\u0026gt; # CA 證書檔案 # 範例 curl -k https://self-signed.example.com curl --cert client.crt --key client.key https://secure.example.com curl --cacert ca-bundle.crt https://secure.example.com Cookie 處理 Cookie 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 發送 Cookie curl -b \u0026#34;session=abc123; user=john\u0026#34; https://httpbin.org/cookies # 從檔案讀取 Cookie curl -b cookies.txt https://httpbin.org/cookies # 儲存 Cookie 到檔案 curl -c cookies.txt https://httpbin.org/cookies/set/session/abc123 # 同時讀取和儲存 Cookie curl -b cookies.txt -c cookies.txt https://example.com/login # Cookie Jar 格式 curl -b cookie-jar.txt -c cookie-jar.txt https://example.com 會話管理 1 2 3 4 5 6 7 8 9 # 登入並保持會話 curl -c session.txt -d \u0026#34;username=john\u0026amp;password=secret\u0026#34; \\ https://example.com/login # 使用會話訪問受保護頁面 curl -b session.txt https://example.com/dashboard # 登出並清除會話 curl -b session.txt -c /dev/null https://example.com/logout 檔案傳輸 檔案下載 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 基本下載 curl -O https://example.com/file.zip # 自訂檔案名 curl -o myfile.zip https://example.com/file.zip # 斷點續傳 curl -C - -O https://example.com/largefile.zip # 限制下載速度 curl --limit-rate 100k -O https://example.com/file.zip # 下載多個檔案 curl -O https://example.com/file1.zip -O https://example.com/file2.zip # 使用範圍下載 curl -r 0-1023 https://example.com/file.txt # 下載前 1024 位元組 檔案上傳 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # FTP 上傳 curl -T localfile.txt ftp://ftp.example.com/remote/ # HTTP PUT 上傳 curl -T document.pdf https://api.example.com/upload # 表單檔案上傳 curl -F \u0026#34;file=@document.pdf\u0026#34; -F \u0026#34;title=My Document\u0026#34; \\ https://example.com/upload # 多檔案上傳 curl -F \u0026#34;file1=@doc1.pdf\u0026#34; -F \u0026#34;file2=@doc2.pdf\u0026#34; \\ https://example.com/upload # 帶進度條的上傳 curl -# -T largefile.zip https://api.example.com/upload 進階功能 輸出格式化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 自訂輸出格式 curl -w \u0026#34;Status: %{http_code}\\nTime: %{time_total}s\\nSize: %{size_download} bytes\\n\u0026#34; \\ -o /dev/null -s https://example.com # 常用格式變數 %{http_code} # HTTP 狀態碼 %{time_total} # 總耗時 %{time_connect} # 連接時間 %{time_starttransfer} # 開始傳輸時間 %{size_download} # 下載大小 %{size_upload} # 上傳大小 %{speed_download} # 下載速度 %{speed_upload} # 上傳速度 # 效能測試範例 curl -w \u0026#34;@curl-format.txt\u0026#34; -o /dev/null -s https://example.com 建立 curl-format.txt 檔案：\n1 2 3 4 5 6 7 8 time_namelookup: %{time_namelookup}s\\n time_connect: %{time_connect}s\\n time_appconnect: %{time_appconnect}s\\n time_pretransfer: %{time_pretransfer}s\\n time_redirect: %{time_redirect}s\\n time_starttransfer: %{time_starttransfer}s\\n ----------\\n time_total: %{time_total}s\\n 重定向處理 1 2 3 4 5 6 7 8 9 10 11 # 跟隨重定向 curl -L https://bit.ly/shortened-url # 限制重定向次數 curl -L --max-redirs 5 https://example.com # 顯示重定向過程 curl -L -v https://bit.ly/shortened-url # 不跟隨重定向（預設） curl https://bit.ly/shortened-url 代理設定 1 2 3 4 5 6 7 8 9 10 11 12 13 # HTTP 代理 curl --proxy http://proxy.example.com:8080 https://httpbin.org/ip # SOCKS 代理 curl --socks5 localhost:1080 https://httpbin.org/ip # 代理認證 curl --proxy-user username:password \\ --proxy http://proxy.example.com:8080 \\ https://httpbin.org/ip # 排除代理 curl --noproxy localhost,127.0.0.1 https://localhost:8080/api 並行請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 背景執行 curl https://api1.example.com \u0026amp; curl https://api2.example.com \u0026amp; curl https://api3.example.com \u0026amp; wait # 使用 xargs 並行 echo -e \u0026#34;https://api1.example.com\\nhttps://api2.example.com\u0026#34; | \\ xargs -n 1 -P 2 curl -s # 循環請求 for i in {1..5}; do curl -s \u0026#34;https://api.example.com/data/$i\u0026#34; \u0026amp; done wait API 測試實戰 REST API 測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 使用者管理 API 測試 BASE_URL=\u0026#34;https://jsonplaceholder.typicode.com\u0026#34; # 1. 獲取所有使用者 curl -s \u0026#34;$BASE_URL/users\u0026#34; | jq \u0026#39;.[0:3]\u0026#39; # 2. 獲取特定使用者 curl -s \u0026#34;$BASE_URL/users/1\u0026#34; | jq \u0026#39;.\u0026#39; # 3. 創建新使用者 curl -X POST \u0026#34;$BASE_URL/users\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;johndoe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34; }\u0026#39; | jq \u0026#39;.\u0026#39; # 4. 更新使用者 curl -X PUT \u0026#34;$BASE_URL/users/1\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Jane Doe\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;janedoe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;jane@example.com\u0026#34; }\u0026#39; | jq \u0026#39;.\u0026#39; # 5. 刪除使用者 curl -X DELETE \u0026#34;$BASE_URL/users/1\u0026#34; -w \u0026#34;Status: %{http_code}\\n\u0026#34; API 效能測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 響應時間測試 test_api_performance() { local url=\u0026#34;$1\u0026#34; local requests=\u0026#34;$2\u0026#34; echo \u0026#34;Testing $url with $requests requests...\u0026#34; for i in $(seq 1 $requests); do curl -w \u0026#34;%{time_total}\\n\u0026#34; -o /dev/null -s \u0026#34;$url\u0026#34; done | awk \u0026#39;{sum+=$1; count++} END {print \u0026#34;Average:\u0026#34;, sum/count \u0026#34;s\u0026#34;}\u0026#39; } test_api_performance \u0026#34;https://httpbin.org/delay/1\u0026#34; 5 # 並發測試 concurrent_test() { local url=\u0026#34;$1\u0026#34; local concurrent=\u0026#34;$2\u0026#34; local total=\u0026#34;$3\u0026#34; echo \u0026#34;Concurrent test: $concurrent parallel requests, $total total\u0026#34; seq 1 $total | xargs -n 1 -P $concurrent -I {} \\ curl -w \u0026#34;Request {}: %{time_total}s\\n\u0026#34; -o /dev/null -s \u0026#34;$url\u0026#34; } concurrent_test \u0026#34;https://httpbin.org/delay/1\u0026#34; 3 10 API 健康檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #!/bin/bash # api_health_check.sh check_api_health() { local name=\u0026#34;$1\u0026#34; local url=\u0026#34;$2\u0026#34; local expected_status=\u0026#34;$3\u0026#34; echo -n \u0026#34;Checking $name... \u0026#34; response=$(curl -s -w \u0026#34;HTTPSTATUS:%{http_code}\u0026#34; \u0026#34;$url\u0026#34;) http_code=$(echo \u0026#34;$response\u0026#34; | tr -d \u0026#39;\\n\u0026#39; | sed -E \u0026#39;s/.*HTTPSTATUS:([0-9]{3})$/\\1/\u0026#39;) body=$(echo \u0026#34;$response\u0026#34; | sed -E \u0026#39;s/HTTPSTATUS:[0-9]{3}$//\u0026#39;) if [ \u0026#34;$http_code\u0026#34; -eq \u0026#34;$expected_status\u0026#34; ]; then echo \u0026#34;✓ OK (HTTP $http_code)\u0026#34; return 0 else echo \u0026#34;✗ FAIL (HTTP $http_code)\u0026#34; echo \u0026#34;Response: $body\u0026#34; return 1 fi } # 健康檢查 check_api_health \u0026#34;Main API\u0026#34; \u0026#34;https://api.example.com/health\u0026#34; 200 check_api_health \u0026#34;User Service\u0026#34; \u0026#34;https://api.example.com/users/1\u0026#34; 200 check_api_health \u0026#34;Auth Service\u0026#34; \u0026#34;https://api.example.com/auth/status\u0026#34; 200 除錯與監控 詳細除錯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 詳細模式 curl -v https://httpbin.org/get # 追蹤 ASCII 格式 curl --trace-ascii debug.txt https://httpbin.org/get # 追蹤二進位格式 curl --trace debug.bin https://httpbin.org/get # 只顯示標頭 curl -I https://httpbin.org/get # 顯示請求和響應標頭 curl -D headers.txt https://httpbin.org/get 網路診斷 1 2 3 4 5 6 7 8 9 10 11 12 13 # DNS 解析時間 curl -w \u0026#34;DNS lookup: %{time_namelookup}s\\n\u0026#34; -o /dev/null -s https://example.com # 連接時間分析 curl -w \u0026#34;Connect: %{time_connect}s, Start transfer: %{time_starttransfer}s, Total: %{time_total}s\\n\u0026#34; \\ -o /dev/null -s https://example.com # 檢查 SSL 證書 curl -vI https://example.com 2\u0026gt;\u0026amp;1 | grep -E \u0026#34;(SSL|TLS|certificate)\u0026#34; # 測試不同 HTTP 版本 curl --http1.1 -I https://example.com curl --http2 -I https://example.com 錯誤處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 基本錯誤處理 if curl -s --fail https://api.example.com/data; then echo \u0026#34;Request successful\u0026#34; else echo \u0026#34;Request failed with exit code $?\u0026#34; fi # 詳細錯誤資訊 curl -s -w \u0026#34;Status: %{http_code}, Exit: %{exitcode}\\n\u0026#34; \\ https://httpbin.org/status/404 # 重試機制 retry_curl() { local url=\u0026#34;$1\u0026#34; local max_attempts=3 local attempt=1 while [ $attempt -le $max_attempts ]; do echo \u0026#34;Attempt $attempt of $max_attempts...\u0026#34; if curl -s --fail \u0026#34;$url\u0026#34;; then echo \u0026#34;Success on attempt $attempt\u0026#34; return 0 fi echo \u0026#34;Failed attempt $attempt\u0026#34; ((attempt++)) sleep 2 done echo \u0026#34;All attempts failed\u0026#34; return 1 } retry_curl \u0026#34;https://unstable-api.example.com\u0026#34; 實用腳本範例 1. API 批次測試腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #!/bin/bash # api_batch_test.sh API_BASE=\u0026#34;https://jsonplaceholder.typicode.com\u0026#34; AUTH_TOKEN=\u0026#34;your-auth-token\u0026#34; # 測試配置 declare -A TESTS=( [\u0026#34;GET /users\u0026#34;]=\u0026#34;$API_BASE/users\u0026#34; [\u0026#34;GET /posts\u0026#34;]=\u0026#34;$API_BASE/posts\u0026#34; [\u0026#34;GET /user/1\u0026#34;]=\u0026#34;$API_BASE/users/1\u0026#34; [\u0026#34;POST /posts\u0026#34;]=\u0026#34;$API_BASE/posts\u0026#34; ) # 執行測試 run_tests() { echo \u0026#34;Starting API batch tests...\u0026#34; echo \u0026#34;==========================\u0026#34; local passed=0 local failed=0 for test_name in \u0026#34;${!TESTS[@]}\u0026#34;; do local url=\u0026#34;${TESTS[$test_name]}\u0026#34; echo -n \u0026#34;Testing $test_name... \u0026#34; if [[ \u0026#34;$test_name\u0026#34; == \u0026#34;POST\u0026#34;* ]]; then # POST 測試 response=$(curl -s -w \u0026#34;HTTPSTATUS:%{http_code}\u0026#34; \\ -X POST \u0026#34;$url\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;Authorization: Bearer $AUTH_TOKEN\u0026#34; \\ -d \u0026#39;{\u0026#34;title\u0026#34;:\u0026#34;Test\u0026#34;,\u0026#34;body\u0026#34;:\u0026#34;Test content\u0026#34;,\u0026#34;userId\u0026#34;:1}\u0026#39;) else # GET 測試 response=$(curl -s -w \u0026#34;HTTPSTATUS:%{http_code}\u0026#34; \\ -H \u0026#34;Authorization: Bearer $AUTH_TOKEN\u0026#34; \\ \u0026#34;$url\u0026#34;) fi http_code=$(echo \u0026#34;$response\u0026#34; | tr -d \u0026#39;\\n\u0026#39; | sed -E \u0026#39;s/.*HTTPSTATUS:([0-9]{3})$/\\1/\u0026#39;) if [[ \u0026#34;$http_code\u0026#34; -ge 200 \u0026amp;\u0026amp; \u0026#34;$http_code\u0026#34; -lt 300 ]]; then echo \u0026#34;✓ PASS (HTTP $http_code)\u0026#34; ((passed++)) else echo \u0026#34;✗ FAIL (HTTP $http_code)\u0026#34; ((failed++)) fi done echo \u0026#34;==========================\u0026#34; echo \u0026#34;Results: $passed passed, $failed failed\u0026#34; } run_tests 2. 檔案同步腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #!/bin/bash # file_sync.sh LOCAL_DIR=\u0026#34;./local_files\u0026#34; REMOTE_BASE=\u0026#34;https://api.example.com/files\u0026#34; AUTH_TOKEN=\u0026#34;your-token\u0026#34; sync_files() { echo \u0026#34;Starting file synchronization...\u0026#34; # 獲取遠程檔案列表 remote_files=$(curl -s -H \u0026#34;Authorization: Bearer $AUTH_TOKEN\u0026#34; \\ \u0026#34;$REMOTE_BASE\u0026#34; | jq -r \u0026#39;.[].filename\u0026#39;) for file in $remote_files; do local_file=\u0026#34;$LOCAL_DIR/$file\u0026#34; remote_url=\u0026#34;$REMOTE_BASE/$file\u0026#34; echo -n \u0026#34;Checking $file... \u0026#34; if [ -f \u0026#34;$local_file\u0026#34; ]; then # 比較檔案雜湊 local_hash=$(sha256sum \u0026#34;$local_file\u0026#34; | cut -d\u0026#39; \u0026#39; -f1) remote_hash=$(curl -s -I -H \u0026#34;Authorization: Bearer $AUTH_TOKEN\u0026#34; \\ \u0026#34;$remote_url\u0026#34; | grep -i \u0026#34;x-file-hash\u0026#34; | cut -d\u0026#39; \u0026#39; -f2 | tr -d \u0026#39;\\r\u0026#39;) if [ \u0026#34;$local_hash\u0026#34; = \u0026#34;$remote_hash\u0026#34; ]; then echo \u0026#34;✓ Up to date\u0026#34; continue fi fi # 下載檔案 echo \u0026#34;⬇ Downloading...\u0026#34; curl -s -H \u0026#34;Authorization: Bearer $AUTH_TOKEN\u0026#34; \\ -o \u0026#34;$local_file\u0026#34; \u0026#34;$remote_url\u0026#34; if [ $? -eq 0 ]; then echo \u0026#34;✓ Downloaded successfully\u0026#34; else echo \u0026#34;✗ Download failed\u0026#34; fi done } mkdir -p \u0026#34;$LOCAL_DIR\u0026#34; sync_files 3. 網站監控腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #!/bin/bash # website_monitor.sh SITES=( \u0026#34;https://example.com\u0026#34; \u0026#34;https://api.example.com/health\u0026#34; \u0026#34;https://cdn.example.com\u0026#34; ) TIMEOUT=10 LOG_FILE=\u0026#34;/var/log/website_monitor.log\u0026#34; log_message() { echo \u0026#34;$(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;) - $1\u0026#34; | tee -a \u0026#34;$LOG_FILE\u0026#34; } check_site() { local url=\u0026#34;$1\u0026#34; local name=$(echo \u0026#34;$url\u0026#34; | sed \u0026#39;s|https\\?://||\u0026#39; | sed \u0026#39;s|/.*||\u0026#39;) response=$(curl -s -w \u0026#34;HTTPSTATUS:%{http_code};TIME:%{time_total}\u0026#34; \\ --max-time \u0026#34;$TIMEOUT\u0026#34; \u0026#34;$url\u0026#34;) if [ $? -eq 0 ]; then http_code=$(echo \u0026#34;$response\u0026#34; | grep -o \u0026#34;HTTPSTATUS:[0-9]*\u0026#34; | cut -d: -f2) time_total=$(echo \u0026#34;$response\u0026#34; | grep -o \u0026#34;TIME:[0-9.]*\u0026#34; | cut -d: -f2) if [ \u0026#34;$http_code\u0026#34; = \u0026#34;200\u0026#34; ]; then log_message \u0026#34;✓ $name - OK (${time_total}s)\u0026#34; else log_message \u0026#34;⚠ $name - HTTP $http_code (${time_total}s)\u0026#34; fi else log_message \u0026#34;✗ $name - TIMEOUT or ERROR\u0026#34; fi } log_message \u0026#34;Starting website monitoring...\u0026#34; for site in \u0026#34;${SITES[@]}\u0026#34;; do check_site \u0026#34;$site\u0026#34; done log_message \u0026#34;Monitoring completed\u0026#34; 效能最佳化 連接重用 1 2 3 4 5 6 7 8 9 10 # HTTP/1.1 Keep-Alive curl --keepalive-time 30 https://api.example.com/endpoint1 curl --keepalive-time 30 https://api.example.com/endpoint2 # HTTP/2 多路復用 curl --http2 https://example.com/resource1 curl --http2 https://example.com/resource2 # 連接池配置 curl --max-time 30 --connect-timeout 10 https://api.example.com 快取與壓縮 1 2 3 4 5 6 7 8 9 10 # 啟用壓縮 curl -H \u0026#34;Accept-Encoding: gzip, deflate\u0026#34; https://example.com # 條件請求 curl -H \u0026#34;If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT\u0026#34; \\ https://example.com/data # ETag 支援 curl -H \u0026#34;If-None-Match: \\\u0026#34;33a64df551425fcc55e4d42a148795d9f25f89d4\\\u0026#34;\u0026#34; \\ https://example.com/resource 批次優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 並行下載 urls=( \u0026#34;https://api.example.com/data1\u0026#34; \u0026#34;https://api.example.com/data2\u0026#34; \u0026#34;https://api.example.com/data3\u0026#34; ) for url in \u0026#34;${urls[@]}\u0026#34;; do curl -s \u0026#34;$url\u0026#34; \u0026gt; \u0026#34;$(basename \u0026#34;$url\u0026#34;).json\u0026#34; \u0026amp; done wait # 限制並行數 printf \u0026#34;%s\\n\u0026#34; \u0026#34;${urls[@]}\u0026#34; | xargs -n 1 -P 3 -I {} \\ sh -c \u0026#39;curl -s \u0026#34;{}\u0026#34; \u0026gt; \u0026#34;$(basename \u0026#34;{}\u0026#34;).json\u0026#34;\u0026#39; 常見問題與解決方案 SSL/TLS 問題 1 2 3 4 5 6 7 8 9 # 證書驗證問題 curl -k https://self-signed.example.com # 跳過驗證（不推薦） curl --cacert /path/to/ca-bundle.crt https://example.com # 指定 CA # 檢查證書資訊 curl -vI https://example.com 2\u0026gt;\u0026amp;1 | grep -A 10 \u0026#34;Server certificate\u0026#34; # 測試 SSL 配置 curl --tlsv1.2 --ciphers HIGH https://example.com 編碼問題 1 2 3 4 5 6 7 8 # UTF-8 編碼 curl -H \u0026#34;Accept-Charset: utf-8\u0026#34; https://example.com # URL 編碼 curl \u0026#34;https://example.com/search?q=$(echo \u0026#39;中文查詢\u0026#39; | curl -Gso /dev/null -w %{url_effective} --data-urlencode @- | cut -c3-)\u0026#34; # 處理特殊字元 curl -G -d \u0026#34;query=hello world\u0026#34; https://example.com/search 超時與重試 1 2 3 4 5 6 7 8 9 # 超時設定 curl --connect-timeout 10 --max-time 30 https://slow-api.example.com # 自動重試 curl --retry 3 --retry-delay 5 https://unstable-api.example.com # 指數退避 curl --retry 3 --retry-delay 1 --retry-max-time 60 \\ https://api.example.com 總結 核心優勢 多功能性：支援多種協定和操作方式 靈活性：豐富的選項和配置能力 可程式性：適合自動化和腳本處理 跨平台：在各種系統上表現一致 效能：高效的網路通訊和傳輸 最佳實踐 安全第一：正確處理認證和 SSL 驗證 錯誤處理：實作適當的重試和錯誤恢復機制 效能優化：使用連接重用和並行處理 日誌記錄：保留詳細的請求和響應日誌 測試自動化：將 API 測試整合到 CI/CD 流程 常用模式記憶 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # API 測試基本模式 curl -X POST https://api.example.com/resource \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;Authorization: Bearer token\u0026#34; \\ -d \u0026#39;{\u0026#34;key\u0026#34;: \u0026#34;value\u0026#34;}\u0026#39; # 檔案操作模式 curl -O https://example.com/file.zip # 下載 curl -T file.txt https://api.example.com/upload # 上傳 # 除錯模式 curl -v -I https://example.com # 詳細標頭 curl -w \u0026#34;%{http_code}\\n\u0026#34; https://example.com # 狀態碼 # 效能測試模式 curl -w \u0026#34;@curl-format.txt\u0026#34; -o /dev/null -s https://example.com cURL 是現代開發者工具箱中不可或缺的利器，掌握其核心功能和進階技巧，能夠大幅提升 API 開發、測試和維護的效率。記住：實務中最重要的是理解 HTTP 協定基礎，並善用 cURL 的豐富選項來解決實際問題。\n參考資料 cURL 官方文檔 cURL Tutorial HTTP/1.1 規範 REST API 設計指南 JSON API 規範 ","permalink":"https://xinqilin.github.io/post/tools/curl/","tags":["cURL","HTTP","API","REST","Web Development","Command Line","Network"],"title":"cURL 完整指南：HTTP 客戶端工具與 API 測試利器"},{"content":"概述 在現代應用程式開發中，一個專案往往由多個服務組成，例如前端、後端 API、資料庫、快取等。這些服務各自運行在不同的容器中，而 Docker Compose 正是為了解決這種多容器應用程式的定義與管理而生。\nDocker Compose 允許您使用一個 YAML 檔案 (docker-compose.yml) 來定義應用程式的所有服務、網路和儲存卷，然後透過單一指令啟動、停止或管理整個應用程式堆疊。這極大地簡化了開發、測試和部署的流程。\n常用 Docker Compose 指令 以下是 Docker Compose 的一些常用指令，用於管理您的多容器應用程式：\n指令 說明 範例 docker-compose --version 顯示 Docker Compose 的版本資訊。 docker-compose --version docker-compose -h 顯示 Docker Compose 的幫助訊息。 docker-compose -h docker-compose up 啟動並建立所有服務的容器。如果容器已存在，則會重新建立。 docker-compose up docker-compose up -d 在背景模式 (detached mode) 啟動並建立所有服務的容器。 docker-compose up -d docker-compose down 停止並移除所有服務的容器、網路和預設儲存卷。 docker-compose down docker-compose exec \u0026lt;service_name\u0026gt; \u0026lt;command\u0026gt; 在指定服務的容器中執行指令。 docker-compose exec microService /bin/bash docker-compose ps 列出所有服務的容器狀態。 docker-compose ps docker-compose top 顯示服務容器的運行進程。 docker-compose top docker-compose logs \u0026lt;service_name\u0026gt; 顯示指定服務容器的日誌輸出。 docker-compose logs microService docker-compose config 驗證 docker-compose.yml 檔案的語法是否正確，並顯示解析後的配置。 docker-compose config docker-compose config -q 靜默模式驗證配置，只在有錯誤時輸出訊息。 docker-compose config -q docker-compose restart \u0026lt;service_name\u0026gt; 重新啟動指定服務的容器。若未指定服務，則重新啟動所有服務。 docker-compose restart microService docker-compose start \u0026lt;service_name\u0026gt; 啟動指定服務的容器。若未指定服務，則啟動所有已停止的服務。 docker-compose start microService docker-compose stop \u0026lt;service_name\u0026gt; 停止指定服務的容器。若未指定服務，則停止所有運行中的服務。 docker-compose stop microService 常用組合指令 1 2 # 驗證配置後，停止並重新啟動所有服務 docker-compose config -q \u0026amp;\u0026amp; docker-compose down \u0026amp;\u0026amp; docker-compose up -d docker-compose.yml 檔案結構詳解 docker-compose.yml 是 Docker Compose 的核心配置檔案，它使用 YAML 語法來定義應用程式的服務。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 # 指定 Docker Compose 檔案格式的版本，建議使用最新穩定版 (目前為 \u0026#39;3.x\u0026#39;) version: \u0026#34;3.8\u0026#34; # 建議使用 3.8 或更高版本，以支援更多功能 # 定義應用程式中的所有服務 (即容器) services: # 自訂服務名稱，例如 \u0026#39;microService\u0026#39;、\u0026#39;web\u0026#39;、\u0026#39;db\u0026#39; 等 microService: # 指定服務所使用的 Docker 映像檔 image: my_image:1.0 # 定義容器的名稱，方便識別和管理 container_name: ms_01 # 埠映射：將主機埠映射到容器埠 (HOST_PORT:CONTAINER_PORT) ports: - \u0026#34;8081:8080\u0026#34; # 將主機的 8081 埠映射到容器的 8080 埠 # 儲存卷映射：將主機路徑映射到容器路徑 (HOST_PATH:CONTAINER_PATH) volumes: - /Users/bill/microService:/app # 將主機的 /Users/bill/microService 目錄映射到容器的 /app 目錄 # 指定服務所連接的網路 networks: - my_network # 連接到名為 \u0026#39;my_network\u0026#39; 的網路 # 定義服務的啟動順序依賴關係 # 注意：depends_on 只保證服務啟動順序，不保證服務內部應用程式完全就緒 # 可搭配 https://github.com/vishnubob/wait-for-it 或其他健康檢查機制確保服務可用 depends_on: - redis # microService 服務會在 redis 服務啟動後才啟動 - mysql # microService 服務會在 mysql 服務啟動後才啟動 # 範例：等同於 `docker run -d -p 8081:8080 -v /Users/bill/microService:/app --network my_network` redis: image: redis:6.0.8 # 使用 Redis 6.0.8 映像檔 ports: - \u0026#34;6379:6379\u0026#34; # 映射 Redis 預設埠 volumes: # 映射 Redis 配置檔，讓容器使用自訂配置 - /app/redis/redis.conf:/etc/redis/redis.conf # 映射 Redis 資料目錄，實現資料持久化 - /app/redis/data:/data networks: - my_network # 覆寫容器的預設啟動指令，讓 Redis 使用指定的配置檔啟動 command: redis-server /etc/redis/redis.conf mysql: image: mysql:5.7 # 使用 MySQL 5.7 映像檔 # 設定 MySQL 容器的環境變數 environment: MYSQL_ROOT_PASSWORD: \u0026#39;123456\u0026#39; # 設定 root 使用者的密碼 MYSQL_ALLOW_EMPTY_PASSWORD: \u0026#39;no\u0026#39; # 不允許 root 密碼為空 MYSQL_DATABASE: \u0026#39;my_test_db\u0026#39; # 建立一個名為 \u0026#39;my_test_db\u0026#39; 的資料庫 MYSQL_USER: \u0026#39;bill\u0026#39; # 建立一個名為 \u0026#39;bill\u0026#39; 的使用者 MYSQL_PASSWORD: \u0026#39;user_pwd\u0026#39; # 設定 \u0026#39;bill\u0026#39; 使用者的密碼 ports: - \u0026#34;3306:3306\u0026#34; # 映射 MySQL 預設埠 volumes: # 映射 MySQL 資料目錄，實現資料持久化 - /app/mysql/db:/var/lib/mysql # 映射 MySQL 配置檔 - /app/mysql/conf/my.cnf:/etc/my.cnf # 映射初始化腳本目錄，容器啟動時會執行此目錄下的 .sh 或 .sql 腳本 - /app/mysql/init:/docker-entrypoint-initdb.d networks: - my_network # 解決 MySQL 8.0 之後預設認證插件導致外部客戶端無法連接的問題 command: --default-authentication-plugin=mysql_native_password # 定義應用程式使用的網路 networks: my_network: # 自訂網路名稱，所有服務將在此網路中互相通訊 # 定義應用程式使用的儲存卷 (可選，如果服務中直接使用匿名卷或綁定掛載則不需要在此定義) # volumes: # my_data: # 自訂儲存卷名稱 ","permalink":"https://xinqilin.github.io/post/devops/docker-compose/","tags":["Docker","Docker Compose","DevOps","Containerization","Microservices","YAML"],"title":"Docker Compose 完整指南：多容器應用程式的定義與執行"},{"content":"概述 Docker 網路是容器化應用程式的基石，它決定了容器如何與外部世界通訊，以及容器之間如何互相連接。理解 Docker 的網路模式對於建構穩健、可擴展的容器化應用程式至關重要。本文將詳細介紹 Docker 提供的幾種主要網路模式及其應用場景。\nDocker 網路模式 Docker 提供了多種網路驅動程式，每種驅動程式都提供不同的網路功能。最常用的包括 bridge、host、none 和 container。\n1. Bridge (橋接模式) 說明：這是 Docker 的預設網路模式。當您不指定網路模式時，Docker 會自動為容器分配一個 IP 位址，並將其連接到一個名為 docker0 的虛擬橋接器上。每個容器都會獲得一個獨立的網路堆疊。 工作原理： Docker 會在主機上建立一個名為 docker0 的虛擬橋接器。 每個容器都會建立一對虛擬乙太網卡 (veth pair)，其中一端連接到容器內的 eth0，另一端連接到 docker0 橋接器。 容器可以透過 docker0 橋接器與同一橋接器上的其他容器通訊，也可以透過主機的網路介面與外部網路通訊。 優點：提供良好的隔離性，容器間預設不直接暴露埠。 缺點：容器需要透過埠映射才能從外部訪問。 2. Host (主機模式) 說明：在主機模式下，容器不會有自己的獨立網路堆疊，而是直接使用主機的網路堆疊。這意味著容器會直接使用主機的 IP 位址和埠。 工作原理：容器內的應用程式會直接綁定到主機的網路介面和埠上。 優點：網路效能最佳，因為沒有額外的網路層。 缺點： 容器不再與主機隔離，容器內應用程式使用的埠不能與主機上已佔用的埠衝突。 安全性較低，因為容器直接暴露在主機網路中。 使用方式：--network host 3. None (無網路模式) 說明：在無網路模式下，容器會建立一個獨立的網路堆疊，但不會對其進行任何網路配置。容器將沒有網路介面，無法與外部通訊。 工作原理：容器只包含一個 lo (loopback) 介面。 優點：適用於只需要計算資源而不需要網路連接的特殊場景，或者需要手動配置網路的進階情況。 缺點：容器無法進行任何網路通訊，除非手動配置。 使用方式：--network none 4. Container (容器模式) 說明：在容器模式下，新建立的容器不會有自己的網路堆疊，而是與另一個已存在的容器共享其網路堆疊。這意味著兩個容器會共享同一個 IP 位址和埠空間。 工作原理：兩個容器共享同一個網路命名空間。 優點：適用於需要緊密協同工作的應用程式，例如主應用程式容器和一個代理或日誌收集容器。 缺點：兩個容器會共享埠，可能導致埠衝突。 使用方式：--network container:\u0026lt;name_or_id\u0026gt; 常用 Docker 網路指令 指令 說明 範例 docker network ls 列出所有 Docker 網路。 docker network ls docker network prune 刪除所有未使用的網路。 docker network prune docker network inspect \u0026lt;network_name_or_id\u0026gt; 顯示指定網路的詳細資訊，包括連接到該網路的容器。 docker network inspect bridge docker inspect \u0026lt;container_id\u0026gt; 顯示指定容器的詳細資訊，包括其網路配置。 docker inspect \u0026lt;container_id\u0026gt; 自訂網路 (User-defined Bridge Networks) 雖然 Docker 預設的 bridge 網路 (docker0) 已經足夠應付許多情況，但強烈建議您建立自訂橋接網路 (User-defined Bridge Networks)。自訂網路提供了更好的隔離性、內建的 DNS 解析和更靈活的配置。\n優點 內建 DNS 解析：在自訂網路中，容器可以透過服務名稱（而不是 IP 位址）互相通訊，因為 Docker 會為自訂網路提供內建的 DNS 解析服務。這使得容器的 IP 位址變化不再是問題。 更好的隔離性：自訂網路中的容器預設只能與同一網路中的其他容器通訊，提供了更好的安全性。 可移植性：在 Docker Compose 中，自訂網路是預設行為，這使得多容器應用程式的定義更加簡潔和可移植。 建立自訂網路 1 2 # 建立一個名為 \u0026#39;my_network\u0026#39; 的自訂橋接網路 docker network create my_network 將容器連接到自訂網路 在啟動容器時，使用 --network 參數指定自訂網路名稱：\n1 2 3 4 5 # 啟動第一個 Tomcat 容器，連接到 \u0026#39;my_network\u0026#39; docker run -d -p 8080:8080 --network my_network --name tomcat_1 tomcat # 啟動第二個 Tomcat 容器，連接到 \u0026#39;my_network\u0026#39; docker run -d -p 8081:8080 --network my_network --name tomcat_2 tomcat 現在，tomcat_1 和 tomcat_2 容器都在 my_network 中，它們可以透過彼此的容器名稱（tomcat_1 和 tomcat_2）互相通訊，例如：\n1 2 3 4 5 # 進入 tomcat_1 容器內部 docker exec -it tomcat_1 bash # 在 tomcat_1 容器內部 ping tomcat_2 ping tomcat_2 容器模式的限制與自訂網路的優勢 您原先的範例中，嘗試讓兩個 Tomcat 容器共享網路，但由於埠衝突而失敗：\n1 2 3 4 # 坑 （下面起不起來因兩台 tomcat 都用 8080 映射出去） # 借用 tomcat_1 網路 docker run -d -p 8080:8080 --name tomcat_1 tomcat docker run -d -p 8081:8080 --network container:tomcat_1 --name tomcat_2 tomcat # 會失敗，因為 tomcat_2 試圖使用 tomcat_1 的 8080 埠 這是因為在 container 模式下，兩個容器共享同一個網路命名空間，包括埠空間。如果 tomcat_1 已經佔用了 8080 埠，那麼 tomcat_2 就無法再使用這個埠。\n相比之下，使用自訂網路則沒有這個問題。每個容器在自訂網路中仍然擁有自己的獨立網路堆疊和埠空間，只是它們可以透過網路名稱互相發現和通訊。這使得自訂網路成為多容器應用程式之間通訊的更優雅和健壯的解決方案。\n透過理解和善用 Docker 網路模式，您可以更有效地設計和管理您的容器化應用程式。\n","permalink":"https://xinqilin.github.io/post/devops/docker-network/","tags":["Docker","Network","DevOps","Containerization","Bridge","Host"],"title":"Docker 網路模式詳解：容器間通訊與外部連接"},{"content":"概述 在自動化測試和網路爬蟲等場景中，經常需要將應用程式與瀏覽器自動化工具 (如 Selenium) 打包到同一個 Docker 容器中。此外，為了支援不同的運行環境（例如 ARM64 或 x86_64 架構，以及 Firefox 或 Chrome 瀏覽器），我們需要一個靈活的建構流程。\n本文將深入解析一個多階段 Dockerfile，它展示了如何：\n建構一個包含 Node.js 應用程式的基礎映像檔。 利用這個基礎映像檔，為不同的 CPU 架構和瀏覽器環境建立多個最終的 Selenium 應用程式映像檔。 透過一個通用的 entrypoint.sh 腳本，在容器啟動時自動判斷環境並執行對應的測試。 Dockerfile 詳解 這個 Dockerfile 採用了多階段建構 (Multi-stage Builds) 的方式，以確保最終映像檔的輕量化和模組化。\n第一階段：應用程式建構 (build 階段) 這個階段負責準備 Node.js 環境並打包應用程式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 FROM ubuntu:22.04 AS build # 設定環境變數 ENV NVM_DIR /opt/nvm # NVM (Node Version Manager) 的安裝目錄 ENV NODE_VERSION v16.13.2 # 指定要安裝的 Node.js 版本 ENV APP_DIR /app # 應用程式的工作目錄 # 建立必要的目錄 RUN [ -d $APP_DIR ] || mkdir -p $APP_DIR RUN [ -d $NVM_DIR ] || mkdir -p $NVM_DIR # 更新套件列表並安裝 curl (用於下載 NVM) RUN apt-get update \u0026amp;\u0026amp; apt-get install curl -y # 安裝 NVM 和指定版本的 Node.js # 從 GitHub 下載 NVM 安裝腳本 RUN curl -o $NVM_DIR/install.sh https://raw.githubusercontent.com/nvm-sh/nvm/master/install.sh # 執行 NVM 安裝腳本 RUN /bin/bash $NVM_DIR/install.sh # 設定 PATH 環境變數，將 Node.js 可執行檔加入路徑 ENV PATH $NVM_DIR/versions/node/$NODE_VERSION/bin:$PATH # 複製應用程式檔案 COPY test /app/test # 複製 \u0026#39;test\u0026#39; 目錄 COPY *.js /app/ # 複製所有 .js 檔案 COPY *.json /app/ # 複製所有 .json 檔案 COPY *.sh /app/ # 複製所有 .sh 腳本 RUN chmod 0755 /app/*.sh # 為腳本添加執行權限 # 設定工作目錄並安裝 Node.js 依賴 WORKDIR $APP_DIR RUN npm install 第二階段：Selenium 瀏覽器映像檔建構 (多個 FROM 階段) 這個 Dockerfile 為不同的 CPU 架構 (ARM64, x86_64) 和瀏覽器 (Firefox, Chrome) 定義了多個最終映像檔。每個階段都從一個預先建構好的 Selenium 映像檔開始，並將第一階段建構好的應用程式複製進來。\nARM64 架構 - Firefox 瀏覽器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 FROM seleniarm/standalone-firefox:latest AS arm64-firefox # 設定終端機和語言環境變數 ENV TERM=\u0026#34;xterm-color\u0026#34; ENV LANG=\u0026#39;en_US.UTF-8\u0026#39; ENV LANGUAGE=\u0026#39;en_US.UTF-8\u0026#39; # 重新設定 NVM 和應用程式目錄 (因為是新的 FROM 階段) ENV NVM_DIR /opt/nvm ENV NODE_VERSION v16.13.2 ENV APP_DIR /app # 建立目錄並調整權限 (使用 sudo 和 chown 是因為基礎映像檔可能以非 root 用戶運行) RUN [ -d $APP_DIR ] || (sudo mkdir -p $APP_DIR \u0026amp;\u0026amp; sudo chown `whoami`:`id -g -n` $APP_DIR) RUN [ -d $NVM_DIR ] || (sudo mkdir -p $NVM_DIR \u0026amp;\u0026amp; sudo chown `whoami`:`id -g -n` $NVM_DIR) # 從 \u0026#39;build\u0026#39; 階段複製 NVM 安裝腳本並執行 COPY --from=build $NVM_DIR/install.sh $NVM_DIR RUN /bin/bash $NVM_DIR/install.sh # 設定 PATH 環境變數 ENV PATH $NVM_DIR/versions/node/$NODE_VERSION/bin:$PATH # 從 \u0026#39;build\u0026#39; 階段複製應用程式檔案 COPY --from=build $APP_DIR $APP_DIR # 調整應用程式目錄的擁有者為 \u0026#39;seluser\u0026#39; (Selenium 映像檔的預設用戶) RUN chown seluser:seluser $APP_DIR # 設定工作目錄 WORKDIR $APP_DIR # 定義容器啟動時執行的命令 (將由 entrypoint.sh 腳本處理) CMD [ \u0026#34;/app/entrypoint.sh\u0026#34; ] ARM64 架構 - Chrome 瀏覽器 1 2 3 FROM seleniarm/standalone-chromium:latest AS arm64-chrome # ... (與 arm64-firefox 階段類似的環境變數、目錄建立、NVM 安裝、應用程式複製和權限調整) ... CMD [ \u0026#34;/app/entrypoint.sh\u0026#34; ] x86_64 架構 - Firefox 瀏覽器 1 2 3 FROM selenium/standalone-firefox:latest AS x86_64-firefox # ... (與 arm64-firefox 階段類似的環境變數、目錄建立、NVM 安裝、應用程式複製和權限調整) ... CMD [ \u0026#34;/app/entrypoint.sh\u0026#34; ] x86_64 架構 - Chrome 瀏覽器 1 2 3 FROM selenium/standalone-chrome:latest AS x86_64-chrome # ... (與 arm64-firefox 階段類似的環境變數、目錄建立、NVM 安裝、應用程式複製和權限調整) ... CMD [ \u0026#34;/app/entrypoint.sh\u0026#34; ] entrypoint.sh 腳本詳解 這個腳本是容器啟動時執行的入口點，它負責根據運行環境動態判斷要執行的 npm 腳本，並確保 Selenium 服務已啟動。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #!/bin/bash # 根據容器中存在的瀏覽器可執行檔來設定 SCRIPTS 變數 # 如果找到 firefox，則 SCRIPTS 為 \u0026#34;docker-firefox\u0026#34; [ -f /usr/bin/firefox ] \u0026amp;\u0026amp; export SCRIPTS=\u0026#34;docker-firefox\u0026#34; # 如果找到 chromium-browser 或 google-chrome，則 SCRIPTS 為 \u0026#34;docker-chrome\u0026#34; [ -f /usr/bin/chromium-browser ] \u0026amp;\u0026amp; export SCRIPTS=\u0026#34;docker-chrome\u0026#34; [ -f /usr/bin/google-chrome ] \u0026amp;\u0026amp; export SCRIPTS=\u0026#34;docker-chrome\u0026#34; # 判斷 CPU 架構 (uname -m 會回傳機器硬體名稱) uu=`uname -m` echo \u0026#39;uname -m:\u0026#39; $uu if [ \u0026#34;$uu\u0026#34; = \u0026#34;arm64\u0026#34; ] || [ \u0026#34;$uu\u0026#34; = \u0026#34;aarch64\u0026#34; ];then # 如果是 ARM64 架構，則在 SCRIPTS 後面加上 \u0026#34;-arm64\u0026#34; export SCRIPTS=\u0026#34;$SCRIPTS-arm64\u0026#34; fi # 啟動 Selenium 服務的入口點腳本 (通常由基礎映像檔提供) # 將標準輸出和標準錯誤重定向到 /dev/null，使其在背景靜默運行 /opt/bin/entry_point.sh \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; # 等待 Selenium 服務啟動 (檢查 localhost:4444 是否可訪問) for number in {1..120} # 最多等待 120 秒 do if curl -s http://localhost:4444; then # -s 靜默模式，不顯示進度或錯誤 break # 如果成功訪問，則跳出迴圈 fi echo \u0026#34;Waiting selenium service,\u0026#34; $number # 顯示等待訊息 sleep 1 # 每秒檢查一次 done # 再次檢查 Selenium 服務是否成功啟動，如果沒有則退出並報錯 if ! curl -s http://localhost:4444; then echo \u0026#34;Selenium service failed to start.\u0026#34; exit 1 fi # 進入應用程式目錄 cd /app # 執行對應的 npm 腳本 echo \u0026#34;npm run $SCRIPTS\u0026#34; npm run $SCRIPTS 最佳實踐與考量 多階段建構：此 Dockerfile 充分利用了多階段建構的優勢，將建構環境與運行環境分離，顯著減小了最終映像檔的大小，並提高了安全性。 跨平台支援：透過為不同 CPU 架構和瀏覽器建立獨立的階段，實現了單一 Dockerfile 支援多種運行環境的能力。 權限管理：在複製應用程式檔案後，使用 chown 調整檔案擁有者，確保應用程式以非 root 用戶運行，這是一個重要的安全實踐。 健壯的啟動腳本：entrypoint.sh 腳本包含了等待外部服務 (Selenium) 啟動的邏輯，這使得容器的啟動更加健壯和可靠。 環境變數：合理使用 ENV 指令來管理版本號和路徑，提高了 Dockerfile 的可維護性。 透過這個詳細的 Dockerfile 和啟動腳本，您可以高效地建構和部署跨平台的 Selenium 自動化測試應用程式。\n","permalink":"https://xinqilin.github.io/post/devops/dockerfile-docker_in_docker/","tags":["Docker","Dockerfile","Multi-stage Build","Selenium","Node.js","DevOps","Cross-platform"],"title":"多階段 Dockerfile：建構跨平台 Selenium 應用程式映像檔"},{"content":"概述 Dockerfile 是一個包含一系列指令的文字檔案，Docker 引擎會讀取這些指令，並自動建構出 Docker 映像檔 (Image)。它定義了映像檔的內容、運行環境以及啟動時執行的指令。理解 Dockerfile 是掌握 Docker 容器化技術的關鍵一步。\nDockerfile 核心指令詳解 1. 基礎指令 FROM：指定基礎映像檔。Dockerfile 的第一條指令必須是 FROM。\n語法：FROM \u0026lt;image\u0026gt;[:\u0026lt;tag\u0026gt;] 範例：FROM ubuntu:18.04 (使用 Ubuntu 18.04 作為基礎映像檔) 注意：如果未指定 tag，預設為 latest。建議明確指定版本，以確保建構的可重複性。 MAINTAINER：指定映像檔的維護者資訊。\n語法：MAINTAINER \u0026lt;name\u0026gt; [email] 範例：MAINTAINER Bill.Lin \u0026lt;zzx123bill@gmail.com\u0026gt; 注意：此指令已過時，建議使用 LABEL 指令來替代，例如 LABEL maintainer=\u0026quot;Bill.Lin \u0026lt;zzx123bill@gmail.com\u0026gt;\u0026quot;。 2. 執行指令 RUN：在建構映像檔時執行命令。每個 RUN 指令都會在映像檔中建立一個新的層 (layer)。\n語法： RUN \u0026lt;command\u0026gt; (shell 模式，預設使用 /bin/sh -c 執行) RUN [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;] (exec 模式，直接執行可執行檔) 範例 (shell 模式)： 1 2 RUN apt-get update -y \\ \u0026amp;\u0026amp; apt-get install nginx -y 注意：使用 \u0026amp;\u0026amp; 將多個命令串聯起來，可以減少映像檔層數，優化映像檔大小。 範例 (exec 模式)： 1 2 RUN [\u0026#34;./test.php\u0026#34;, \u0026#34;dev\u0026#34;, \u0026#34;offline\u0026#34;] # 等同於在容器內執行 `./test.php dev offline` CMD：設定容器啟動時預設執行的命令。如果 docker run 命令後帶有參數，CMD 的命令會被覆蓋。一個 Dockerfile 中只能有一個 CMD，多個 CMD 只有最後一個生效。\n語法： CMD [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;] (exec 模式，推薦) CMD [\u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;] (作為 ENTRYPOINT 的預設參數) CMD command param1 param2 (shell 模式) 範例：CMD [\u0026quot;nginx\u0026quot;, \u0026quot;-g\u0026quot;, \u0026quot;daemon off;\u0026quot;] (啟動 Nginx 並保持在前台運行) 注意：CMD 會被 docker run \u0026lt;image\u0026gt; \u0026lt;command\u0026gt; 中的 \u0026lt;command\u0026gt; 覆蓋。 ENTRYPOINT：設定容器啟動時執行的命令。ENTRYPOINT 不會被 docker run 後的參數覆蓋，而是將這些參數作為 ENTRYPOINT 命令的參數。\n語法：ENTRYPOINT [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;] (exec 模式，推薦) 範例：ENTRYPOINT [\u0026quot;docker-entrypoint.sh\u0026quot;] CMD 與 ENTRYPOINT 組合使用： 當 ENTRYPOINT 和 CMD 都使用 exec 模式時，CMD 的內容會作為 ENTRYPOINT 的參數。 1 2 3 4 FROM nginx ENTRYPOINT [\u0026#34;nginx\u0026#34;, \u0026#34;-c\u0026#34;] CMD [\u0026#34;/etc/nginx/nginx.conf\u0026#34;] # 容器啟動時實際執行：nginx -c /etc/nginx/nginx.conf 這種組合常用於設定固定的啟動命令，同時允許使用者透過 CMD 或 docker run 參數來提供預設或自訂的參數。 3. 環境設定 WORKDIR：設定工作目錄。後續的 RUN, CMD, ENTRYPOINT, COPY, ADD 指令都會在這個目錄下執行。\n語法：WORKDIR /path/to/workdir 範例： 1 2 WORKDIR /app COPY . /app # 將建構上下文中的檔案複製到容器的 /app 目錄 USER：指定運行容器時的用戶或用戶組。\n語法：USER \u0026lt;user\u0026gt;[:\u0026lt;group\u0026gt;] 範例：USER nobody (以非 root 用戶運行，提高安全性) 注意：預設為 root。在生產環境中，建議使用非 root 用戶運行應用程式。 VOLUME：建立一個掛載點，將容器內的路徑標記為外部掛載點，用於持久化資料或共享資料。\n語法：VOLUME [\u0026quot;/data\u0026quot;] 範例：VOLUME /var/lib/mysql (將 MySQL 資料目錄標記為儲存卷) ARG：定義建構時的變數。這些變數只在 docker build 過程中有效，不會保留在最終的映像檔中。\n語法：ARG \u0026lt;name\u0026gt;[=\u0026lt;default value\u0026gt;] 範例： 1 2 ARG VERSION=1.0 FROM myapp:${VERSION} 使用：docker build --build-arg VERSION=2.0 . ENV：設定環境變數。這些變數會保留在最終的映像檔中，並在容器運行時可用。\n語法：ENV \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; ... 範例： 1 2 ENV MY_PATH /usr/local WORKDIR $MY_PATH # WORKDIR 可以使用 ENV 定義的變數 EXPOSE：聲明容器運行時監聽的埠。這只是一個文件說明，並不會實際發布埠。要發布埠，需要在 docker run 或 docker-compose.yml 中使用 -p 或 ports。\n語法：EXPOSE \u0026lt;port\u0026gt; [\u0026lt;port\u0026gt;...] 範例：EXPOSE 8080 (聲明容器會監聽 8080 埠) 4. 檔案操作 COPY：將建構上下文中的檔案或目錄複製到映像檔中。\n語法：COPY \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt; 範例：COPY ./target/mms.war /app/mms.war (將主機 target 目錄下的 mms.war 複製到容器的 /app 目錄) 注意：COPY 只能複製本地建構上下文中的檔案。 ADD：與 COPY 類似，但 ADD 具有額外的功能：\n如果 \u0026lt;src\u0026gt; 是一個壓縮檔 (如 .tar, .gz, .zip)，它會自動解壓縮到 \u0026lt;dest\u0026gt;。 如果 \u0026lt;src\u0026gt; 是一個 URL，它會從該 URL 下載檔案。 語法：ADD \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt; 範例：ADD https://example.com/app.tar.gz /app/ 注意：由於 ADD 的自動解壓縮和 URL 下載功能可能導致不確定性，通常建議優先使用 COPY，除非您明確需要 ADD 的特殊功能。 Docker Build 流程 使用 docker build 命令來建構 Docker 映像檔。\n語法：docker build [OPTIONS] PATH | URL | - 範例：docker build -t my-app:1.0 . -t my-app:1.0：為映像檔指定名稱和標籤。 .：指定建構上下文的路徑。Docker 會將此路徑下的所有檔案發送到 Docker Daemon，作為建構過程的上下文。 範例：Java Spring Boot 應用程式的多階段建構 多階段建構 (Multi-stage Builds) 允許您在一個 Dockerfile 中使用多個 FROM 指令。每個 FROM 指令都可以使用不同的基礎映像檔，並且每個階段都可以獨立地建構。最終的映像檔只包含您需要的最終產物，大大減少了映像檔的大小。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # --- 第一階段：建構應用程式 --- # 使用一個包含 Java 開發工具包 (JDK) 的映像檔來編譯和打包應用程式 FROM openjdk:11-jdk-slim AS build # 設定工作目錄 WORKDIR /app # 將 Maven 的設定檔複製到容器中 (如果有的話) # COPY settings.xml /root/.m2/ # 將專案的 pom.xml 複製到容器中，並下載依賴，利用 Docker 層快取 COPY pom.xml . RUN mvn dependency:go-offline # 將所有原始碼複製到容器中 COPY src ./src # 編譯並打包應用程式，生成 JAR 檔案 RUN mvn clean package -DskipTests # --- 第二階段：運行應用程式 --- # 使用一個輕量級的 Java 運行環境 (JRE) 映像檔來運行應用程式 FROM openjdk:11-jre-slim # 設定環境變數，指定應用程式的 JAR 檔案路徑 ENV APP_HOME=/app # 設定工作目錄 WORKDIR $APP_HOME # 從第一階段複製編譯好的 JAR 檔案 COPY --from=build /app/target/*.jar app.jar # 暴露應用程式監聽的埠 EXPOSE 8080 # 定義容器啟動時執行的命令 ENTRYPOINT [\u0026#34;java\u0026#34;, \u0026#34;-jar\u0026#34;, \u0026#34;app.jar\u0026#34;] 這個範例展示了如何使用多階段建構來：\n在第一個階段 (build) 中編譯 Java 應用程式，生成一個 JAR 檔案。 在第二個階段中，只複製最終的 JAR 檔案到一個更小的 JRE 基礎映像檔中。 這樣可以避免將編譯工具、原始碼等不必要的內容包含在最終的運行映像檔中，從而顯著減小映像檔大小，提高安全性和部署效率。\n透過熟練掌握 Dockerfile 的各項指令和最佳實踐，您可以更有效地建構和管理您的 Docker 映像檔。\n","permalink":"https://xinqilin.github.io/post/devops/dockerfile-basic/","tags":["Docker","Dockerfile","DevOps","Containerization","Image Build"],"title":"Dockerfile 基礎：建構 Docker 映像檔的核心指令"},{"content":"UML 統一建模語言完整指南 概述 UML（Unified Modeling Language，統一建模語言）是一種標準化的建模語言，用於軟體系統的視覺化、規範、建構和文檔化。UML 提供了多種圖形表示法，幫助開發人員理解系統結構、行為和互動關係。\nUML 圖形分類 結構圖（Structure Diagrams） 類別圖（Class Diagram）：展示類別及其關係 物件圖（Object Diagram）：展示特定時刻的物件實例 封裝圖（Package Diagram）：展示套件及其依賴關係 部署圖（Deployment Diagram）：展示系統部署結構 行為圖（Behavior Diagrams） 使用案例圖（Use Case Diagram）：展示系統功能和用戶互動 活動圖（Activity Diagram）：展示工作流程和業務邏輯 狀態圖（State Diagram）：展示物件狀態變化 互動圖（Interaction Diagrams） 序列圖（Sequence Diagram）：展示物件間的時間順序互動 協作圖（Collaboration Diagram）：展示物件間的協作關係 時序圖（Timing Diagram）：展示物件在時間軸上的狀態變化 類別圖關係詳解 1. 依賴關係（Dependency） 符號： 虛線箭頭 A -----\u0026gt; B\n意義： A 類別使用 B 類別，通常是臨時性的使用關係，如方法參數、局部變數或靜態方法調用。\nJava 實現範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 依賴關係示例 public class OrderService { // 方法參數依賴 public void processOrder(Order order, PaymentProcessor processor) { // OrderService 依賴 PaymentProcessor processor.processPayment(order.getAmount()); } // 靜態方法依賴 public void validateOrder(Order order) { // OrderService 依賴 OrderValidator if (!OrderValidator.validate(order)) { throw new ValidationException(\u0026#34;無效的訂單\u0026#34;); } } // 局部變數依賴 public void sendNotification(Order order) { // OrderService 依賴 EmailService EmailService emailService = new EmailService(); emailService.sendOrderConfirmation(order); } } // 被依賴的類 public class PaymentProcessor { public void processPayment(BigDecimal amount) { // 處理付款邏輯 } } public class OrderValidator { public static boolean validate(Order order) { return order != null \u0026amp;\u0026amp; order.getAmount() != null; } } public class EmailService { public void sendOrderConfirmation(Order order) { // 發送確認郵件 } } 2. 關聯關係（Association） 符號： 實線箭頭 A -----\u0026gt; B\n意義： 長期的結構性關係，一個類別知道另一個類別的存在。\nJava 實現範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // 單向關聯 public class Customer { private String name; private String email; // Customer 關聯到 Order private List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;(); public void addOrder(Order order) { orders.add(order); } public List\u0026lt;Order\u0026gt; getOrders() { return new ArrayList\u0026lt;\u0026gt;(orders); } } // 雙向關聯 public class Order { private String orderId; private BigDecimal amount; // Order 關聯到 Customer private Customer customer; public Order(Customer customer) { this.customer = customer; customer.addOrder(this); } public Customer getCustomer() { return customer; } } // 多對多關聯 public class Student { private String name; private List\u0026lt;Course\u0026gt; courses = new ArrayList\u0026lt;\u0026gt;(); public void enrollCourse(Course course) { courses.add(course); course.addStudent(this); } } public class Course { private String name; private List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); public void addStudent(Student student) { students.add(student); } } 3. 聚合關係（Aggregation） 符號： 空心菱形 A ◇-----\u0026gt; B\n意義： \u0026ldquo;has-a\u0026rdquo; 關係，整體包含部分，但部分可以獨立存在。\nJava 實現範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // 聚合關係示例 public class Department { private String name; private List\u0026lt;Employee\u0026gt; employees = new ArrayList\u0026lt;\u0026gt;(); public Department(String name) { this.name = name; } // 聚合：部門包含員工，但員工可以獨立存在 public void addEmployee(Employee employee) { employees.add(employee); } public void removeEmployee(Employee employee) { employees.remove(employee); } public List\u0026lt;Employee\u0026gt; getEmployees() { return new ArrayList\u0026lt;\u0026gt;(employees); } } public class Employee { private String name; private String position; public Employee(String name, String position) { this.name = name; this.position = position; } // 員工可以獨立存在，不依賴於部門 public void work() { System.out.println(name + \u0026#34; 正在工作\u0026#34;); } } // 使用範例 public class CompanyExample { public static void main(String[] args) { Department itDepartment = new Department(\u0026#34;IT部門\u0026#34;); Employee emp1 = new Employee(\u0026#34;張三\u0026#34;, \u0026#34;軟體工程師\u0026#34;); Employee emp2 = new Employee(\u0026#34;李四\u0026#34;, \u0026#34;系統分析師\u0026#34;); itDepartment.addEmployee(emp1); itDepartment.addEmployee(emp2); // 員工可以離開部門，但仍然存在 itDepartment.removeEmployee(emp1); emp1.work(); // 員工依然可以工作 } } 4. 組合關係（Composition） 符號： 實心菱形 A ◆-----\u0026gt; B\n意義： 強聚合關係，整體和部分的生命週期相同，部分不能獨立存在。\nJava 實現範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 // 組合關係示例 public class House { private String address; private List\u0026lt;Room\u0026gt; rooms = new ArrayList\u0026lt;\u0026gt;(); public House(String address) { this.address = address; // 組合：房子創建時，房間也被創建 initializeRooms(); } private void initializeRooms() { rooms.add(new Room(\u0026#34;客廳\u0026#34;, 30)); rooms.add(new Room(\u0026#34;臥室\u0026#34;, 20)); rooms.add(new Room(\u0026#34;廚房\u0026#34;, 15)); } public void addRoom(String name, int area) { rooms.add(new Room(name, area)); } public List\u0026lt;Room\u0026gt; getRooms() { return new ArrayList\u0026lt;\u0026gt;(rooms); } // 房子銷毀時，房間也隨之銷毀 public void demolish() { rooms.clear(); System.out.println(\u0026#34;房子被拆毀，所有房間也消失了\u0026#34;); } // 內部類，生命週期與外部類相同 private class Room { private String name; private int area; public Room(String name, int area) { this.name = name; this.area = area; } public String getName() { return name; } public int getArea() { return area; } } } // 另一個組合關係示例 public class Car { private String brand; private Engine engine; private List\u0026lt;Wheel\u0026gt; wheels = new ArrayList\u0026lt;\u0026gt;(); public Car(String brand) { this.brand = brand; // 組合：汽車創建時，引擎和車輪也被創建 this.engine = new Engine(2000); initializeWheels(); } private void initializeWheels() { for (int i = 0; i \u0026lt; 4; i++) { wheels.add(new Wheel(16)); } } public void start() { engine.start(); System.out.println(brand + \u0026#34; 汽車啟動\u0026#34;); } // 汽車銷毀時，引擎和車輪也隨之銷毀 public void destroy() { engine.stop(); wheels.clear(); System.out.println(brand + \u0026#34; 汽車被銷毀\u0026#34;); } // 內部類，體現組合關係 private class Engine { private int displacement; public Engine(int displacement) { this.displacement = displacement; } public void start() { System.out.println(\u0026#34;引擎啟動：\u0026#34; + displacement + \u0026#34;cc\u0026#34;); } public void stop() { System.out.println(\u0026#34;引擎停止\u0026#34;); } } private class Wheel { private int size; public Wheel(int size) { this.size = size; } public int getSize() { return size; } } } 5. 實現關係（Implementation） 符號： 虛線三角箭頭 A ----▷ B\n意義： 類別實現介面或抽象類別。\nJava 實現範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 // 介面定義 public interface PaymentProcessor { void processPayment(BigDecimal amount); boolean validatePayment(PaymentRequest request); } // 具體實現類 public class CreditCardProcessor implements PaymentProcessor { @Override public void processPayment(BigDecimal amount) { System.out.println(\u0026#34;使用信用卡處理付款: \u0026#34; + amount); } @Override public boolean validatePayment(PaymentRequest request) { return request.getCreditCardNumber() != null \u0026amp;\u0026amp; request.getExpiryDate() != null \u0026amp;\u0026amp; request.getCvv() != null; } } public class PayPalProcessor implements PaymentProcessor { @Override public void processPayment(BigDecimal amount) { System.out.println(\u0026#34;使用 PayPal 處理付款: \u0026#34; + amount); } @Override public boolean validatePayment(PaymentRequest request) { return request.getPaypalEmail() != null \u0026amp;\u0026amp; request.getPassword() != null; } } // 抽象類別實現 public abstract class AbstractVehicle { protected String brand; protected String model; public AbstractVehicle(String brand, String model) { this.brand = brand; this.model = model; } public abstract void start(); public abstract void stop(); public void displayInfo() { System.out.println(\u0026#34;品牌: \u0026#34; + brand + \u0026#34;, 型號: \u0026#34; + model); } } public class Motorcycle extends AbstractVehicle { public Motorcycle(String brand, String model) { super(brand, model); } @Override public void start() { System.out.println(\u0026#34;機車啟動\u0026#34;); } @Override public void stop() { System.out.println(\u0026#34;機車停止\u0026#34;); } } 6. 繼承關係（Inheritance） 符號： 實線三角箭頭 A ----▷ B\n意義： \u0026ldquo;is-a\u0026rdquo; 關係，子類別繼承父類別的屬性和方法。\nJava 實現範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 // 父類別 public class Animal { protected String name; protected int age; public Animal(String name, int age) { this.name = name; this.age = age; } public void eat() { System.out.println(name + \u0026#34; 正在吃食物\u0026#34;); } public void sleep() { System.out.println(name + \u0026#34; 正在睡覺\u0026#34;); } public void makeSound() { System.out.println(name + \u0026#34; 發出聲音\u0026#34;); } } // 子類別 - 繼承 Animal public class Dog extends Animal { private String breed; public Dog(String name, int age, String breed) { super(name, age); this.breed = breed; } @Override public void makeSound() { System.out.println(name + \u0026#34; 汪汪叫\u0026#34;); } public void fetch() { System.out.println(name + \u0026#34; 正在撿球\u0026#34;); } } public class Cat extends Animal { private boolean isIndoor; public Cat(String name, int age, boolean isIndoor) { super(name, age); this.isIndoor = isIndoor; } @Override public void makeSound() { System.out.println(name + \u0026#34; 喵喵叫\u0026#34;); } public void climb() { System.out.println(name + \u0026#34; 正在爬樹\u0026#34;); } } // 多層繼承 public class WorkingDog extends Dog { private String jobType; public WorkingDog(String name, int age, String breed, String jobType) { super(name, age, breed); this.jobType = jobType; } public void work() { System.out.println(name + \u0026#34; 正在執行 \u0026#34; + jobType + \u0026#34; 工作\u0026#34;); } } 設計模式的 UML 表示 1. 單例模式（Singleton Pattern） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * UML 類別圖: * * ┌─────────────────────┐ * │ Singleton │ * ├─────────────────────┤ * │ - instance: Singleton │ * ├─────────────────────┤ * │ - Singleton() │ * │ + getInstance(): Singleton │ * │ + doSomething(): void │ * └─────────────────────┘ */ public class Singleton { private static volatile Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } public void doSomething() { System.out.println(\u0026#34;執行業務邏輯\u0026#34;); } } 2. 工廠模式（Factory Pattern） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /** * UML 類別圖: * * ┌─────────────────┐ ┌─────────────────┐ * │ Product │◄────────│ ProductFactory │ * │ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; │ │ │ * └─────────────────┘ └─────────────────┘ * △ │ * │ │ * ┌─────────────────┐ │ * │ ConcreteProduct │ │ * │ │ │ * └─────────────────┘ │ * │ * ┌─────────────────┐ * │ConcreteFactory │ * │ │ * └─────────────────┘ */ public interface Product { void use(); } public class ConcreteProductA implements Product { @Override public void use() { System.out.println(\u0026#34;使用產品 A\u0026#34;); } } public class ConcreteProductB implements Product { @Override public void use() { System.out.println(\u0026#34;使用產品 B\u0026#34;); } } public class ProductFactory { public static Product createProduct(String type) { switch (type.toLowerCase()) { case \u0026#34;a\u0026#34;: return new ConcreteProductA(); case \u0026#34;b\u0026#34;: return new ConcreteProductB(); default: throw new IllegalArgumentException(\u0026#34;未知的產品類型: \u0026#34; + type); } } } 3. 觀察者模式（Observer Pattern） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /** * UML 類別圖: * * ┌─────────────────┐ ┌─────────────────┐ * │ Subject │◄────────│ Observer │ * │ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; │ │ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; │ * │ │ │ │ * │+ attach(Observer)│ │+ update() │ * │+ detach(Observer)│ │ │ * │+ notifyObservers()│ └─────────────────┘ * └─────────────────┘ △ * △ │ * │ │ * ┌─────────────────┐ ┌─────────────────┐ * │ConcreteSubject │ │ConcreteObserver │ * │ │ │ │ * │- observers: List│ │- subject: Subject│ * │- state: String │ │ │ * └─────────────────┘ └─────────────────┘ */ public interface Subject { void attach(Observer observer); void detach(Observer observer); void notifyObservers(); } public interface Observer { void update(String message); } public class ConcreteSubject implements Subject { private List\u0026lt;Observer\u0026gt; observers = new ArrayList\u0026lt;\u0026gt;(); private String state; @Override public void attach(Observer observer) { observers.add(observer); } @Override public void detach(Observer observer) { observers.remove(observer); } @Override public void notifyObservers() { for (Observer observer : observers) { observer.update(state); } } public void setState(String state) { this.state = state; notifyObservers(); } } public class ConcreteObserver implements Observer { private String name; public ConcreteObserver(String name) { this.name = name; } @Override public void update(String message) { System.out.println(name + \u0026#34; 收到更新: \u0026#34; + message); } } 序列圖（Sequence Diagram） 基本概念 序列圖展示物件之間的時間順序互動，包含：\n參與者（Actor）：外部用戶或系統 物件（Object）：系統中的物件實例 生命線（Lifeline）：垂直虛線，表示物件的生命週期 訊息（Message）：物件間的互動 序列圖範例：訂單處理流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * 序列圖表示: * * 用戶 訂單服務 庫存服務 付款服務 郵件服務 * │ │ │ │ │ * │───────►│ │ │ │ 1. 創建訂單 * │ │─────────►│ │ │ 2. 檢查庫存 * │ │◄─────────│ │ │ 3. 庫存確認 * │ │──────────────────►│ │ 4. 處理付款 * │ │◄──────────────────│ │ 5. 付款確認 * │ │───────────────────────────►│ 6. 發送確認郵件 * │ │◄───────────────────────────│ 7. 郵件發送成功 * │◄───────│ │ │ │ 8. 返回訂單確認 * │ │ │ │ │ */ // 對應的 Java 實現 @Service public class OrderService { private final InventoryService inventoryService; private final PaymentService paymentService; private final EmailService emailService; public OrderService(InventoryService inventoryService, PaymentService paymentService, EmailService emailService) { this.inventoryService = inventoryService; this.paymentService = paymentService; this.emailService = emailService; } public OrderResult createOrder(OrderRequest request) { // 1. 創建訂單 Order order = new Order(request); // 2-3. 檢查庫存 if (!inventoryService.checkStock(order.getItems())) { return OrderResult.failure(\u0026#34;庫存不足\u0026#34;); } // 4-5. 處理付款 PaymentResult paymentResult = paymentService.processPayment(order.getAmount()); if (!paymentResult.isSuccess()) { return OrderResult.failure(\u0026#34;付款失敗\u0026#34;); } // 6-7. 發送確認郵件 emailService.sendOrderConfirmation(order); // 8. 返回訂單確認 return OrderResult.success(order); } } 使用案例圖（Use Case Diagram） 基本概念 使用案例圖展示系統功能和用戶之間的關係：\n參與者（Actor）：與系統互動的外部實體 使用案例（Use Case）：系統提供的功能 關係（Relationship）：參與者和使用案例之間的關係 使用案例圖範例：電商系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 /** * 使用案例圖表示: * * 顧客 管理員 * │ │ * │ │ * ┌─────────────┐ ┌─────────────┐ * │ 瀏覽商品 │ │ 管理商品 │ * └─────────────┘ └─────────────┘ * │ │ * ┌─────────────┐ ┌─────────────┐ * │ 添加到購物車 │ │ 查看訂單 │ * └─────────────┘ └─────────────┘ * │ │ * ┌─────────────┐ ┌─────────────┐ * │ 結帳付款 │ │ 管理用戶 │ * └─────────────┘ └─────────────┘ * │ * ┌─────────────┐ * │ 查看訂單狀態 │ * └─────────────┘ */ // 對應的 Java 實現 @RestController @RequestMapping(\u0026#34;/api\u0026#34;) public class ECommerceController { private final ProductService productService; private final CartService cartService; private final OrderService orderService; // 顧客功能 @GetMapping(\u0026#34;/products\u0026#34;) public List\u0026lt;Product\u0026gt; browseProducts() { return productService.getAllProducts(); } @PostMapping(\u0026#34;/cart/add\u0026#34;) public ResponseEntity\u0026lt;Void\u0026gt; addToCart(@RequestBody CartItem item) { cartService.addItem(item); return ResponseEntity.ok().build(); } @PostMapping(\u0026#34;/checkout\u0026#34;) public ResponseEntity\u0026lt;Order\u0026gt; checkout(@RequestBody CheckoutRequest request) { Order order = orderService.processOrder(request); return ResponseEntity.ok(order); } @GetMapping(\u0026#34;/orders/{id}\u0026#34;) public ResponseEntity\u0026lt;Order\u0026gt; getOrderStatus(@PathVariable Long id) { Order order = orderService.findById(id); return ResponseEntity.ok(order); } } @RestController @RequestMapping(\u0026#34;/api/admin\u0026#34;) public class AdminController { private final ProductService productService; private final OrderService orderService; private final UserService userService; // 管理員功能 @PostMapping(\u0026#34;/products\u0026#34;) public ResponseEntity\u0026lt;Product\u0026gt; createProduct(@RequestBody Product product) { Product created = productService.createProduct(product); return ResponseEntity.ok(created); } @GetMapping(\u0026#34;/orders\u0026#34;) public List\u0026lt;Order\u0026gt; getAllOrders() { return orderService.getAllOrders(); } @GetMapping(\u0026#34;/users\u0026#34;) public List\u0026lt;User\u0026gt; getAllUsers() { return userService.getAllUsers(); } } 活動圖（Activity Diagram） 基本概念 活動圖展示工作流程和業務邏輯：\n開始節點：流程開始 結束節點：流程結束 活動（Activity）：執行的動作 決策節點：條件判斷 分支和合併：並行處理 活動圖範例：用戶註冊流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 /** * 活動圖表示: * * ●（開始） * │ * ┌─────────────┐ * │ 輸入用戶信息 │ * └─────────────┘ * │ * ┌─────────────┐ * │ 驗證輸入 │ * └─────────────┘ * │ * ◇（決策） * ╱ ╲ * ╱ ╲ * ╱有效？╲ * ╲ ╱ * ╲ ╱ * ╲ ╱ * │ * 是│ 否 * │ │ * │ ┌─────────────┐ * │ │ 顯示錯誤 │ * │ └─────────────┘ * │ │ * │ │（回到輸入） * │ │ * ┌─────────────┐ * │ 創建用戶 │ * └─────────────┘ * │ * ┌─────────────┐ * │ 發送歡迎郵件 │ * └─────────────┘ * │ * ●（結束） */ // 對應的 Java 實現 @Service public class UserRegistrationService { private final UserRepository userRepository; private final EmailService emailService; private final UserValidator validator; public UserRegistrationService(UserRepository userRepository, EmailService emailService, UserValidator validator) { this.userRepository = userRepository; this.emailService = emailService; this.validator = validator; } public RegistrationResult registerUser(UserRegistrationRequest request) { // 1. 輸入用戶信息（由前端提供） // 2. 驗證輸入 ValidationResult validationResult = validator.validate(request); // 3. 決策：是否有效 if (!validationResult.isValid()) { // 否：顯示錯誤 return RegistrationResult.failure(validationResult.getErrors()); } // 是：創建用戶 User user = new User(request.getUsername(), request.getEmail()); User savedUser = userRepository.save(user); // 發送歡迎郵件 emailService.sendWelcomeEmail(savedUser); return RegistrationResult.success(savedUser); } } 狀態圖（State Diagram） 基本概念 狀態圖展示物件在不同狀態之間的轉換：\n狀態（State）：物件的特定條件 轉換（Transition）：從一個狀態到另一個狀態的變化 事件（Event）：觸發轉換的條件 動作（Action）：轉換時執行的操作 狀態圖範例：訂單狀態管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 /** * 狀態圖表示: * * ●（初始） * │ * │ 創建訂單 * ▼ * ┌─────────────┐ * │ PENDING │ * │ (待處理) │ * └─────────────┘ * │ │ * │確認 │取消 * ▼ ▼ * ┌─────────────┐ ┌─────────────┐ * │ CONFIRMED │ │ CANCELLED │ * │ (已確認) │ │ (已取消) │ * └─────────────┘ └─────────────┘ * │ │ * │發貨 │ * ▼ ▼ * ┌─────────────┐ ●（結束） * │ SHIPPED │ * │ (已發貨) │ * └─────────────┘ * │ * │完成 * ▼ * ┌─────────────┐ * │ DELIVERED │ * │ (已送達) │ * └─────────────┘ * │ * ▼ * ●（結束） */ // 對應的 Java 實現 public enum OrderStatus { PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED } @Entity public class Order { @Id private String id; @Enumerated(EnumType.STRING) private OrderStatus status; private LocalDateTime createdAt; private LocalDateTime updatedAt; public Order() { this.status = OrderStatus.PENDING; this.createdAt = LocalDateTime.now(); this.updatedAt = LocalDateTime.now(); } // 狀態轉換方法 public void confirm() { if (status != OrderStatus.PENDING) { throw new IllegalStateException(\u0026#34;只有待處理的訂單可以確認\u0026#34;); } this.status = OrderStatus.CONFIRMED; this.updatedAt = LocalDateTime.now(); } public void cancel() { if (status == OrderStatus.SHIPPED || status == OrderStatus.DELIVERED) { throw new IllegalStateException(\u0026#34;已發貨或已送達的訂單不能取消\u0026#34;); } this.status = OrderStatus.CANCELLED; this.updatedAt = LocalDateTime.now(); } public void ship() { if (status != OrderStatus.CONFIRMED) { throw new IllegalStateException(\u0026#34;只有已確認的訂單可以發貨\u0026#34;); } this.status = OrderStatus.SHIPPED; this.updatedAt = LocalDateTime.now(); } public void deliver() { if (status != OrderStatus.SHIPPED) { throw new IllegalStateException(\u0026#34;只有已發貨的訂單可以標記為送達\u0026#34;); } this.status = OrderStatus.DELIVERED; this.updatedAt = LocalDateTime.now(); } // Getters and Setters public String getId() { return id; } public void setId(String id) { this.id = id; } public OrderStatus getStatus() { return status; } public LocalDateTime getCreatedAt() { return createdAt; } public LocalDateTime getUpdatedAt() { return updatedAt; } } @Service public class OrderStateService { private final OrderRepository orderRepository; private final ApplicationEventPublisher eventPublisher; public OrderStateService(OrderRepository orderRepository, ApplicationEventPublisher eventPublisher) { this.orderRepository = orderRepository; this.eventPublisher = eventPublisher; } @Transactional public void confirmOrder(String orderId) { Order order = orderRepository.findById(orderId) .orElseThrow(() -\u0026gt; new OrderNotFoundException(\u0026#34;訂單不存在: \u0026#34; + orderId)); order.confirm(); orderRepository.save(order); eventPublisher.publishEvent(new OrderConfirmedEvent(order)); } @Transactional public void cancelOrder(String orderId) { Order order = orderRepository.findById(orderId) .orElseThrow(() -\u0026gt; new OrderNotFoundException(\u0026#34;訂單不存在: \u0026#34; + orderId)); order.cancel(); orderRepository.save(order); eventPublisher.publishEvent(new OrderCancelledEvent(order)); } @Transactional public void shipOrder(String orderId) { Order order = orderRepository.findById(orderId) .orElseThrow(() -\u0026gt; new OrderNotFoundException(\u0026#34;訂單不存在: \u0026#34; + orderId)); order.ship(); orderRepository.save(order); eventPublisher.publishEvent(new OrderShippedEvent(order)); } @Transactional public void deliverOrder(String orderId) { Order order = orderRepository.findById(orderId) .orElseThrow(() -\u0026gt; new OrderNotFoundException(\u0026#34;訂單不存在: \u0026#34; + orderId)); order.deliver(); orderRepository.save(order); eventPublisher.publishEvent(new OrderDeliveredEvent(order)); } } 企業級應用：微服務架構 UML 設計 系統架構圖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 /** * 微服務架構部署圖: * * ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ * │ 用戶服務 │ │ 訂單服務 │ │ 商品服務 │ * │ User Service │ │Order Service│ │Product Service│ * │ :8081 │ │ :8082 │ │ :8083 │ * └─────────────┘ └─────────────┘ └─────────────┘ * │ │ │ * └───────────────────┼───────────────────┘ * │ * ┌─────────────┐ * │ API Gateway │ * │ :8080 │ * └─────────────┘ * │ * ┌─────────────┐ * │ 前端應用 │ * │ :3000 │ * └─────────────┘ */ // API Gateway 配置 @Configuration @EnableZuulProxy public class GatewayConfig { @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder) { return builder.routes() .route(\u0026#34;user-service\u0026#34;, r -\u0026gt; r.path(\u0026#34;/api/users/**\u0026#34;) .uri(\u0026#34;lb://user-service\u0026#34;)) .route(\u0026#34;order-service\u0026#34;, r -\u0026gt; r.path(\u0026#34;/api/orders/**\u0026#34;) .uri(\u0026#34;lb://order-service\u0026#34;)) .route(\u0026#34;product-service\u0026#34;, r -\u0026gt; r.path(\u0026#34;/api/products/**\u0026#34;) .uri(\u0026#34;lb://product-service\u0026#34;)) .build(); } } // 服務間通信接口 @FeignClient(name = \u0026#34;user-service\u0026#34;) public interface UserServiceClient { @GetMapping(\u0026#34;/api/users/{id}\u0026#34;) User getUserById(@PathVariable Long id); @PostMapping(\u0026#34;/api/users\u0026#34;) User createUser(@RequestBody CreateUserRequest request); } @FeignClient(name = \u0026#34;product-service\u0026#34;) public interface ProductServiceClient { @GetMapping(\u0026#34;/api/products/{id}\u0026#34;) Product getProductById(@PathVariable Long id); @PostMapping(\u0026#34;/api/products/reserve\u0026#34;) ReservationResult reserveProducts(@RequestBody List\u0026lt;ProductReservation\u0026gt; reservations); } // 訂單服務實現 @Service public class OrderService { private final UserServiceClient userServiceClient; private final ProductServiceClient productServiceClient; private final OrderRepository orderRepository; public OrderService(UserServiceClient userServiceClient, ProductServiceClient productServiceClient, OrderRepository orderRepository) { this.userServiceClient = userServiceClient; this.productServiceClient = productServiceClient; this.orderRepository = orderRepository; } @Transactional public Order createOrder(CreateOrderRequest request) { // 驗證用戶 User user = userServiceClient.getUserById(request.getUserId()); if (user == null) { throw new UserNotFoundException(\u0026#34;用戶不存在\u0026#34;); } // 預留商品 List\u0026lt;ProductReservation\u0026gt; reservations = request.getItems().stream() .map(item -\u0026gt; new ProductReservation(item.getProductId(), item.getQuantity())) .collect(Collectors.toList()); ReservationResult result = productServiceClient.reserveProducts(reservations); if (!result.isSuccess()) { throw new ProductReservationException(\u0026#34;商品預留失敗\u0026#34;); } // 創建訂單 Order order = new Order(user.getId(), request.getItems()); return orderRepository.save(order); } } UML 建模最佳實踐 1. 模型一致性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 保持模型與代碼的一致性 public class Customer { private String customerId; private String name; private String email; private List\u0026lt;Order\u0026gt; orders; // 構造函數 public Customer(String customerId, String name, String email) { this.customerId = customerId; this.name = name; this.email = email; this.orders = new ArrayList\u0026lt;\u0026gt;(); } // UML 中定義的方法 public void addOrder(Order order) { orders.add(order); order.setCustomer(this); } public List\u0026lt;Order\u0026gt; getOrders() { return Collections.unmodifiableList(orders); } } 2. 適當的抽象級別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 高層設計 - 顯示主要組件 public interface PaymentService { PaymentResult processPayment(PaymentRequest request); } // 詳細設計 - 顯示具體實現 @Service public class CreditCardPaymentService implements PaymentService { private final CreditCardValidator validator; private final PaymentGateway gateway; private final TransactionLogger logger; @Override public PaymentResult processPayment(PaymentRequest request) { // 詳細實現邏輯 if (!validator.validate(request)) { return PaymentResult.failure(\u0026#34;驗證失敗\u0026#34;); } GatewayResponse response = gateway.charge(request); logger.log(request, response); return response.isSuccess() ? PaymentResult.success(response.getTransactionId()) : PaymentResult.failure(response.getErrorMessage()); } } 3. 文檔化標準 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 /** * 類別文檔模板 * * 類別名稱: OrderProcessor * 職責: 處理訂單相關的業務邏輯 * 協作者: OrderRepository, PaymentService, InventoryService * * 生命週期: * - 創建: 通過 Spring 容器自動創建 * - 銷毀: 應用程式關閉時自動銷毀 * * 狀態: 無狀態服務 * * 異常: * - OrderNotFoundException: 訂單不存在 * - PaymentException: 付款處理異常 * - InventoryException: 庫存不足 */ @Service public class OrderProcessor { private final OrderRepository orderRepository; private final PaymentService paymentService; private final InventoryService inventoryService; public OrderProcessor(OrderRepository orderRepository, PaymentService paymentService, InventoryService inventoryService) { this.orderRepository = orderRepository; this.paymentService = paymentService; this.inventoryService = inventoryService; } /** * 處理訂單 * * 前置條件: * - 訂單必須存在 * - 商品庫存充足 * - 付款信息有效 * * 後置條件: * - 訂單狀態更新 * - 庫存數量減少 * - 付款記錄創建 * * @param orderId 訂單ID * @return 處理結果 * @throws OrderNotFoundException 訂單不存在 * @throws PaymentException 付款失敗 * @throws InventoryException 庫存不足 */ @Transactional public OrderResult processOrder(String orderId) { // 實現邏輯 Order order = orderRepository.findById(orderId) .orElseThrow(() -\u0026gt; new OrderNotFoundException(\u0026#34;訂單不存在: \u0026#34; + orderId)); // 檢查庫存 if (!inventoryService.checkStock(order.getItems())) { throw new InventoryException(\u0026#34;庫存不足\u0026#34;); } // 處理付款 PaymentResult paymentResult = paymentService.processPayment(order.getPaymentInfo()); if (!paymentResult.isSuccess()) { throw new PaymentException(\u0026#34;付款失敗: \u0026#34; + paymentResult.getErrorMessage()); } // 更新訂單狀態 order.setStatus(OrderStatus.CONFIRMED); orderRepository.save(order); return OrderResult.success(order); } } 總結 UML 統一建模語言是軟體開發中的重要工具：\n關鍵優勢 視覺化溝通：提供清晰的視覺表示，促進團隊溝通 設計驗證：在編碼前驗證設計的正確性 文檔化：為系統提供完整的文檔 標準化：統一的符號和語義，便於理解 最佳實踐 適當的細節層次：根據目標受眾選擇合適的抽象級別 模型一致性：確保 UML 模型與實際代碼保持一致 迭代改進：隨著系統演進不斷更新 UML 模型 工具支援：使用專業的 UML 建模工具提高效率 現代應用 在現代軟體開發中，UML 特別適用於：\n微服務架構設計 領域驅動設計（DDD） 企業級應用架構 系統整合設計 通過正確使用 UML，可以大幅提升軟體設計的品質和團隊協作效率。\n參考資料 UML 2.5 官方規範 Martin Fowler - UML Distilled Object-Oriented Analysis and Design with Applications Spring Boot 官方文檔 ","permalink":"https://xinqilin.github.io/post/architecture/uml/","tags":["UML","Unified Modeling Language","Software Design","Architecture","Class Diagram","Sequence Diagram","Use Case Diagram","Design Patterns","Object-Oriented Design","Software Modeling","Enterprise Architecture","System Design"],"title":"UML 統一建模語言完整指南：軟體設計與架構建模最佳實踐"},{"content":"概述 Spring Framework 的核心特性之一是依賴注入（Dependency Injection, DI），它實現了控制反轉（Inversion of Control, IoC）的設計模式。正確使用依賴注入不僅能提升程式碼的可測試性和可維護性，還能降低組件間的耦合度。本文將深入探討 Spring 中各種依賴注入方式，並重點說明最佳實踐。\n為什麼不建議使用 @Autowired Field Injection？ 當你在 IntelliJ IDEA 中使用 @Autowired 進行欄位注入時，會看到這樣的警告：\n1 2 3 4 Field injection is not recommended Inspection info: Spring Team recommends: \u0026#34;Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies\u0026#34;. 這個警告背後有深刻的技術理由，讓我們逐一分析。\nSpring 依賴注入的三種方式 1. Field Injection（不建議） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Service public class OrderService { @Autowired private PaymentService paymentService; // ❌ 不建議 @Autowired private InventoryService inventoryService; // ❌ 不建議 @Autowired private EmailService emailService; // ❌ 不建議 public void processOrder(Order order) { paymentService.processPayment(order); inventoryService.updateStock(order); emailService.sendConfirmation(order); } } Field Injection 的問題：\n問題 1：違反單一職責原則 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Service public class UserService { @Autowired private UserRepository userRepository; @Autowired private EmailService emailService; @Autowired private SmsService smsService; @Autowired private AuditService auditService; @Autowired private CacheService cacheService; @Autowired private ValidationService validationService; @Autowired private SecurityService securityService; @Autowired private LoggingService loggingService; @Autowired private MetricsService metricsService; @Autowired private ConfigurationService configurationService; // ... 還有更多依賴 // 當你看到這麼多依賴時，應該重新思考這個類別的職責 } 問題 2：無法進行單元測試 1 2 3 4 5 6 7 8 9 10 11 public class OrderServiceTest { @Test public void testProcessOrder() { // ❌ 無法輕易創建 OrderService 實例進行測試 OrderService orderService = new OrderService(); // PaymentService 為 null! Order order = new Order(); orderService.processOrder(order); // NullPointerException! } } 問題 3：隱藏的依賴關係 1 2 3 4 // 從這個建構子看不出這個類別需要什麼依賴 public class OrderService { // 依賴隱藏在類別內部，外部無法得知 } 問題 4：循環依賴不易發現 1 2 3 4 5 6 7 8 9 10 11 @Service public class ServiceA { @Autowired private ServiceB serviceB; // 循環依賴在運行時才會發現 } @Service public class ServiceB { @Autowired private ServiceA serviceA; // 循環依賴在運行時才會發現 } 2. Setter Injection（條件性建議） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Service public class OrderService { private PaymentService paymentService; private EmailService emailService; @Autowired public void setPaymentService(PaymentService paymentService) { this.paymentService = paymentService; } @Autowired public void setEmailService(EmailService emailService) { this.emailService = emailService; } public void processOrder(Order order) { if (paymentService != null) { paymentService.processPayment(order); } if (emailService != null) { emailService.sendConfirmation(order); } } } Setter Injection 適用場景：\n可選依賴（Optional Dependencies） 循環依賴的暫時解決方案 需要在運行時重新配置依賴 3. Constructor Injection（強烈建議） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Service public class OrderService { private final PaymentService paymentService; private final InventoryService inventoryService; private final EmailService emailService; // ✅ 推薦：Constructor Injection public OrderService(PaymentService paymentService, InventoryService inventoryService, EmailService emailService) { this.paymentService = Objects.requireNonNull(paymentService, \u0026#34;PaymentService cannot be null\u0026#34;); this.inventoryService = Objects.requireNonNull(inventoryService, \u0026#34;InventoryService cannot be null\u0026#34;); this.emailService = Objects.requireNonNull(emailService, \u0026#34;EmailService cannot be null\u0026#34;); } public void processOrder(Order order) { paymentService.processPayment(order); inventoryService.updateStock(order); emailService.sendConfirmation(order); } } Constructor Injection 的優勢 1. 不可變性（Immutability） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Service public class OrderService { // ✅ final 關鍵字確保依賴不會被修改 private final PaymentService paymentService; private final InventoryService inventoryService; public OrderService(PaymentService paymentService, InventoryService inventoryService) { this.paymentService = paymentService; this.inventoryService = inventoryService; } // 無法意外修改依賴關係 } 2. 強制依賴檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Service public class OrderService { private final PaymentService paymentService; public OrderService(PaymentService paymentService) { // ✅ 在物件創建時就確保依賴存在 this.paymentService = Objects.requireNonNull(paymentService, \u0026#34;PaymentService is required for OrderService\u0026#34;); } public void processOrder(Order order) { // ✅ 保證 paymentService 不為 null paymentService.processPayment(order); } } 3. 易於單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @ExtendWith(MockitoExtension.class) class OrderServiceTest { @Mock private PaymentService paymentService; @Mock private InventoryService inventoryService; @Mock private EmailService emailService; private OrderService orderService; @BeforeEach void setUp() { // ✅ 易於創建測試實例 orderService = new OrderService(paymentService, inventoryService, emailService); } @Test void testProcessOrder() { // Given Order order = new Order(); when(paymentService.processPayment(order)).thenReturn(true); // When orderService.processOrder(order); // Then verify(paymentService).processPayment(order); verify(inventoryService).updateStock(order); verify(emailService).sendConfirmation(order); } } 4. 明確的依賴關係 1 2 3 4 5 6 7 8 9 10 11 // ✅ 從建構子就能清楚看到所有依賴 public class OrderService { public OrderService(PaymentService paymentService, InventoryService inventoryService, EmailService emailService, AuditService auditService) { // 如果建構子參數太多，說明這個類別承擔了太多職責 // 這是一個程式碼異味（Code Smell），提醒我們重構 } } 使用 Lombok 簡化 Constructor Injection 基本用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Service @RequiredArgsConstructor // ✅ Lombok 自動生成建構子 public class OrderService { private final PaymentService paymentService; private final InventoryService inventoryService; private final EmailService emailService; // Lombok 自動生成： // public OrderService(PaymentService paymentService, // InventoryService inventoryService, // EmailService emailService) { // this.paymentService = paymentService; // this.inventoryService = inventoryService; // this.emailService = emailService; // } public void processOrder(Order order) { paymentService.processPayment(order); inventoryService.updateStock(order); emailService.sendConfirmation(order); } } 混合必要和可選依賴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Service @RequiredArgsConstructor public class NotificationService { // 必要依賴（final） private final EmailService emailService; private final SmsService smsService; // 可選依賴（non-final） private PushNotificationService pushService; private SlackService slackService; @Autowired(required = false) public void setPushNotificationService(PushNotificationService pushService) { this.pushService = pushService; } @Autowired(required = false) public void setSlackService(SlackService slackService) { this.slackService = slackService; } public void sendNotification(String message, User user) { // 必要服務 emailService.send(message, user.getEmail()); smsService.send(message, user.getPhone()); // 可選服務 if (pushService != null) { pushService.send(message, user.getDeviceToken()); } if (slackService != null) { slackService.send(message, user.getSlackChannel()); } } } 進階依賴注入技巧 1. 條件性依賴注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Configuration public class ServiceConfiguration { @Bean @ConditionalOnProperty(name = \u0026#34;payment.provider\u0026#34;, havingValue = \u0026#34;stripe\u0026#34;) public PaymentService stripePaymentService() { return new StripePaymentService(); } @Bean @ConditionalOnProperty(name = \u0026#34;payment.provider\u0026#34;, havingValue = \u0026#34;paypal\u0026#34;) public PaymentService paypalPaymentService() { return new PaypalPaymentService(); } @Bean @ConditionalOnMissingBean(PaymentService.class) public PaymentService defaultPaymentService() { return new DefaultPaymentService(); } } 2. 集合注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Service @RequiredArgsConstructor public class NotificationService { // ✅ 注入所有 NotificationProvider 實作 private final List\u0026lt;NotificationProvider\u0026gt; providers; public void sendNotification(String message, User user) { providers.forEach(provider -\u0026gt; { try { provider.send(message, user); } catch (Exception e) { log.warn(\u0026#34;Failed to send notification via {}: {}\u0026#34;, provider.getClass().getSimpleName(), e.getMessage()); } }); } } // 不同的通知提供者 @Component public class EmailNotificationProvider implements NotificationProvider { public void send(String message, User user) { // 發送郵件 } } @Component public class SmsNotificationProvider implements NotificationProvider { public void send(String message, User user) { // 發送簡訊 } } 3. 限定符注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 使用 @Qualifier 區分相同類型的 Bean @Service @RequiredArgsConstructor public class OrderService { @Qualifier(\u0026#34;primary\u0026#34;) private final PaymentService primaryPaymentService; @Qualifier(\u0026#34;backup\u0026#34;) private final PaymentService backupPaymentService; public void processPayment(Order order) { try { primaryPaymentService.processPayment(order); } catch (PaymentException e) { log.warn(\u0026#34;Primary payment failed, trying backup: {}\u0026#34;, e.getMessage()); backupPaymentService.processPayment(order); } } } @Configuration public class PaymentConfiguration { @Bean @Qualifier(\u0026#34;primary\u0026#34;) public PaymentService primaryPaymentService() { return new StripePaymentService(); } @Bean @Qualifier(\u0026#34;backup\u0026#34;) public PaymentService backupPaymentService() { return new PaypalPaymentService(); } } 4. Profile 相關注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Configuration public class DatabaseConfiguration { @Bean @Profile(\u0026#34;dev\u0026#34;) public DataSource devDataSource() { return new H2DataSource(); } @Bean @Profile(\u0026#34;prod\u0026#34;) public DataSource prodDataSource() { return new MySQLDataSource(); } @Bean @Profile(\u0026#34;test\u0026#34;) public DataSource testDataSource() { return new TestContainerDataSource(); } } 常見陷阱與解決方案 1. 循環依賴問題 問題示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class OrderService { private final CustomerService customerService; public OrderService(CustomerService customerService) { this.customerService = customerService; } } @Service public class CustomerService { private final OrderService orderService; // ❌ 循環依賴 public CustomerService(OrderService orderService) { this.orderService = orderService; } } 解決方案 1：重新設計架構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // ✅ 引入共享服務，避免循環依賴 @Service @RequiredArgsConstructor public class OrderService { private final CustomerRepository customerRepository; private final OrderRepository orderRepository; private final OrderValidationService validationService; } @Service @RequiredArgsConstructor public class CustomerService { private final CustomerRepository customerRepository; private final OrderRepository orderRepository; } @Service @RequiredArgsConstructor public class OrderValidationService { private final CustomerRepository customerRepository; private final PaymentService paymentService; } 解決方案 2：使用事件驅動架構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Service @RequiredArgsConstructor public class OrderService { private final ApplicationEventPublisher eventPublisher; private final OrderRepository orderRepository; public void createOrder(Order order) { order = orderRepository.save(order); // ✅ 發布事件而非直接調用 eventPublisher.publishEvent(new OrderCreatedEvent(order)); } } @Service @RequiredArgsConstructor @EventListener public class CustomerService { private final CustomerRepository customerRepository; @EventListener public void handleOrderCreated(OrderCreatedEvent event) { // 處理訂單創建事件 updateCustomerOrderCount(event.getOrder().getCustomerId()); } } 2. 建構子參數過多 問題識別： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class UserService { // ❌ 建構子參數過多，違反 SRP 原則 public UserService(UserRepository userRepository, EmailService emailService, SmsService smsService, AuditService auditService, CacheService cacheService, ValidationService validationService, SecurityService securityService, NotificationService notificationService, PaymentService paymentService, ReportService reportService) { // 太多依賴！ } } 解決方案：拆分服務 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // ✅ 拆分為多個專門的服務 @Service @RequiredArgsConstructor public class UserService { private final UserRepository userRepository; private final UserValidationService validationService; private final UserSecurityService securityService; } @Service @RequiredArgsConstructor public class UserNotificationService { private final EmailService emailService; private final SmsService smsService; private final NotificationService notificationService; } @Service @RequiredArgsConstructor public class UserBillingService { private final PaymentService paymentService; private final BillingRepository billingRepository; } 3. 可選依賴處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Service @RequiredArgsConstructor public class UserService { private final UserRepository userRepository; private final EmailService emailService; // ✅ 可選依賴使用 Optional private final Optional\u0026lt;SmsService\u0026gt; smsService; public void createUser(User user) { user = userRepository.save(user); // 必要服務 emailService.sendWelcomeEmail(user); // 可選服務 smsService.ifPresent(service -\u0026gt; service.sendWelcomeSms(user.getPhone()) ); } } @Configuration public class ServiceConfiguration { @Bean @ConditionalOnProperty(name = \u0026#34;sms.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public SmsService smsService() { return new TwilioSmsService(); } } 效能考量 1. 延遲初始化 1 2 3 4 5 6 7 8 9 10 11 12 @Service @Lazy // ✅ 延遲初始化，減少啟動時間 @RequiredArgsConstructor public class ReportService { private final DataAnalysisService dataAnalysisService; private final ChartGenerationService chartService; public Report generateReport(String type) { // 只有在實際使用時才會初始化 return dataAnalysisService.analyze(type); } } 2. 原型 Bean 的注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Service @RequiredArgsConstructor public class OrderProcessorService { private final ApplicationContext applicationContext; public void processOrder(Order order) { // ✅ 每次都創建新的處理器實例 OrderProcessor processor = applicationContext.getBean(OrderProcessor.class); processor.process(order); } } @Component @Scope(\u0026#34;prototype\u0026#34;) // 原型範圍 public class OrderProcessor { public void process(Order order) { // 處理邏輯 } } 3. Provider 模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Service @RequiredArgsConstructor public class OrderService { // ✅ 使用 Provider 延遲獲取 Bean private final Provider\u0026lt;ExpensiveService\u0026gt; expensiveServiceProvider; public void processSpecialOrder(Order order) { if (order.isSpecial()) { // 只有在需要時才獲取昂貴的服務 ExpensiveService service = expensiveServiceProvider.get(); service.processSpecialOrder(order); } } } 測試最佳實踐 1. 使用 Constructor Injection 的測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @ExtendWith(MockitoExtension.class) class OrderServiceTest { @Mock private PaymentService paymentService; @Mock private InventoryService inventoryService; @Mock private EmailService emailService; private OrderService orderService; @BeforeEach void setUp() { // ✅ 清晰的測試設置 orderService = new OrderService(paymentService, inventoryService, emailService); } @Test void shouldProcessOrderSuccessfully() { // Given Order order = TestDataBuilder.createOrder(); when(paymentService.processPayment(order)).thenReturn(PaymentResult.success()); // When OrderResult result = orderService.processOrder(order); // Then assertThat(result.isSuccessful()).isTrue(); verify(paymentService).processPayment(order); verify(inventoryService).updateStock(order); verify(emailService).sendConfirmation(order); } @Test void shouldHandlePaymentFailure() { // Given Order order = TestDataBuilder.createOrder(); when(paymentService.processPayment(order)) .thenThrow(new PaymentException(\u0026#34;Payment failed\u0026#34;)); // When \u0026amp; Then assertThatThrownBy(() -\u0026gt; orderService.processOrder(order)) .isInstanceOf(OrderProcessingException.class) .hasMessageContaining(\u0026#34;Payment failed\u0026#34;); verify(inventoryService, never()).updateStock(order); verify(emailService, never()).sendConfirmation(order); } } 2. Integration Testing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @SpringBootTest @TestPropertySource(properties = { \u0026#34;spring.datasource.url=jdbc:h2:mem:testdb\u0026#34;, \u0026#34;payment.provider=mock\u0026#34; }) class OrderServiceIntegrationTest { @Autowired private OrderService orderService; @MockBean // ✅ Spring Boot 的 Mock 支援 private EmailService emailService; @Test void shouldProcessOrderEndToEnd() { // Given Order order = TestDataBuilder.createOrder(); // When OrderResult result = orderService.processOrder(order); // Then assertThat(result.isSuccessful()).isTrue(); verify(emailService).sendConfirmation(order); } } Spring Boot 中的依賴注入 1. 自動配置與依賴注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @SpringBootApplication public class ECommerceApplication { public static void main(String[] args) { SpringApplication.run(ECommerceApplication.class, args); } } // ✅ Spring Boot 自動配置 + Constructor Injection @RestController @RequiredArgsConstructor @RequestMapping(\u0026#34;/api/orders\u0026#34;) public class OrderController { private final OrderService orderService; private final OrderMapper orderMapper; @PostMapping public ResponseEntity\u0026lt;OrderDto\u0026gt; createOrder(@RequestBody CreateOrderRequest request) { Order order = orderMapper.toEntity(request); Order savedOrder = orderService.createOrder(order); OrderDto dto = orderMapper.toDto(savedOrder); return ResponseEntity.ok(dto); } } 2. Configuration Properties 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @ConfigurationProperties(prefix = \u0026#34;app.order\u0026#34;) @ConstructorBinding // ✅ 不可變配置類 @RequiredArgsConstructor @Getter public class OrderProperties { private final Duration timeout; private final int maxRetries; private final boolean enableNotifications; private final PaymentConfig payment; @RequiredArgsConstructor @Getter public static class PaymentConfig { private final String provider; private final Duration timeout; private final boolean enableRetry; } } // 使用配置 @Service @RequiredArgsConstructor public class OrderService { private final OrderProperties properties; private final PaymentService paymentService; public void processOrder(Order order) { try { paymentService.processPayment(order, properties.getPayment().getTimeout()); } catch (PaymentException e) { if (properties.getPayment().isEnableRetry()) { retryPayment(order); } } } } 監控與偵錯 1. Bean 依賴關係檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Component @RequiredArgsConstructor public class DependencyHealthIndicator implements HealthIndicator { private final List\u0026lt;HealthCheckable\u0026gt; healthCheckableServices; @Override public Health health() { Health.Builder builder = Health.up(); for (HealthCheckable service : healthCheckableServices) { try { service.checkHealth(); builder.withDetail(service.getClass().getSimpleName(), \u0026#34;UP\u0026#34;); } catch (Exception e) { builder.withDetail(service.getClass().getSimpleName(), \u0026#34;DOWN: \u0026#34; + e.getMessage()); builder.down(); } } return builder.build(); } } 2. 依賴注入除錯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @EventListener @Component @Slf4j public class ApplicationStartupListener { @EventListener public void handleContextRefresh(ContextRefreshedEvent event) { ApplicationContext context = event.getApplicationContext(); log.info(\u0026#34;=== Spring Context Loaded ===\u0026#34;); log.info(\u0026#34;Total beans: {}\u0026#34;, context.getBeanDefinitionCount()); // 列出所有 Bean String[] beanNames = context.getBeanDefinitionNames(); for (String beanName : beanNames) { Object bean = context.getBean(beanName); log.debug(\u0026#34;Bean: {} -\u0026gt; {}\u0026#34;, beanName, bean.getClass().getName()); } } } 總結 依賴注入方式比較 注入方式 推薦度 優點 缺點 適用場景 Constructor ⭐⭐⭐⭐⭐ 不可變、強制檢查、易測試 建構子可能變長 預設選擇 Setter ⭐⭐⭐ 靈活、支援可選依賴 可變、晚期檢查 可選依賴、循環依賴 Field ⭐ 簡潔 難測試、隱藏依賴、可變 避免使用 最佳實踐總結 優先使用 Constructor Injection：確保依賴的不可變性和強制檢查 使用 Lombok @RequiredArgsConstructor：減少模板程式碼 限制建構子參數數量：超過 5 個參數考慮重構 使用 final 關鍵字：確保依賴不會被意外修改 適當使用 @Qualifier：區分相同類型的 Bean 考慮可選依賴：使用 Optional 或 Setter Injection 避免循環依賴：重新設計架構或使用事件驅動 編寫完整的測試：利用 Constructor Injection 的可測試性 遷移策略 如果你的專案目前大量使用 Field Injection，可以採用漸進式遷移：\n新程式碼：立即採用 Constructor Injection 現有程式碼：在修改時逐步重構 關鍵服務：優先重構核心業務邏輯 工具支援：使用 IDE 的自動重構功能 正確的依賴注入不僅是技術最佳實踐，更是建立可維護、可測試、高品質軟體的基礎。\n參考資料 Spring Framework Reference Documentation Spring Boot Reference Guide Effective Java by Joshua Bloch Clean Code by Robert Martin Spring in Action by Craig Walls ","permalink":"https://xinqilin.github.io/post/backend/@autowired/","tags":["Java","Spring","DI","IoC","Autowired","Constructor","Best-Practices"],"title":"Spring 依賴注入完整指南：@Autowired 與最佳實踐"},{"content":"概述 SOLID 是物件導向程式設計和軟體架構設計中五個核心設計原則的縮寫，由 Robert C. Martin（Uncle Bob）在 21 世紀初期提出。這些原則旨在讓軟體設計更加容易理解、靈活且可維護。\nSOLID 原則不僅適用於物件導向程式設計，也是現代軟體架構的基石，從微服務設計到 Clean Architecture 都深受其影響。\nSOLID 原則概覽 首字母 英文原則名稱 中文名稱 核心概念 S Single Responsibility Principle 單一職責原則 一個類別應該只有一個改變的理由 O Open/Closed Principle 開閉原則 對擴展開放，對修改封閉 L Liskov Substitution Principle 里氏替換原則 子類別應該能完全替換父類別 I Interface Segregation Principle 介面隔離原則 客戶端不應該依賴它不需要的介面 D Dependency Inversion Principle 依賴反轉原則 依賴於抽象而非具體實作 1. Single Responsibility Principle (SRP) - 單一職責原則 定義 一個類別應該只有一個引起它變化的原因\n核心概念 高內聚性：類別內部的方法和屬性應該為同一個目標服務 低耦合性：減少類別之間的依賴關係 明確責任：每個類別都應該有明確且單一的職責 違反 SRP 的範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // ❌ 違反 SRP：一個類別承擔多種職責 public class User { private String name; private String email; // 用戶資料驗證職責 public boolean validateEmail(String email) { return email.contains(\u0026#34;@\u0026#34;) \u0026amp;\u0026amp; email.contains(\u0026#34;.\u0026#34;); } // 用戶持久化職責 public void saveToDatabase() { // 資料庫存儲邏輯 System.out.println(\u0026#34;儲存用戶到資料庫\u0026#34;); } // 用戶通知職責 public void sendWelcomeEmail() { // 郵件發送邏輯 System.out.println(\u0026#34;發送歡迎郵件\u0026#34;); } // 用戶報表職責 public String generateUserReport() { return \u0026#34;用戶報表: \u0026#34; + name + \u0026#34; - \u0026#34; + email; } } 遵循 SRP 的重構範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 // ✅ 遵循 SRP：職責分離 // 1. 用戶實體類別（僅負責用戶資料） public class User { private String name; private String email; public User(String name, String email) { this.name = name; this.email = email; } // Getter and Setter methods public String getName() { return name; } public String getEmail() { return email; } public void setName(String name) { this.name = name; } public void setEmail(String email) { this.email = email; } } // 2. 用戶驗證服務（僅負責驗證邏輯） @Service public class UserValidator { public boolean validateEmail(String email) { return email != null \u0026amp;\u0026amp; email.contains(\u0026#34;@\u0026#34;) \u0026amp;\u0026amp; email.contains(\u0026#34;.\u0026#34;) \u0026amp;\u0026amp; email.length() \u0026gt; 5; } public boolean validateName(String name) { return name != null \u0026amp;\u0026amp; name.trim().length() \u0026gt; 0 \u0026amp;\u0026amp; name.length() \u0026lt;= 50; } public ValidationResult validateUser(User user) { ValidationResult result = new ValidationResult(); if (!validateName(user.getName())) { result.addError(\u0026#34;用戶名格式無效\u0026#34;); } if (!validateEmail(user.getEmail())) { result.addError(\u0026#34;郵箱格式無效\u0026#34;); } return result; } } // 3. 用戶持久化服務（僅負責資料存取） @Repository public class UserRepository { public void save(User user) { // 資料庫存儲邏輯 System.out.println(\u0026#34;儲存用戶到資料庫: \u0026#34; + user.getName()); } public User findByEmail(String email) { // 查詢邏輯 return new User(\u0026#34;找到的用戶\u0026#34;, email); } public List\u0026lt;User\u0026gt; findAll() { // 查詢所有用戶 return Arrays.asList(new User(\u0026#34;用戶1\u0026#34;, \u0026#34;user1@example.com\u0026#34;)); } } // 4. 用戶通知服務（僅負責通知邏輯） @Service public class UserNotificationService { public void sendWelcomeEmail(User user) { System.out.println(\u0026#34;發送歡迎郵件給: \u0026#34; + user.getEmail()); } public void sendPasswordResetEmail(User user) { System.out.println(\u0026#34;發送密碼重設郵件給: \u0026#34; + user.getEmail()); } public void sendAccountActivationEmail(User user) { System.out.println(\u0026#34;發送帳戶啟用郵件給: \u0026#34; + user.getEmail()); } } // 5. 用戶報表服務（僅負責報表生成） @Service public class UserReportService { public String generateUserReport(User user) { return String.format(\u0026#34;用戶報表\\n姓名: %s\\n郵箱: %s\\n生成時間: %s\u0026#34;, user.getName(), user.getEmail(), LocalDateTime.now()); } public String generateUsersListReport(List\u0026lt;User\u0026gt; users) { StringBuilder report = new StringBuilder(\u0026#34;用戶列表報表\\n\u0026#34;); users.forEach(user -\u0026gt; report.append(String.format(\u0026#34;- %s (%s)\\n\u0026#34;, user.getName(), user.getEmail())) ); return report.toString(); } } // 6. 用戶服務協調器（組合各種服務） @Service public class UserService { private final UserValidator userValidator; private final UserRepository userRepository; private final UserNotificationService notificationService; public UserService(UserValidator userValidator, UserRepository userRepository, UserNotificationService notificationService) { this.userValidator = userValidator; this.userRepository = userRepository; this.notificationService = notificationService; } public Result\u0026lt;User\u0026gt; createUser(String name, String email) { User user = new User(name, email); // 驗證用戶資料 ValidationResult validation = userValidator.validateUser(user); if (!validation.isValid()) { return Result.failure(\u0026#34;驗證失敗: \u0026#34; + validation.getErrors()); } // 儲存用戶 userRepository.save(user); // 發送歡迎郵件 notificationService.sendWelcomeEmail(user); return Result.success(user); } } SRP 的好處 降低複雜度：每個類別的責任明確，易於理解 提高可讀性：程式碼結構清晰，功能劃分明確 增強可維護性：修改某個功能時，只需要關注特定的類別 提升可測試性：職責單一的類別更容易進行單元測試 促進重用性：功能獨立的類別可以在不同場景中重複使用 2. Open/Closed Principle (OCP) - 開閉原則 定義 軟體實體（類別、模組、函數等）應該對擴展開放，對修改封閉\n核心概念 對擴展開放：可以透過新增程式碼來擴展功能 對修改封閉：不應該修改現有的程式碼 策略模式：透過抽象介面實現不同的實作策略 違反 OCP 的範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // ❌ 違反 OCP：每次新增形狀都需要修改計算器類別 public class AreaCalculator { public double calculateArea(Object shape) { if (shape instanceof Rectangle) { Rectangle rectangle = (Rectangle) shape; return rectangle.getWidth() * rectangle.getHeight(); } else if (shape instanceof Circle) { Circle circle = (Circle) shape; return Math.PI * circle.getRadius() * circle.getRadius(); } else if (shape instanceof Triangle) { // 新增三角形需要修改此方法 Triangle triangle = (Triangle) shape; return 0.5 * triangle.getBase() * triangle.getHeight(); } // 每次新增新形狀都需要修改這裡 throw new IllegalArgumentException(\u0026#34;不支援的形狀類型\u0026#34;); } } 遵循 OCP 的重構範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 // ✅ 遵循 OCP：定義抽象介面 public interface Shape { double calculateArea(); String getShapeType(); } // 具體實作 - 矩形 public class Rectangle implements Shape { private double width; private double height; public Rectangle(double width, double height) { this.width = width; this.height = height; } @Override public double calculateArea() { return width * height; } @Override public String getShapeType() { return \u0026#34;矩形\u0026#34;; } // Getter methods public double getWidth() { return width; } public double getHeight() { return height; } } // 具體實作 - 圓形 public class Circle implements Shape { private double radius; public Circle(double radius) { this.radius = radius; } @Override public double calculateArea() { return Math.PI * radius * radius; } @Override public String getShapeType() { return \u0026#34;圓形\u0026#34;; } public double getRadius() { return radius; } } // 具體實作 - 三角形（新增時無需修改現有程式碼） public class Triangle implements Shape { private double base; private double height; public Triangle(double base, double height) { this.base = base; this.height = height; } @Override public double calculateArea() { return 0.5 * base * height; } @Override public String getShapeType() { return \u0026#34;三角形\u0026#34;; } public double getBase() { return base; } public double getHeight() { return height; } } // 新增多邊形（無需修改現有程式碼） public class Polygon implements Shape { private List\u0026lt;Point\u0026gt; vertices; public Polygon(List\u0026lt;Point\u0026gt; vertices) { this.vertices = vertices; } @Override public double calculateArea() { // 使用鞋帶公式計算多邊形面積 double area = 0; int n = vertices.size(); for (int i = 0; i \u0026lt; n; i++) { int j = (i + 1) % n; area += vertices.get(i).getX() * vertices.get(j).getY(); area -= vertices.get(j).getX() * vertices.get(i).getY(); } return Math.abs(area) / 2.0; } @Override public String getShapeType() { return \u0026#34;多邊形\u0026#34;; } } // 面積計算器（無需修改，支援所有 Shape 實作） @Service public class AreaCalculator { public double calculateArea(Shape shape) { return shape.calculateArea(); } public List\u0026lt;AreaReport\u0026gt; calculateMultipleAreas(List\u0026lt;Shape\u0026gt; shapes) { return shapes.stream() .map(shape -\u0026gt; new AreaReport( shape.getShapeType(), shape.calculateArea() )) .collect(Collectors.toList()); } public double calculateTotalArea(List\u0026lt;Shape\u0026gt; shapes) { return shapes.stream() .mapToDouble(Shape::calculateArea) .sum(); } } // 形狀工廠（支援擴展新形狀） @Component public class ShapeFactory { public Shape createRectangle(double width, double height) { return new Rectangle(width, height); } public Shape createCircle(double radius) { return new Circle(radius); } public Shape createTriangle(double base, double height) { return new Triangle(base, height); } public Shape createPolygon(List\u0026lt;Point\u0026gt; vertices) { return new Polygon(vertices); } } // 使用範例 @RestController @RequestMapping(\u0026#34;/shapes\u0026#34;) public class ShapeController { private final AreaCalculator areaCalculator; private final ShapeFactory shapeFactory; public ShapeController(AreaCalculator areaCalculator, ShapeFactory shapeFactory) { this.areaCalculator = areaCalculator; this.shapeFactory = shapeFactory; } @PostMapping(\u0026#34;/rectangle/area\u0026#34;) public AreaResponse calculateRectangleArea(@RequestBody RectangleRequest request) { Shape rectangle = shapeFactory.createRectangle(request.getWidth(), request.getHeight()); double area = areaCalculator.calculateArea(rectangle); return new AreaResponse(rectangle.getShapeType(), area); } @PostMapping(\u0026#34;/circle/area\u0026#34;) public AreaResponse calculateCircleArea(@RequestBody CircleRequest request) { Shape circle = shapeFactory.createCircle(request.getRadius()); double area = areaCalculator.calculateArea(circle); return new AreaResponse(circle.getShapeType(), area); } } 進階應用：策略模式與工廠模式結合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 // 折扣策略介面 public interface DiscountStrategy { double calculateDiscount(double originalPrice); String getStrategyName(); } // 具體折扣策略 @Component(\u0026#34;regular\u0026#34;) public class RegularCustomerDiscount implements DiscountStrategy { @Override public double calculateDiscount(double originalPrice) { return originalPrice * 0.05; // 5% 折扣 } @Override public String getStrategyName() { return \u0026#34;一般客戶折扣\u0026#34;; } } @Component(\u0026#34;vip\u0026#34;) public class VipCustomerDiscount implements DiscountStrategy { @Override public double calculateDiscount(double originalPrice) { return originalPrice * 0.15; // 15% 折扣 } @Override public String getStrategyName() { return \u0026#34;VIP 客戶折扣\u0026#34;; } } @Component(\u0026#34;premium\u0026#34;) public class PremiumCustomerDiscount implements DiscountStrategy { @Override public double calculateDiscount(double originalPrice) { return originalPrice * 0.25; // 25% 折扣 } @Override public String getStrategyName() { return \u0026#34;尊享客戶折扣\u0026#34;; } } // 折扣計算器（對修改封閉，對擴展開放） @Service public class DiscountCalculator { private final Map\u0026lt;String, DiscountStrategy\u0026gt; strategies; public DiscountCalculator(Map\u0026lt;String, DiscountStrategy\u0026gt; strategies) { this.strategies = strategies; } public DiscountResult calculateDiscount(String customerType, double originalPrice) { DiscountStrategy strategy = strategies.get(customerType); if (strategy == null) { throw new IllegalArgumentException(\u0026#34;不支援的客戶類型: \u0026#34; + customerType); } double discountAmount = strategy.calculateDiscount(originalPrice); double finalPrice = originalPrice - discountAmount; return new DiscountResult( strategy.getStrategyName(), originalPrice, discountAmount, finalPrice ); } } 3. Liskov Substitution Principle (LSP) - 里氏替換原則 定義 子類別必須能夠替換其父類別，而不會改變程式的正確性\n核心概念 行為相容性：子類別的行為應該與父類別一致 契約保持：子類別不能違反父類別建立的契約 強化前置條件：子類別不能強化前置條件 弱化後置條件：子類別不能弱化後置條件 違反 LSP 的範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 // ❌ 違反 LSP：正方形修改了矩形的行為契約 public class Rectangle { protected double width; protected double height; public Rectangle(double width, double height) { this.width = width; this.height = height; } public void setWidth(double width) { this.width = width; } public void setHeight(double height) { this.height = height; } public double getWidth() { return width; } public double getHeight() { return height; } public double getArea() { return width * height; } } // ❌ 正方形繼承矩形，但違反了里氏替換原則 public class Square extends Rectangle { public Square(double side) { super(side, side); } // 違反LSP：改變了父類別的行為契約 @Override public void setWidth(double width) { this.width = width; this.height = width; // 強制保持正方形性質 } @Override public void setHeight(double height) { this.width = height; // 強制保持正方形性質 this.height = height; } } // 測試程式碼展示問題 public class GeometryTest { public static void testRectangle(Rectangle rectangle) { rectangle.setWidth(4); rectangle.setHeight(5); // 期望面積是 20，但如果傳入 Square 物件，面積會是 25 double expectedArea = 20; double actualArea = rectangle.getArea(); System.out.println(\u0026#34;期望面積: \u0026#34; + expectedArea); System.out.println(\u0026#34;實際面積: \u0026#34; + actualArea); System.out.println(\u0026#34;測試結果: \u0026#34; + (expectedArea == actualArea ? \u0026#34;通過\u0026#34; : \u0026#34;失敗\u0026#34;)); } public static void main(String[] args) { Rectangle rectangle = new Rectangle(0, 0); testRectangle(rectangle); // 通過 Rectangle square = new Square(0); testRectangle(square); // 失敗！違反了 LSP } } 遵循 LSP 的重構範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 // ✅ 遵循 LSP：重新設計繼承階層 // 抽象基礎類別 public abstract class Shape { public abstract double getArea(); public abstract double getPerimeter(); public abstract String getShapeType(); // 模板方法 public String getShapeInfo() { return String.format(\u0026#34;%s - 面積: %.2f, 周長: %.2f\u0026#34;, getShapeType(), getArea(), getPerimeter()); } } // 矩形實作 public class Rectangle extends Shape { private double width; private double height; public Rectangle(double width, double height) { if (width \u0026lt;= 0 || height \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;長度和寬度必須大於 0\u0026#34;); } this.width = width; this.height = height; } @Override public double getArea() { return width * height; } @Override public double getPerimeter() { return 2 * (width + height); } @Override public String getShapeType() { return \u0026#34;矩形\u0026#34;; } // 只提供安全的修改方法 public Rectangle resize(double newWidth, double newHeight) { return new Rectangle(newWidth, newHeight); } public double getWidth() { return width; } public double getHeight() { return height; } } // 正方形實作（不繼承矩形） public class Square extends Shape { private double side; public Square(double side) { if (side \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;邊長必須大於 0\u0026#34;); } this.side = side; } @Override public double getArea() { return side * side; } @Override public double getPerimeter() { return 4 * side; } @Override public String getShapeType() { return \u0026#34;正方形\u0026#34;; } public Square resize(double newSide) { return new Square(newSide); } public double getSide() { return side; } } // 圓形實作 public class Circle extends Shape { private double radius; public Circle(double radius) { if (radius \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;半徑必須大於 0\u0026#34;); } this.radius = radius; } @Override public double getArea() { return Math.PI * radius * radius; } @Override public double getPerimeter() { return 2 * Math.PI * radius; } @Override public String getShapeType() { return \u0026#34;圓形\u0026#34;; } public Circle resize(double newRadius) { return new Circle(newRadius); } public double getRadius() { return radius; } } // 幾何計算器（可以安全地使用任何 Shape 子類別） @Service public class GeometryCalculator { // 可以安全地接受任何 Shape 子類別 public double calculateArea(Shape shape) { return shape.getArea(); } public double calculatePerimeter(Shape shape) { return shape.getPerimeter(); } public List\u0026lt;ShapeReport\u0026gt; generateShapeReports(List\u0026lt;Shape\u0026gt; shapes) { return shapes.stream() .map(shape -\u0026gt; new ShapeReport( shape.getShapeType(), shape.getArea(), shape.getPerimeter() )) .collect(Collectors.toList()); } public Shape findLargestShape(List\u0026lt;Shape\u0026gt; shapes) { return shapes.stream() .max(Comparator.comparing(Shape::getArea)) .orElseThrow(() -\u0026gt; new IllegalArgumentException(\u0026#34;形狀列表不能為空\u0026#34;)); } } // 測試證明 LSP 合規性 @Component public class GeometryTestService { private final GeometryCalculator calculator; public GeometryTestService(GeometryCalculator calculator) { this.calculator = calculator; } public void testShapePolymorphism() { List\u0026lt;Shape\u0026gt; shapes = Arrays.asList( new Rectangle(4, 5), // 面積: 20 new Square(4), // 面積: 16 new Circle(3) // 面積: ~28.27 ); // 所有形狀都可以安全地使用相同的方法 shapes.forEach(shape -\u0026gt; { System.out.println(shape.getShapeInfo()); }); // 找出最大面積的形狀 Shape largest = calculator.findLargestShape(shapes); System.out.println(\u0026#34;最大形狀: \u0026#34; + largest.getShapeInfo()); } } LSP 的進階應用：契約設計 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 // 定義清楚的契約 public abstract class Bird { protected String name; protected double weight; public Bird(String name, double weight) { this.name = name; this.weight = weight; } // 契約：所有鳥類都可以吃 public abstract void eat(String food); // 契約：所有鳥類都可以移動 public abstract void move(); public String getName() { return name; } public double getWeight() { return weight; } } // 可飛行的鳥類介面 public interface Flyable { void fly(); double getMaxFlightHeight(); } // 可游泳的鳥類介面 public interface Swimmable { void swim(); double getMaxDivingDepth(); } // 具體實作 - 老鷹（可飛行） public class Eagle extends Bird implements Flyable { public Eagle(String name, double weight) { super(name, weight); } @Override public void eat(String food) { System.out.println(name + \u0026#34; 正在吃 \u0026#34; + food); } @Override public void move() { fly(); // 老鷹主要透過飛行移動 } @Override public void fly() { System.out.println(name + \u0026#34; 正在高空飛翔\u0026#34;); } @Override public double getMaxFlightHeight() { return 3000; // 3000公尺 } } // 具體實作 - 企鵝（可游泳，不能飛行） public class Penguin extends Bird implements Swimmable { public Penguin(String name, double weight) { super(name, weight); } @Override public void eat(String food) { System.out.println(name + \u0026#34; 正在吃 \u0026#34; + food); } @Override public void move() { swim(); // 企鵝主要透過游泳移動 } @Override public void swim() { System.out.println(name + \u0026#34; 正在水中游泳\u0026#34;); } @Override public double getMaxDivingDepth() { return 200; // 200公尺 } } // 鳥類管理服務（完全遵循 LSP） @Service public class BirdManagementService { // 可以安全地處理任何 Bird 子類別 public void feedBird(Bird bird, String food) { bird.eat(food); } public void moveBird(Bird bird) { bird.move(); } // 專門處理可飛行的鳥類 public void makeFly(Flyable flyableBird) { flyableBird.fly(); System.out.println(\u0026#34;最大飛行高度: \u0026#34; + flyableBird.getMaxFlightHeight() + \u0026#34; 公尺\u0026#34;); } // 專門處理可游泳的鳥類 public void makeSwim(Swimmable swimmableBird) { swimmableBird.swim(); System.out.println(\u0026#34;最大潛水深度: \u0026#34; + swimmableBird.getMaxDivingDepth() + \u0026#34; 公尺\u0026#34;); } } 4. Interface Segregation Principle (ISP) - 介面隔離原則 定義 不應該強迫客戶端依賴它們不使用的介面方法\n核心概念 介面最小化：介面應該只包含客戶端需要的方法 職責分離：大介面應該拆分成多個小介面 依賴最小化：降低介面之間的耦合度 違反 ISP 的範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // ❌ 違反 ISP：萬能介面，強迫實作不需要的方法 public interface MediaPlayer { void playAudio(String audioFile); void playVideo(String videoFile); void displaySubtitles(String subtitleFile); void adjustVolume(int volume); void adjustBrightness(int brightness); void recordAudio(); void recordVideo(); void takeScreenshot(); void applyAudioFilter(String filter); void applyVideoFilter(String filter); } // ❌ 音頻播放器被迫實作不需要的視頻相關方法 public class AudioPlayer implements MediaPlayer { @Override public void playAudio(String audioFile) { System.out.println(\u0026#34;播放音頻: \u0026#34; + audioFile); } @Override public void adjustVolume(int volume) { System.out.println(\u0026#34;調整音量到: \u0026#34; + volume); } @Override public void applyAudioFilter(String filter) { System.out.println(\u0026#34;應用音頻濾鏡: \u0026#34; + filter); } // 被迫實作不需要的方法 @Override public void playVideo(String videoFile) { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援視頻播放\u0026#34;); } @Override public void displaySubtitles(String subtitleFile) { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援字幕\u0026#34;); } @Override public void adjustBrightness(int brightness) { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援亮度調整\u0026#34;); } @Override public void recordAudio() { throw new UnsupportedOperationException(\u0026#34;此音頻播放器不支援錄音\u0026#34;); } @Override public void recordVideo() { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援視頻錄製\u0026#34;); } @Override public void takeScreenshot() { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援截圖\u0026#34;); } @Override public void applyVideoFilter(String filter) { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援視頻濾鏡\u0026#34;); } } 遵循 ISP 的重構範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 // ✅ 遵循 ISP：將大介面拆分成多個職責明確的小介面 // 基礎播放介面 public interface Playable { void play(String file); void pause(); void stop(); void seek(long position); } // 音頻相關介面 public interface AudioPlayable extends Playable { void adjustVolume(int volume); int getVolume(); } // 視頻相關介面 public interface VideoPlayable extends Playable { void adjustBrightness(int brightness); void adjustContrast(int contrast); int getBrightness(); int getContrast(); } // 字幕支援介面 public interface SubtitleSupport { void loadSubtitles(String subtitleFile); void showSubtitles(boolean show); void adjustSubtitleSize(int size); } // 錄音介面 public interface AudioRecordable { void startAudioRecording(String outputFile); void stopAudioRecording(); boolean isRecording(); } // 錄影介面 public interface VideoRecordable { void startVideoRecording(String outputFile); void stopVideoRecording(); void takeScreenshot(String outputFile); } // 濾鏡支援介面 public interface AudioFilterSupport { void applyAudioFilter(AudioFilter filter); void removeAudioFilter(); List\u0026lt;AudioFilter\u0026gt; getAvailableAudioFilters(); } public interface VideoFilterSupport { void applyVideoFilter(VideoFilter filter); void removeVideoFilter(); List\u0026lt;VideoFilter\u0026gt; getAvailableVideoFilters(); } // 音頻播放器實作（只實作需要的介面） @Component public class SimpleAudioPlayer implements AudioPlayable, AudioFilterSupport { private int volume = 50; private boolean isPlaying = false; private AudioFilter currentFilter; @Override public void play(String file) { System.out.println(\u0026#34;播放音頻檔案: \u0026#34; + file); isPlaying = true; } @Override public void pause() { System.out.println(\u0026#34;暫停播放\u0026#34;); isPlaying = false; } @Override public void stop() { System.out.println(\u0026#34;停止播放\u0026#34;); isPlaying = false; } @Override public void seek(long position) { System.out.println(\u0026#34;跳轉到位置: \u0026#34; + position + \u0026#34; 秒\u0026#34;); } @Override public void adjustVolume(int volume) { this.volume = Math.max(0, Math.min(100, volume)); System.out.println(\u0026#34;音量調整為: \u0026#34; + this.volume); } @Override public int getVolume() { return volume; } @Override public void applyAudioFilter(AudioFilter filter) { this.currentFilter = filter; System.out.println(\u0026#34;應用音頻濾鏡: \u0026#34; + filter.getName()); } @Override public void removeAudioFilter() { this.currentFilter = null; System.out.println(\u0026#34;移除音頻濾鏡\u0026#34;); } @Override public List\u0026lt;AudioFilter\u0026gt; getAvailableAudioFilters() { return Arrays.asList( new AudioFilter(\u0026#34;回音\u0026#34;, \u0026#34;echo\u0026#34;), new AudioFilter(\u0026#34;降噪\u0026#34;, \u0026#34;noise_reduction\u0026#34;), new AudioFilter(\u0026#34;等化器\u0026#34;, \u0026#34;equalizer\u0026#34;) ); } } // 專業錄音機實作（實作錄音相關介面） @Component public class ProfessionalAudioRecorder implements AudioPlayable, AudioRecordable, AudioFilterSupport { private int volume = 50; private boolean isPlaying = false; private boolean isRecording = false; private String currentRecordingFile; // 實作播放功能 @Override public void play(String file) { if (!isRecording) { System.out.println(\u0026#34;播放音頻檔案: \u0026#34; + file); isPlaying = true; } else { System.out.println(\u0026#34;錄音中，無法播放\u0026#34;); } } @Override public void pause() { System.out.println(\u0026#34;暫停播放\u0026#34;); isPlaying = false; } @Override public void stop() { System.out.println(\u0026#34;停止播放\u0026#34;); isPlaying = false; } @Override public void seek(long position) { System.out.println(\u0026#34;跳轉到位置: \u0026#34; + position + \u0026#34; 秒\u0026#34;); } @Override public void adjustVolume(int volume) { this.volume = Math.max(0, Math.min(100, volume)); System.out.println(\u0026#34;音量調整為: \u0026#34; + this.volume); } @Override public int getVolume() { return volume; } // 實作錄音功能 @Override public void startAudioRecording(String outputFile) { if (!isPlaying) { this.currentRecordingFile = outputFile; this.isRecording = true; System.out.println(\u0026#34;開始錄音到: \u0026#34; + outputFile); } else { System.out.println(\u0026#34;播放中，無法錄音\u0026#34;); } } @Override public void stopAudioRecording() { if (isRecording) { this.isRecording = false; System.out.println(\u0026#34;錄音完成: \u0026#34; + currentRecordingFile); this.currentRecordingFile = null; } } @Override public boolean isRecording() { return isRecording; } // 實作濾鏡功能 @Override public void applyAudioFilter(AudioFilter filter) { System.out.println(\u0026#34;應用專業音頻濾鏡: \u0026#34; + filter.getName()); } @Override public void removeAudioFilter() { System.out.println(\u0026#34;移除音頻濾鏡\u0026#34;); } @Override public List\u0026lt;AudioFilter\u0026gt; getAvailableAudioFilters() { return Arrays.asList( new AudioFilter(\u0026#34;回音\u0026#34;, \u0026#34;echo\u0026#34;), new AudioFilter(\u0026#34;降噪\u0026#34;, \u0026#34;noise_reduction\u0026#34;), new AudioFilter(\u0026#34;等化器\u0026#34;, \u0026#34;equalizer\u0026#34;), new AudioFilter(\u0026#34;壓縮器\u0026#34;, \u0026#34;compressor\u0026#34;), new AudioFilter(\u0026#34;限制器\u0026#34;, \u0026#34;limiter\u0026#34;) ); } } // 視頻播放器實作（實作視頻相關介面） @Component public class VideoPlayer implements VideoPlayable, SubtitleSupport, VideoFilterSupport { private int brightness = 50; private int contrast = 50; private boolean subtitlesVisible = false; private String currentSubtitleFile; @Override public void play(String file) { System.out.println(\u0026#34;播放視頻檔案: \u0026#34; + file); } @Override public void pause() { System.out.println(\u0026#34;暫停視頻\u0026#34;); } @Override public void stop() { System.out.println(\u0026#34;停止視頻\u0026#34;); } @Override public void seek(long position) { System.out.println(\u0026#34;跳轉到視頻位置: \u0026#34; + position + \u0026#34; 秒\u0026#34;); } @Override public void adjustBrightness(int brightness) { this.brightness = Math.max(0, Math.min(100, brightness)); System.out.println(\u0026#34;亮度調整為: \u0026#34; + this.brightness); } @Override public void adjustContrast(int contrast) { this.contrast = Math.max(0, Math.min(100, contrast)); System.out.println(\u0026#34;對比度調整為: \u0026#34; + this.contrast); } @Override public int getBrightness() { return brightness; } @Override public int getContrast() { return contrast; } // 字幕支援 @Override public void loadSubtitles(String subtitleFile) { this.currentSubtitleFile = subtitleFile; System.out.println(\u0026#34;載入字幕檔案: \u0026#34; + subtitleFile); } @Override public void showSubtitles(boolean show) { this.subtitlesVisible = show; System.out.println(\u0026#34;字幕顯示: \u0026#34; + (show ? \u0026#34;開啟\u0026#34; : \u0026#34;關閉\u0026#34;)); } @Override public void adjustSubtitleSize(int size) { System.out.println(\u0026#34;字幕大小調整為: \u0026#34; + size); } // 視頻濾鏡支援 @Override public void applyVideoFilter(VideoFilter filter) { System.out.println(\u0026#34;應用視頻濾鏡: \u0026#34; + filter.getName()); } @Override public void removeVideoFilter() { System.out.println(\u0026#34;移除視頻濾鏡\u0026#34;); } @Override public List\u0026lt;VideoFilter\u0026gt; getAvailableVideoFilters() { return Arrays.asList( new VideoFilter(\u0026#34;模糊\u0026#34;, \u0026#34;blur\u0026#34;), new VideoFilter(\u0026#34;銳化\u0026#34;, \u0026#34;sharpen\u0026#34;), new VideoFilter(\u0026#34;色彩增強\u0026#34;, \u0026#34;color_enhance\u0026#34;) ); } } // 媒體管理服務（使用介面隔離的好處） @Service public class MediaManagementService { // 只處理播放功能 public void playMedia(Playable player, String file) { player.play(file); } // 只處理音頻播放 public void playAudioWithVolume(AudioPlayable audioPlayer, String file, int volume) { audioPlayer.adjustVolume(volume); audioPlayer.play(file); } // 只處理錄音功能 public void recordAudio(AudioRecordable recorder, String outputFile) { if (!recorder.isRecording()) { recorder.startAudioRecording(outputFile); } } // 只處理字幕功能 public void setupSubtitles(SubtitleSupport player, String subtitleFile) { player.loadSubtitles(subtitleFile); player.showSubtitles(true); } } 5. Dependency Inversion Principle (DIP) - 依賴反轉原則 定義 高層模組不應該依賴低層模組，兩者都應該依賴於抽象。抽象不應該依賴於細節，細節應該依賴於抽象。\n核心概念 依賴注入：透過外部注入依賴而非內部創建 控制反轉：將依賴關係的控制權交給外部容器 抽象依賴：依賴於介面而非具體實作 違反 DIP 的範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // ❌ 違反 DIP：高層模組直接依賴低層模組的具體實作 public class MySQLDatabase { public void save(String data) { System.out.println(\u0026#34;儲存資料到 MySQL: \u0026#34; + data); } public String load(String id) { return \u0026#34;從 MySQL 載入資料: \u0026#34; + id; } } public class EmailService { public void sendEmail(String to, String subject, String body) { System.out.println(\u0026#34;發送郵件到: \u0026#34; + to); System.out.println(\u0026#34;主題: \u0026#34; + subject); System.out.println(\u0026#34;內容: \u0026#34; + body); } } // ❌ UserService 直接依賴具體實作，難以測試和擴展 public class UserService { private MySQLDatabase database; // 直接依賴具體實作 private EmailService emailService; // 直接依賴具體實作 public UserService() { this.database = new MySQLDatabase(); // 在構造函數中創建依賴 this.emailService = new EmailService(); // 硬編碼依賴 } public void createUser(String username, String email) { // 驗證邏輯 if (username == null || username.trim().isEmpty()) { throw new IllegalArgumentException(\u0026#34;用戶名不能為空\u0026#34;); } // 儲存用戶（依賴具體的 MySQL 實作） String userData = \u0026#34;User: \u0026#34; + username + \u0026#34;, Email: \u0026#34; + email; database.save(userData); // 發送歡迎郵件（依賴具體的郵件服務實作） emailService.sendEmail(email, \u0026#34;歡迎\u0026#34;, \u0026#34;歡迎加入我們的平台！\u0026#34;); } public String getUser(String userId) { return database.load(userId); } } 遵循 DIP 的重構範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 // ✅ 遵循 DIP：定義抽象介面 // 資料庫抽象介面 public interface UserRepository { void save(User user); Optional\u0026lt;User\u0026gt; findById(String id); Optional\u0026lt;User\u0026gt; findByEmail(String email); List\u0026lt;User\u0026gt; findAll(); void delete(String id); } // 通知服務抽象介面 public interface NotificationService { void sendWelcomeNotification(User user); void sendPasswordResetNotification(User user, String resetToken); void sendAccountActivationNotification(User user, String activationToken); } // 用戶驗證抽象介面 public interface UserValidator { ValidationResult validate(User user); boolean isEmailUnique(String email); boolean isUsernameValid(String username); } // 具體實作 - MySQL 資料庫 @Repository public class MySQLUserRepository implements UserRepository { @Override public void save(User user) { System.out.println(\u0026#34;儲存用戶到 MySQL: \u0026#34; + user.getUsername()); // 實際的資料庫操作邏輯 } @Override public Optional\u0026lt;User\u0026gt; findById(String id) { System.out.println(\u0026#34;從 MySQL 查找用戶: \u0026#34; + id); // 實際的查詢邏輯 return Optional.of(new User(id, \u0026#34;user@example.com\u0026#34;)); } @Override public Optional\u0026lt;User\u0026gt; findByEmail(String email) { System.out.println(\u0026#34;從 MySQL 根據郵箱查找用戶: \u0026#34; + email); return Optional.empty(); } @Override public List\u0026lt;User\u0026gt; findAll() { System.out.println(\u0026#34;從 MySQL 查找所有用戶\u0026#34;); return Arrays.asList(new User(\u0026#34;1\u0026#34;, \u0026#34;user1@example.com\u0026#34;)); } @Override public void delete(String id) { System.out.println(\u0026#34;從 MySQL 刪除用戶: \u0026#34; + id); } } // 具體實作 - MongoDB 資料庫（可替換實作） @Repository @Profile(\u0026#34;mongodb\u0026#34;) public class MongoUserRepository implements UserRepository { @Override public void save(User user) { System.out.println(\u0026#34;儲存用戶到 MongoDB: \u0026#34; + user.getUsername()); } @Override public Optional\u0026lt;User\u0026gt; findById(String id) { System.out.println(\u0026#34;從 MongoDB 查找用戶: \u0026#34; + id); return Optional.of(new User(id, \u0026#34;user@example.com\u0026#34;)); } @Override public Optional\u0026lt;User\u0026gt; findByEmail(String email) { System.out.println(\u0026#34;從 MongoDB 根據郵箱查找用戶: \u0026#34; + email); return Optional.empty(); } @Override public List\u0026lt;User\u0026gt; findAll() { System.out.println(\u0026#34;從 MongoDB 查找所有用戶\u0026#34;); return Arrays.asList(new User(\u0026#34;1\u0026#34;, \u0026#34;user1@example.com\u0026#34;)); } @Override public void delete(String id) { System.out.println(\u0026#34;從 MongoDB 刪除用戶: \u0026#34; + id); } } // 具體實作 - 郵件通知服務 @Service public class EmailNotificationService implements NotificationService { @Override public void sendWelcomeNotification(User user) { System.out.println(\u0026#34;發送歡迎郵件到: \u0026#34; + user.getEmail()); // 實際的郵件發送邏輯 } @Override public void sendPasswordResetNotification(User user, String resetToken) { System.out.println(\u0026#34;發送密碼重設郵件到: \u0026#34; + user.getEmail()); System.out.println(\u0026#34;重設令牌: \u0026#34; + resetToken); } @Override public void sendAccountActivationNotification(User user, String activationToken) { System.out.println(\u0026#34;發送帳戶啟用郵件到: \u0026#34; + user.getEmail()); System.out.println(\u0026#34;啟用令牌: \u0026#34; + activationToken); } } // 具體實作 - SMS 通知服務（可替換實作） @Service @Profile(\u0026#34;sms\u0026#34;) public class SMSNotificationService implements NotificationService { @Override public void sendWelcomeNotification(User user) { System.out.println(\u0026#34;發送歡迎 SMS 到: \u0026#34; + user.getPhoneNumber()); } @Override public void sendPasswordResetNotification(User user, String resetToken) { System.out.println(\u0026#34;發送密碼重設 SMS 到: \u0026#34; + user.getPhoneNumber()); System.out.println(\u0026#34;重設代碼: \u0026#34; + resetToken); } @Override public void sendAccountActivationNotification(User user, String activationToken) { System.out.println(\u0026#34;發送帳戶啟用 SMS 到: \u0026#34; + user.getPhoneNumber()); System.out.println(\u0026#34;啟用代碼: \u0026#34; + activationToken); } } // 具體實作 - 用戶驗證器 @Component public class DefaultUserValidator implements UserValidator { private final UserRepository userRepository; public DefaultUserValidator(UserRepository userRepository) { this.userRepository = userRepository; } @Override public ValidationResult validate(User user) { ValidationResult result = new ValidationResult(); if (!isUsernameValid(user.getUsername())) { result.addError(\u0026#34;用戶名格式無效\u0026#34;); } if (!isEmailValid(user.getEmail())) { result.addError(\u0026#34;郵箱格式無效\u0026#34;); } if (!isEmailUnique(user.getEmail())) { result.addError(\u0026#34;郵箱已被使用\u0026#34;); } return result; } @Override public boolean isEmailUnique(String email) { return userRepository.findByEmail(email).isEmpty(); } @Override public boolean isUsernameValid(String username) { return username != null \u0026amp;\u0026amp; username.trim().length() \u0026gt;= 3 \u0026amp;\u0026amp; username.trim().length() \u0026lt;= 50 \u0026amp;\u0026amp; username.matches(\u0026#34;^[a-zA-Z0-9_]+$\u0026#34;); } private boolean isEmailValid(String email) { return email != null \u0026amp;\u0026amp; email.contains(\u0026#34;@\u0026#34;) \u0026amp;\u0026amp; email.contains(\u0026#34;.\u0026#34;) \u0026amp;\u0026amp; email.length() \u0026gt; 5; } } // 高層模組 - 用戶服務（依賴於抽象） @Service public class UserService { private final UserRepository userRepository; private final NotificationService notificationService; private final UserValidator userValidator; // 依賴注入：透過構造函數注入依賴 public UserService(UserRepository userRepository, NotificationService notificationService, UserValidator userValidator) { this.userRepository = userRepository; this.notificationService = notificationService; this.userValidator = userValidator; } public Result\u0026lt;User\u0026gt; createUser(String username, String email) { User user = new User(username, email); // 驗證用戶資料 ValidationResult validation = userValidator.validate(user); if (!validation.isValid()) { return Result.failure(\u0026#34;驗證失敗: \u0026#34; + validation.getErrors()); } try { // 儲存用戶 userRepository.save(user); // 發送通知 notificationService.sendWelcomeNotification(user); return Result.success(user); } catch (Exception e) { return Result.failure(\u0026#34;創建用戶失敗: \u0026#34; + e.getMessage()); } } public Result\u0026lt;User\u0026gt; getUserById(String id) { Optional\u0026lt;User\u0026gt; user = userRepository.findById(id); if (user.isPresent()) { return Result.success(user.get()); } else { return Result.failure(\u0026#34;用戶不存在\u0026#34;); } } public Result\u0026lt;Void\u0026gt; resetPassword(String email) { Optional\u0026lt;User\u0026gt; userOpt = userRepository.findByEmail(email); if (userOpt.isEmpty()) { return Result.failure(\u0026#34;用戶不存在\u0026#34;); } User user = userOpt.get(); String resetToken = generateResetToken(); // 儲存重設令牌（實際應該儲存到資料庫） // userRepository.saveResetToken(user.getId(), resetToken); // 發送重設通知 notificationService.sendPasswordResetNotification(user, resetToken); return Result.success(null); } private String generateResetToken() { return \u0026#34;RESET-\u0026#34; + UUID.randomUUID().toString(); } } // 配置類別（控制依賴注入） @Configuration public class UserServiceConfiguration { @Bean @ConditionalOnProperty(name = \u0026#34;database.type\u0026#34;, havingValue = \u0026#34;mysql\u0026#34;, matchIfMissing = true) public UserRepository mysqlUserRepository() { return new MySQLUserRepository(); } @Bean @ConditionalOnProperty(name = \u0026#34;database.type\u0026#34;, havingValue = \u0026#34;mongodb\u0026#34;) public UserRepository mongoUserRepository() { return new MongoUserRepository(); } @Bean @ConditionalOnProperty(name = \u0026#34;notification.type\u0026#34;, havingValue = \u0026#34;email\u0026#34;, matchIfMissing = true) public NotificationService emailNotificationService() { return new EmailNotificationService(); } @Bean @ConditionalOnProperty(name = \u0026#34;notification.type\u0026#34;, havingValue = \u0026#34;sms\u0026#34;) public NotificationService smsNotificationService() { return new SMSNotificationService(); } } DIP 的進階應用：工廠模式與策略模式結合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 // 報表生成策略介面 public interface ReportGenerator { String generateReport(List\u0026lt;User\u0026gt; users); String getReportFormat(); } // CSV 報表生成器 @Component(\u0026#34;csvReportGenerator\u0026#34;) public class CSVReportGenerator implements ReportGenerator { @Override public String generateReport(List\u0026lt;User\u0026gt; users) { StringBuilder csv = new StringBuilder(); csv.append(\u0026#34;用戶名,郵箱,創建時間\\n\u0026#34;); users.forEach(user -\u0026gt; csv.append(String.format(\u0026#34;%s,%s,%s\\n\u0026#34;, user.getUsername(), user.getEmail(), user.getCreatedAt())) ); return csv.toString(); } @Override public String getReportFormat() { return \u0026#34;CSV\u0026#34;; } } // JSON 報表生成器 @Component(\u0026#34;jsonReportGenerator\u0026#34;) public class JSONReportGenerator implements ReportGenerator { private final ObjectMapper objectMapper; public JSONReportGenerator(ObjectMapper objectMapper) { this.objectMapper = objectMapper; } @Override public String generateReport(List\u0026lt;User\u0026gt; users) { try { Map\u0026lt;String, Object\u0026gt; report = new HashMap\u0026lt;\u0026gt;(); report.put(\u0026#34;totalUsers\u0026#34;, users.size()); report.put(\u0026#34;generatedAt\u0026#34;, LocalDateTime.now()); report.put(\u0026#34;users\u0026#34;, users); return objectMapper.writeValueAsString(report); } catch (Exception e) { throw new RuntimeException(\u0026#34;JSON 報表生成失敗\u0026#34;, e); } } @Override public String getReportFormat() { return \u0026#34;JSON\u0026#34;; } } // 報表工廠 @Service public class ReportGeneratorFactory { private final Map\u0026lt;String, ReportGenerator\u0026gt; generators; public ReportGeneratorFactory(Map\u0026lt;String, ReportGenerator\u0026gt; generators) { this.generators = generators; } public ReportGenerator getGenerator(String format) { ReportGenerator generator = generators.get(format.toLowerCase() + \u0026#34;ReportGenerator\u0026#34;); if (generator == null) { throw new IllegalArgumentException(\u0026#34;不支援的報表格式: \u0026#34; + format); } return generator; } public List\u0026lt;String\u0026gt; getSupportedFormats() { return generators.values().stream() .map(ReportGenerator::getReportFormat) .collect(Collectors.toList()); } } // 報表服務（高層模組，依賴於抽象） @Service public class UserReportService { private final UserRepository userRepository; private final ReportGeneratorFactory reportGeneratorFactory; public UserReportService(UserRepository userRepository, ReportGeneratorFactory reportGeneratorFactory) { this.userRepository = userRepository; this.reportGeneratorFactory = reportGeneratorFactory; } public String generateUserReport(String format) { List\u0026lt;User\u0026gt; users = userRepository.findAll(); ReportGenerator generator = reportGeneratorFactory.getGenerator(format); return generator.generateReport(users); } public List\u0026lt;String\u0026gt; getSupportedReportFormats() { return reportGeneratorFactory.getSupportedFormats(); } } 總結 SOLID 原則是軟體設計的基石，它們相互補充，共同促進程式碼的品質：\n核心價值 可維護性：每個原則都有助於降低程式碼修改的複雜度 可擴展性：支援新功能的增加而不破壞現有功能 可測試性：依賴注入和介面隔離使單元測試更容易 可重用性：職責明確的類別可以在不同場景中重複使用 實踐建議 從小處開始：在新專案中逐步應用 SOLID 原則 重構現有程式碼：識別違反 SOLID 原則的程式碼並逐步改進 使用現代框架：Spring、依賴注入容器等工具有助於實踐 SOLID 原則 程式碼審查：在團隊中推廣 SOLID 原則的理解和應用 持續學習：SOLID 原則是軟體架構的基礎，需要在實踐中不斷深化理解 常見陷阱 過度設計：不要為了遵循原則而增加不必要的複雜性 教條主義：原則是指導而非絕對規則，需要根據具體情況靈活應用 忽略性能：在追求設計原則的同時要考慮性能影響 缺乏漸進性：不要試圖一次性重構整個系統，要採用漸進式改進 SOLID 原則不僅適用於物件導向程式設計，在微服務架構、函數式程式設計等現代軟體架構中同樣具有指導意義。掌握這些原則將顯著提升你的軟體設計能力。\n參考資料 Clean Code by Robert C. Martin Agile Software Development, Principles, Patterns, and Practices SOLID Principles of Object Oriented Design Spring Framework Documentation ","permalink":"https://xinqilin.github.io/post/architecture/solid/","tags":["SOLID","Design Principles","OOP","Software Architecture","Clean Code","Best Practices"],"title":"SOLID 設計原則完整指南：物件導向程式設計的五大核心原則"},{"content":"筆記 Vue 未整理 version 套件 vetur vue2 snippets webpack -\u0026gt; npm install webpack -g vue -\u0026gt; npm install -g @vue/cli-init chrome: vue plugin\n快速開始 vue init webpack \u0026lt;你的app名字\u0026gt;\nnpm run dev\nmain.js -\u0026gt; 路由 index.js 在 [router 內]\n1 2 3 4 5 6 7 8 9 10 export default new Router({ routes:[ { path: \u0026#39;/\u0026#39;, name: \u0026#39;HelloWorld\u0026#39;, component: HelloWorld } ] }) HelloWorld.vue 內容 在 [components內]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data(){ return name: \u0026#39;Bill\u0026#39; } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 跳頁\n1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;router-link to=\u0026#34;/HelloWorld\u0026#34;\u0026gt;go to hello world\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 單向綁定 1 2 3 4 v-text v-html v-bind:href=\u0026#34;link\u0026#34; vue instance 內的 method 的 data:{link} (v-bind:href 可縮寫:href) 雙向綁定 v-model\n綁定事件 1 2 3 4 5 6 7 8 9 10 v-on:click=\u0026#34;num++\u0026#34; = @click v-on 防止事件冒泡{ `.stop`: 阻止事件冒泡倒父層 `.prevent`: 阻止默認(預設) 事件發生 `.capture`: 阻止事件捕獲模式 `.self`: 只有自身觸發事件才執行 `.once`: 只執行一次 } 按鍵修飾符 v-on:keyup.13 1 2 3 4 5 6 7 8 9 10 11 12 13 13 是鍵碼 v-on 按鍵修飾符 懶人包{ `.enter` `.tab` `.delete` `.esc` `.space` `.up` `.down` `.left` `.right` } v-for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 v-for = \u0026#34;user in users\u0026#34; 或 v-for=\u0026#34;(user, index) in users\u0026#34; v-for = \u0026#34;(value, key, index) in users\u0026#34; {{value}} {{key}} {{index}} v-for 增加 :key = \u0026#34;\u0026#34; 可增加效率 最主要是是別惟一值 :key 是 v-bind縮寫 v-if 裡面都填boolean 整個標籤不見 v-show 裡面都填boolean 是用 display:none 常跟 v-if 一起用 v-else-if v-else 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // computed 計算屬性 // watch 監控屬性 // filter 過濾屬性 -\u0026gt; 使用 {{user.gender | genderFilter}} new Vue({ el: \u0026#34;#app\u0026#34;, data:{ a:100, b:200 }, computed: { total: function(){ return this.a+this.b } }, watch:{ a: function(newValue, oldValue){ alert(\u0026#34;new: \u0026#34;+newValue+\u0026#34; , old: \u0026#34;+oldValue) if(a\u0026gt;3){ this.msg = \u0026#34;太多\u0026#34; } } }, filters:{ genderFilter(val){ if(val == 1) return \u0026#34;male\u0026#34; else return \u0026#34;female\u0026#34; } } }) 組件:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;script\u0026gt; Global 組件: Vue.component(\u0026#34;counter\u0026#34;,{ template: `\u0026lt;button v-on:click = \u0026#34;count++\u0026#34;\u0026gt; {{count}}\u0026lt;/button\u0026gt;` data(){ return { count: 0 } } }); 區域組件: const buttonCounter = { template: `\u0026lt;button v-on:click = \u0026#34;count++\u0026#34;\u0026gt; {{count}}\u0026lt;/button\u0026gt;` data(){ return { count: 0 } } } 後 放入 vue instance components:{}中 components:{ \u0026#39;button-counter 名字\u0026#39;: buttonCounter } ``` \u0026lt;button-counter\u0026gt;\u0026lt;/button-counter\u0026gt; 使用 ``` \u0026lt;/script\u0026gt; lifeCycle 1 2 3 4 5 6 7 8 9 10 11 let app = new Vue(){ el: app, data: { }, beforeCreate: function(){ } // 放一些生命週期的東西 }; ","permalink":"https://xinqilin.github.io/post/frontend/vue-intro/","tags":[],"title":"Vue Intro"},{"content":"概述 JSON Web Token (JWT) 是一種開放標準 (RFC 7519)，定義了一種簡潔、自包含的方式，用於在各方之間安全地傳輸資訊。JWT 在現代 Web 應用程式中廣泛用於身份驗證和授權，特別適合分散式系統和微服務架構。\nJWT 核心特徵 無狀態性：伺服器不需要儲存 Session 資訊 可擴展性：適合分散式和微服務環境 跨域支援：支援跨網域請求 自包含：Token 包含所有必要的使用者資訊 數位簽名：確保 Token 的完整性和真實性 JWT 結構 JWT 由三部分組成，以點號（.）分隔：\n1 Header.Payload.Signature Header：包含 Token 類型和簽名演算法 Payload：包含聲明（Claims），即使用者資訊和其他資料 Signature：用於驗證 Token 是否被篡改 Spring Boot 整合實作 1. 依賴配置 Maven 依賴設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;jjwt.version\u0026gt;0.12.3\u0026lt;/jjwt.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!-- Spring Boot Starters --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- JWT Library (推薦使用最新版本) --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jjwt.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-impl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jjwt.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-jackson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jjwt.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Gradle 依賴設定 1 2 3 4 5 6 7 8 9 10 dependencies { implementation \u0026#39;org.springframework.boot:spring-boot-starter-web\u0026#39; implementation \u0026#39;org.springframework.boot:spring-boot-starter-security\u0026#39; implementation \u0026#39;org.springframework.boot:spring-boot-starter-data-jpa\u0026#39; implementation \u0026#39;org.springframework.boot:spring-boot-starter-validation\u0026#39; implementation \u0026#39;io.jsonwebtoken:jjwt-api:0.12.3\u0026#39; runtimeOnly \u0026#39;io.jsonwebtoken:jjwt-impl:0.12.3\u0026#39; runtimeOnly \u0026#39;io.jsonwebtoken:jjwt-jackson:0.12.3\u0026#39; } 2. 資料模型 認證請求 DTO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package com.example.jwt.dto; import jakarta.validation.constraints.NotBlank; import jakarta.validation.constraints.Size; public class AuthenticationRequest { @NotBlank(message = \u0026#34;使用者名稱不能為空\u0026#34;) @Size(min = 3, max = 50, message = \u0026#34;使用者名稱長度必須在3-50字符之間\u0026#34;) private String username; @NotBlank(message = \u0026#34;密碼不能為空\u0026#34;) @Size(min = 6, max = 100, message = \u0026#34;密碼長度必須在6-100字符之間\u0026#34;) private String password; // 建構子 public AuthenticationRequest() {} public AuthenticationRequest(String username, String password) { this.username = username; this.password = password; } // Getters and Setters public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } 認證回應 DTO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package com.example.jwt.dto; import com.fasterxml.jackson.annotation.JsonProperty; public class AuthenticationResponse { @JsonProperty(\u0026#34;access_token\u0026#34;) private final String accessToken; @JsonProperty(\u0026#34;token_type\u0026#34;) private final String tokenType = \u0026#34;Bearer\u0026#34;; @JsonProperty(\u0026#34;expires_in\u0026#34;) private final long expiresIn; @JsonProperty(\u0026#34;refresh_token\u0026#34;) private String refreshToken; public AuthenticationResponse(String accessToken, long expiresIn) { this.accessToken = accessToken; this.expiresIn = expiresIn; } public AuthenticationResponse(String accessToken, long expiresIn, String refreshToken) { this.accessToken = accessToken; this.expiresIn = expiresIn; this.refreshToken = refreshToken; } // Getters public String getAccessToken() { return accessToken; } public String getTokenType() { return tokenType; } public long getExpiresIn() { return expiresIn; } public String getRefreshToken() { return refreshToken; } } 使用者實體 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 package com.example.jwt.entity; import jakarta.persistence.*; import jakarta.validation.constraints.Email; import jakarta.validation.constraints.NotBlank; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.userdetails.UserDetails; import java.time.LocalDateTime; import java.util.*; import java.util.stream.Collectors; @Entity @Table(name = \u0026#34;users\u0026#34;) public class User implements UserDetails { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotBlank @Column(unique = true, nullable = false) private String username; @NotBlank @Email @Column(unique = true, nullable = false) private String email; @NotBlank @Column(nullable = false) private String password; @Column(name = \u0026#34;first_name\u0026#34;) private String firstName; @Column(name = \u0026#34;last_name\u0026#34;) private String lastName; @Column(name = \u0026#34;enabled\u0026#34;) private boolean enabled = true; @Column(name = \u0026#34;account_non_expired\u0026#34;) private boolean accountNonExpired = true; @Column(name = \u0026#34;credentials_non_expired\u0026#34;) private boolean credentialsNonExpired = true; @Column(name = \u0026#34;account_non_locked\u0026#34;) private boolean accountNonLocked = true; @Column(name = \u0026#34;created_at\u0026#34;) private LocalDateTime createdAt = LocalDateTime.now(); @Column(name = \u0026#34;updated_at\u0026#34;) private LocalDateTime updatedAt = LocalDateTime.now(); @ElementCollection(targetClass = Role.class, fetch = FetchType.EAGER) @Enumerated(EnumType.STRING) @CollectionTable(name = \u0026#34;user_roles\u0026#34;) private Set\u0026lt;Role\u0026gt; roles = new HashSet\u0026lt;\u0026gt;(); // 建構子 public User() {} public User(String username, String email, String password) { this.username = username; this.email = email; this.password = password; this.roles.add(Role.USER); } // UserDetails interface 實作 @Override public Collection\u0026lt;? extends GrantedAuthority\u0026gt; getAuthorities() { return roles.stream() .map(role -\u0026gt; new SimpleGrantedAuthority(\u0026#34;ROLE_\u0026#34; + role.name())) .collect(Collectors.toList()); } @Override public String getPassword() { return password; } @Override public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return accountNonExpired; } @Override public boolean isAccountNonLocked() { return accountNonLocked; } @Override public boolean isCredentialsNonExpired() { return credentialsNonExpired; } @Override public boolean isEnabled() { return enabled; } // Getters and Setters public Long getId() { return id; } public void setId(Long id) { this.id = id; } public void setUsername(String username) { this.username = username; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public void setPassword(String password) { this.password = password; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public Set\u0026lt;Role\u0026gt; getRoles() { return roles; } public void setRoles(Set\u0026lt;Role\u0026gt; roles) { this.roles = roles; } public LocalDateTime getCreatedAt() { return createdAt; } public LocalDateTime getUpdatedAt() { return updatedAt; } @PreUpdate public void preUpdate() { this.updatedAt = LocalDateTime.now(); } } enum Role { USER, ADMIN, MODERATOR } 3. JWT 工具類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 package com.example.jwt.util; import io.jsonwebtoken.*; import io.jsonwebtoken.io.Decoders; import io.jsonwebtoken.security.Keys; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Value; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.stereotype.Component; import javax.crypto.SecretKey; import java.util.Date; import java.util.HashMap; import java.util.Map; import java.util.function.Function; @Component public class JwtUtil { private static final Logger logger = LoggerFactory.getLogger(JwtUtil.class); @Value(\u0026#34;${jwt.secret}\u0026#34;) private String jwtSecret; @Value(\u0026#34;${jwt.expiration}\u0026#34;) private long jwtExpiration; @Value(\u0026#34;${jwt.refresh-expiration}\u0026#34;) private long refreshExpiration; /** * 從 Token 中提取使用者名稱 */ public String extractUsername(String token) { return extractClaim(token, Claims::getSubject); } /** * 從 Token 中提取過期時間 */ public Date extractExpiration(String token) { return extractClaim(token, Claims::getExpiration); } /** * 從 Token 中提取特定的聲明 */ public \u0026lt;T\u0026gt; T extractClaim(String token, Function\u0026lt;Claims, T\u0026gt; claimsResolver) { final Claims claims = extractAllClaims(token); return claimsResolver.apply(claims); } /** * 提取 Token 中的所有聲明 */ private Claims extractAllClaims(String token) { try { return Jwts.parser() .verifyWith(getSignInKey()) .build() .parseSignedClaims(token) .getPayload(); } catch (ExpiredJwtException e) { logger.warn(\u0026#34;JWT token 已過期: {}\u0026#34;, e.getMessage()); throw e; } catch (UnsupportedJwtException e) { logger.warn(\u0026#34;不支援的 JWT token: {}\u0026#34;, e.getMessage()); throw e; } catch (MalformedJwtException e) { logger.warn(\u0026#34;格式錯誤的 JWT token: {}\u0026#34;, e.getMessage()); throw e; } catch (IllegalArgumentException e) { logger.warn(\u0026#34;JWT claims string 為空: {}\u0026#34;, e.getMessage()); throw e; } } /** * 檢查 Token 是否過期 */ public boolean isTokenExpired(String token) { try { return extractExpiration(token).before(new Date()); } catch (ExpiredJwtException e) { return true; } } /** * 生成訪問 Token */ public String generateAccessToken(UserDetails userDetails) { Map\u0026lt;String, Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(\u0026#34;roles\u0026#34;, userDetails.getAuthorities()); return createToken(claims, userDetails.getUsername(), jwtExpiration); } /** * 生成刷新 Token */ public String generateRefreshToken(UserDetails userDetails) { return createToken(new HashMap\u0026lt;\u0026gt;(), userDetails.getUsername(), refreshExpiration); } /** * 創建 Token */ private String createToken(Map\u0026lt;String, Object\u0026gt; claims, String subject, long expiration) { Date now = new Date(); Date expiryDate = new Date(now.getTime() + expiration); return Jwts.builder() .claims(claims) .subject(subject) .issuedAt(now) .expiration(expiryDate) .signWith(getSignInKey()) .compact(); } /** * 驗證 Token */ public boolean validateToken(String token, UserDetails userDetails) { try { final String username = extractUsername(token); return (username.equals(userDetails.getUsername()) \u0026amp;\u0026amp; !isTokenExpired(token)); } catch (JwtException | IllegalArgumentException e) { logger.warn(\u0026#34;JWT token 驗證失敗: {}\u0026#34;, e.getMessage()); return false; } } /** * 驗證 Token 格式和簽名 */ public boolean validateToken(String token) { try { Jwts.parser() .verifyWith(getSignInKey()) .build() .parseSignedClaims(token); return true; } catch (JwtException | IllegalArgumentException e) { logger.warn(\u0026#34;JWT token 驗證失敗: {}\u0026#34;, e.getMessage()); return false; } } /** * 獲取簽名金鑰 */ private SecretKey getSignInKey() { byte[] keyBytes = Decoders.BASE64.decode(jwtSecret); return Keys.hmacShaKeyFor(keyBytes); } /** * 獲取 Token 的剩餘有效時間（毫秒） */ public long getExpirationTime() { return jwtExpiration; } /** * 檢查 Token 是否需要刷新（剩餘時間少於 30 分鐘） */ public boolean shouldRefreshToken(String token) { try { Date expiration = extractExpiration(token); Date now = new Date(); long timeLeft = expiration.getTime() - now.getTime(); return timeLeft \u0026lt; (30 * 60 * 1000); // 30 分鐘 } catch (Exception e) { return false; } } } 4. JWT 請求過濾器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 package com.example.jwt.filter; import com.example.jwt.service.CustomUserDetailsService; import com.example.jwt.util.JwtUtil; import jakarta.servlet.FilterChain; import jakarta.servlet.ServletException; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.web.authentication.WebAuthenticationDetailsSource; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import org.springframework.web.filter.OncePerRequestFilter; import java.io.IOException; @Component public class JwtAuthenticationFilter extends OncePerRequestFilter { private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class); private static final String BEARER_PREFIX = \u0026#34;Bearer \u0026#34;; private static final String AUTHORIZATION_HEADER = \u0026#34;Authorization\u0026#34;; @Autowired private JwtUtil jwtUtil; @Autowired private CustomUserDetailsService userDetailsService; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { try { String jwt = getJwtFromRequest(request); if (StringUtils.hasText(jwt) \u0026amp;\u0026amp; jwtUtil.validateToken(jwt)) { String username = jwtUtil.extractUsername(jwt); // 檢查 SecurityContext 中是否已有認證資訊 if (username != null \u0026amp;\u0026amp; SecurityContextHolder.getContext().getAuthentication() == null) { UserDetails userDetails = userDetailsService.loadUserByUsername(username); if (jwtUtil.validateToken(jwt, userDetails)) { UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken( userDetails, null, userDetails.getAuthorities()); authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); SecurityContextHolder.getContext().setAuthentication(authentication); logger.debug(\u0026#34;設定使用者 \u0026#39;{}\u0026#39; 的安全上下文\u0026#34;, username); } } } } catch (Exception e) { logger.error(\u0026#34;無法設定使用者認證: {}\u0026#34;, e.getMessage()); } filterChain.doFilter(request, response); } /** * 從請求中提取 JWT Token */ private String getJwtFromRequest(HttpServletRequest request) { String bearerToken = request.getHeader(AUTHORIZATION_HEADER); if (StringUtils.hasText(bearerToken) \u0026amp;\u0026amp; bearerToken.startsWith(BEARER_PREFIX)) { return bearerToken.substring(BEARER_PREFIX.length()); } return null; } @Override protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException { String path = request.getRequestURI(); // 排除不需要 JWT 驗證的路徑 return path.startsWith(\u0026#34;/api/auth/\u0026#34;) || path.startsWith(\u0026#34;/swagger-ui/\u0026#34;) || path.startsWith(\u0026#34;/v3/api-docs/\u0026#34;) || path.equals(\u0026#34;/health\u0026#34;) || path.equals(\u0026#34;/favicon.ico\u0026#34;); } } 5. Spring Security 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 package com.example.jwt.config; import com.example.jwt.filter.JwtAuthenticationFilter; import com.example.jwt.service.CustomUserDetailsService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.AuthenticationProvider; import org.springframework.security.authentication.dao.DaoAuthenticationProvider; import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration; import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.security.web.SecurityFilterChain; import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.CorsConfigurationSource; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import java.util.Arrays; @Configuration @EnableWebSecurity @EnableMethodSecurity(prePostEnabled = true) public class SecurityConfig { @Autowired private CustomUserDetailsService userDetailsService; @Autowired private JwtAuthenticationFilter jwtAuthenticationFilter; @Autowired private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint; @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(12); } @Bean public AuthenticationProvider authenticationProvider() { DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider(); authProvider.setUserDetailsService(userDetailsService); authProvider.setPasswordEncoder(passwordEncoder()); return authProvider; } @Bean public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception { return config.getAuthenticationManager(); } @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .csrf(AbstractHttpConfigurer::disable) .cors(cors -\u0026gt; cors.configurationSource(corsConfigurationSource())) .sessionManagement(session -\u0026gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) .authorizeHttpRequests(authz -\u0026gt; authz // 公開端點 .requestMatchers( \u0026#34;/api/auth/**\u0026#34;, \u0026#34;/swagger-ui/**\u0026#34;, \u0026#34;/v3/api-docs/**\u0026#34;, \u0026#34;/health\u0026#34;, \u0026#34;/favicon.ico\u0026#34; ).permitAll() // 管理員端點 .requestMatchers(\u0026#34;/api/admin/**\u0026#34;).hasRole(\u0026#34;ADMIN\u0026#34;) // 其他端點需要認證 .anyRequest().authenticated() ) .exceptionHandling(ex -\u0026gt; ex.authenticationEntryPoint(jwtAuthenticationEntryPoint)) .authenticationProvider(authenticationProvider()) .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class); return http.build(); } @Bean public CorsConfigurationSource corsConfigurationSource() { CorsConfiguration configuration = new CorsConfiguration(); configuration.setAllowedOriginPatterns(Arrays.asList(\u0026#34;*\u0026#34;)); configuration.setAllowedMethods(Arrays.asList(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;OPTIONS\u0026#34;)); configuration.setAllowedHeaders(Arrays.asList(\u0026#34;*\u0026#34;)); configuration.setAllowCredentials(true); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\u0026#34;/**\u0026#34;, configuration); return source; } } 6. 認證控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package com.example.jwt.controller; import com.example.jwt.dto.AuthenticationRequest; import com.example.jwt.dto.AuthenticationResponse; import com.example.jwt.service.AuthenticationService; import jakarta.validation.Valid; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; @RestController @RequestMapping(\u0026#34;/api/auth\u0026#34;) @CrossOrigin(origins = \u0026#34;*\u0026#34;, maxAge = 3600) public class AuthController { @Autowired private AuthenticationService authenticationService; /** * 使用者登入 */ @PostMapping(\u0026#34;/login\u0026#34;) public ResponseEntity\u0026lt;AuthenticationResponse\u0026gt; login( @Valid @RequestBody AuthenticationRequest request) { AuthenticationResponse response = authenticationService.authenticate(request); return ResponseEntity.ok(response); } /** * 刷新 Token */ @PostMapping(\u0026#34;/refresh\u0026#34;) public ResponseEntity\u0026lt;AuthenticationResponse\u0026gt; refreshToken( @RequestHeader(\u0026#34;Authorization\u0026#34;) String refreshToken) { AuthenticationResponse response = authenticationService.refreshToken(refreshToken); return ResponseEntity.ok(response); } /** * 登出（可選：加入黑名單機制） */ @PostMapping(\u0026#34;/logout\u0026#34;) public ResponseEntity\u0026lt;Void\u0026gt; logout(@RequestHeader(\u0026#34;Authorization\u0026#34;) String token) { authenticationService.logout(token); return ResponseEntity.ok().build(); } /** * 驗證 Token 有效性 */ @GetMapping(\u0026#34;/validate\u0026#34;) public ResponseEntity\u0026lt;Boolean\u0026gt; validateToken(@RequestHeader(\u0026#34;Authorization\u0026#34;) String token) { boolean isValid = authenticationService.validateToken(token); return ResponseEntity.ok(isValid); } } 7. 認證服務 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 package com.example.jwt.service; import com.example.jwt.dto.AuthenticationRequest; import com.example.jwt.dto.AuthenticationResponse; import com.example.jwt.util.JwtUtil; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.BadCredentialsException; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.Authentication; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.stereotype.Service; @Service public class AuthenticationService { @Autowired private AuthenticationManager authenticationManager; @Autowired private CustomUserDetailsService userDetailsService; @Autowired private JwtUtil jwtUtil; @Autowired private TokenBlacklistService tokenBlacklistService; /** * 認證使用者並生成 Token */ public AuthenticationResponse authenticate(AuthenticationRequest request) { try { // 驗證使用者憑證 Authentication authentication = authenticationManager.authenticate( new UsernamePasswordAuthenticationToken( request.getUsername(), request.getPassword() ) ); // 載入使用者詳細資訊 UserDetails userDetails = userDetailsService.loadUserByUsername(request.getUsername()); // 生成 Token String accessToken = jwtUtil.generateAccessToken(userDetails); String refreshToken = jwtUtil.generateRefreshToken(userDetails); return new AuthenticationResponse( accessToken, jwtUtil.getExpirationTime(), refreshToken ); } catch (BadCredentialsException e) { throw new BadCredentialsException(\u0026#34;使用者名稱或密碼錯誤\u0026#34;); } } /** * 刷新 Token */ public AuthenticationResponse refreshToken(String refreshToken) { // 移除 Bearer 前綴 String token = refreshToken.startsWith(\u0026#34;Bearer \u0026#34;) ? refreshToken.substring(7) : refreshToken; if (!jwtUtil.validateToken(token)) { throw new RuntimeException(\u0026#34;無效的刷新 Token\u0026#34;); } String username = jwtUtil.extractUsername(token); UserDetails userDetails = userDetailsService.loadUserByUsername(username); String newAccessToken = jwtUtil.generateAccessToken(userDetails); return new AuthenticationResponse(newAccessToken, jwtUtil.getExpirationTime()); } /** * 登出並將 Token 加入黑名單 */ public void logout(String token) { String jwtToken = token.startsWith(\u0026#34;Bearer \u0026#34;) ? token.substring(7) : token; tokenBlacklistService.blacklistToken(jwtToken); } /** * 驗證 Token */ public boolean validateToken(String token) { String jwtToken = token.startsWith(\u0026#34;Bearer \u0026#34;) ? token.substring(7) : token; return jwtUtil.validateToken(jwtToken) \u0026amp;\u0026amp; !tokenBlacklistService.isTokenBlacklisted(jwtToken); } } 配置檔案 application.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # JWT 配置 jwt: # 使用強密鑰（至少256位） secret: ${JWT_SECRET:dGhpc2lzYXZlcnlzZWN1cmVzZWNyZXRrZXl0aGF0aXNhdGxlYXN0MjU2Yml0c2xvbmc=} # Access Token 過期時間（15分鐘） expiration: 900000 # Refresh Token 過期時間（7天） refresh-expiration: 604800000 # Spring Security 配置 spring: security: # OAuth2 配置（可選） oauth2: client: registration: google: client-id: ${GOOGLE_CLIENT_ID:} client-secret: ${GOOGLE_CLIENT_SECRET:} scope: openid,profile,email # 日誌配置 logging: level: com.example.jwt: DEBUG org.springframework.security: DEBUG 安全性最佳實踐 1. 密鑰管理 1 2 3 4 5 6 7 8 // 生成安全的密鑰 public class KeyGenerator { public static void main(String[] args) { SecretKey key = Keys.secretKeyFor(SignatureAlgorithm.HS256); String encodedKey = Encoders.BASE64.encode(key.getEncoded()); System.out.println(\u0026#34;Generated key: \u0026#34; + encodedKey); } } 2. Token 黑名單服務 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.example.jwt.service; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Service; import java.util.concurrent.TimeUnit; @Service public class TokenBlacklistService { @Autowired private RedisTemplate\u0026lt;String, String\u0026gt; redisTemplate; private static final String BLACKLIST_PREFIX = \u0026#34;jwt:blacklist:\u0026#34;; /** * 將 Token 加入黑名單 */ public void blacklistToken(String token) { String key = BLACKLIST_PREFIX + token; // 設定過期時間等於 Token 的剩餘有效時間 redisTemplate.opsForValue().set(key, \u0026#34;blacklisted\u0026#34;, 24, TimeUnit.HOURS); } /** * 檢查 Token 是否在黑名單中 */ public boolean isTokenBlacklisted(String token) { String key = BLACKLIST_PREFIX + token; return Boolean.TRUE.equals(redisTemplate.hasKey(key)); } } 3. 異常處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package com.example.jwt.exception; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.security.authentication.BadCredentialsException; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.RestControllerAdvice; @RestControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(BadCredentialsException.class) public ResponseEntity\u0026lt;ErrorResponse\u0026gt; handleBadCredentials(BadCredentialsException e) { ErrorResponse error = new ErrorResponse( HttpStatus.UNAUTHORIZED.value(), \u0026#34;認證失敗\u0026#34;, e.getMessage() ); return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error); } @ExceptionHandler(JwtException.class) public ResponseEntity\u0026lt;ErrorResponse\u0026gt; handleJwtException(JwtException e) { ErrorResponse error = new ErrorResponse( HttpStatus.UNAUTHORIZED.value(), \u0026#34;Token 錯誤\u0026#34;, e.getMessage() ); return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error); } } class ErrorResponse { private int status; private String error; private String message; private long timestamp; public ErrorResponse(int status, String error, String message) { this.status = status; this.error = error; this.message = message; this.timestamp = System.currentTimeMillis(); } // Getters and Setters // ... } 使用範例 1. 前端整合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // JavaScript 前端範例 class AuthService { constructor() { this.baseURL = \u0026#39;http://localhost:8080/api\u0026#39;; this.token = localStorage.getItem(\u0026#39;accessToken\u0026#39;); } async login(username, password) { try { const response = await fetch(`${this.baseURL}/auth/login`, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, body: JSON.stringify({ username, password }) }); if (response.ok) { const data = await response.json(); this.token = data.access_token; localStorage.setItem(\u0026#39;accessToken\u0026#39;, this.token); localStorage.setItem(\u0026#39;refreshToken\u0026#39;, data.refresh_token); return data; } else { throw new Error(\u0026#39;登入失敗\u0026#39;); } } catch (error) { console.error(\u0026#39;登入錯誤:\u0026#39;, error); throw error; } } async apiCall(endpoint, options = {}) { const config = { ...options, headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${this.token}`, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, ...options.headers } }; let response = await fetch(`${this.baseURL}${endpoint}`, config); // 如果 Token 過期，嘗試刷新 if (response.status === 401) { await this.refreshToken(); config.headers[\u0026#39;Authorization\u0026#39;] = `Bearer ${this.token}`; response = await fetch(`${this.baseURL}${endpoint}`, config); } return response; } async refreshToken() { const refreshToken = localStorage.getItem(\u0026#39;refreshToken\u0026#39;); if (!refreshToken) { this.logout(); return; } try { const response = await fetch(`${this.baseURL}/auth/refresh`, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${refreshToken}` } }); if (response.ok) { const data = await response.json(); this.token = data.access_token; localStorage.setItem(\u0026#39;accessToken\u0026#39;, this.token); } else { this.logout(); } } catch (error) { console.error(\u0026#39;Token 刷新失敗:\u0026#39;, error); this.logout(); } } logout() { localStorage.removeItem(\u0026#39;accessToken\u0026#39;); localStorage.removeItem(\u0026#39;refreshToken\u0026#39;); this.token = null; window.location.href = \u0026#39;/login\u0026#39;; } } 2. 測試範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package com.example.jwt; import com.example.jwt.util.JwtUtil; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.UserDetails; import java.util.ArrayList; import static org.junit.jupiter.api.Assertions.*; @SpringBootTest public class JwtUtilTest { @Autowired private JwtUtil jwtUtil; @Test public void testGenerateAndValidateToken() { // 建立測試使用者 UserDetails userDetails = new User(\u0026#34;testuser\u0026#34;, \u0026#34;password\u0026#34;, new ArrayList\u0026lt;\u0026gt;()); // 生成 Token String token = jwtUtil.generateAccessToken(userDetails); assertNotNull(token); // 驗證 Token assertTrue(jwtUtil.validateToken(token, userDetails)); // 提取使用者名稱 String extractedUsername = jwtUtil.extractUsername(token); assertEquals(\u0026#34;testuser\u0026#34;, extractedUsername); // 檢查 Token 是否未過期 assertFalse(jwtUtil.isTokenExpired(token)); } } 效能最佳化 1. Redis 快取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Configuration @EnableCaching public class CacheConfig { @Bean public CacheManager cacheManager(RedisConnectionFactory connectionFactory) { RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofMinutes(15)) .serializeKeysWith(RedisSerializationContext.SerializationPair .fromSerializer(new StringRedisSerializer())) .serializeValuesWith(RedisSerializationContext.SerializationPair .fromSerializer(new GenericJackson2JsonRedisSerializer())); return RedisCacheManager.builder(connectionFactory) .cacheDefaults(config) .build(); } } 2. 非同步處理 1 2 3 4 5 6 7 8 9 10 11 @Service public class AsyncAuthService { @Async @EventListener public void handleUserLogin(UserLoginEvent event) { // 記錄登入日誌 // 發送通知 // 更新使用者統計 } } 監控和日誌 1. 認證監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component public class AuthenticationEventListener { private static final Logger logger = LoggerFactory.getLogger(AuthenticationEventListener.class); @EventListener public void onAuthenticationSuccess(AuthenticationSuccessEvent event) { String username = event.getAuthentication().getName(); logger.info(\u0026#34;使用者 {} 登入成功\u0026#34;, username); } @EventListener public void onAuthenticationFailure(AbstractAuthenticationFailureEvent event) { String username = event.getAuthentication().getName(); logger.warn(\u0026#34;使用者 {} 登入失敗: {}\u0026#34;, username, event.getException().getMessage()); } } 2. 效能監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Aspect @Component public class JwtPerformanceAspect { private static final Logger logger = LoggerFactory.getLogger(JwtPerformanceAspect.class); @Around(\u0026#34;execution(* com.example.jwt.util.JwtUtil.*(..))\u0026#34;) public Object measureExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable { long startTime = System.currentTimeMillis(); Object result = joinPoint.proceed(); long endTime = System.currentTimeMillis(); logger.debug(\u0026#34;方法 {} 執行時間: {} ms\u0026#34;, joinPoint.getSignature().getName(), endTime - startTime); return result; } } 常見問題與解決方案 1. Token 過期處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 自動 Token 刷新攔截器 @Component public class TokenRefreshInterceptor implements HandlerInterceptor { @Autowired private JwtUtil jwtUtil; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = getTokenFromRequest(request); if (token != null \u0026amp;\u0026amp; jwtUtil.shouldRefreshToken(token)) { // 設定回應標頭提示前端刷新 Token response.setHeader(\u0026#34;X-Token-Refresh-Required\u0026#34;, \u0026#34;true\u0026#34;); } return true; } } 2. 跨域處理 1 2 3 4 5 6 7 8 9 10 11 12 13 @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/api/**\u0026#34;) .allowedOriginPatterns(\u0026#34;*\u0026#34;) .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;OPTIONS\u0026#34;) .allowedHeaders(\u0026#34;*\u0026#34;) .allowCredentials(true) .maxAge(3600); } } 總結 核心優勢 無狀態性：伺服器無需存儲 Session，適合分散式系統 可擴展性：支援微服務架構和負載均衡 跨域支援：解決傳統 Session 的跨域問題 安全性：數位簽名確保 Token 完整性 靈活性：可攜帶自訂使用者資訊 最佳實踐 使用強密鑰：至少 256 位的隨機密鑰 適當的過期時間：短期 Access Token + 長期 Refresh Token Token 黑名單：支援登出和緊急撤銷 HTTPS 傳輸：確保 Token 傳輸安全 輸入驗證：驗證所有使用者輸入 錯誤處理：優雅處理認證錯誤 監控日誌：記錄認證事件和異常 常用命令速查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 生成密鑰 openssl rand -base64 32 # 解析 JWT Token echo \u0026#34;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...\u0026#34; | cut -d. -f2 | base64 -d # 測試 API curl -X POST http://localhost:8080/api/auth/login \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;password\u0026#34;}\u0026#39; # 使用 Token 訪問 API curl -X GET http://localhost:8080/api/users \\ -H \u0026#34;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...\u0026#34; JWT 是現代 Web 應用程式認證的標準解決方案，正確實作能夠提供安全、可擴展的認證機制。記住：安全性設計應該從一開始就考慮，而不是後續添加的功能。\n參考資料 JWT Official Website RFC 7519 - JSON Web Token Spring Security Documentation JJWT Library OWASP JWT Security Guide ","permalink":"https://xinqilin.github.io/post/backend/jwt/","tags":["JWT","Spring Security","Authentication","Java","Spring Boot","Security","REST API","Token"],"title":"JWT 認證機制完整實作：Spring Security 整合與最佳實踐"},{"content":"概述 Swagger（現稱為 OpenAPI）是目前最流行的 REST API 文檔化工具之一。它不僅能自動生成美觀的 API 文檔，還提供互動式測試介面，支援多種程式語言的客戶端程式碼生成。本文將全面介紹如何在 Spring Boot 專案中整合和使用 Swagger，從基礎配置到進階功能的完整實戰指南。\n版本選擇與依賴配置 OpenAPI 3.0 vs Swagger 2.0 特性 Swagger 2.0 OpenAPI 3.0 規範版本 較舊 最新標準 Spring Boot 支援 良好 原生支援 功能豐富度 基本功能 豐富特性 社群活躍度 維護模式 積極開發 推薦度 僅限舊專案 強烈推薦 現代化依賴配置（OpenAPI 3.0） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!-- 推薦：SpringDoc OpenAPI 3 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-starter-webmvc-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 安全整合 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-security\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- WebFlux 支援 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-starter-webflux-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 傳統 Swagger 2.0 配置（僅供參考） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;!-- 傳統：Springfox Swagger 2 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; OpenAPI 3.0 基礎配置 1. 應用程式配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # application.yml springdoc: api-docs: path: /api-docs enabled: true swagger-ui: path: /swagger-ui.html enabled: true operations-sorter: method tags-sorter: alpha try-it-out-enabled: true filter: true display-request-duration: true packages-to-scan: com.example.controller paths-to-match: /api/** default-consumes-media-type: application/json default-produces-media-type: application/json # 自訂配置 app: api: title: E-Commerce API description: 電商平台核心 API 服務 version: 1.0.0 contact: name: API Support Team email: api-support@example.com url: https://example.com/support license: name: Apache 2.0 url: https://www.apache.org/licenses/LICENSE-2.0.html terms-of-service: https://example.com/terms 2. 進階 OpenAPI 配置類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @Configuration @EnableOpenApi public class OpenApiConfiguration { @Value(\u0026#34;${app.api.title}\u0026#34;) private String title; @Value(\u0026#34;${app.api.description}\u0026#34;) private String description; @Value(\u0026#34;${app.api.version}\u0026#34;) private String version; @Bean public OpenAPI customOpenAPI() { return new OpenAPI() .info(createApiInfo()) .servers(createServers()) .security(createSecurityRequirements()) .components(createComponents()); } private Info createApiInfo() { return new Info() .title(title) .description(description) .version(version) .contact(new Contact() .name(\u0026#34;API Support Team\u0026#34;) .email(\u0026#34;api-support@example.com\u0026#34;) .url(\u0026#34;https://example.com/support\u0026#34;)) .license(new License() .name(\u0026#34;Apache 2.0\u0026#34;) .url(\u0026#34;https://www.apache.org/licenses/LICENSE-2.0.html\u0026#34;)) .termsOfService(\u0026#34;https://example.com/terms\u0026#34;); } private List\u0026lt;Server\u0026gt; createServers() { return List.of( new Server() .url(\u0026#34;https://api.example.com\u0026#34;) .description(\u0026#34;Production Server\u0026#34;), new Server() .url(\u0026#34;https://staging-api.example.com\u0026#34;) .description(\u0026#34;Staging Server\u0026#34;), new Server() .url(\u0026#34;http://localhost:8080\u0026#34;) .description(\u0026#34;Development Server\u0026#34;) ); } private List\u0026lt;SecurityRequirement\u0026gt; createSecurityRequirements() { return List.of( new SecurityRequirement().addList(\u0026#34;bearerAuth\u0026#34;), new SecurityRequirement().addList(\u0026#34;apiKey\u0026#34;) ); } private Components createComponents() { return new Components() .addSecuritySchemes(\u0026#34;bearerAuth\u0026#34;, new SecurityScheme() .type(SecurityScheme.Type.HTTP) .scheme(\u0026#34;bearer\u0026#34;) .bearerFormat(\u0026#34;JWT\u0026#34;) .description(\u0026#34;JWT Bearer Token Authentication\u0026#34;)) .addSecuritySchemes(\u0026#34;apiKey\u0026#34;, new SecurityScheme() .type(SecurityScheme.Type.APIKEY) .in(SecurityScheme.In.HEADER) .name(\u0026#34;X-API-Key\u0026#34;) .description(\u0026#34;API Key Authentication\u0026#34;)) .addSchemas(\u0026#34;Error\u0026#34;, createErrorSchema()) .addSchemas(\u0026#34;PageInfo\u0026#34;, createPageInfoSchema()); } private Schema\u0026lt;?\u0026gt; createErrorSchema() { return new Schema\u0026lt;\u0026gt;() .type(\u0026#34;object\u0026#34;) .addProperties(\u0026#34;timestamp\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;string\u0026#34;).format(\u0026#34;date-time\u0026#34;)) .addProperties(\u0026#34;status\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;integer\u0026#34;)) .addProperties(\u0026#34;error\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;string\u0026#34;)) .addProperties(\u0026#34;message\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;string\u0026#34;)) .addProperties(\u0026#34;path\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;string\u0026#34;)); } private Schema\u0026lt;?\u0026gt; createPageInfoSchema() { return new Schema\u0026lt;\u0026gt;() .type(\u0026#34;object\u0026#34;) .addProperties(\u0026#34;page\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;integer\u0026#34;)) .addProperties(\u0026#34;size\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;integer\u0026#34;)) .addProperties(\u0026#34;totalElements\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;integer\u0026#34;)) .addProperties(\u0026#34;totalPages\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;integer\u0026#34;)); } } 控制器註解詳解 1. 完整的 REST Controller 範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 @RestController @RequestMapping(\u0026#34;/api/v1/users\u0026#34;) @Tag(name = \u0026#34;User Management\u0026#34;, description = \u0026#34;用戶管理相關 API\u0026#34;) @SecurityRequirement(name = \u0026#34;bearerAuth\u0026#34;) public class UserController { private final UserService userService; public UserController(UserService userService) { this.userService = userService; } @GetMapping @Operation( summary = \u0026#34;獲取用戶列表\u0026#34;, description = \u0026#34;分頁查詢用戶資訊，支援多種過濾條件\u0026#34;, tags = {\u0026#34;User Management\u0026#34;} ) @ApiResponses(value = { @ApiResponse( responseCode = \u0026#34;200\u0026#34;, description = \u0026#34;成功獲取用戶列表\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = PagedUserResponse.class), examples = @ExampleObject( name = \u0026#34;用戶列表範例\u0026#34;, value = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;content\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;username\u0026#34;: \u0026#34;john_doe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34;, \u0026#34;firstName\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Doe\u0026#34;, \u0026#34;createdAt\u0026#34;: \u0026#34;2023-01-15T10:30:00Z\u0026#34; } ], \u0026#34;pageable\u0026#34;: { \u0026#34;page\u0026#34;: 0, \u0026#34;size\u0026#34;: 20, \u0026#34;totalElements\u0026#34;: 1, \u0026#34;totalPages\u0026#34;: 1 } } \u0026#34;\u0026#34;\u0026#34; ) ) ), @ApiResponse( responseCode = \u0026#34;400\u0026#34;, description = \u0026#34;請求參數錯誤\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = ErrorResponse.class) ) ), @ApiResponse( responseCode = \u0026#34;401\u0026#34;, description = \u0026#34;未授權訪問\u0026#34;, content = @Content(schema = @Schema(implementation = ErrorResponse.class)) ), @ApiResponse( responseCode = \u0026#34;403\u0026#34;, description = \u0026#34;權限不足\u0026#34;, content = @Content(schema = @Schema(implementation = ErrorResponse.class)) ) }) public ResponseEntity\u0026lt;Page\u0026lt;UserResponse\u0026gt;\u0026gt; getUsers( @Parameter( description = \u0026#34;頁碼（從 0 開始）\u0026#34;, example = \u0026#34;0\u0026#34;, schema = @Schema(minimum = \u0026#34;0\u0026#34;, defaultValue = \u0026#34;0\u0026#34;) ) @RequestParam(defaultValue = \u0026#34;0\u0026#34;) @Min(0) int page, @Parameter( description = \u0026#34;每頁大小\u0026#34;, example = \u0026#34;20\u0026#34;, schema = @Schema(minimum = \u0026#34;1\u0026#34;, maximum = \u0026#34;100\u0026#34;, defaultValue = \u0026#34;20\u0026#34;) ) @RequestParam(defaultValue = \u0026#34;20\u0026#34;) @Min(1) @Max(100) int size, @Parameter( description = \u0026#34;排序欄位，格式：field,direction\u0026#34;, example = \u0026#34;createdAt,desc\u0026#34;, array = @ArraySchema(schema = @Schema(type = \u0026#34;string\u0026#34;)) ) @RequestParam(defaultValue = \u0026#34;createdAt,desc\u0026#34;) String[] sort, @Parameter( description = \u0026#34;用戶名搜尋關鍵字\u0026#34;, example = \u0026#34;john\u0026#34; ) @RequestParam(required = false) String username, @Parameter( description = \u0026#34;郵箱搜尋關鍵字\u0026#34;, example = \u0026#34;example.com\u0026#34; ) @RequestParam(required = false) String email, @Parameter( description = \u0026#34;用戶狀態過濾\u0026#34;, schema = @Schema(allowableValues = {\u0026#34;ACTIVE\u0026#34;, \u0026#34;INACTIVE\u0026#34;, \u0026#34;SUSPENDED\u0026#34;}) ) @RequestParam(required = false) UserStatus status ) { UserSearchCriteria criteria = UserSearchCriteria.builder() .username(username) .email(email) .status(status) .build(); Pageable pageable = createPageable(page, size, sort); Page\u0026lt;UserResponse\u0026gt; users = userService.findUsers(criteria, pageable); return ResponseEntity.ok(users); } @GetMapping(\u0026#34;/{id}\u0026#34;) @Operation( summary = \u0026#34;根據 ID 獲取用戶\u0026#34;, description = \u0026#34;根據用戶 ID 獲取詳細資訊\u0026#34; ) @ApiResponses(value = { @ApiResponse( responseCode = \u0026#34;200\u0026#34;, description = \u0026#34;成功獲取用戶資訊\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = UserDetailResponse.class) ) ), @ApiResponse(responseCode = \u0026#34;404\u0026#34;, description = \u0026#34;用戶不存在\u0026#34;) }) public ResponseEntity\u0026lt;UserDetailResponse\u0026gt; getUserById( @Parameter( description = \u0026#34;用戶 ID\u0026#34;, required = true, example = \u0026#34;123\u0026#34; ) @PathVariable @Positive Long id ) { UserDetailResponse user = userService.findDetailById(id); return ResponseEntity.ok(user); } @PostMapping @Operation( summary = \u0026#34;創建新用戶\u0026#34;, description = \u0026#34;創建新的用戶帳戶，郵箱必須唯一\u0026#34; ) @ApiResponses(value = { @ApiResponse( responseCode = \u0026#34;201\u0026#34;, description = \u0026#34;用戶創建成功\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = UserResponse.class) ) ), @ApiResponse( responseCode = \u0026#34;400\u0026#34;, description = \u0026#34;請求資料驗證失敗\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = ValidationErrorResponse.class) ) ), @ApiResponse( responseCode = \u0026#34;409\u0026#34;, description = \u0026#34;郵箱已存在\u0026#34; ) }) public ResponseEntity\u0026lt;UserResponse\u0026gt; createUser( @io.swagger.v3.oas.annotations.parameters.RequestBody( description = \u0026#34;用戶創建請求\u0026#34;, required = true, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = CreateUserRequest.class), examples = @ExampleObject( name = \u0026#34;用戶創建範例\u0026#34;, value = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;username\u0026#34;: \u0026#34;john_doe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34;, \u0026#34;firstName\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Doe\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;SecurePassword123!\u0026#34; } \u0026#34;\u0026#34;\u0026#34; ) ) ) @RequestBody @Valid CreateUserRequest request ) { UserResponse user = userService.createUser(request); URI location = URI.create(\u0026#34;/api/v1/users/\u0026#34; + user.getId()); return ResponseEntity.created(location).body(user); } @PutMapping(\u0026#34;/{id}\u0026#34;) @Operation( summary = \u0026#34;更新用戶資訊\u0026#34;, description = \u0026#34;更新指定用戶的基本資訊\u0026#34; ) public ResponseEntity\u0026lt;UserResponse\u0026gt; updateUser( @PathVariable @Positive Long id, @RequestBody @Valid UpdateUserRequest request ) { UserResponse user = userService.updateUser(id, request); return ResponseEntity.ok(user); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) @Operation( summary = \u0026#34;刪除用戶\u0026#34;, description = \u0026#34;軟刪除指定用戶（標記為已刪除狀態）\u0026#34; ) @ApiResponses(value = { @ApiResponse(responseCode = \u0026#34;204\u0026#34;, description = \u0026#34;刪除成功\u0026#34;), @ApiResponse(responseCode = \u0026#34;404\u0026#34;, description = \u0026#34;用戶不存在\u0026#34;), @ApiResponse(responseCode = \u0026#34;409\u0026#34;, description = \u0026#34;用戶有關聯資料，無法刪除\u0026#34;) }) public ResponseEntity\u0026lt;Void\u0026gt; deleteUser( @PathVariable @Positive Long id ) { userService.deleteUser(id); return ResponseEntity.noContent().build(); } @PostMapping(\u0026#34;/{id}/avatar\u0026#34;) @Operation( summary = \u0026#34;上傳用戶頭像\u0026#34;, description = \u0026#34;上傳用戶頭像圖片，支援 JPG、PNG 格式\u0026#34; ) @ApiResponses(value = { @ApiResponse( responseCode = \u0026#34;200\u0026#34;, description = \u0026#34;頭像上傳成功\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = UploadResponse.class) ) ), @ApiResponse(responseCode = \u0026#34;400\u0026#34;, description = \u0026#34;檔案格式不支援\u0026#34;), @ApiResponse(responseCode = \u0026#34;413\u0026#34;, description = \u0026#34;檔案大小超出限制\u0026#34;) }) public ResponseEntity\u0026lt;UploadResponse\u0026gt; uploadAvatar( @PathVariable @Positive Long id, @Parameter( description = \u0026#34;頭像圖片檔案\u0026#34;, required = true, content = @Content(mediaType = \u0026#34;multipart/form-data\u0026#34;) ) @RequestParam(\u0026#34;file\u0026#34;) MultipartFile file ) { UploadResponse response = userService.uploadAvatar(id, file); return ResponseEntity.ok(response); } } 2. DTO 類別註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @Schema(description = \u0026#34;用戶創建請求\u0026#34;) public class CreateUserRequest { @Schema( description = \u0026#34;用戶名\u0026#34;, example = \u0026#34;john_doe\u0026#34;, minLength = 3, maxLength = 50, pattern = \u0026#34;^[a-zA-Z0-9_]+$\u0026#34; ) @NotBlank(message = \u0026#34;用戶名不能為空\u0026#34;) @Size(min = 3, max = 50, message = \u0026#34;用戶名長度必須在 3-50 字元之間\u0026#34;) @Pattern(regexp = \u0026#34;^[a-zA-Z0-9_]+$\u0026#34;, message = \u0026#34;用戶名只能包含字母、數字和底線\u0026#34;) private String username; @Schema( description = \u0026#34;郵箱地址\u0026#34;, example = \u0026#34;john@example.com\u0026#34;, format = \u0026#34;email\u0026#34; ) @NotBlank(message = \u0026#34;郵箱不能為空\u0026#34;) @Email(message = \u0026#34;郵箱格式不正確\u0026#34;) private String email; @Schema( description = \u0026#34;名字\u0026#34;, example = \u0026#34;John\u0026#34;, maxLength = 30 ) @NotBlank(message = \u0026#34;名字不能為空\u0026#34;) @Size(max = 30, message = \u0026#34;名字長度不能超過 30 字元\u0026#34;) private String firstName; @Schema( description = \u0026#34;姓氏\u0026#34;, example = \u0026#34;Doe\u0026#34;, maxLength = 30 ) @NotBlank(message = \u0026#34;姓氏不能為空\u0026#34;) @Size(max = 30, message = \u0026#34;姓氏長度不能超過 30 字元\u0026#34;) private String lastName; @Schema( description = \u0026#34;密碼\u0026#34;, example = \u0026#34;SecurePassword123!\u0026#34;, minLength = 8, maxLength = 100, format = \u0026#34;password\u0026#34; ) @NotBlank(message = \u0026#34;密碼不能為空\u0026#34;) @Size(min = 8, max = 100, message = \u0026#34;密碼長度必須在 8-100 字元之間\u0026#34;) @Pattern( regexp = \u0026#34;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[@$!%*?\u0026amp;])[A-Za-z\\\\d@$!%*?\u0026amp;]+$\u0026#34;, message = \u0026#34;密碼必須包含大小寫字母、數字和特殊字元\u0026#34; ) private String password; @Schema( description = \u0026#34;出生日期\u0026#34;, example = \u0026#34;1990-01-15\u0026#34;, format = \u0026#34;date\u0026#34; ) @Past(message = \u0026#34;出生日期必須是過去的日期\u0026#34;) private LocalDate birthDate; @Schema( description = \u0026#34;用戶角色\u0026#34;, allowableValues = {\u0026#34;USER\u0026#34;, \u0026#34;ADMIN\u0026#34;, \u0026#34;MODERATOR\u0026#34;}, defaultValue = \u0026#34;USER\u0026#34; ) private UserRole role = UserRole.USER; // Getters and Setters... } @Schema(description = \u0026#34;分頁用戶回應\u0026#34;) public class PagedUserResponse { @Schema(description = \u0026#34;用戶列表\u0026#34;) private List\u0026lt;UserResponse\u0026gt; content; @Schema(description = \u0026#34;分頁資訊\u0026#34;) private PageInfo pageable; // Getters and Setters... } @Schema(description = \u0026#34;用戶基本資訊回應\u0026#34;) public class UserResponse { @Schema(description = \u0026#34;用戶 ID\u0026#34;, example = \u0026#34;123\u0026#34;) private Long id; @Schema(description = \u0026#34;用戶名\u0026#34;, example = \u0026#34;john_doe\u0026#34;) private String username; @Schema(description = \u0026#34;郵箱\u0026#34;, example = \u0026#34;john@example.com\u0026#34;) private String email; @Schema(description = \u0026#34;全名\u0026#34;, example = \u0026#34;John Doe\u0026#34;) private String fullName; @Schema(description = \u0026#34;頭像 URL\u0026#34;, example = \u0026#34;https://example.com/avatars/123.jpg\u0026#34;) private String avatarUrl; @Schema(description = \u0026#34;用戶狀態\u0026#34;, allowableValues = {\u0026#34;ACTIVE\u0026#34;, \u0026#34;INACTIVE\u0026#34;, \u0026#34;SUSPENDED\u0026#34;}) private UserStatus status; @Schema(description = \u0026#34;創建時間\u0026#34;, format = \u0026#34;date-time\u0026#34;) private LocalDateTime createdAt; @Schema(description = \u0026#34;最後登入時間\u0026#34;, format = \u0026#34;date-time\u0026#34;) private LocalDateTime lastLoginAt; // Getters and Setters... } 安全配置整合 1. JWT Bearer Token 整合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @Configuration @EnableWebSecurity public class SecurityConfiguration { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { return http .csrf(csrf -\u0026gt; csrf.disable()) .authorizeHttpRequests(auth -\u0026gt; auth // Swagger 相關路徑公開 .requestMatchers( \u0026#34;/api-docs/**\u0026#34;, \u0026#34;/swagger-ui/**\u0026#34;, \u0026#34;/swagger-ui.html\u0026#34;, \u0026#34;/webjars/**\u0026#34; ).permitAll() // 公開 API .requestMatchers(HttpMethod.POST, \u0026#34;/api/v1/auth/**\u0026#34;).permitAll() .requestMatchers(HttpMethod.GET, \u0026#34;/api/v1/public/**\u0026#34;).permitAll() // 需要認證的 API .anyRequest().authenticated() ) .oauth2ResourceServer(oauth2 -\u0026gt; oauth2 .jwt(jwt -\u0026gt; jwt.jwtDecoder(jwtDecoder())) ) .sessionManagement(session -\u0026gt; session .sessionCreationPolicy(SessionCreationPolicy.STATELESS) ) .build(); } @Bean public JwtDecoder jwtDecoder() { return NimbusJwtDecoder.withJwkSetUri(\u0026#34;https://your-auth-server/.well-known/jwks.json\u0026#34;) .build(); } } // 在 Controller 中指定安全需求 @RestController @RequestMapping(\u0026#34;/api/v1/admin\u0026#34;) @Tag(name = \u0026#34;Admin Management\u0026#34;, description = \u0026#34;管理員專用 API\u0026#34;) @SecurityRequirement(name = \u0026#34;bearerAuth\u0026#34;) @PreAuthorize(\u0026#34;hasRole(\u0026#39;ADMIN\u0026#39;)\u0026#34;) public class AdminController { @GetMapping(\u0026#34;/users\u0026#34;) @Operation( summary = \u0026#34;管理員查看所有用戶\u0026#34;, description = \u0026#34;需要 ADMIN 角色權限\u0026#34; ) @PreAuthorize(\u0026#34;hasAuthority(\u0026#39;USER_READ_ALL\u0026#39;)\u0026#34;) public ResponseEntity\u0026lt;Page\u0026lt;UserResponse\u0026gt;\u0026gt; getAllUsersForAdmin( @ParameterObject Pageable pageable ) { // Implementation... return ResponseEntity.ok().build(); } } 2. API Key 認證 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 @Component public class ApiKeyAuthenticationFilter extends OncePerRequestFilter { private static final String API_KEY_HEADER = \u0026#34;X-API-Key\u0026#34;; private final ApiKeyService apiKeyService; public ApiKeyAuthenticationFilter(ApiKeyService apiKeyService) { this.apiKeyService = apiKeyService; } @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain ) throws ServletException, IOException { String apiKey = request.getHeader(API_KEY_HEADER); if (apiKey != null \u0026amp;\u0026amp; apiKeyService.isValidApiKey(apiKey)) { ApiKeyDetails details = apiKeyService.getApiKeyDetails(apiKey); ApiKeyAuthenticationToken authentication = new ApiKeyAuthenticationToken(details); SecurityContextHolder.getContext().setAuthentication(authentication); } filterChain.doFilter(request, response); } } // 在特定 Controller 中使用 API Key @RestController @RequestMapping(\u0026#34;/api/v1/webhook\u0026#34;) @Tag(name = \u0026#34;Webhook API\u0026#34;, description = \u0026#34;第三方系統回調 API\u0026#34;) @SecurityRequirement(name = \u0026#34;apiKey\u0026#34;) public class WebhookController { @PostMapping(\u0026#34;/payment\u0026#34;) @Operation( summary = \u0026#34;支付結果回調\u0026#34;, description = \u0026#34;第三方支付系統回調通知\u0026#34; ) public ResponseEntity\u0026lt;Void\u0026gt; handlePaymentWebhook( @RequestBody PaymentWebhookRequest request ) { // Implementation... return ResponseEntity.ok().build(); } } 進階功能配置 1. 自訂文檔分組 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @Configuration public class OpenApiGroupConfiguration { @Bean @Primary public GroupedOpenApi publicApi() { return GroupedOpenApi.builder() .group(\u0026#34;public\u0026#34;) .displayName(\u0026#34;Public API\u0026#34;) .pathsToMatch(\u0026#34;/api/v1/public/**\u0026#34;, \u0026#34;/api/v1/auth/**\u0026#34;) .build(); } @Bean public GroupedOpenApi userApi() { return GroupedOpenApi.builder() .group(\u0026#34;user\u0026#34;) .displayName(\u0026#34;User API\u0026#34;) .pathsToMatch(\u0026#34;/api/v1/users/**\u0026#34;, \u0026#34;/api/v1/profile/**\u0026#34;) .addOperationCustomizer((operation, handlerMethod) -\u0026gt; { operation.addSecurityItem(new SecurityRequirement().addList(\u0026#34;bearerAuth\u0026#34;)); return operation; }) .build(); } @Bean public GroupedOpenApi adminApi() { return GroupedOpenApi.builder() .group(\u0026#34;admin\u0026#34;) .displayName(\u0026#34;Admin API\u0026#34;) .pathsToMatch(\u0026#34;/api/v1/admin/**\u0026#34;) .addOperationCustomizer((operation, handlerMethod) -\u0026gt; { operation.addSecurityItem(new SecurityRequirement().addList(\u0026#34;bearerAuth\u0026#34;)); // 添加管理員 API 的額外標籤 operation.addTagsItem(\u0026#34;Admin Only\u0026#34;); return operation; }) .build(); } @Bean public GroupedOpenApi internalApi() { return GroupedOpenApi.builder() .group(\u0026#34;internal\u0026#34;) .displayName(\u0026#34;Internal API\u0026#34;) .pathsToMatch(\u0026#34;/api/internal/**\u0026#34;) .addOperationCustomizer((operation, handlerMethod) -\u0026gt; { operation.addSecurityItem(new SecurityRequirement().addList(\u0026#34;apiKey\u0026#34;)); return operation; }) .build(); } } 2. 自訂操作符處理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @Component public class CustomOperationCustomizer implements OperationCustomizer { @Override public Operation customize(Operation operation, HandlerMethod handlerMethod) { // 自動添加通用錯誤回應 addCommonErrorResponses(operation); // 為分頁端點添加通用參數 if (isPaginationEndpoint(handlerMethod)) { addPaginationParameters(operation); } // 添加請求追蹤資訊 addRequestTrackingInfo(operation); return operation; } private void addCommonErrorResponses(Operation operation) { ApiResponses responses = operation.getResponses(); if (responses.get(\u0026#34;400\u0026#34;) == null) { responses.addApiResponse(\u0026#34;400\u0026#34;, new ApiResponse() .description(\u0026#34;請求參數錯誤\u0026#34;) .content(new Content() .addMediaType(\u0026#34;application/json\u0026#34;, new MediaType() .schema(new Schema\u0026lt;\u0026gt;().$ref(\u0026#34;#/components/schemas/Error\u0026#34;))))); } if (responses.get(\u0026#34;500\u0026#34;) == null) { responses.addApiResponse(\u0026#34;500\u0026#34;, new ApiResponse() .description(\u0026#34;內部伺服器錯誤\u0026#34;) .content(new Content() .addMediaType(\u0026#34;application/json\u0026#34;, new MediaType() .schema(new Schema\u0026lt;\u0026gt;().$ref(\u0026#34;#/components/schemas/Error\u0026#34;))))); } } private boolean isPaginationEndpoint(HandlerMethod handlerMethod) { return Arrays.stream(handlerMethod.getMethodParameters()) .anyMatch(param -\u0026gt; Pageable.class.isAssignableFrom(param.getParameterType())); } private void addPaginationParameters(Operation operation) { if (operation.getParameters() == null) { operation.setParameters(new ArrayList\u0026lt;\u0026gt;()); } // 添加通用分頁參數 operation.getParameters().add(new Parameter() .name(\u0026#34;page\u0026#34;) .in(ParameterIn.QUERY) .description(\u0026#34;頁碼（從 0 開始）\u0026#34;) .schema(new IntegerSchema().minimum(BigDecimal.ZERO)._default(0))); operation.getParameters().add(new Parameter() .name(\u0026#34;size\u0026#34;) .in(ParameterIn.QUERY) .description(\u0026#34;每頁大小\u0026#34;) .schema(new IntegerSchema().minimum(BigDecimal.ONE).maximum(BigDecimal.valueOf(100))._default(20))); } private void addRequestTrackingInfo(Operation operation) { operation.addExtension(\u0026#34;x-request-id\u0026#34;, \u0026#34;自動生成的請求追蹤 ID\u0026#34;); operation.addExtension(\u0026#34;x-rate-limit\u0026#34;, \u0026#34;API 呼叫頻率限制資訊\u0026#34;); } } 3. 自訂 Schema 處理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @Component public class CustomModelConverter implements ModelConverter { @Override public ModelConverterContext resolve( AnnotatedType annotatedType, ModelConverterContext context, Iterator\u0026lt;ModelConverter\u0026gt; chain ) { if (chain.hasNext()) { context = chain.next().resolve(annotatedType, context, chain); } // 自訂枚舉處理 if (annotatedType.getType() instanceof Class\u0026lt;?\u0026gt; clazz \u0026amp;\u0026amp; clazz.isEnum()) { Schema\u0026lt;?\u0026gt; schema = context.getDefinedModels().get(annotatedType.getType().getTypeName()); if (schema != null) { enhanceEnumSchema(schema, clazz); } } return context; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private void enhanceEnumSchema(Schema\u0026lt;?\u0026gt; schema, Class\u0026lt;?\u0026gt; enumClass) { if (enumClass.isEnum()) { Enum\u0026lt;?\u0026gt;[] enumConstants = (Enum\u0026lt;?\u0026gt;[]) enumClass.getEnumConstants(); List\u0026lt;String\u0026gt; enumValues = Arrays.stream(enumConstants) .map(Enum::name) .collect(Collectors.toList()); schema.setEnum(enumValues); // 添加枚舉描述 StringBuilder description = new StringBuilder(schema.getDescription() != null ? schema.getDescription() : \u0026#34;\u0026#34;); description.append(\u0026#34;\\n\\n可用值：\\n\u0026#34;); for (Enum\u0026lt;?\u0026gt; enumConstant : enumConstants) { description.append(\u0026#34;- `\u0026#34;).append(enumConstant.name()).append(\u0026#34;`\u0026#34;); // 如果枚舉有描述方法，添加描述 try { Method getDescription = enumClass.getMethod(\u0026#34;getDescription\u0026#34;); Object desc = getDescription.invoke(enumConstant); if (desc != null) { description.append(\u0026#34;: \u0026#34;).append(desc); } } catch (Exception ignored) { // 忽略沒有 getDescription 方法的情況 } description.append(\u0026#34;\\n\u0026#34;); } schema.setDescription(description.toString()); } } } 測試整合 1. API 文檔測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @TestMethodOrder(OrderAnnotation.class) class OpenApiDocumentationTest { @Autowired private TestRestTemplate restTemplate; @LocalServerPort private int port; @Test @Order(1) void testOpenApiJsonGeneration() { String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/api-docs\u0026#34;; ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.getForEntity(url, String.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK); assertThat(response.getBody()).isNotNull(); // 驗證 JSON 結構 DocumentContext context = JsonPath.parse(response.getBody()); assertThat(context.read(\u0026#34;$.openapi\u0026#34;, String.class)).isEqualTo(\u0026#34;3.0.1\u0026#34;); assertThat(context.read(\u0026#34;$.info.title\u0026#34;, String.class)).isNotEmpty(); assertThat(context.read(\u0026#34;$.paths\u0026#34;, Map.class)).isNotEmpty(); } @Test @Order(2) void testSwaggerUiAccess() { String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/swagger-ui.html\u0026#34;; ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.getForEntity(url, String.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK); assertThat(response.getBody()).contains(\u0026#34;Swagger UI\u0026#34;); } @Test @Order(3) void testApiGroupsGeneration() { String[] groups = {\u0026#34;public\u0026#34;, \u0026#34;user\u0026#34;, \u0026#34;admin\u0026#34;, \u0026#34;internal\u0026#34;}; for (String group : groups) { String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/api-docs/\u0026#34; + group; ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.getForEntity(url, String.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK); DocumentContext context = JsonPath.parse(response.getBody()); assertThat(context.read(\u0026#34;$.paths\u0026#34;, Map.class)).isNotEmpty(); } } @Test @Order(4) void testSecuritySchemesDefinition() { String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/api-docs\u0026#34;; ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.getForEntity(url, String.class); DocumentContext context = JsonPath.parse(response.getBody()); // 驗證安全方案定義 assertThat(context.read(\u0026#34;$.components.securitySchemes.bearerAuth.type\u0026#34;, String.class)) .isEqualTo(\u0026#34;http\u0026#34;); assertThat(context.read(\u0026#34;$.components.securitySchemes.apiKey.type\u0026#34;, String.class)) .isEqualTo(\u0026#34;apiKey\u0026#34;); } } 2. 契約測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) class ApiContractTest { @Autowired private TestRestTemplate restTemplate; @Autowired private ObjectMapper objectMapper; @LocalServerPort private int port; @Test void testUserApiContract() throws Exception { // 獲取 OpenAPI 規範 String openApiJson = getOpenApiJson(); OpenAPIV3Parser parser = new OpenAPIV3Parser(); OpenAPI openAPI = parser.readContents(openApiJson).getOpenAPI(); // 測試用戶創建端點 PathItem userPath = openAPI.getPaths().get(\u0026#34;/api/v1/users\u0026#34;); assertThat(userPath).isNotNull(); Operation postOperation = userPath.getPost(); assertThat(postOperation).isNotNull(); assertThat(postOperation.getSummary()).isEqualTo(\u0026#34;創建新用戶\u0026#34;); // 驗證請求 Schema RequestBody requestBody = postOperation.getRequestBody(); assertThat(requestBody).isNotNull(); Content content = requestBody.getContent(); MediaType mediaType = content.get(\u0026#34;application/json\u0026#34;); assertThat(mediaType).isNotNull(); // 驗證回應 Schema ApiResponse response201 = postOperation.getResponses().get(\u0026#34;201\u0026#34;); assertThat(response201).isNotNull(); assertThat(response201.getDescription()).isEqualTo(\u0026#34;用戶創建成功\u0026#34;); } @Test void testActualApiMatchesContract() throws Exception { // 根據文檔測試實際 API String requestJson = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;username\u0026#34;: \u0026#34;test_user\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;test@example.com\u0026#34;, \u0026#34;firstName\u0026#34;: \u0026#34;Test\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;User\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;TestPassword123!\u0026#34; } \u0026#34;\u0026#34;\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); headers.setBearerAuth(\u0026#34;valid-jwt-token\u0026#34;); HttpEntity\u0026lt;String\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(requestJson, headers); // 假設這個端點在測試環境中可用 String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/api/v1/users\u0026#34;; ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.postForEntity(url, request, String.class); // 根據文檔，應該返回 201 或 401（如果沒有有效 token） assertThat(response.getStatusCode()) .isIn(HttpStatus.CREATED, HttpStatus.UNAUTHORIZED); } private String getOpenApiJson() { String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/api-docs\u0026#34;; return restTemplate.getForObject(url, String.class); } } 部署與 CI/CD 整合 1. 文檔生成腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #!/bin/bash # scripts/generate-api-docs.sh set -e echo \u0026#34;🚀 生成 API 文檔...\u0026#34; # 啟動應用程式 echo \u0026#34;啟動 Spring Boot 應用程式...\u0026#34; java -jar target/api-service.jar --server.port=8080 \u0026amp; APP_PID=$! # 等待應用程式啟動 echo \u0026#34;等待應用程式啟動...\u0026#34; for i in {1..30}; do if curl -s http://localhost:8080/actuator/health \u0026gt; /dev/null; then echo \u0026#34;應用程式已啟動\u0026#34; break fi sleep 2 done # 生成 OpenAPI JSON echo \u0026#34;下載 OpenAPI 規範...\u0026#34; curl -o docs/openapi.json http://localhost:8080/api-docs # 生成不同格式的文檔 echo \u0026#34;生成 HTML 文檔...\u0026#34; npx @redocly/openapi-cli build-docs docs/openapi.json --output docs/api.html echo \u0026#34;生成 Markdown 文檔...\u0026#34; npx widdershins docs/openapi.json -o docs/api.md # 生成客戶端 SDK echo \u0026#34;生成客戶端 SDK...\u0026#34; mkdir -p generated/java-client npx @openapitools/openapi-generator-cli generate \\ -i docs/openapi.json \\ -g java \\ -o generated/java-client \\ --additional-properties=invokerPackage=com.example.client # 停止應用程式 echo \u0026#34;停止應用程式...\u0026#34; kill $APP_PID echo \u0026#34;✅ API 文檔生成完成\u0026#34; 2. GitHub Actions 工作流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 # .github/workflows/api-docs.yml name: Generate API Documentation on: push: branches: [ main, develop ] pull_request: branches: [ main ] jobs: generate-docs: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set up JDK 17 uses: actions/setup-java@v3 with: java-version: \u0026#39;17\u0026#39; distribution: \u0026#39;temurin\u0026#39; - name: Cache Maven dependencies uses: actions/cache@v3 with: path: ~/.m2 key: ${{ runner.os }}-m2-${{ hashFiles(\u0026#39;**/pom.xml\u0026#39;) }} - name: Build application run: mvn clean package -DskipTests - name: Setup Node.js uses: actions/setup-node@v3 with: node-version: \u0026#39;18\u0026#39; - name: Install documentation tools run: | npm install -g @redocly/openapi-cli npm install -g widdershins npm install -g @openapitools/openapi-generator-cli - name: Generate API documentation run: | chmod +x scripts/generate-api-docs.sh ./scripts/generate-api-docs.sh - name: Upload documentation artifacts uses: actions/upload-artifact@v3 with: name: api-documentation path: | docs/ generated/ - name: Deploy to GitHub Pages if: github.ref == \u0026#39;refs/heads/main\u0026#39; uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./docs 3. Docker 整合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Dockerfile.docs FROM openjdk:17-jdk-slim as builder WORKDIR /app COPY . . RUN ./mvnw clean package -DskipTests FROM node:18-alpine as docs-generator WORKDIR /app # 安裝文檔生成工具 RUN npm install -g @redocly/openapi-cli widdershins @openapitools/openapi-generator-cli # 複製應用程式 COPY --from=builder /app/target/*.jar app.jar # 生成文檔的腳本 COPY scripts/generate-docs-docker.sh . RUN chmod +x generate-docs-docker.sh EXPOSE 8080 CMD [\u0026#34;./generate-docs-docker.sh\u0026#34;] 效能優化與最佳實踐 1. 大型 API 的文檔優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @Configuration public class OpenApiPerformanceConfiguration { @Bean @ConditionalOnProperty(name = \u0026#34;springdoc.api-docs.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public OpenApiCustomiser openApiCustomiser() { return openApi -\u0026gt; { // 移除不必要的 Schema removeUnusedSchemas(openApi); // 簡化複雜的嵌套對象 simplifyNestedObjects(openApi); // 添加快取頭 addCacheHeaders(openApi); }; } private void removeUnusedSchemas(OpenAPI openApi) { if (openApi.getComponents() != null \u0026amp;\u0026amp; openApi.getComponents().getSchemas() != null) { Set\u0026lt;String\u0026gt; usedSchemas = findUsedSchemas(openApi); openApi.getComponents().getSchemas().entrySet() .removeIf(entry -\u0026gt; !usedSchemas.contains(entry.getKey())); } } private Set\u0026lt;String\u0026gt; findUsedSchemas(OpenAPI openApi) { Set\u0026lt;String\u0026gt; usedSchemas = new HashSet\u0026lt;\u0026gt;(); if (openApi.getPaths() != null) { openApi.getPaths().values().forEach(pathItem -\u0026gt; { Stream.of( pathItem.getGet(), pathItem.getPost(), pathItem.getPut(), pathItem.getDelete(), pathItem.getPatch() ).filter(Objects::nonNull) .forEach(operation -\u0026gt; collectUsedSchemas(operation, usedSchemas)); }); } return usedSchemas; } private void collectUsedSchemas(Operation operation, Set\u0026lt;String\u0026gt; usedSchemas) { // 從請求體收集 if (operation.getRequestBody() != null \u0026amp;\u0026amp; operation.getRequestBody().getContent() != null) { operation.getRequestBody().getContent().values() .forEach(mediaType -\u0026gt; collectSchemaRefs(mediaType.getSchema(), usedSchemas)); } // 從回應收集 if (operation.getResponses() != null) { operation.getResponses().values().forEach(response -\u0026gt; { if (response.getContent() != null) { response.getContent().values() .forEach(mediaType -\u0026gt; collectSchemaRefs(mediaType.getSchema(), usedSchemas)); } }); } } private void collectSchemaRefs(Schema\u0026lt;?\u0026gt; schema, Set\u0026lt;String\u0026gt; usedSchemas) { if (schema != null) { if (schema.get$ref() != null) { String schemaName = schema.get$ref().substring(\u0026#34;#/components/schemas/\u0026#34;.length()); usedSchemas.add(schemaName); } // 遞迴處理嵌套 Schema if (schema.getProperties() != null) { schema.getProperties().values().forEach(prop -\u0026gt; collectSchemaRefs((Schema\u0026lt;?\u0026gt;) prop, usedSchemas)); } } } } 2. 快取策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @RestController @RequestMapping(\u0026#34;/api-docs\u0026#34;) public class CachedApiDocsController { private final SpringDocConfigProperties springDocConfigProperties; private final ObjectMapper objectMapper; private final Cache\u0026lt;String, String\u0026gt; apiDocsCache; public CachedApiDocsController( SpringDocConfigProperties springDocConfigProperties, ObjectMapper objectMapper ) { this.springDocConfigProperties = springDocConfigProperties; this.objectMapper = objectMapper; this.apiDocsCache = Caffeine.newBuilder() .maximumSize(10) .expireAfterWrite(Duration.ofMinutes(30)) .build(); } @GetMapping( value = \u0026#34;/{group}\u0026#34;, produces = MediaType.APPLICATION_JSON_VALUE ) public ResponseEntity\u0026lt;String\u0026gt; getCachedApiDocs( @PathVariable String group, HttpServletRequest request ) { String cacheKey = group + \u0026#34;_\u0026#34; + getVersionHash(); String cachedDocs = apiDocsCache.get(cacheKey, key -\u0026gt; { // 生成文檔的邏輯 return generateApiDocs(group); }); return ResponseEntity.ok() .cacheControl(CacheControl.maxAge(Duration.ofHours(1))) .eTag(calculateETag(cachedDocs)) .body(cachedDocs); } private String getVersionHash() { // 基於應用程式版本和配置生成雜湊 String version = getClass().getPackage().getImplementationVersion(); return DigestUtils.md5Hex(version != null ? version : \u0026#34;dev\u0026#34;); } private String calculateETag(String content) { return \u0026#34;\\\u0026#34;\u0026#34; + DigestUtils.md5Hex(content) + \u0026#34;\\\u0026#34;\u0026#34;; } } 3. 環境配置最佳實踐 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # application-dev.yml springdoc: api-docs: enabled: true swagger-ui: enabled: true try-it-out-enabled: true operations-sorter: method tags-sorter: alpha display-request-duration: true doc-expansion: list default-models-expand-depth: 2 # application-prod.yml springdoc: api-docs: enabled: false # 生產環境關閉 swagger-ui: enabled: false # 生產環境關閉 # application-staging.yml springdoc: api-docs: enabled: true swagger-ui: enabled: true try-it-out-enabled: false # 測試環境禁止直接測試 監控與分析 1. API 使用情況追蹤 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Component public class ApiUsageTracker { private final MeterRegistry meterRegistry; private final Counter apiCallsCounter; private final Timer apiResponseTimer; public ApiUsageTracker(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; this.apiCallsCounter = Counter.builder(\u0026#34;api.calls\u0026#34;) .description(\u0026#34;API 呼叫次數\u0026#34;) .register(meterRegistry); this.apiResponseTimer = Timer.builder(\u0026#34;api.response.time\u0026#34;) .description(\u0026#34;API 回應時間\u0026#34;) .register(meterRegistry); } @EventListener public void trackApiCall(ApiCallEvent event) { apiCallsCounter .tag(\u0026#34;endpoint\u0026#34;, event.getEndpoint()) .tag(\u0026#34;method\u0026#34;, event.getMethod()) .tag(\u0026#34;status\u0026#34;, String.valueOf(event.getStatusCode())) .increment(); apiResponseTimer .tag(\u0026#34;endpoint\u0026#34;, event.getEndpoint()) .record(event.getResponseTime(), TimeUnit.MILLISECONDS); } } @RestController @RequestMapping(\u0026#34;/api/v1/analytics\u0026#34;) @Tag(name = \u0026#34;API Analytics\u0026#34;, description = \u0026#34;API 使用情況分析\u0026#34;) public class ApiAnalyticsController { private final MeterRegistry meterRegistry; public ApiAnalyticsController(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; } @GetMapping(\u0026#34;/metrics\u0026#34;) @Operation(summary = \u0026#34;獲取 API 使用統計\u0026#34;) public ResponseEntity\u0026lt;ApiMetrics\u0026gt; getApiMetrics() { Map\u0026lt;String, Double\u0026gt; endpointCalls = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;String, Double\u0026gt; averageResponseTimes = new HashMap\u0026lt;\u0026gt;(); meterRegistry.getMeters().forEach(meter -\u0026gt; { if (meter instanceof Counter counter \u0026amp;\u0026amp; meter.getId().getName().equals(\u0026#34;api.calls\u0026#34;)) { String endpoint = meter.getId().getTag(\u0026#34;endpoint\u0026#34;); endpointCalls.put(endpoint, counter.count()); } if (meter instanceof Timer timer \u0026amp;\u0026amp; meter.getId().getName().equals(\u0026#34;api.response.time\u0026#34;)) { String endpoint = meter.getId().getTag(\u0026#34;endpoint\u0026#34;); averageResponseTimes.put(endpoint, timer.mean(TimeUnit.MILLISECONDS)); } }); ApiMetrics metrics = new ApiMetrics(endpointCalls, averageResponseTimes); return ResponseEntity.ok(metrics); } } 總結 Swagger/OpenAPI 是現代 API 開發的必備工具，提供了從文檔生成到測試、監控的完整解決方案。透過本文的深入介紹，我們了解到：\n核心價值 自動化文檔：減少手動維護成本，確保文檔與程式碼同步 互動式測試：提供友善的 API 測試介面 團隊協作：統一的 API 規範促進前後端協作 程式碼生成：支援多種語言的客戶端 SDK 自動生成 最佳實踐要點 選擇 OpenAPI 3.0：使用最新標準和工具鏈 完整的註解：提供詳細的描述、範例和驗證規則 安全整合：正確配置認證和授權機制 效能優化：適當的快取和文檔分組策略 CI/CD 整合：自動化文檔生成和部署流程 進階應用 契約測試和 API 治理 多環境配置和版本管理 監控和分析 API 使用情況 與微服務架構的整合 正確實施 Swagger/OpenAPI 不僅能提升開發效率，還能建立標準化的 API 開發流程，為團隊帶來長期的技術價值。\n參考資料 OpenAPI Specification SpringDoc OpenAPI Spring Boot OpenAPI Integration OpenAPI Generator Swagger UI Configuration ","permalink":"https://xinqilin.github.io/post/backend/swagger2/","tags":["Java","Spring","Swagger","OpenAPI","API","Documentation","SpringBoot","REST"],"title":"Swagger/OpenAPI 完整指南：API 文檔化與測試最佳實踐"},{"content":"概述 RestTemplate 是 Spring Framework 提供的同步 HTTP 客戶端，用於簡化 RESTful Web 服務的調用。雖然在 Spring 5.0 之後被標記為維護模式（推薦使用 WebClient），但在許多現有項目中仍廣泛使用。本文將深入介紹 RestTemplate 的完整使用方法和最佳實踐。\n核心特性 簡化 HTTP 操作：提供便捷的 GET、POST、PUT、DELETE 等方法 自動序列化：支援 JSON、XML 等格式的自動轉換 異常處理：統一的異常處理機制 攔截器支援：請求和響應攔截器 靈活配置：連接池、超時、重試等配置 適用場景 微服務通信：服務間的 HTTP 調用 第三方 API 整合：調用外部 REST API 資料同步：不同系統間的資料交換 輕量級 HTTP 客戶端：簡單的 HTTP 請求需求 基礎配置與設定 1. 依賴配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;dependencies\u0026gt; \u0026lt;!-- Spring Boot Starter Web --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Apache HttpClient（可選，提供更好的連接池支援） --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- OkHttp（可選，現代化的 HTTP 客戶端） --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.squareup.okhttp3\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;okhttp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Jackson（JSON 處理） --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Testing --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 2. 基礎配置類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 package com.example.resttemplate.config; import org.apache.http.client.HttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.impl.conn.PoolingHttpClientConnectionManager; import org.springframework.boot.web.client.RestTemplateBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.client.HttpComponentsClientHttpRequestFactory; import org.springframework.http.client.SimpleClientHttpRequestFactory; import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter; import org.springframework.web.client.RestTemplate; import java.time.Duration; import java.util.Arrays; @Configuration public class RestTemplateConfig { /** * 基礎 RestTemplate 配置 */ @Bean(\u0026#34;basicRestTemplate\u0026#34;) public RestTemplate basicRestTemplate() { SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); factory.setConnectTimeout(5000); // 連接超時 5 秒 factory.setReadTimeout(10000); // 讀取超時 10 秒 RestTemplate restTemplate = new RestTemplate(factory); // 添加 JSON 消息轉換器 restTemplate.getMessageConverters().add(new MappingJackson2HttpMessageConverter()); return restTemplate; } /** * 使用 RestTemplateBuilder 構建（推薦方式） */ @Bean(\u0026#34;standardRestTemplate\u0026#34;) public RestTemplate standardRestTemplate(RestTemplateBuilder builder) { return builder .setConnectTimeout(Duration.ofSeconds(5)) .setReadTimeout(Duration.ofSeconds(10)) .additionalMessageConverters(new MappingJackson2HttpMessageConverter()) .build(); } /** * 高性能 RestTemplate（使用 Apache HttpClient） */ @Bean(\u0026#34;highPerformanceRestTemplate\u0026#34;) public RestTemplate highPerformanceRestTemplate() { // 連接池管理器 PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(); connectionManager.setMaxTotal(200); // 最大連接數 connectionManager.setDefaultMaxPerRoute(50); // 每個路由的最大連接數 // HttpClient 配置 HttpClient httpClient = HttpClients.custom() .setConnectionManager(connectionManager) .setConnectionManagerShared(true) .build(); // 請求工廠 HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(httpClient); factory.setConnectTimeout(5000); factory.setReadTimeout(10000); return new RestTemplate(factory); } /** * 帶有自訂配置的 RestTemplate */ @Bean(\u0026#34;customRestTemplate\u0026#34;) public RestTemplate customRestTemplate() { RestTemplate restTemplate = new RestTemplate(); // 添加攔截器 restTemplate.setInterceptors(Arrays.asList( new LoggingInterceptor(), new AuthenticationInterceptor(), new RetryInterceptor() )); // 設置錯誤處理器 restTemplate.setErrorHandler(new CustomResponseErrorHandler()); return restTemplate; } } 3. 屬性配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # application.yml rest-client: connection: timeout: 5000 read-timeout: 10000 max-connections: 200 max-connections-per-route: 50 retry: max-attempts: 3 delay: 1000 base-urls: user-service: \u0026#34;http://localhost:8081\u0026#34; order-service: \u0026#34;http://localhost:8082\u0026#34; payment-service: \u0026#34;http://localhost:8083\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @ConfigurationProperties(prefix = \u0026#34;rest-client\u0026#34;) @Component public class RestClientProperties { private Connection connection = new Connection(); private Retry retry = new Retry(); private Map\u0026lt;String, String\u0026gt; baseUrls = new HashMap\u0026lt;\u0026gt;(); // getter 和 setter 方法 public static class Connection { private int timeout = 5000; private int readTimeout = 10000; private int maxConnections = 200; private int maxConnectionsPerRoute = 50; // getter 和 setter 方法 } public static class Retry { private int maxAttempts = 3; private long delay = 1000; // getter 和 setter 方法 } } 基礎 HTTP 操作 1. GET 請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 package com.example.resttemplate.service; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.core.ParameterizedTypeReference; import org.springframework.http.*; import org.springframework.stereotype.Service; import org.springframework.web.client.RestTemplate; import org.springframework.web.util.UriComponentsBuilder; import java.net.URI; import java.util.HashMap; import java.util.List; import java.util.Map; @Service public class RestClientService { private final RestTemplate restTemplate; public RestClientService(@Qualifier(\u0026#34;standardRestTemplate\u0026#34;) RestTemplate restTemplate) { this.restTemplate = restTemplate; } /** * 基礎 GET 請求 */ public User getUserById(Long userId) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; return restTemplate.getForObject(url, User.class, userId); } /** * 帶有查詢參數的 GET 請求 */ public List\u0026lt;User\u0026gt; getUsersByDepartment(String department, int page, int size) { String url = \u0026#34;https://api.example.com/users\u0026#34;; URI uri = UriComponentsBuilder.fromUriString(url) .queryParam(\u0026#34;department\u0026#34;, department) .queryParam(\u0026#34;page\u0026#34;, page) .queryParam(\u0026#34;size\u0026#34;, size) .build() .toUri(); ResponseEntity\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; response = restTemplate.exchange( uri, HttpMethod.GET, null, new ParameterizedTypeReference\u0026lt;List\u0026lt;User\u0026gt;\u0026gt;() {} ); return response.getBody(); } /** * 使用 Map 作為 URI 變數 */ public User getUserWithMap(Long userId) { String url = \u0026#34;https://api.example.com/users/{id}/profile/{section}\u0026#34;; Map\u0026lt;String, Object\u0026gt; uriVariables = new HashMap\u0026lt;\u0026gt;(); uriVariables.put(\u0026#34;id\u0026#34;, userId); uriVariables.put(\u0026#34;section\u0026#34;, \u0026#34;basic\u0026#34;); return restTemplate.getForObject(url, User.class, uriVariables); } /** * 帶有請求頭的 GET 請求 */ public User getUserWithHeaders(Long userId, String authToken) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.set(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + authToken); headers.set(\u0026#34;Accept\u0026#34;, MediaType.APPLICATION_JSON_VALUE); HttpEntity\u0026lt;String\u0026gt; entity = new HttpEntity\u0026lt;\u0026gt;(headers); ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.exchange( url, HttpMethod.GET, entity, User.class, userId ); return response.getBody(); } /** * 獲取完整的響應資訊 */ public ResponseEntity\u0026lt;User\u0026gt; getUserWithFullResponse(Long userId) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.getForEntity(url, User.class, userId); // 可以獲取狀態碼、頭部、主體等資訊 HttpStatus statusCode = response.getStatusCode(); HttpHeaders responseHeaders = response.getHeaders(); User user = response.getBody(); return response; } } 2. POST 請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 /** * POST 請求範例 */ @Service public class PostRequestService { private final RestTemplate restTemplate; public PostRequestService(@Qualifier(\u0026#34;standardRestTemplate\u0026#34;) RestTemplate restTemplate) { this.restTemplate = restTemplate; } /** * 基礎 POST 請求 */ public User createUser(User newUser) { String url = \u0026#34;https://api.example.com/users\u0026#34;; return restTemplate.postForObject(url, newUser, User.class); } /** * 帶有請求頭的 POST 請求 */ public ResponseEntity\u0026lt;User\u0026gt; createUserWithHeaders(User newUser, String authToken) { String url = \u0026#34;https://api.example.com/users\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); headers.set(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + authToken); HttpEntity\u0026lt;User\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(newUser, headers); return restTemplate.postForEntity(url, request, User.class); } /** * 表單數據 POST 請求 */ public String submitForm(String email, String password) { String url = \u0026#34;https://api.example.com/login\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); MultiValueMap\u0026lt;String, String\u0026gt; formData = new LinkedMultiValueMap\u0026lt;\u0026gt;(); formData.add(\u0026#34;email\u0026#34;, email); formData.add(\u0026#34;password\u0026#34;, password); HttpEntity\u0026lt;MultiValueMap\u0026lt;String, String\u0026gt;\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(formData, headers); return restTemplate.postForObject(url, request, String.class); } /** * JSON 數據 POST 請求 */ public ApiResponse\u0026lt;User\u0026gt; createUserWithResponse(CreateUserRequest request) { String url = \u0026#34;https://api.example.com/users\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); headers.set(\u0026#34;X-Request-ID\u0026#34;, generateRequestId()); HttpEntity\u0026lt;CreateUserRequest\u0026gt; httpEntity = new HttpEntity\u0026lt;\u0026gt;(request, headers); ResponseEntity\u0026lt;ApiResponse\u0026lt;User\u0026gt;\u0026gt; response = restTemplate.exchange( url, HttpMethod.POST, httpEntity, new ParameterizedTypeReference\u0026lt;ApiResponse\u0026lt;User\u0026gt;\u0026gt;() {} ); return response.getBody(); } /** * 文件上傳 POST 請求 */ public String uploadFile(MultipartFile file, String description) { String url = \u0026#34;https://api.example.com/files/upload\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.MULTIPART_FORM_DATA); MultiValueMap\u0026lt;String, Object\u0026gt; formData = new LinkedMultiValueMap\u0026lt;\u0026gt;(); formData.add(\u0026#34;file\u0026#34;, file.getResource()); formData.add(\u0026#34;description\u0026#34;, description); HttpEntity\u0026lt;MultiValueMap\u0026lt;String, Object\u0026gt;\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(formData, headers); return restTemplate.postForObject(url, request, String.class); } private String generateRequestId() { return UUID.randomUUID().toString(); } } 3. PUT 和 DELETE 請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 /** * PUT 和 DELETE 請求範例 */ @Service public class UpdateDeleteService { private final RestTemplate restTemplate; public UpdateDeleteService(@Qualifier(\u0026#34;standardRestTemplate\u0026#34;) RestTemplate restTemplate) { this.restTemplate = restTemplate; } /** * PUT 更新請求 */ public User updateUser(Long userId, User updatedUser) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity\u0026lt;User\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(updatedUser, headers); ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.exchange( url, HttpMethod.PUT, request, User.class, userId ); return response.getBody(); } /** * PATCH 部分更新請求 */ public User partialUpdateUser(Long userId, Map\u0026lt;String, Object\u0026gt; updates) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(updates, headers); ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.exchange( url, HttpMethod.PATCH, request, User.class, userId ); return response.getBody(); } /** * DELETE 刪除請求 */ public void deleteUser(Long userId) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; restTemplate.delete(url, userId); } /** * 帶有響應的 DELETE 請求 */ public ApiResponse\u0026lt;Void\u0026gt; deleteUserWithResponse(Long userId, String authToken) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.set(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + authToken); HttpEntity\u0026lt;String\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(headers); ResponseEntity\u0026lt;ApiResponse\u0026lt;Void\u0026gt;\u0026gt; response = restTemplate.exchange( url, HttpMethod.DELETE, request, new ParameterizedTypeReference\u0026lt;ApiResponse\u0026lt;Void\u0026gt;\u0026gt;() {}, userId ); return response.getBody(); } /** * 批量刪除請求 */ public void deleteUsers(List\u0026lt;Long\u0026gt; userIds) { String url = \u0026#34;https://api.example.com/users/batch\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); DeleteBatchRequest request = new DeleteBatchRequest(userIds); HttpEntity\u0026lt;DeleteBatchRequest\u0026gt; httpEntity = new HttpEntity\u0026lt;\u0026gt;(request, headers); restTemplate.exchange( url, HttpMethod.DELETE, httpEntity, Void.class ); } } 高級功能與自訂 1. 攔截器實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 /** * 日誌攔截器 */ @Component public class LoggingInterceptor implements ClientHttpRequestInterceptor { private static final Logger logger = LoggerFactory.getLogger(LoggingInterceptor.class); @Override public ClientHttpResponse intercept( HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { logRequest(request, body); long startTime = System.currentTimeMillis(); ClientHttpResponse response = execution.execute(request, body); long duration = System.currentTimeMillis() - startTime; logResponse(response, duration); return response; } private void logRequest(HttpRequest request, byte[] body) { logger.info(\u0026#34;===========================request begin================================================\u0026#34;); logger.info(\u0026#34;URI : {}\u0026#34;, request.getURI()); logger.info(\u0026#34;Method : {}\u0026#34;, request.getMethod()); logger.info(\u0026#34;Headers : {}\u0026#34;, request.getHeaders()); logger.info(\u0026#34;Request body: {}\u0026#34;, new String(body, StandardCharsets.UTF_8)); logger.info(\u0026#34;==========================request end================================================\u0026#34;); } private void logResponse(ClientHttpResponse response, long duration) throws IOException { logger.info(\u0026#34;============================response begin==========================================\u0026#34;); logger.info(\u0026#34;Status code : {}\u0026#34;, response.getStatusCode()); logger.info(\u0026#34;Status text : {}\u0026#34;, response.getStatusText()); logger.info(\u0026#34;Headers : {}\u0026#34;, response.getHeaders()); logger.info(\u0026#34;Duration : {} ms\u0026#34;, duration); logger.info(\u0026#34;=======================response end=================================================\u0026#34;); } } /** * 認證攔截器 */ @Component public class AuthenticationInterceptor implements ClientHttpRequestInterceptor { private final TokenService tokenService; public AuthenticationInterceptor(TokenService tokenService) { this.tokenService = tokenService; } @Override public ClientHttpResponse intercept( HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { // 獲取並設置認證 token String token = tokenService.getCurrentToken(); if (token != null) { request.getHeaders().set(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + token); } return execution.execute(request, body); } } /** * 重試攔截器 */ @Component public class RetryInterceptor implements ClientHttpRequestInterceptor { private static final Logger logger = LoggerFactory.getLogger(RetryInterceptor.class); private final int maxRetries; private final long retryDelay; public RetryInterceptor(@Value(\u0026#34;${rest-client.retry.max-attempts:3}\u0026#34;) int maxRetries, @Value(\u0026#34;${rest-client.retry.delay:1000}\u0026#34;) long retryDelay) { this.maxRetries = maxRetries; this.retryDelay = retryDelay; } @Override public ClientHttpResponse intercept( HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { IOException lastException = null; for (int attempt = 1; attempt \u0026lt;= maxRetries; attempt++) { try { ClientHttpResponse response = execution.execute(request, body); // 檢查是否需要重試（例如：5xx 錯誤） if (shouldRetry(response) \u0026amp;\u0026amp; attempt \u0026lt; maxRetries) { logger.warn(\u0026#34;Request failed with status {}, retrying... (attempt {}/{})\u0026#34;, response.getStatusCode(), attempt, maxRetries); // 等待後重試 try { Thread.sleep(retryDelay * attempt); // 指數退避 } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new IOException(\u0026#34;Interrupted during retry delay\u0026#34;, e); } continue; } return response; } catch (IOException e) { lastException = e; if (attempt \u0026lt; maxRetries) { logger.warn(\u0026#34;Request failed, retrying... (attempt {}/{}) - {}\u0026#34;, attempt, maxRetries, e.getMessage()); try { Thread.sleep(retryDelay * attempt); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); throw new IOException(\u0026#34;Interrupted during retry delay\u0026#34;, ie); } } else { logger.error(\u0026#34;Request failed after {} attempts\u0026#34;, maxRetries, e); } } } throw lastException; } private boolean shouldRetry(ClientHttpResponse response) throws IOException { HttpStatus status = response.getStatusCode(); return status.is5xxServerError() || status == HttpStatus.REQUEST_TIMEOUT; } } 2. 自訂錯誤處理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 /** * 自訂響應錯誤處理器 */ @Component public class CustomResponseErrorHandler implements ResponseErrorHandler { private static final Logger logger = LoggerFactory.getLogger(CustomResponseErrorHandler.class); @Override public boolean hasError(ClientHttpResponse response) throws IOException { HttpStatus status = response.getStatusCode(); return status.series() == HttpStatus.Series.CLIENT_ERROR || status.series() == HttpStatus.Series.SERVER_ERROR; } @Override public void handleError(ClientHttpResponse response) throws IOException { HttpStatus status = response.getStatusCode(); String responseBody = getResponseBody(response); logger.error(\u0026#34;HTTP Error: {} - {}, Response: {}\u0026#34;, status.value(), status.getReasonPhrase(), responseBody); switch (status.series()) { case CLIENT_ERROR: handleClientError(status, responseBody); break; case SERVER_ERROR: handleServerError(status, responseBody); break; default: throw new RestClientException(\u0026#34;Unknown HTTP error: \u0026#34; + status); } } private void handleClientError(HttpStatus status, String responseBody) { switch (status) { case BAD_REQUEST: throw new BadRequestException(\u0026#34;Invalid request: \u0026#34; + responseBody); case UNAUTHORIZED: throw new UnauthorizedException(\u0026#34;Authentication required\u0026#34;); case FORBIDDEN: throw new ForbiddenException(\u0026#34;Access denied\u0026#34;); case NOT_FOUND: throw new NotFoundException(\u0026#34;Resource not found\u0026#34;); case CONFLICT: throw new ConflictException(\u0026#34;Resource conflict: \u0026#34; + responseBody); case TOO_MANY_REQUESTS: throw new RateLimitException(\u0026#34;Rate limit exceeded\u0026#34;); default: throw new ClientErrorException(\u0026#34;Client error: \u0026#34; + status + \u0026#34; - \u0026#34; + responseBody); } } private void handleServerError(HttpStatus status, String responseBody) { switch (status) { case INTERNAL_SERVER_ERROR: throw new ServerErrorException(\u0026#34;Internal server error: \u0026#34; + responseBody); case BAD_GATEWAY: throw new BadGatewayException(\u0026#34;Bad gateway\u0026#34;); case SERVICE_UNAVAILABLE: throw new ServiceUnavailableException(\u0026#34;Service unavailable\u0026#34;); case GATEWAY_TIMEOUT: throw new GatewayTimeoutException(\u0026#34;Gateway timeout\u0026#34;); default: throw new ServerErrorException(\u0026#34;Server error: \u0026#34; + status + \u0026#34; - \u0026#34; + responseBody); } } private String getResponseBody(ClientHttpResponse response) { try (InputStream inputStream = response.getBody()) { return StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { logger.warn(\u0026#34;Failed to read response body\u0026#34;, e); return \u0026#34;Unable to read response body\u0026#34;; } } } 3. 自訂異常類別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 // 基礎異常類別 public abstract class RestClientException extends RuntimeException { public RestClientException(String message) { super(message); } public RestClientException(String message, Throwable cause) { super(message, cause); } } // 客戶端錯誤異常 public class ClientErrorException extends RestClientException { public ClientErrorException(String message) { super(message); } } public class BadRequestException extends ClientErrorException { public BadRequestException(String message) { super(message); } } public class UnauthorizedException extends ClientErrorException { public UnauthorizedException(String message) { super(message); } } public class ForbiddenException extends ClientErrorException { public ForbiddenException(String message) { super(message); } } public class NotFoundException extends ClientErrorException { public NotFoundException(String message) { super(message); } } public class ConflictException extends ClientErrorException { public ConflictException(String message) { super(message); } } public class RateLimitException extends ClientErrorException { public RateLimitException(String message) { super(message); } } // 服務器錯誤異常 public class ServerErrorException extends RestClientException { public ServerErrorException(String message) { super(message); } } public class BadGatewayException extends ServerErrorException { public BadGatewayException(String message) { super(message); } } public class ServiceUnavailableException extends ServerErrorException { public ServiceUnavailableException(String message) { super(message); } } public class GatewayTimeoutException extends ServerErrorException { public GatewayTimeoutException(String message) { super(message); } } 實際應用場景 1. 微服務通信 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 /** * 用戶服務客戶端 */ @Service public class UserServiceClient { private final RestTemplate restTemplate; private final RestClientProperties properties; public UserServiceClient(@Qualifier(\u0026#34;highPerformanceRestTemplate\u0026#34;) RestTemplate restTemplate, RestClientProperties properties) { this.restTemplate = restTemplate; this.properties = properties; } /** * 獲取用戶資訊 */ public Optional\u0026lt;User\u0026gt; getUserById(Long userId) { String url = properties.getBaseUrls().get(\u0026#34;user-service\u0026#34;) + \u0026#34;/api/users/{id}\u0026#34;; try { User user = restTemplate.getForObject(url, User.class, userId); return Optional.ofNullable(user); } catch (NotFoundException e) { return Optional.empty(); } } /** * 批量獲取用戶資訊 */ public List\u0026lt;User\u0026gt; getUsersByIds(List\u0026lt;Long\u0026gt; userIds) { String url = properties.getBaseUrls().get(\u0026#34;user-service\u0026#34;) + \u0026#34;/api/users/batch\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity\u0026lt;List\u0026lt;Long\u0026gt;\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(userIds, headers); ResponseEntity\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; response = restTemplate.exchange( url, HttpMethod.POST, request, new ParameterizedTypeReference\u0026lt;List\u0026lt;User\u0026gt;\u0026gt;() {} ); return response.getBody(); } /** * 創建用戶 */ public User createUser(CreateUserRequest request) { String url = properties.getBaseUrls().get(\u0026#34;user-service\u0026#34;) + \u0026#34;/api/users\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity\u0026lt;CreateUserRequest\u0026gt; httpEntity = new HttpEntity\u0026lt;\u0026gt;(request, headers); return restTemplate.postForObject(url, httpEntity, User.class); } /** * 更新用戶狀態 */ public void updateUserStatus(Long userId, UserStatus status) { String url = properties.getBaseUrls().get(\u0026#34;user-service\u0026#34;) + \u0026#34;/api/users/{id}/status\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); UpdateStatusRequest request = new UpdateStatusRequest(status); HttpEntity\u0026lt;UpdateStatusRequest\u0026gt; httpEntity = new HttpEntity\u0026lt;\u0026gt;(request, headers); restTemplate.exchange(url, HttpMethod.PUT, httpEntity, Void.class, userId); } } /** * 訂單服務客戶端 */ @Service public class OrderServiceClient { private final RestTemplate restTemplate; private final RestClientProperties properties; public OrderServiceClient(@Qualifier(\u0026#34;highPerformanceRestTemplate\u0026#34;) RestTemplate restTemplate, RestClientProperties properties) { this.restTemplate = restTemplate; this.properties = properties; } /** * 創建訂單 */ public Order createOrder(CreateOrderRequest request) { String url = properties.getBaseUrls().get(\u0026#34;order-service\u0026#34;) + \u0026#34;/api/orders\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); headers.set(\u0026#34;X-Request-ID\u0026#34;, UUID.randomUUID().toString()); HttpEntity\u0026lt;CreateOrderRequest\u0026gt; httpEntity = new HttpEntity\u0026lt;\u0026gt;(request, headers); ResponseEntity\u0026lt;Order\u0026gt; response = restTemplate.postForEntity(url, httpEntity, Order.class); if (response.getStatusCode() == HttpStatus.CREATED) { return response.getBody(); } else { throw new RuntimeException(\u0026#34;Failed to create order: \u0026#34; + response.getStatusCode()); } } /** * 獲取用戶訂單列表 */ public PagedResponse\u0026lt;Order\u0026gt; getUserOrders(Long userId, int page, int size) { String url = properties.getBaseUrls().get(\u0026#34;order-service\u0026#34;) + \u0026#34;/api/users/{userId}/orders\u0026#34;; URI uri = UriComponentsBuilder.fromUriString(url) .queryParam(\u0026#34;page\u0026#34;, page) .queryParam(\u0026#34;size\u0026#34;, size) .build(userId); ResponseEntity\u0026lt;PagedResponse\u0026lt;Order\u0026gt;\u0026gt; response = restTemplate.exchange( uri, HttpMethod.GET, null, new ParameterizedTypeReference\u0026lt;PagedResponse\u0026lt;Order\u0026gt;\u0026gt;() {} ); return response.getBody(); } /** * 取消訂單 */ public void cancelOrder(Long orderId, String reason) { String url = properties.getBaseUrls().get(\u0026#34;order-service\u0026#34;) + \u0026#34;/api/orders/{id}/cancel\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); CancelOrderRequest request = new CancelOrderRequest(reason); HttpEntity\u0026lt;CancelOrderRequest\u0026gt; httpEntity = new HttpEntity\u0026lt;\u0026gt;(request, headers); restTemplate.exchange(url, HttpMethod.POST, httpEntity, Void.class, orderId); } } 2. 第三方 API 整合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 /** * 第三方支付服務整合 */ @Service public class PaymentGatewayClient { private final RestTemplate restTemplate; private final PaymentConfig paymentConfig; public PaymentGatewayClient(@Qualifier(\u0026#34;customRestTemplate\u0026#34;) RestTemplate restTemplate, PaymentConfig paymentConfig) { this.restTemplate = restTemplate; this.paymentConfig = paymentConfig; } /** * 創建支付訂單 */ public PaymentResponse createPayment(PaymentRequest paymentRequest) { String url = paymentConfig.getBaseUrl() + \u0026#34;/api/v1/payments\u0026#34;; HttpHeaders headers = createAuthHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity\u0026lt;PaymentRequest\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(paymentRequest, headers); try { ResponseEntity\u0026lt;PaymentResponse\u0026gt; response = restTemplate.postForEntity( url, request, PaymentResponse.class); return response.getBody(); } catch (Exception e) { throw new PaymentException(\u0026#34;Failed to create payment\u0026#34;, e); } } /** * 查詢支付狀態 */ public PaymentStatus queryPaymentStatus(String paymentId) { String url = paymentConfig.getBaseUrl() + \u0026#34;/api/v1/payments/{paymentId}/status\u0026#34;; HttpHeaders headers = createAuthHeaders(); HttpEntity\u0026lt;String\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(headers); try { ResponseEntity\u0026lt;PaymentStatusResponse\u0026gt; response = restTemplate.exchange( url, HttpMethod.GET, request, PaymentStatusResponse.class, paymentId); return response.getBody().getStatus(); } catch (NotFoundException e) { throw new PaymentNotFoundException(\u0026#34;Payment not found: \u0026#34; + paymentId); } } /** * 退款請求 */ public RefundResponse processRefund(String paymentId, RefundRequest refundRequest) { String url = paymentConfig.getBaseUrl() + \u0026#34;/api/v1/payments/{paymentId}/refund\u0026#34;; HttpHeaders headers = createAuthHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity\u0026lt;RefundRequest\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(refundRequest, headers); try { ResponseEntity\u0026lt;RefundResponse\u0026gt; response = restTemplate.exchange( url, HttpMethod.POST, request, RefundResponse.class, paymentId); return response.getBody(); } catch (Exception e) { throw new RefundException(\u0026#34;Failed to process refund\u0026#34;, e); } } /** * 創建認證頭 */ private HttpHeaders createAuthHeaders() { HttpHeaders headers = new HttpHeaders(); String auth = paymentConfig.getApiKey() + \u0026#34;:\u0026#34; + paymentConfig.getApiSecret(); String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes()); headers.set(\u0026#34;Authorization\u0026#34;, \u0026#34;Basic \u0026#34; + encodedAuth); headers.set(\u0026#34;X-API-Version\u0026#34;, paymentConfig.getApiVersion()); return headers; } } /** * 外部資料同步服務 */ @Service public class DataSyncService { private final RestTemplate restTemplate; private final DataSyncConfig config; public DataSyncService(@Qualifier(\u0026#34;standardRestTemplate\u0026#34;) RestTemplate restTemplate, DataSyncConfig config) { this.restTemplate = restTemplate; this.config = config; } /** * 同步用戶資料 */ @Async public CompletableFuture\u0026lt;SyncResult\u0026gt; syncUserData() { String url = config.getExternalApiUrl() + \u0026#34;/users/export\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.set(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + config.getAccessToken()); headers.set(\u0026#34;Accept\u0026#34;, MediaType.APPLICATION_JSON_VALUE); HttpEntity\u0026lt;String\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(headers); try { ResponseEntity\u0026lt;List\u0026lt;ExternalUser\u0026gt;\u0026gt; response = restTemplate.exchange( url, HttpMethod.GET, request, new ParameterizedTypeReference\u0026lt;List\u0026lt;ExternalUser\u0026gt;\u0026gt;() {} ); List\u0026lt;ExternalUser\u0026gt; externalUsers = response.getBody(); // 處理同步邏輯 int syncedCount = processSyncData(externalUsers); return CompletableFuture.completedFuture( new SyncResult(true, syncedCount, \u0026#34;Sync completed successfully\u0026#34;)); } catch (Exception e) { return CompletableFuture.completedFuture( new SyncResult(false, 0, \u0026#34;Sync failed: \u0026#34; + e.getMessage())); } } private int processSyncData(List\u0026lt;ExternalUser\u0026gt; externalUsers) { // 同步處理邏輯 return externalUsers != null ? externalUsers.size() : 0; } } 效能優化與監控 1. 連接池優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 /** * 高效能 RestTemplate 配置 */ @Configuration public class HighPerformanceRestTemplateConfig { @Bean(\u0026#34;pooledRestTemplate\u0026#34;) public RestTemplate pooledRestTemplate() { // 連接池管理器配置 PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(); connectionManager.setMaxTotal(300); // 最大連接數 connectionManager.setDefaultMaxPerRoute(100); // 每個路由的最大連接數 connectionManager.setValidateAfterInactivity(2000); // 連接空閒檢查時間 // 連接池清理策略 connectionManager.closeExpiredConnections(); connectionManager.closeIdleConnections(30, TimeUnit.SECONDS); // 請求配置 RequestConfig requestConfig = RequestConfig.custom() .setConnectionRequestTimeout(5000) // 從連接池獲取連接的超時時間 .setConnectTimeout(5000) // 連接超時時間 .setSocketTimeout(30000) // 讀取超時時間 .build(); // HttpClient 配置 CloseableHttpClient httpClient = HttpClients.custom() .setConnectionManager(connectionManager) .setDefaultRequestConfig(requestConfig) .setRetryHandler(new DefaultHttpRequestRetryHandler(3, true)) .setKeepAliveStrategy((response, context) -\u0026gt; 30 * 1000) // 30 秒 keep-alive .build(); // 請求工廠 HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(httpClient); return new RestTemplate(factory); } /** * 連接池監控 */ @Component public class ConnectionPoolMonitor { private final PoolingHttpClientConnectionManager connectionManager; private final MeterRegistry meterRegistry; public ConnectionPoolMonitor(PoolingHttpClientConnectionManager connectionManager, MeterRegistry meterRegistry) { this.connectionManager = connectionManager; this.meterRegistry = meterRegistry; // 註冊連接池指標 Gauge.builder(\u0026#34;http.connections.total\u0026#34;) .description(\u0026#34;Total connections in pool\u0026#34;) .register(meterRegistry, this, monitor -\u0026gt; monitor.connectionManager.getTotalStats().getMax()); Gauge.builder(\u0026#34;http.connections.available\u0026#34;) .description(\u0026#34;Available connections in pool\u0026#34;) .register(meterRegistry, this, monitor -\u0026gt; monitor.connectionManager.getTotalStats().getAvailable()); Gauge.builder(\u0026#34;http.connections.leased\u0026#34;) .description(\u0026#34;Leased connections in pool\u0026#34;) .register(meterRegistry, this, monitor -\u0026gt; monitor.connectionManager.getTotalStats().getLeased()); } @EventListener @Async public void logConnectionPoolStats(ApplicationReadyEvent event) { ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); executor.scheduleAtFixedRate(this::logStats, 0, 30, TimeUnit.SECONDS); } private void logStats() { PoolStats totalStats = connectionManager.getTotalStats(); logger.info(\u0026#34;Connection Pool Stats - Total: {}, Available: {}, Leased: {}, Pending: {}\u0026#34;, totalStats.getMax(), totalStats.getAvailable(), totalStats.getLeased(), totalStats.getPending()); } } } 2. 響應時間監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 /** * HTTP 請求監控攔截器 */ @Component public class MetricsInterceptor implements ClientHttpRequestInterceptor { private final MeterRegistry meterRegistry; private final Timer.Builder timerBuilder; public MetricsInterceptor(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; this.timerBuilder = Timer.builder(\u0026#34;http.client.requests\u0026#34;) .description(\u0026#34;HTTP client request duration\u0026#34;); } @Override public ClientHttpResponse intercept( HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { Timer.Sample sample = Timer.start(meterRegistry); try { ClientHttpResponse response = execution.execute(request, body); // 記錄成功請求指標 sample.stop(timerBuilder .tag(\u0026#34;method\u0026#34;, request.getMethod().name()) .tag(\u0026#34;uri\u0026#34;, getUriTemplate(request.getURI())) .tag(\u0026#34;status\u0026#34;, String.valueOf(response.getStatusCode().value())) .tag(\u0026#34;outcome\u0026#34;, getOutcome(response)) .register(meterRegistry)); return response; } catch (IOException e) { // 記錄失敗請求指標 sample.stop(timerBuilder .tag(\u0026#34;method\u0026#34;, request.getMethod().name()) .tag(\u0026#34;uri\u0026#34;, getUriTemplate(request.getURI())) .tag(\u0026#34;status\u0026#34;, \u0026#34;IO_ERROR\u0026#34;) .tag(\u0026#34;outcome\u0026#34;, \u0026#34;ERROR\u0026#34;) .register(meterRegistry)); throw e; } } private String getUriTemplate(URI uri) { String path = uri.getPath(); // 簡化路徑模板（移除具體 ID） return path.replaceAll(\u0026#34;/\\\\d+\u0026#34;, \u0026#34;/{id}\u0026#34;); } private String getOutcome(ClientHttpResponse response) throws IOException { HttpStatus status = response.getStatusCode(); if (status.is2xxSuccessful()) { return \u0026#34;SUCCESS\u0026#34;; } else if (status.is4xxClientError()) { return \u0026#34;CLIENT_ERROR\u0026#34;; } else if (status.is5xxServerError()) { return \u0026#34;SERVER_ERROR\u0026#34;; } else { return \u0026#34;UNKNOWN\u0026#34;; } } } 3. 快取策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 /** * 帶快取的 REST 客戶端 */ @Service public class CachedRestClientService { private final RestTemplate restTemplate; private final CacheManager cacheManager; public CachedRestClientService(@Qualifier(\u0026#34;standardRestTemplate\u0026#34;) RestTemplate restTemplate, CacheManager cacheManager) { this.restTemplate = restTemplate; this.cacheManager = cacheManager; } /** * 帶快取的用戶查詢 */ @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#userId\u0026#34;, unless = \u0026#34;#result == null\u0026#34;) public User getUserById(Long userId) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; return restTemplate.getForObject(url, User.class, userId); } /** * 快取失效更新 */ @CacheEvict(value = \u0026#34;users\u0026#34;, key = \u0026#34;#userId\u0026#34;) public User updateUser(Long userId, User updatedUser) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity\u0026lt;User\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(updatedUser, headers); ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.exchange( url, HttpMethod.PUT, request, User.class, userId); return response.getBody(); } /** * 條件快取：基於響應頭的快取策略 */ public User getUserWithConditionalCache(Long userId) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; // 檢查快取 Cache cache = cacheManager.getCache(\u0026#34;users\u0026#34;); Cache.ValueWrapper cachedValue = cache.get(userId); HttpHeaders headers = new HttpHeaders(); if (cachedValue != null) { CachedUser cachedUser = (CachedUser) cachedValue.get(); // 添加 If-None-Match 頭 headers.set(\u0026#34;If-None-Match\u0026#34;, cachedUser.getEtag()); } HttpEntity\u0026lt;String\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(headers); try { ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.exchange( url, HttpMethod.GET, request, User.class, userId); // 更新快取 String etag = response.getHeaders().getETag(); if (etag != null) { CachedUser cachedUser = new CachedUser(response.getBody(), etag); cache.put(userId, cachedUser); } return response.getBody(); } catch (HttpClientErrorException e) { if (e.getStatusCode() == HttpStatus.NOT_MODIFIED \u0026amp;\u0026amp; cachedValue != null) { // 返回快取的值 return ((CachedUser) cachedValue.get()).getUser(); } throw e; } } private static class CachedUser { private final User user; private final String etag; public CachedUser(User user, String etag) { this.user = user; this.etag = etag; } public User getUser() { return user; } public String getEtag() { return etag; } } } 測試策略 1. 單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 /** * RestTemplate 單元測試 */ @ExtendWith(MockitoExtension.class) class RestClientServiceTest { @Mock private RestTemplate restTemplate; @InjectMocks private RestClientService restClientService; private MockRestServiceServer mockServer; private ObjectMapper objectMapper; @BeforeEach void setUp() { mockServer = MockRestServiceServer.createServer(restTemplate); objectMapper = new ObjectMapper(); } @Test @DisplayName(\u0026#34;成功獲取用戶資訊\u0026#34;) void testGetUserById_Success() throws JsonProcessingException { // Given Long userId = 1L; User expectedUser = new User(userId, \u0026#34;john@example.com\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;); String expectedJson = objectMapper.writeValueAsString(expectedUser); mockServer.expect(requestTo(\u0026#34;https://api.example.com/users/1\u0026#34;)) .andExpect(method(HttpMethod.GET)) .andRespond(withSuccess(expectedJson, MediaType.APPLICATION_JSON)); // When User actualUser = restClientService.getUserById(userId); // Then mockServer.verify(); assertThat(actualUser).isNotNull(); assertThat(actualUser.getId()).isEqualTo(userId); assertThat(actualUser.getEmail()).isEqualTo(\u0026#34;john@example.com\u0026#34;); } @Test @DisplayName(\u0026#34;用戶不存在時拋出異常\u0026#34;) void testGetUserById_NotFound() { // Given Long userId = 999L; mockServer.expect(requestTo(\u0026#34;https://api.example.com/users/999\u0026#34;)) .andExpect(method(HttpMethod.GET)) .andRespond(withStatus(HttpStatus.NOT_FOUND)); // When \u0026amp; Then assertThatThrownBy(() -\u0026gt; restClientService.getUserById(userId)) .isInstanceOf(NotFoundException.class); mockServer.verify(); } @Test @DisplayName(\u0026#34;帶有查詢參數的 GET 請求\u0026#34;) void testGetUsersByDepartment() throws JsonProcessingException { // Given String department = \u0026#34;IT\u0026#34;; int page = 0; int size = 10; List\u0026lt;User\u0026gt; expectedUsers = Arrays.asList( new User(1L, \u0026#34;john@example.com\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;), new User(2L, \u0026#34;jane@example.com\u0026#34;, \u0026#34;Jane\u0026#34;, \u0026#34;Smith\u0026#34;) ); String expectedJson = objectMapper.writeValueAsString(expectedUsers); mockServer.expect(requestTo(containsString(\u0026#34;https://api.example.com/users\u0026#34;))) .andExpect(queryParam(\u0026#34;department\u0026#34;, \u0026#34;IT\u0026#34;)) .andExpect(queryParam(\u0026#34;page\u0026#34;, \u0026#34;0\u0026#34;)) .andExpect(queryParam(\u0026#34;size\u0026#34;, \u0026#34;10\u0026#34;)) .andExpect(method(HttpMethod.GET)) .andRespond(withSuccess(expectedJson, MediaType.APPLICATION_JSON)); // When List\u0026lt;User\u0026gt; actualUsers = restClientService.getUsersByDepartment(department, page, size); // Then mockServer.verify(); assertThat(actualUsers).hasSize(2); } @Test @DisplayName(\u0026#34;POST 請求創建用戶\u0026#34;) void testCreateUser() throws JsonProcessingException { // Given User newUser = new User(null, \u0026#34;bob@example.com\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Johnson\u0026#34;); User createdUser = new User(3L, \u0026#34;bob@example.com\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Johnson\u0026#34;); String requestJson = objectMapper.writeValueAsString(newUser); String responseJson = objectMapper.writeValueAsString(createdUser); mockServer.expect(requestTo(\u0026#34;https://api.example.com/users\u0026#34;)) .andExpect(method(HttpMethod.POST)) .andExpect(content().json(requestJson)) .andExpected(header(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;)) .andRespond(withSuccess(responseJson, MediaType.APPLICATION_JSON)); // When User actualUser = restClientService.createUser(newUser); // Then mockServer.verify(); assertThat(actualUser.getId()).isEqualTo(3L); assertThat(actualUser.getEmail()).isEqualTo(\u0026#34;bob@example.com\u0026#34;); } @Test @DisplayName(\u0026#34;服務器錯誤時的重試機制\u0026#34;) void testRetryOnServerError() { // Given Long userId = 1L; mockServer.expect(times(3), requestTo(\u0026#34;https://api.example.com/users/1\u0026#34;)) .andExpect(method(HttpMethod.GET)) .andRespond(withServerError()); // When \u0026amp; Then assertThatThrownBy(() -\u0026gt; restClientService.getUserById(userId)) .isInstanceOf(ServerErrorException.class); mockServer.verify(); } } 2. 整合測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 /** * RestTemplate 整合測試 */ @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @TestPropertySource(locations = \u0026#34;classpath:application-integration-test.properties\u0026#34;) class RestClientIntegrationTest { @Autowired private RestClientService restClientService; @Autowired private TestRestTemplate testRestTemplate; @MockBean private RestTemplate restTemplate; private WireMockServer wireMockServer; @BeforeEach void setUp() { wireMockServer = new WireMockServer(wireMockConfig().port(8089)); wireMockServer.start(); configureFor(\u0026#34;localhost\u0026#34;, 8089); } @AfterEach void tearDown() { wireMockServer.stop(); } @Test @DisplayName(\u0026#34;完整的用戶管理流程\u0026#34;) void testCompleteUserManagementFlow() throws JsonProcessingException { ObjectMapper objectMapper = new ObjectMapper(); // 1. 模擬創建用戶 API User newUser = new User(null, \u0026#34;integration@example.com\u0026#34;, \u0026#34;Integration\u0026#34;, \u0026#34;Test\u0026#34;); User createdUser = new User(1L, \u0026#34;integration@example.com\u0026#34;, \u0026#34;Integration\u0026#34;, \u0026#34;Test\u0026#34;); stubFor(post(urlEqualTo(\u0026#34;/api/users\u0026#34;)) .willReturn(aResponse() .withStatus(201) .withHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .withBody(objectMapper.writeValueAsString(createdUser)))); // 2. 模擬獲取用戶 API stubFor(get(urlEqualTo(\u0026#34;/api/users/1\u0026#34;)) .willReturn(aResponse() .withStatus(200) .withHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .withBody(objectMapper.writeValueAsString(createdUser)))); // 3. 模擬更新用戶 API User updatedUser = new User(1L, \u0026#34;updated@example.com\u0026#34;, \u0026#34;Updated\u0026#34;, \u0026#34;User\u0026#34;); stubFor(put(urlEqualTo(\u0026#34;/api/users/1\u0026#34;)) .willReturn(aResponse() .withStatus(200) .withHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .withBody(objectMapper.writeValueAsString(updatedUser)))); // 4. 模擬刪除用戶 API stubFor(delete(urlEqualTo(\u0026#34;/api/users/1\u0026#34;)) .willReturn(aResponse().withStatus(204))); // 執行測試流程 // 創建用戶 User created = restClientService.createUser(newUser); assertThat(created.getId()).isEqualTo(1L); // 獲取用戶 User retrieved = restClientService.getUserById(1L); assertThat(retrieved.getEmail()).isEqualTo(\u0026#34;integration@example.com\u0026#34;); // 更新用戶 User updated = restClientService.updateUser(1L, updatedUser); assertThat(updated.getEmail()).isEqualTo(\u0026#34;updated@example.com\u0026#34;); // 刪除用戶 assertDoesNotThrow(() -\u0026gt; restClientService.deleteUser(1L)); // 驗證所有請求都被調用 verify(postRequestedFor(urlEqualTo(\u0026#34;/api/users\u0026#34;))); verify(getRequestedFor(urlEqualTo(\u0026#34;/api/users/1\u0026#34;))); verify(putRequestedFor(urlEqualTo(\u0026#34;/api/users/1\u0026#34;))); verify(deleteRequestedFor(urlEqualTo(\u0026#34;/api/users/1\u0026#34;))); } @Test @DisplayName(\u0026#34;錯誤處理和重試機制\u0026#34;) void testErrorHandlingAndRetry() { // 模擬服務器錯誤，然後成功 stubFor(get(urlEqualTo(\u0026#34;/api/users/1\u0026#34;)) .inScenario(\u0026#34;Retry Scenario\u0026#34;) .whenScenarioStateIs(STARTED) .willSetStateTo(\u0026#34;First Attempt\u0026#34;) .willReturn(aResponse().withStatus(500))); stubFor(get(urlEqualTo(\u0026#34;/api/users/1\u0026#34;)) .inScenario(\u0026#34;Retry Scenario\u0026#34;) .whenScenarioStateIs(\u0026#34;First Attempt\u0026#34;) .willSetStateTo(\u0026#34;Second Attempt\u0026#34;) .willReturn(aResponse().withStatus(500))); stubFor(get(urlEqualTo(\u0026#34;/api/users/1\u0026#34;)) .inScenario(\u0026#34;Retry Scenario\u0026#34;) .whenScenarioStateIs(\u0026#34;Second Attempt\u0026#34;) .willReturn(aResponse() .withStatus(200) .withHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .withBody(\u0026#34;{\\\u0026#34;id\\\u0026#34;:1,\\\u0026#34;email\\\u0026#34;:\\\u0026#34;test@example.com\\\u0026#34;}\u0026#34;))); // 執行測試 User user = restClientService.getUserById(1L); assertThat(user.getId()).isEqualTo(1L); // 驗證重試了 3 次 verify(3, getRequestedFor(urlEqualTo(\u0026#34;/api/users/1\u0026#34;))); } } 現代化替代方案 1. WebClient 遷移指南 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /** * WebClient 遷移範例 */ @Service public class ModernRestClientService { private final WebClient webClient; public ModernRestClientService(WebClient.Builder webClientBuilder) { this.webClient = webClientBuilder .baseUrl(\u0026#34;https://api.example.com\u0026#34;) .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .build(); } /** * 異步 GET 請求 */ public Mono\u0026lt;User\u0026gt; getUserByIdAsync(Long userId) { return webClient.get() .uri(\u0026#34;/users/{id}\u0026#34;, userId) .retrieve() .bodyToMono(User.class); } /** * 響應式 POST 請求 */ public Mono\u0026lt;User\u0026gt; createUserAsync(User newUser) { return webClient.post() .uri(\u0026#34;/users\u0026#34;) .bodyValue(newUser) .retrieve() .bodyToMono(User.class); } /** * 錯誤處理 */ public Mono\u0026lt;User\u0026gt; getUserWithErrorHandling(Long userId) { return webClient.get() .uri(\u0026#34;/users/{id}\u0026#34;, userId) .retrieve() .onStatus(HttpStatus::is4xxClientError, response -\u0026gt; Mono.error(new NotFoundException(\u0026#34;User not found\u0026#34;))) .onStatus(HttpStatus::is5xxServerError, response -\u0026gt; Mono.error(new ServerErrorException(\u0026#34;Server error\u0026#34;))) .bodyToMono(User.class); } /** * 流式處理 */ public Flux\u0026lt;User\u0026gt; getAllUsersStream() { return webClient.get() .uri(\u0026#34;/users/stream\u0026#34;) .retrieve() .bodyToFlux(User.class); } } 2. RestTemplate vs WebClient 對比 特性 RestTemplate WebClient API 風格 同步阻塞 異步非阻塞 響應式支援 不支援 完整支援 效能 中等 高 記憶體使用 較高 較低 背壓處理 不支援 支援 Spring 5+ 支援 維護模式 主推方案 學習曲線 較低 較高 最佳實踐與建議 1. 配置最佳實踐 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 /** * RestTemplate 最佳實踐配置 */ @Configuration public class RestTemplateBestPractices { /** * 生產環境推薦配置 */ @Bean @Primary public RestTemplate productionRestTemplate() { // 1. 使用連接池 PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(); connectionManager.setMaxTotal(200); connectionManager.setDefaultMaxPerRoute(50); connectionManager.setValidateAfterInactivity(2000); // 2. 配置超時 RequestConfig requestConfig = RequestConfig.custom() .setConnectionRequestTimeout(5000) .setConnectTimeout(5000) .setSocketTimeout(30000) .build(); // 3. 配置重試 HttpRequestRetryHandler retryHandler = new DefaultHttpRequestRetryHandler(3, true); // 4. 配置 Keep-Alive ConnectionKeepAliveStrategy keepAliveStrategy = (response, context) -\u0026gt; 30 * 1000; CloseableHttpClient httpClient = HttpClients.custom() .setConnectionManager(connectionManager) .setDefaultRequestConfig(requestConfig) .setRetryHandler(retryHandler) .setKeepAliveStrategy(keepAliveStrategy) .build(); HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(httpClient); RestTemplate restTemplate = new RestTemplate(factory); // 5. 添加攔截器 restTemplate.setInterceptors(Arrays.asList( new LoggingInterceptor(), new MetricsInterceptor(meterRegistry), new AuthenticationInterceptor(tokenService) )); // 6. 設置錯誤處理器 restTemplate.setErrorHandler(new CustomResponseErrorHandler()); return restTemplate; } /** * 常見錯誤和解決方案 */ public void demonstrateCommonPitfalls() { // ❌ 錯誤：未設置超時 RestTemplate badTemplate = new RestTemplate(); // ✅ 正確：設置合理的超時 SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); factory.setConnectTimeout(5000); factory.setReadTimeout(30000); RestTemplate goodTemplate = new RestTemplate(factory); // ❌ 錯誤：未使用連接池 // 每次請求都創建新連接 // ✅ 正確：使用連接池復用連接 // 見上面的生產環境配置 // ❌ 錯誤：未處理異常 try { String result = badTemplate.getForObject(\u0026#34;http://api.example.com/data\u0026#34;, String.class); } catch (Exception e) { // 直接忽略異常 } // ✅ 正確：適當的異常處理 try { String result = goodTemplate.getForObject(\u0026#34;http://api.example.com/data\u0026#34;, String.class); } catch (ResourceAccessException e) { logger.error(\u0026#34;Network error\u0026#34;, e); throw new ServiceUnavailableException(\u0026#34;Service temporarily unavailable\u0026#34;); } catch (HttpClientErrorException e) { logger.error(\u0026#34;Client error: {}\u0026#34;, e.getStatusCode(), e); throw new BadRequestException(\u0026#34;Invalid request\u0026#34;); } } } 2. 安全性考量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 /** * RestTemplate 安全配置 */ @Configuration public class SecureRestTemplateConfig { /** * HTTPS 配置 */ @Bean public RestTemplate secureRestTemplate() throws Exception { TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -\u0026gt; true; SSLContext sslContext = org.apache.http.ssl.SSLContexts.custom() .loadTrustMaterial(null, acceptingTrustStrategy) .build(); SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext); CloseableHttpClient httpClient = HttpClients.custom() .setSSLSocketFactory(csf) .build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(); requestFactory.setHttpClient(httpClient); return new RestTemplate(requestFactory); } /** * 認證配置 */ @Component public class SecureAuthInterceptor implements ClientHttpRequestInterceptor { @Override public ClientHttpResponse intercept( HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { // 1. 添加 API Key request.getHeaders().set(\u0026#34;X-API-Key\u0026#34;, getApiKey()); // 2. 添加請求簽名 String signature = generateSignature(request, body); request.getHeaders().set(\u0026#34;X-Signature\u0026#34;, signature); // 3. 添加時間戳防重放 request.getHeaders().set(\u0026#34;X-Timestamp\u0026#34;, String.valueOf(System.currentTimeMillis())); return execution.execute(request, body); } private String getApiKey() { // 從安全配置中獲取 API Key return securityConfig.getApiKey(); } private String generateSignature(HttpRequest request, byte[] body) { // 實作請求簽名邏輯 return hmacSha256(request.getURI() + new String(body), getSecretKey()); } } } 總結 RestTemplate 作為 Spring 生態系統中的經典 HTTP 客戶端，提供了豐富的功能和良好的擴展性：\n主要優勢 簡單易用：直觀的 API 設計，易於上手 功能完整：支援所有 HTTP 方法和豐富的配置選項 Spring 整合：與 Spring 框架完美整合 擴展性好：支援攔截器、錯誤處理器等擴展機制 穩定成熟：經過長期驗證，穩定可靠 適用場景 傳統 Spring 應用：非響應式應用的 HTTP 客戶端需求 微服務通信：服務間的同步調用 第三方 API 整合：調用外部 REST API 遺留系統維護：現有系統的維護和升級 遷移建議 雖然 RestTemplate 在維護模式，但對於以下情況建議遷移到 WebClient：\n新項目開發：使用 WebClient 獲得更好的效能 高並發需求：WebClient 的非阻塞特性更適合 響應式程式設計：需要響應式流的場景 效能敏感：對效能有較高要求的應用 通過合理的配置和最佳實踐，RestTemplate 仍然是一個可靠的 HTTP 客戶端選擇，特別是在現有項目的維護和漸進式升級場景中。\n","permalink":"https://xinqilin.github.io/post/backend/resttemplate/","tags":["Spring","RestTemplate","HTTP Client","WebClient","REST API","Microservices","Error Handling","Testing","Performance"],"title":"Spring RestTemplate 完整實戰指南：HTTP 客戶端最佳實踐"},{"content":"前言 在現代軟體開發中，設定檔是不可或缺的一環。從 Java 的 Spring Boot 框架 (Spring MVC 過往使用大量的 XML)，到我目前使用的 Hugo 靜態網站產生器，都能看到 .properties、.yml 或 .toml 等格式的身影。\n雖然這些格式各有優勢，但在雲原生領域，特別是設定 Kubernetes (K8s) 資源時，YAML (YAML Ain\u0026rsquo;t Markup Language) 已成為事實上的標準。因此，掌握 YAML 的語法至關重要。\n核心語法 YAML 的設計目標是易於人類閱讀和撰寫。它的語法主要基於縮排和幾個簡單的符號。\n註解: 使用 # 號標示單行註解。 文件開頭: 使用三個連字號 --- 作為文件的開始符號 (選用)。 鍵值對 (Key-Value Pair) YAML 的基本組成單位是鍵值對，格式為 key: value (注意冒號後面需要一個空格)。\n1 apiVersion: v1 階層/物件 (Objects) 透過換行和縮排 (建議使用兩個空格) 來表示階層關係。這在 JSON 中相當於一個物件。\n以下範例等同於 spring.datasource.username = \u0026quot;root\u0026quot;。\n1 2 3 spring: datasource: username: root 陣列/列表 (Arrays/Lists) 陣列有兩種常見的表示方式：\n塊序列 (Block Sequence): 透過換行、縮排，並在每個元素前加上 - (連字號 + 空格) 來表示。這種形式更易讀，且元素可以是複雜的物件。\n1 2 3 args: - \u0026#34;parameter1\u0026#34; - \u0026#34;parameter2\u0026#34; 流序列 (Flow Sequence): 將所有元素放在方括號 [] 中，並用逗號分隔。適合表示簡單的一維陣列。\n1 2 items: [1, 2, 3, 4, 5] args: [\u0026#34;parameter1\u0026#34;, \u0026#34;parameter2\u0026#34;] 綜合範例 讓我們來看一個更完整的範例，這個範例來自 CloudBees YAML Tutorial。\nYAML 格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --- doe: \u0026#34;a deer, a female deer\u0026#34; ray: \u0026#34;a drop of golden sun\u0026#34; pi: 3.14159 xmas: true french-hens: 3 calling-birds: - huey - dewey - louie - fred xmas-fifth-day: calling-birds: four french-hens: 3 golden-rings: 5 partridges: count: 1 location: \u0026#34;a pear tree\u0026#34; turtle-doves: two 等效的 JSON 格式 這個 YAML 結構可以完全對應到以下的 JSON 物件，展示了其清晰的資料表達能力。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \u0026#34;doe\u0026#34;: \u0026#34;a deer, a female deer\u0026#34;, \u0026#34;ray\u0026#34;: \u0026#34;a drop of golden sun\u0026#34;, \u0026#34;pi\u0026#34;: 3.14159, \u0026#34;xmas\u0026#34;: true, \u0026#34;french-hens\u0026#34;: 3, \u0026#34;calling-birds\u0026#34;: [ \u0026#34;huey\u0026#34;, \u0026#34;dewey\u0026#34;, \u0026#34;louie\u0026#34;, \u0026#34;fred\u0026#34; ], \u0026#34;xmas-fifth-day\u0026#34;: { \u0026#34;calling-birds\u0026#34;: \u0026#34;four\u0026#34;, \u0026#34;french-hens\u0026#34;: 3, \u0026#34;golden-rings\u0026#34;: 5, \u0026#34;partridges\u0026#34;: { \u0026#34;count\u0026#34;: 1, \u0026#34;location\u0026#34;: \u0026#34;a pear tree\u0026#34; }, \u0026#34;turtle-doves\u0026#34;: \u0026#34;two\u0026#34; } } 參考資料 CloudBees YAML Tutorial 菜鳥教程 - YAML 簡介 ","permalink":"https://xinqilin.github.io/post/tools/yaml/","tags":["YAML","Configuration","Kubernetes","Spring Boot","DevOps"],"title":"YAML 語法從入門到實踐"},{"content":"MergeSort Time complexity = log n * O(n) = O(n logn)\nMergeSort 套一句柯P 講的話，小問題解決了，就沒有大問題了\n將 n 個個數的陣列，先左右各切一半，一直切，切到最小單位後，開始拿兩條被切的單位做排序、合併 ! 合久必分，分久必合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import java.util.*; public class MergeSort { public static void mergeSort(int[] array) { int[] workArray = new int[array.length]; Sort(array, workArray, 0, array.length - 1); } private static void Sort(int[] array, int[] workArray, int start, int end) { if (start \u0026gt;= end) return; //避免溢位 start + end 可能超出去 int mid = start + (end - start)/2; Sort(array, workArray, start, mid); Sort(array, workArray, mid+1, end); Merge(array, workArray, start, mid, mid+1, end); } private static void Merge(int[] array, int[] workArray, int leftStart, int leftEnd, int rightStart, int rightEnd) { int leftPtr = leftStart, rightPtr = rightStart, index = leftStart; while (leftPtr \u0026lt;= leftEnd || rightPtr \u0026lt;= rightEnd) { if (leftPtr \u0026lt;= leftEnd \u0026amp;\u0026amp; rightPtr \u0026lt;= rightEnd) { //最後一排 if (array[rightPtr] \u0026lt; array[leftPtr]) workArray[index] = array[rightPtr++]; else workArray[index] = array[leftPtr++]; } else if (leftPtr \u0026lt;= leftEnd){ // 左邊排序 workArray[index] = array[leftPtr++]; }else{ // 右邊排序 workArray[index] = array[rightPtr++]; } ++index; } for (int i = leftStart; i \u0026lt; index; i++) array[i] = workArray[i]; } public static void main(String[] args) { int[] data = new int[10]; for (int i = 0; i \u0026lt; data.length; i++) { data[i] = (int) (Math.random() * 100); } System.out.println(\u0026#34;before: \u0026#34; + Arrays.toString(data)); mergeSort(data); System.out.println(\u0026#34;after: \u0026#34; + Arrays.toString(data)); } } ![MergeSortResult](images/Algorithm/mergeSort/mergeSortResult.png) 演算法序列，會用來記錄算法，再用自己或其他人寫的 code 我能吸收的做紀錄，目的是讓自己能多看，然後背起來\n","permalink":"https://xinqilin.github.io/post/algorithm/mergesort/","tags":["Java","Algorithm"],"title":"MergeSort"},{"content":"CQRS (Command Query Responsibility Segregation) 完整實作指南 模式概述 CQRS (Command Query Responsibility Segregation，命令查詢職責分離) 是一種架構模式，將讀取操作（Query）和寫入操作（Command）分離到不同的模型中。這種分離允許每個模型針對其特定用途進行優化，提高系統的擴展性和性能。\n核心概念 1. CQS 原則基礎 CQS (Command Query Separation) 原則是 CQRS 的理論基礎：\nCommand（命令）：\n會對系統產生影響的動作 改變系統狀態 不回傳結果（void） 具有副作用 Query（查詢）：\n不會對系統產生影響的動作 不改變系統狀態 回傳結果 無副作用 2. CQRS 擴展 CQRS 將 CQS 原則從方法級別擴展到架構級別：\n寫入模型（Write Model）：專注於業務邏輯和數據一致性 讀取模型（Read Model）：專注於查詢性能和數據展示 分離的數據存儲：不同的存儲可以針對讀寫操作進行優化 傳統 CQRS 實現 1. 基本架構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 // 命令接口 public interface Command { // 命令標記接口 } // 查詢接口 public interface Query\u0026lt;T\u0026gt; { // 查詢標記接口 } // 命令處理器接口 public interface CommandHandler\u0026lt;T extends Command\u0026gt; { void handle(T command); } // 查詢處理器接口 public interface QueryHandler\u0026lt;T extends Query\u0026lt;R\u0026gt;, R\u0026gt; { R handle(T query); } // 命令總線 @Component public class CommandBus { private final Map\u0026lt;Class\u0026lt;? extends Command\u0026gt;, CommandHandler\u0026lt;? extends Command\u0026gt;\u0026gt; handlers; public CommandBus(List\u0026lt;CommandHandler\u0026lt;? extends Command\u0026gt;\u0026gt; handlerList) { this.handlers = handlerList.stream() .collect(Collectors.toMap( this::getCommandType, Function.identity() )); } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T extends Command\u0026gt; void send(T command) { CommandHandler\u0026lt;T\u0026gt; handler = (CommandHandler\u0026lt;T\u0026gt;) handlers.get(command.getClass()); if (handler == null) { throw new IllegalArgumentException(\u0026#34;未找到命令處理器: \u0026#34; + command.getClass()); } handler.handle(command); } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private Class\u0026lt;? extends Command\u0026gt; getCommandType(CommandHandler\u0026lt;? extends Command\u0026gt; handler) { return (Class\u0026lt;? extends Command\u0026gt;) ((ParameterizedType) handler.getClass() .getGenericInterfaces()[0]).getActualTypeArguments()[0]; } } // 查詢總線 @Component public class QueryBus { private final Map\u0026lt;Class\u0026lt;? extends Query\u0026lt;?\u0026gt;\u0026gt;, QueryHandler\u0026lt;? extends Query\u0026lt;?\u0026gt;, ?\u0026gt;\u0026gt; handlers; public QueryBus(List\u0026lt;QueryHandler\u0026lt;? extends Query\u0026lt;?\u0026gt;, ?\u0026gt;\u0026gt; handlerList) { this.handlers = handlerList.stream() .collect(Collectors.toMap( this::getQueryType, Function.identity() )); } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T extends Query\u0026lt;R\u0026gt;, R\u0026gt; R send(T query) { QueryHandler\u0026lt;T, R\u0026gt; handler = (QueryHandler\u0026lt;T, R\u0026gt;) handlers.get(query.getClass()); if (handler == null) { throw new IllegalArgumentException(\u0026#34;未找到查詢處理器: \u0026#34; + query.getClass()); } return handler.handle(query); } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private Class\u0026lt;? extends Query\u0026lt;?\u0026gt;\u0026gt; getQueryType(QueryHandler\u0026lt;? extends Query\u0026lt;?\u0026gt;, ?\u0026gt; handler) { return (Class\u0026lt;? extends Query\u0026lt;?\u0026gt;\u0026gt;) ((ParameterizedType) handler.getClass() .getGenericInterfaces()[0]).getActualTypeArguments()[0]; } } 2. 用戶管理系統示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 // 用戶實體（寫入模型） @Entity @Table(name = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String username; @Column(nullable = false) private String password; @Column(nullable = false) private String email; @Enumerated(EnumType.STRING) private UserStatus status; @CreationTimestamp private LocalDateTime createdAt; @UpdateTimestamp private LocalDateTime updatedAt; // 業務方法 public void activate() { this.status = UserStatus.ACTIVE; } public void deactivate() { this.status = UserStatus.INACTIVE; } public void updatePassword(String newPassword) { this.password = newPassword; } // 構造函數、getter、setter 略 } // 用戶狀態枚舉 public enum UserStatus { ACTIVE, INACTIVE, PENDING, BANNED } // 用戶讀取模型 @Document(collection = \u0026#34;user_views\u0026#34;) public class UserView { @Id private String id; private Long userId; private String username; private String email; private String status; private String createdAt; private String updatedAt; private int totalOrders; private BigDecimal totalSpent; private String lastLoginAt; // 構造函數、getter、setter 略 } // 創建用戶命令 public class CreateUserCommand implements Command { private final String username; private final String password; private final String email; public CreateUserCommand(String username, String password, String email) { this.username = username; this.password = password; this.email = email; } // Getter 方法 public String getUsername() { return username; } public String getPassword() { return password; } public String getEmail() { return email; } } // 更新用戶命令 public class UpdateUserCommand implements Command { private final Long userId; private final String email; private final UserStatus status; public UpdateUserCommand(Long userId, String email, UserStatus status) { this.userId = userId; this.email = email; this.status = status; } // Getter 方法 public Long getUserId() { return userId; } public String getEmail() { return email; } public UserStatus getStatus() { return status; } } // 用戶查詢 public class GetUserQuery implements Query\u0026lt;UserView\u0026gt; { private final Long userId; public GetUserQuery(Long userId) { this.userId = userId; } public Long getUserId() { return userId; } } // 用戶列表查詢 public class GetUserListQuery implements Query\u0026lt;Page\u0026lt;UserView\u0026gt;\u0026gt; { private final String username; private final UserStatus status; private final Pageable pageable; public GetUserListQuery(String username, UserStatus status, Pageable pageable) { this.username = username; this.status = status; this.pageable = pageable; } // Getter 方法 public String getUsername() { return username; } public UserStatus getStatus() { return status; } public Pageable getPageable() { return pageable; } } // 創建用戶命令處理器 @Component public class CreateUserCommandHandler implements CommandHandler\u0026lt;CreateUserCommand\u0026gt; { private final UserRepository userRepository; private final PasswordEncoder passwordEncoder; private final ApplicationEventPublisher eventPublisher; public CreateUserCommandHandler(UserRepository userRepository, PasswordEncoder passwordEncoder, ApplicationEventPublisher eventPublisher) { this.userRepository = userRepository; this.passwordEncoder = passwordEncoder; this.eventPublisher = eventPublisher; } @Override @Transactional public void handle(CreateUserCommand command) { // 驗證用戶名是否已存在 if (userRepository.existsByUsername(command.getUsername())) { throw new IllegalArgumentException(\u0026#34;用戶名已存在: \u0026#34; + command.getUsername()); } // 創建用戶 User user = new User(); user.setUsername(command.getUsername()); user.setPassword(passwordEncoder.encode(command.getPassword())); user.setEmail(command.getEmail()); user.setStatus(UserStatus.ACTIVE); User savedUser = userRepository.save(user); // 發布事件 eventPublisher.publishEvent(new UserCreatedEvent(savedUser.getId(), savedUser.getUsername(), savedUser.getEmail())); } } // 更新用戶命令處理器 @Component public class UpdateUserCommandHandler implements CommandHandler\u0026lt;UpdateUserCommand\u0026gt; { private final UserRepository userRepository; private final ApplicationEventPublisher eventPublisher; public UpdateUserCommandHandler(UserRepository userRepository, ApplicationEventPublisher eventPublisher) { this.userRepository = userRepository; this.eventPublisher = eventPublisher; } @Override @Transactional public void handle(UpdateUserCommand command) { User user = userRepository.findById(command.getUserId()) .orElseThrow(() -\u0026gt; new IllegalArgumentException(\u0026#34;用戶不存在: \u0026#34; + command.getUserId())); // 更新用戶信息 if (command.getEmail() != null) { user.setEmail(command.getEmail()); } if (command.getStatus() != null) { user.setStatus(command.getStatus()); } userRepository.save(user); // 發布事件 eventPublisher.publishEvent(new UserUpdatedEvent(user.getId(), user.getUsername(), user.getEmail(), user.getStatus())); } } // 用戶查詢處理器 @Component public class GetUserQueryHandler implements QueryHandler\u0026lt;GetUserQuery, UserView\u0026gt; { private final UserViewRepository userViewRepository; public GetUserQueryHandler(UserViewRepository userViewRepository) { this.userViewRepository = userViewRepository; } @Override public UserView handle(GetUserQuery query) { return userViewRepository.findByUserId(query.getUserId()) .orElseThrow(() -\u0026gt; new IllegalArgumentException(\u0026#34;用戶不存在: \u0026#34; + query.getUserId())); } } // 用戶列表查詢處理器 @Component public class GetUserListQueryHandler implements QueryHandler\u0026lt;GetUserListQuery, Page\u0026lt;UserView\u0026gt;\u0026gt; { private final UserViewRepository userViewRepository; public GetUserListQueryHandler(UserViewRepository userViewRepository) { this.userViewRepository = userViewRepository; } @Override public Page\u0026lt;UserView\u0026gt; handle(GetUserListQuery query) { return userViewRepository.findByFilters( query.getUsername(), query.getStatus(), query.getPageable() ); } } 3. 事件驅動架構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // 用戶創建事件 public class UserCreatedEvent { private final Long userId; private final String username; private final String email; private final LocalDateTime occurredAt; public UserCreatedEvent(Long userId, String username, String email) { this.userId = userId; this.username = username; this.email = email; this.occurredAt = LocalDateTime.now(); } // Getter 方法 public Long getUserId() { return userId; } public String getUsername() { return username; } public String getEmail() { return email; } public LocalDateTime getOccurredAt() { return occurredAt; } } // 用戶更新事件 public class UserUpdatedEvent { private final Long userId; private final String username; private final String email; private final UserStatus status; private final LocalDateTime occurredAt; public UserUpdatedEvent(Long userId, String username, String email, UserStatus status) { this.userId = userId; this.username = username; this.email = email; this.status = status; this.occurredAt = LocalDateTime.now(); } // Getter 方法 public Long getUserId() { return userId; } public String getUsername() { return username; } public String getEmail() { return email; } public UserStatus getStatus() { return status; } public LocalDateTime getOccurredAt() { return occurredAt; } } // 讀取模型投影處理器 @Component public class UserViewProjectionHandler { private final UserViewRepository userViewRepository; public UserViewProjectionHandler(UserViewRepository userViewRepository) { this.userViewRepository = userViewRepository; } @EventListener @Async public void handle(UserCreatedEvent event) { UserView userView = new UserView(); userView.setUserId(event.getUserId()); userView.setUsername(event.getUsername()); userView.setEmail(event.getEmail()); userView.setStatus(UserStatus.ACTIVE.name()); userView.setCreatedAt(event.getOccurredAt().toString()); userView.setUpdatedAt(event.getOccurredAt().toString()); userView.setTotalOrders(0); userView.setTotalSpent(BigDecimal.ZERO); userViewRepository.save(userView); } @EventListener @Async public void handle(UserUpdatedEvent event) { UserView userView = userViewRepository.findByUserId(event.getUserId()) .orElseThrow(() -\u0026gt; new IllegalStateException(\u0026#34;用戶視圖不存在: \u0026#34; + event.getUserId())); userView.setUsername(event.getUsername()); userView.setEmail(event.getEmail()); userView.setStatus(event.getStatus().name()); userView.setUpdatedAt(event.getOccurredAt().toString()); userViewRepository.save(userView); } } 事件溯源 (Event Sourcing) 整合 1. 事件存儲 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 // 事件基類 @MappedSuperclass public abstract class DomainEvent { private String eventId; private String aggregateId; private String eventType; private LocalDateTime occurredAt; private String userId; private long version; protected DomainEvent() { this.eventId = UUID.randomUUID().toString(); this.occurredAt = LocalDateTime.now(); } protected DomainEvent(String aggregateId, String eventType, String userId, long version) { this(); this.aggregateId = aggregateId; this.eventType = eventType; this.userId = userId; this.version = version; } // Getter 和 Setter 方法 public String getEventId() { return eventId; } public void setEventId(String eventId) { this.eventId = eventId; } public String getAggregateId() { return aggregateId; } public void setAggregateId(String aggregateId) { this.aggregateId = aggregateId; } public String getEventType() { return eventType; } public void setEventType(String eventType) { this.eventType = eventType; } public LocalDateTime getOccurredAt() { return occurredAt; } public void setOccurredAt(LocalDateTime occurredAt) { this.occurredAt = occurredAt; } public String getUserId() { return userId; } public void setUserId(String userId) { this.userId = userId; } public long getVersion() { return version; } public void setVersion(long version) { this.version = version; } } // 事件存儲實體 @Entity @Table(name = \u0026#34;event_store\u0026#34;) public class EventStore { @Id private String eventId; @Column(nullable = false) private String aggregateId; @Column(nullable = false) private String eventType; @Column(nullable = false, columnDefinition = \u0026#34;TEXT\u0026#34;) private String eventData; @Column(nullable = false) private LocalDateTime occurredAt; @Column private String userId; @Column(nullable = false) private long version; // 構造函數、getter、setter 略 } // 事件存儲倉庫 @Repository public interface EventStoreRepository extends JpaRepository\u0026lt;EventStore, String\u0026gt; { List\u0026lt;EventStore\u0026gt; findByAggregateIdOrderByVersionAsc(String aggregateId); List\u0026lt;EventStore\u0026gt; findByAggregateIdAndVersionGreaterThanOrderByVersionAsc(String aggregateId, long version); boolean existsByAggregateIdAndVersion(String aggregateId, long version); } // 事件存儲服務 @Service public class EventStoreService { private final EventStoreRepository eventStoreRepository; private final ObjectMapper objectMapper; public EventStoreService(EventStoreRepository eventStoreRepository, ObjectMapper objectMapper) { this.eventStoreRepository = eventStoreRepository; this.objectMapper = objectMapper; } public void saveEvent(DomainEvent event) { try { EventStore eventStore = new EventStore(); eventStore.setEventId(event.getEventId()); eventStore.setAggregateId(event.getAggregateId()); eventStore.setEventType(event.getEventType()); eventStore.setEventData(objectMapper.writeValueAsString(event)); eventStore.setOccurredAt(event.getOccurredAt()); eventStore.setUserId(event.getUserId()); eventStore.setVersion(event.getVersion()); eventStoreRepository.save(eventStore); } catch (JsonProcessingException e) { throw new RuntimeException(\u0026#34;事件序列化失敗\u0026#34;, e); } } public List\u0026lt;DomainEvent\u0026gt; getEvents(String aggregateId) { return eventStoreRepository.findByAggregateIdOrderByVersionAsc(aggregateId) .stream() .map(this::deserializeEvent) .collect(Collectors.toList()); } public List\u0026lt;DomainEvent\u0026gt; getEventsFromVersion(String aggregateId, long version) { return eventStoreRepository.findByAggregateIdAndVersionGreaterThanOrderByVersionAsc(aggregateId, version) .stream() .map(this::deserializeEvent) .collect(Collectors.toList()); } private DomainEvent deserializeEvent(EventStore eventStore) { try { Class\u0026lt;?\u0026gt; eventClass = Class.forName(eventStore.getEventType()); return (DomainEvent) objectMapper.readValue(eventStore.getEventData(), eventClass); } catch (Exception e) { throw new RuntimeException(\u0026#34;事件反序列化失敗\u0026#34;, e); } } } 2. 聚合根與事件溯源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 // 聚合根基類 public abstract class AggregateRoot { private String id; private long version; private final List\u0026lt;DomainEvent\u0026gt; uncommittedEvents = new ArrayList\u0026lt;\u0026gt;(); protected AggregateRoot() { this.id = UUID.randomUUID().toString(); this.version = 0; } protected AggregateRoot(String id) { this.id = id; this.version = 0; } protected void addEvent(DomainEvent event) { event.setAggregateId(this.id); event.setVersion(this.version + 1); this.uncommittedEvents.add(event); } public List\u0026lt;DomainEvent\u0026gt; getUncommittedEvents() { return new ArrayList\u0026lt;\u0026gt;(uncommittedEvents); } public void markEventsAsCommitted() { this.version += uncommittedEvents.size(); this.uncommittedEvents.clear(); } public void loadFromHistory(List\u0026lt;DomainEvent\u0026gt; events) { events.forEach(this::apply); this.version = events.size(); } protected abstract void apply(DomainEvent event); // Getter 和 Setter 方法 public String getId() { return id; } public long getVersion() { return version; } } // 用戶聚合根 public class UserAggregate extends AggregateRoot { private String username; private String email; private UserStatus status; private LocalDateTime createdAt; private LocalDateTime updatedAt; public UserAggregate() { super(); } public UserAggregate(String id) { super(id); } // 創建用戶 public static UserAggregate create(String username, String email, String userId) { UserAggregate user = new UserAggregate(); user.addEvent(new UserCreatedDomainEvent(user.getId(), username, email, userId)); return user; } // 更新用戶 public void updateUser(String email, UserStatus status, String userId) { if (!Objects.equals(this.email, email) || !Objects.equals(this.status, status)) { this.addEvent(new UserUpdatedDomainEvent(this.getId(), this.username, email, status, userId)); } } // 刪除用戶 public void deleteUser(String userId) { this.addEvent(new UserDeletedDomainEvent(this.getId(), this.username, userId)); } @Override protected void apply(DomainEvent event) { if (event instanceof UserCreatedDomainEvent) { apply((UserCreatedDomainEvent) event); } else if (event instanceof UserUpdatedDomainEvent) { apply((UserUpdatedDomainEvent) event); } else if (event instanceof UserDeletedDomainEvent) { apply((UserDeletedDomainEvent) event); } } private void apply(UserCreatedDomainEvent event) { this.username = event.getUsername(); this.email = event.getEmail(); this.status = UserStatus.ACTIVE; this.createdAt = event.getOccurredAt(); this.updatedAt = event.getOccurredAt(); } private void apply(UserUpdatedDomainEvent event) { this.username = event.getUsername(); this.email = event.getEmail(); this.status = event.getStatus(); this.updatedAt = event.getOccurredAt(); } private void apply(UserDeletedDomainEvent event) { this.status = UserStatus.INACTIVE; this.updatedAt = event.getOccurredAt(); } // Getter 方法 public String getUsername() { return username; } public String getEmail() { return email; } public UserStatus getStatus() { return status; } public LocalDateTime getCreatedAt() { return createdAt; } public LocalDateTime getUpdatedAt() { return updatedAt; } } // 用戶創建領域事件 public class UserCreatedDomainEvent extends DomainEvent { private String username; private String email; public UserCreatedDomainEvent() { super(); } public UserCreatedDomainEvent(String aggregateId, String username, String email, String userId) { super(aggregateId, \u0026#34;UserCreatedDomainEvent\u0026#34;, userId, 1); this.username = username; this.email = email; } // Getter 和 Setter 方法 public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } } // 用戶更新領域事件 public class UserUpdatedDomainEvent extends DomainEvent { private String username; private String email; private UserStatus status; public UserUpdatedDomainEvent() { super(); } public UserUpdatedDomainEvent(String aggregateId, String username, String email, UserStatus status, String userId) { super(aggregateId, \u0026#34;UserUpdatedDomainEvent\u0026#34;, userId, 1); this.username = username; this.email = email; this.status = status; } // Getter 和 Setter 方法 public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public UserStatus getStatus() { return status; } public void setStatus(UserStatus status) { this.status = status; } } // 用戶刪除領域事件 public class UserDeletedDomainEvent extends DomainEvent { private String username; public UserDeletedDomainEvent() { super(); } public UserDeletedDomainEvent(String aggregateId, String username, String userId) { super(aggregateId, \u0026#34;UserDeletedDomainEvent\u0026#34;, userId, 1); this.username = username; } // Getter 和 Setter 方法 public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } 企業級應用場景 1. 電商系統實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 // 訂單聚合根 public class OrderAggregate extends AggregateRoot { private String customerId; private List\u0026lt;OrderItem\u0026gt; items; private BigDecimal totalAmount; private OrderStatus status; private LocalDateTime createdAt; private LocalDateTime updatedAt; public OrderAggregate() { super(); this.items = new ArrayList\u0026lt;\u0026gt;(); this.totalAmount = BigDecimal.ZERO; this.status = OrderStatus.PENDING; } // 創建訂單 public static OrderAggregate create(String customerId, List\u0026lt;OrderItem\u0026gt; items, String userId) { OrderAggregate order = new OrderAggregate(); order.addEvent(new OrderCreatedDomainEvent(order.getId(), customerId, items, userId)); return order; } // 添加商品 public void addItem(OrderItem item, String userId) { this.addEvent(new OrderItemAddedDomainEvent(this.getId(), item, userId)); } // 確認訂單 public void confirm(String userId) { if (this.status != OrderStatus.PENDING) { throw new IllegalStateException(\u0026#34;只有待處理的訂單可以確認\u0026#34;); } this.addEvent(new OrderConfirmedDomainEvent(this.getId(), userId)); } // 取消訂單 public void cancel(String reason, String userId) { if (this.status == OrderStatus.SHIPPED || this.status == OrderStatus.DELIVERED) { throw new IllegalStateException(\u0026#34;已發貨或已送達的訂單不能取消\u0026#34;); } this.addEvent(new OrderCancelledDomainEvent(this.getId(), reason, userId)); } @Override protected void apply(DomainEvent event) { if (event instanceof OrderCreatedDomainEvent) { apply((OrderCreatedDomainEvent) event); } else if (event instanceof OrderItemAddedDomainEvent) { apply((OrderItemAddedDomainEvent) event); } else if (event instanceof OrderConfirmedDomainEvent) { apply((OrderConfirmedDomainEvent) event); } else if (event instanceof OrderCancelledDomainEvent) { apply((OrderCancelledDomainEvent) event); } } private void apply(OrderCreatedDomainEvent event) { this.customerId = event.getCustomerId(); this.items = new ArrayList\u0026lt;\u0026gt;(event.getItems()); this.totalAmount = calculateTotalAmount(); this.status = OrderStatus.PENDING; this.createdAt = event.getOccurredAt(); this.updatedAt = event.getOccurredAt(); } private void apply(OrderItemAddedDomainEvent event) { this.items.add(event.getItem()); this.totalAmount = calculateTotalAmount(); this.updatedAt = event.getOccurredAt(); } private void apply(OrderConfirmedDomainEvent event) { this.status = OrderStatus.CONFIRMED; this.updatedAt = event.getOccurredAt(); } private void apply(OrderCancelledDomainEvent event) { this.status = OrderStatus.CANCELLED; this.updatedAt = event.getOccurredAt(); } private BigDecimal calculateTotalAmount() { return items.stream() .map(item -\u0026gt; item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity()))) .reduce(BigDecimal.ZERO, BigDecimal::add); } // Getter 方法 public String getCustomerId() { return customerId; } public List\u0026lt;OrderItem\u0026gt; getItems() { return new ArrayList\u0026lt;\u0026gt;(items); } public BigDecimal getTotalAmount() { return totalAmount; } public OrderStatus getStatus() { return status; } public LocalDateTime getCreatedAt() { return createdAt; } public LocalDateTime getUpdatedAt() { return updatedAt; } } // 訂單項目 public class OrderItem { private String productId; private String productName; private int quantity; private BigDecimal price; public OrderItem(String productId, String productName, int quantity, BigDecimal price) { this.productId = productId; this.productName = productName; this.quantity = quantity; this.price = price; } // Getter 和 Setter 方法 public String getProductId() { return productId; } public void setProductId(String productId) { this.productId = productId; } public String getProductName() { return productName; } public void setProductName(String productName) { this.productName = productName; } public int getQuantity() { return quantity; } public void setQuantity(int quantity) { this.quantity = quantity; } public BigDecimal getPrice() { return price; } public void setPrice(BigDecimal price) { this.price = price; } } // 訂單狀態 public enum OrderStatus { PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED } // 訂單創建命令 public class CreateOrderCommand implements Command { private final String customerId; private final List\u0026lt;OrderItem\u0026gt; items; public CreateOrderCommand(String customerId, List\u0026lt;OrderItem\u0026gt; items) { this.customerId = customerId; this.items = items; } // Getter 方法 public String getCustomerId() { return customerId; } public List\u0026lt;OrderItem\u0026gt; getItems() { return items; } } // 訂單確認命令 public class ConfirmOrderCommand implements Command { private final String orderId; public ConfirmOrderCommand(String orderId) { this.orderId = orderId; } public String getOrderId() { return orderId; } } // 訂單查詢 public class GetOrderQuery implements Query\u0026lt;OrderView\u0026gt; { private final String orderId; public GetOrderQuery(String orderId) { this.orderId = orderId; } public String getOrderId() { return orderId; } } // 訂單視圖 @Document(collection = \u0026#34;order_views\u0026#34;) public class OrderView { @Id private String id; private String orderId; private String customerId; private String customerName; private List\u0026lt;OrderItemView\u0026gt; items; private BigDecimal totalAmount; private String status; private String createdAt; private String updatedAt; // 構造函數、getter、setter 略 } // 訂單項目視圖 public class OrderItemView { private String productId; private String productName; private int quantity; private BigDecimal price; private BigDecimal subtotal; // 構造函數、getter、setter 略 } 2. 庫存管理系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 // 庫存聚合根 public class InventoryAggregate extends AggregateRoot { private String productId; private int quantity; private int reservedQuantity; private LocalDateTime lastUpdated; public InventoryAggregate() { super(); } // 初始化庫存 public static InventoryAggregate initialize(String productId, int initialQuantity, String userId) { InventoryAggregate inventory = new InventoryAggregate(); inventory.addEvent(new InventoryInitializedDomainEvent(inventory.getId(), productId, initialQuantity, userId)); return inventory; } // 增加庫存 public void addStock(int quantity, String reason, String userId) { if (quantity \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;增加的庫存數量必須大於0\u0026#34;); } this.addEvent(new StockAddedDomainEvent(this.getId(), this.productId, quantity, reason, userId)); } // 預留庫存 public void reserveStock(int quantity, String orderId, String userId) { if (quantity \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;預留的庫存數量必須大於0\u0026#34;); } if (this.quantity - this.reservedQuantity \u0026lt; quantity) { throw new IllegalStateException(\u0026#34;可用庫存不足\u0026#34;); } this.addEvent(new StockReservedDomainEvent(this.getId(), this.productId, quantity, orderId, userId)); } // 確認庫存消耗 public void confirmStock(int quantity, String orderId, String userId) { if (quantity \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;確認的庫存數量必須大於0\u0026#34;); } if (this.reservedQuantity \u0026lt; quantity) { throw new IllegalStateException(\u0026#34;預留庫存不足\u0026#34;); } this.addEvent(new StockConfirmedDomainEvent(this.getId(), this.productId, quantity, orderId, userId)); } // 釋放預留庫存 public void releaseReservedStock(int quantity, String orderId, String userId) { if (quantity \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;釋放的庫存數量必須大於0\u0026#34;); } if (this.reservedQuantity \u0026lt; quantity) { throw new IllegalStateException(\u0026#34;預留庫存不足\u0026#34;); } this.addEvent(new StockReleasedDomainEvent(this.getId(), this.productId, quantity, orderId, userId)); } @Override protected void apply(DomainEvent event) { if (event instanceof InventoryInitializedDomainEvent) { apply((InventoryInitializedDomainEvent) event); } else if (event instanceof StockAddedDomainEvent) { apply((StockAddedDomainEvent) event); } else if (event instanceof StockReservedDomainEvent) { apply((StockReservedDomainEvent) event); } else if (event instanceof StockConfirmedDomainEvent) { apply((StockConfirmedDomainEvent) event); } else if (event instanceof StockReleasedDomainEvent) { apply((StockReleasedDomainEvent) event); } } private void apply(InventoryInitializedDomainEvent event) { this.productId = event.getProductId(); this.quantity = event.getInitialQuantity(); this.reservedQuantity = 0; this.lastUpdated = event.getOccurredAt(); } private void apply(StockAddedDomainEvent event) { this.quantity += event.getQuantity(); this.lastUpdated = event.getOccurredAt(); } private void apply(StockReservedDomainEvent event) { this.reservedQuantity += event.getQuantity(); this.lastUpdated = event.getOccurredAt(); } private void apply(StockConfirmedDomainEvent event) { this.quantity -= event.getQuantity(); this.reservedQuantity -= event.getQuantity(); this.lastUpdated = event.getOccurredAt(); } private void apply(StockReleasedDomainEvent event) { this.reservedQuantity -= event.getQuantity(); this.lastUpdated = event.getOccurredAt(); } // 計算可用庫存 public int getAvailableQuantity() { return quantity - reservedQuantity; } // Getter 方法 public String getProductId() { return productId; } public int getQuantity() { return quantity; } public int getReservedQuantity() { return reservedQuantity; } public LocalDateTime getLastUpdated() { return lastUpdated; } } // 庫存相關領域事件 public class InventoryInitializedDomainEvent extends DomainEvent { private String productId; private int initialQuantity; public InventoryInitializedDomainEvent() { super(); } public InventoryInitializedDomainEvent(String aggregateId, String productId, int initialQuantity, String userId) { super(aggregateId, \u0026#34;InventoryInitializedDomainEvent\u0026#34;, userId, 1); this.productId = productId; this.initialQuantity = initialQuantity; } // Getter 和 Setter 方法 public String getProductId() { return productId; } public void setProductId(String productId) { this.productId = productId; } public int getInitialQuantity() { return initialQuantity; } public void setInitialQuantity(int initialQuantity) { this.initialQuantity = initialQuantity; } } public class StockAddedDomainEvent extends DomainEvent { private String productId; private int quantity; private String reason; public StockAddedDomainEvent() { super(); } public StockAddedDomainEvent(String aggregateId, String productId, int quantity, String reason, String userId) { super(aggregateId, \u0026#34;StockAddedDomainEvent\u0026#34;, userId, 1); this.productId = productId; this.quantity = quantity; this.reason = reason; } // Getter 和 Setter 方法 public String getProductId() { return productId; } public void setProductId(String productId) { this.productId = productId; } public int getQuantity() { return quantity; } public void setQuantity(int quantity) { this.quantity = quantity; } public String getReason() { return reason; } public void setReason(String reason) { this.reason = reason; } } public class StockReservedDomainEvent extends DomainEvent { private String productId; private int quantity; private String orderId; public StockReservedDomainEvent() { super(); } public StockReservedDomainEvent(String aggregateId, String productId, int quantity, String orderId, String userId) { super(aggregateId, \u0026#34;StockReservedDomainEvent\u0026#34;, userId, 1); this.productId = productId; this.quantity = quantity; this.orderId = orderId; } // Getter 和 Setter 方法 public String getProductId() { return productId; } public void setProductId(String productId) { this.productId = productId; } public int getQuantity() { return quantity; } public void setQuantity(int quantity) { this.quantity = quantity; } public String getOrderId() { return orderId; } public void setOrderId(String orderId) { this.orderId = orderId; } } Spring Boot 整合 1. 配置類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @Configuration @EnableAsync @EnableJpaRepositories(basePackages = \u0026#34;com.example.repository\u0026#34;) @EnableMongoRepositories(basePackages = \u0026#34;com.example.readmodel.repository\u0026#34;) public class CqrsConfiguration { @Bean public ObjectMapper objectMapper() { ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(new JavaTimeModule()); mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); return mapper; } @Bean public ApplicationEventPublisher applicationEventPublisher(ApplicationContext context) { return context; } @Bean public TaskExecutor taskExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(5); executor.setMaxPoolSize(10); executor.setQueueCapacity(25); executor.setThreadNamePrefix(\u0026#34;cqrs-async-\u0026#34;); executor.initialize(); return executor; } } // 資料庫配置 @Configuration public class DatabaseConfiguration { @Primary @Bean @ConfigurationProperties(\u0026#34;spring.datasource\u0026#34;) public DataSource primaryDataSource() { return DataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(\u0026#34;spring.datasource.readonly\u0026#34;) public DataSource readOnlyDataSource() { return DataSourceBuilder.create().build(); } @Primary @Bean public JdbcTemplate primaryJdbcTemplate(@Qualifier(\u0026#34;primaryDataSource\u0026#34;) DataSource dataSource) { return new JdbcTemplate(dataSource); } @Bean public JdbcTemplate readOnlyJdbcTemplate(@Qualifier(\u0026#34;readOnlyDataSource\u0026#34;) DataSource dataSource) { return new JdbcTemplate(dataSource); } } 2. 控制器實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { private final CommandBus commandBus; private final QueryBus queryBus; public UserController(CommandBus commandBus, QueryBus queryBus) { this.commandBus = commandBus; this.queryBus = queryBus; } @PostMapping public ResponseEntity\u0026lt;ApiResponse\u0026lt;Void\u0026gt;\u0026gt; createUser(@RequestBody @Valid CreateUserRequest request) { try { CreateUserCommand command = new CreateUserCommand( request.getUsername(), request.getPassword(), request.getEmail() ); commandBus.send(command); return ResponseEntity.ok(ApiResponse.\u0026lt;Void\u0026gt;success() .message(\u0026#34;用戶創建成功\u0026#34;) .build()); } catch (Exception e) { return ResponseEntity.badRequest().body(ApiResponse.\u0026lt;Void\u0026gt;failure(\u0026#34;創建用戶失敗\u0026#34;) .error(e.getMessage()) .build()); } } @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;ApiResponse\u0026lt;UserView\u0026gt;\u0026gt; getUser(@PathVariable Long id) { try { GetUserQuery query = new GetUserQuery(id); UserView user = queryBus.send(query); return ResponseEntity.ok(ApiResponse.success(user) .message(\u0026#34;用戶查詢成功\u0026#34;) .build()); } catch (Exception e) { return ResponseEntity.notFound().build(); } } @GetMapping public ResponseEntity\u0026lt;ApiResponse\u0026lt;Page\u0026lt;UserView\u0026gt;\u0026gt;\u0026gt; getUsers( @RequestParam(required = false) String username, @RequestParam(required = false) UserStatus status, @PageableDefault(size = 20) Pageable pageable) { try { GetUserListQuery query = new GetUserListQuery(username, status, pageable); Page\u0026lt;UserView\u0026gt; users = queryBus.send(query); return ResponseEntity.ok(ApiResponse.success(users) .message(\u0026#34;用戶列表查詢成功\u0026#34;) .metadata(\u0026#34;total\u0026#34;, users.getTotalElements()) .metadata(\u0026#34;pages\u0026#34;, users.getTotalPages()) .build()); } catch (Exception e) { return ResponseEntity.badRequest().body(ApiResponse.\u0026lt;Page\u0026lt;UserView\u0026gt;\u0026gt;failure(\u0026#34;查詢用戶列表失敗\u0026#34;) .error(e.getMessage()) .build()); } } @PutMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;ApiResponse\u0026lt;Void\u0026gt;\u0026gt; updateUser(@PathVariable Long id, @RequestBody @Valid UpdateUserRequest request) { try { UpdateUserCommand command = new UpdateUserCommand(id, request.getEmail(), request.getStatus()); commandBus.send(command); return ResponseEntity.ok(ApiResponse.\u0026lt;Void\u0026gt;success() .message(\u0026#34;用戶更新成功\u0026#34;) .build()); } catch (Exception e) { return ResponseEntity.badRequest().body(ApiResponse.\u0026lt;Void\u0026gt;failure(\u0026#34;更新用戶失敗\u0026#34;) .error(e.getMessage()) .build()); } } } // 請求 DTO public class CreateUserRequest { @NotBlank(message = \u0026#34;用戶名不能為空\u0026#34;) private String username; @NotBlank(message = \u0026#34;密碼不能為空\u0026#34;) @Size(min = 6, message = \u0026#34;密碼長度至少6位\u0026#34;) private String password; @NotBlank(message = \u0026#34;郵箱不能為空\u0026#34;) @Email(message = \u0026#34;郵箱格式不正確\u0026#34;) private String email; // 構造函數、getter、setter 略 } public class UpdateUserRequest { @Email(message = \u0026#34;郵箱格式不正確\u0026#34;) private String email; private UserStatus status; // 構造函數、getter、setter 略 } 3. 測試實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 @SpringBootTest @Transactional class CqrsIntegrationTest { @Autowired private CommandBus commandBus; @Autowired private QueryBus queryBus; @Autowired private UserRepository userRepository; @Autowired private UserViewRepository userViewRepository; @Test void testCreateAndQueryUser() { // Given CreateUserCommand command = new CreateUserCommand(\u0026#34;testuser\u0026#34;, \u0026#34;password123\u0026#34;, \u0026#34;test@example.com\u0026#34;); // When commandBus.send(command); // Then // 驗證寫入模型 Optional\u0026lt;User\u0026gt; user = userRepository.findByUsername(\u0026#34;testuser\u0026#34;); assertThat(user).isPresent(); assertThat(user.get().getEmail()).isEqualTo(\u0026#34;test@example.com\u0026#34;); assertThat(user.get().getStatus()).isEqualTo(UserStatus.ACTIVE); // 等待異步投影完成 await().atMost(5, TimeUnit.SECONDS).until(() -\u0026gt; { return userViewRepository.findByUserId(user.get().getId()).isPresent(); }); // 驗證讀取模型 GetUserQuery query = new GetUserQuery(user.get().getId()); UserView userView = queryBus.send(query); assertThat(userView.getUsername()).isEqualTo(\u0026#34;testuser\u0026#34;); assertThat(userView.getEmail()).isEqualTo(\u0026#34;test@example.com\u0026#34;); assertThat(userView.getStatus()).isEqualTo(UserStatus.ACTIVE.name()); } @Test void testUpdateUser() { // Given User user = createTestUser(); // When UpdateUserCommand command = new UpdateUserCommand(user.getId(), \u0026#34;updated@example.com\u0026#34;, UserStatus.INACTIVE); commandBus.send(command); // Then User updatedUser = userRepository.findById(user.getId()).orElseThrow(); assertThat(updatedUser.getEmail()).isEqualTo(\u0026#34;updated@example.com\u0026#34;); assertThat(updatedUser.getStatus()).isEqualTo(UserStatus.INACTIVE); // 驗證讀取模型最終一致性 await().atMost(5, TimeUnit.SECONDS).until(() -\u0026gt; { UserView userView = userViewRepository.findByUserId(user.getId()).orElse(null); return userView != null \u0026amp;\u0026amp; \u0026#34;updated@example.com\u0026#34;.equals(userView.getEmail()) \u0026amp;\u0026amp; UserStatus.INACTIVE.name().equals(userView.getStatus()); }); } @Test void testUserListQuery() { // Given createTestUser(\u0026#34;user1\u0026#34;, \u0026#34;user1@example.com\u0026#34;, UserStatus.ACTIVE); createTestUser(\u0026#34;user2\u0026#34;, \u0026#34;user2@example.com\u0026#34;, UserStatus.INACTIVE); // When GetUserListQuery query = new GetUserListQuery(null, UserStatus.ACTIVE, PageRequest.of(0, 10)); Page\u0026lt;UserView\u0026gt; result = queryBus.send(query); // Then assertThat(result.getContent()).hasSize(1); assertThat(result.getContent().get(0).getUsername()).isEqualTo(\u0026#34;user1\u0026#34;); assertThat(result.getContent().get(0).getStatus()).isEqualTo(UserStatus.ACTIVE.name()); } private User createTestUser() { return createTestUser(\u0026#34;testuser\u0026#34;, \u0026#34;test@example.com\u0026#34;, UserStatus.ACTIVE); } private User createTestUser(String username, String email, UserStatus status) { User user = new User(); user.setUsername(username); user.setPassword(\u0026#34;password123\u0026#34;); user.setEmail(email); user.setStatus(status); return userRepository.save(user); } } @WebMvcTest(UserController.class) class UserControllerTest { @Autowired private MockMvc mockMvc; @MockBean private CommandBus commandBus; @MockBean private QueryBus queryBus; @Test void testCreateUser() throws Exception { // Given CreateUserRequest request = new CreateUserRequest(\u0026#34;testuser\u0026#34;, \u0026#34;password123\u0026#34;, \u0026#34;test@example.com\u0026#34;); // When \u0026amp; Then mockMvc.perform(post(\u0026#34;/api/users\u0026#34;) .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(request))) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.success\u0026#34;).value(true)) .andExpect(jsonPath(\u0026#34;$.message\u0026#34;).value(\u0026#34;用戶創建成功\u0026#34;)); verify(commandBus).send(any(CreateUserCommand.class)); } @Test void testGetUser() throws Exception { // Given UserView userView = new UserView(); userView.setUserId(1L); userView.setUsername(\u0026#34;testuser\u0026#34;); userView.setEmail(\u0026#34;test@example.com\u0026#34;); userView.setStatus(UserStatus.ACTIVE.name()); when(queryBus.send(any(GetUserQuery.class))).thenReturn(userView); // When \u0026amp; Then mockMvc.perform(get(\u0026#34;/api/users/1\u0026#34;)) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.success\u0026#34;).value(true)) .andExpect(jsonPath(\u0026#34;$.data.username\u0026#34;).value(\u0026#34;testuser\u0026#34;)) .andExpect(jsonPath(\u0026#34;$.data.email\u0026#34;).value(\u0026#34;test@example.com\u0026#34;)); verify(queryBus).send(any(GetUserQuery.class)); } } 性能優化與最佳實踐 1. 事件處理優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 // 批量事件處理 @Component public class BatchEventProcessor { private final List\u0026lt;DomainEvent\u0026gt; eventBatch = new ArrayList\u0026lt;\u0026gt;(); private final Object lock = new Object(); @Value(\u0026#34;${cqrs.event.batch.size:100}\u0026#34;) private int batchSize; @Value(\u0026#34;${cqrs.event.batch.timeout:5000}\u0026#34;) private long batchTimeout; @Autowired private EventStoreService eventStoreService; @Autowired private ApplicationEventPublisher eventPublisher; @PostConstruct public void initialize() { // 定期刷新批次 ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); scheduler.scheduleAtFixedRate(this::flushBatch, batchTimeout, batchTimeout, TimeUnit.MILLISECONDS); } public void addEvent(DomainEvent event) { synchronized (lock) { eventBatch.add(event); if (eventBatch.size() \u0026gt;= batchSize) { flushBatch(); } } } private void flushBatch() { List\u0026lt;DomainEvent\u0026gt; toProcess; synchronized (lock) { if (eventBatch.isEmpty()) { return; } toProcess = new ArrayList\u0026lt;\u0026gt;(eventBatch); eventBatch.clear(); } // 批量保存事件 toProcess.forEach(eventStoreService::saveEvent); // 批量發布事件 toProcess.forEach(eventPublisher::publishEvent); } } // 異步事件處理 @Component public class AsyncEventHandler { private final ThreadPoolTaskExecutor executor; public AsyncEventHandler() { this.executor = new ThreadPoolTaskExecutor(); this.executor.setCorePoolSize(5); this.executor.setMaxPoolSize(20); this.executor.setQueueCapacity(100); this.executor.setThreadNamePrefix(\u0026#34;async-event-\u0026#34;); this.executor.initialize(); } @EventListener public void handleUserCreated(UserCreatedEvent event) { executor.submit(() -\u0026gt; { try { // 異步處理用戶創建事件 processUserCreatedEvent(event); } catch (Exception e) { // 錯誤處理和重試邏輯 handleEventProcessingError(event, e); } }); } private void processUserCreatedEvent(UserCreatedEvent event) { // 具體的事件處理邏輯 updateUserView(event); sendWelcomeEmail(event); updateStatistics(event); } private void handleEventProcessingError(Object event, Exception e) { // 實現錯誤處理和重試邏輯 log.error(\u0026#34;事件處理失敗: \u0026#34; + event.getClass().getSimpleName(), e); } } 2. 讀寫分離優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // 讀寫分離路由 @Component public class DatabaseRouter { private final DataSource writeDataSource; private final DataSource readDataSource; public DatabaseRouter(@Qualifier(\u0026#34;writeDataSource\u0026#34;) DataSource writeDataSource, @Qualifier(\u0026#34;readDataSource\u0026#34;) DataSource readDataSource) { this.writeDataSource = writeDataSource; this.readDataSource = readDataSource; } public DataSource getDataSource(boolean isWrite) { return isWrite ? writeDataSource : readDataSource; } } // 動態數據源切換 @Component public class DynamicDataSourceContextHolder { private static final ThreadLocal\u0026lt;Boolean\u0026gt; contextHolder = new ThreadLocal\u0026lt;\u0026gt;(); public static void setWriteDataSource() { contextHolder.set(true); } public static void setReadDataSource() { contextHolder.set(false); } public static boolean isWriteDataSource() { return Boolean.TRUE.equals(contextHolder.get()); } public static void clearDataSourceType() { contextHolder.remove(); } } // 讀寫分離攔截器 @Component public class ReadWriteSplittingInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { String method = request.getMethod(); if (\u0026#34;GET\u0026#34;.equals(method)) { DynamicDataSourceContextHolder.setReadDataSource(); } else { DynamicDataSourceContextHolder.setWriteDataSource(); } return true; } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { DynamicDataSourceContextHolder.clearDataSourceType(); } } 監控與診斷 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // CQRS 監控 @Component public class CqrsMonitor { private final MeterRegistry meterRegistry; private final Counter commandCounter; private final Counter queryCounter; private final Timer commandTimer; private final Timer queryTimer; public CqrsMonitor(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; this.commandCounter = Counter.builder(\u0026#34;cqrs.commands\u0026#34;) .description(\u0026#34;Total number of commands processed\u0026#34;) .register(meterRegistry); this.queryCounter = Counter.builder(\u0026#34;cqrs.queries\u0026#34;) .description(\u0026#34;Total number of queries processed\u0026#34;) .register(meterRegistry); this.commandTimer = Timer.builder(\u0026#34;cqrs.command.duration\u0026#34;) .description(\u0026#34;Command processing time\u0026#34;) .register(meterRegistry); this.queryTimer = Timer.builder(\u0026#34;cqrs.query.duration\u0026#34;) .description(\u0026#34;Query processing time\u0026#34;) .register(meterRegistry); } public \u0026lt;T extends Command\u0026gt; void recordCommand(T command, Runnable execution) { commandCounter.increment(Tags.of(\u0026#34;type\u0026#34;, command.getClass().getSimpleName())); commandTimer.recordCallable(() -\u0026gt; { execution.run(); return null; }); } public \u0026lt;T extends Query\u0026lt;R\u0026gt;, R\u0026gt; R recordQuery(T query, Supplier\u0026lt;R\u0026gt; execution) { queryCounter.increment(Tags.of(\u0026#34;type\u0026#34;, query.getClass().getSimpleName())); return queryTimer.recordCallable(execution::get); } } // 事件存儲監控 @Component public class EventStoreMonitor { private final MeterRegistry meterRegistry; private final Counter eventsSaved; private final Counter eventsLoaded; private final Timer saveTimer; private final Timer loadTimer; public EventStoreMonitor(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; this.eventsSaved = Counter.builder(\u0026#34;eventstore.events.saved\u0026#34;) .description(\u0026#34;Number of events saved to event store\u0026#34;) .register(meterRegistry); this.eventsLoaded = Counter.builder(\u0026#34;eventstore.events.loaded\u0026#34;) .description(\u0026#34;Number of events loaded from event store\u0026#34;) .register(meterRegistry); this.saveTimer = Timer.builder(\u0026#34;eventstore.save.duration\u0026#34;) .description(\u0026#34;Time taken to save events\u0026#34;) .register(meterRegistry); this.loadTimer = Timer.builder(\u0026#34;eventstore.load.duration\u0026#34;) .description(\u0026#34;Time taken to load events\u0026#34;) .register(meterRegistry); } public void recordEventSaved(String eventType) { eventsSaved.increment(Tags.of(\u0026#34;type\u0026#34;, eventType)); } public void recordEventLoaded(String eventType) { eventsLoaded.increment(Tags.of(\u0026#34;type\u0026#34;, eventType)); } public \u0026lt;T\u0026gt; T recordSaveOperation(Supplier\u0026lt;T\u0026gt; operation) { return saveTimer.recordCallable(operation::get); } public \u0026lt;T\u0026gt; T recordLoadOperation(Supplier\u0026lt;T\u0026gt; operation) { return loadTimer.recordCallable(operation::get); } } 總結 CQRS 是一種強大的架構模式，特別適用於：\n高併發系統：分離讀寫操作，提高系統並發能力 複雜業務邏輯：將複雜的業務邏輯與查詢邏輯分離 事件驅動架構：與事件溯源結合，構建事件驅動的系統 可擴展系統：支持讀寫模型的獨立擴展 關鍵最佳實踐 事件設計：設計清晰的事件結構和事件版本控制 最終一致性：接受並處理最終一致性的挑戰 監控告警：實施完善的監控和告警機制 錯誤處理：設計健壯的錯誤處理和重試機制 性能優化：實施讀寫分離、批量處理等優化策略 測試策略：建立全面的測試策略，包括事件重播測試 CQRS 結合事件溯源為企業級應用提供了強大的架構基礎，能夠有效處理複雜的業務場景和高並發需求。正確實施 CQRS 可以大幅提升系統的可維護性、可擴展性和性能。\n","permalink":"https://xinqilin.github.io/post/architecture/cqrs/","tags":["Architecture","CQRS","Command Query Responsibility Segregation","Event Sourcing","Microservices","Domain-Driven Design","Spring Boot","Enterprise Architecture","Scalability","Performance","Event-Driven Architecture","Eventual Consistency","Read Write Separation"],"title":"CQRS (Command Query Responsibility Segregation) 完整實作指南：命令與查詢職責分離的企業架構模式"},{"content":"概述 在 Java 程式開發中，經常需要對 Map 集合按照 Value 值進行排序。Map 本身並不保證元素的順序，因此需要採用特定的技術來實現按 Value 排序。本文將深入介紹多種實作方式，並分析其效能特徵和適用場景。\n核心概念 Map 排序特性：Map 接口本身不提供排序功能 排序策略：通過轉換為 List 或使用 Stream API 實現 排序穩定性：保持相等元素的相對順序 效能考量：時間複雜度和空間複雜度的權衡 常見應用場景 統計排名：字頻統計、用戶評分排序 資料分析：銷售數據排序、效能指標排名 快取管理：LRU 快取的熱點資料排序 搜尋結果：相關性得分排序 實作方法一：Collections.sort + Map.Entry 1. 基礎實作 這是最傳統且直觀的方法，通過將 Map 的 entrySet 轉換為 List 進行排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package com.example.sorting; import java.util.*; import java.util.stream.Collectors; public class MapSortingExample { public static void main(String[] args) { // 創建測試資料 Map\u0026lt;String, Integer\u0026gt; wordFrequency = createSampleData(); // 方法一：使用 Collections.sort 排序 Map\u0026lt;String, Integer\u0026gt; sortedByValue = sortByValueUsingCollections(wordFrequency); System.out.println(\u0026#34;排序結果: \u0026#34; + sortedByValue); } /** * 使用 Collections.sort 按 Value 排序（降序） */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValueUsingCollections(Map\u0026lt;K, V\u0026gt; map) { // 將 Map 的 entrySet 轉換為 List List\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(map.entrySet()); // 使用 Collections.sort 排序 Collections.sort(list, new Comparator\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt;() { @Override public int compare(Map.Entry\u0026lt;K, V\u0026gt; entry1, Map.Entry\u0026lt;K, V\u0026gt; entry2) { // 降序排列：entry2 - entry1 return entry2.getValue().compareTo(entry1.getValue()); } }); // 將排序後的結果放入 LinkedHashMap 保持順序 Map\u0026lt;K, V\u0026gt; sortedMap = new LinkedHashMap\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;K, V\u0026gt; entry : list) { sortedMap.put(entry.getKey(), entry.getValue()); } return sortedMap; } /** * 創建測試資料 */ private static Map\u0026lt;String, Integer\u0026gt; createSampleData() { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;apple\u0026#34;, 10); map.put(\u0026#34;banana\u0026#34;, 25); map.put(\u0026#34;cherry\u0026#34;, 5); map.put(\u0026#34;date\u0026#34;, 15); map.put(\u0026#34;elderberry\u0026#34;, 30); return map; } } 2. Lambda 表達式簡化版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** * 使用 Lambda 表達式簡化比較器 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValueWithLambda(Map\u0026lt;K, V\u0026gt; map) { List\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(map.entrySet()); // Lambda 表達式簡化比較器 Collections.sort(list, (entry1, entry2) -\u0026gt; entry2.getValue().compareTo(entry1.getValue()) ); Map\u0026lt;K, V\u0026gt; sortedMap = new LinkedHashMap\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;K, V\u0026gt; entry : list) { sortedMap.put(entry.getKey(), entry.getValue()); } return sortedMap; } /** * 更簡潔的 Lambda 版本，支援升序/降序 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValue( Map\u0026lt;K, V\u0026gt; map, boolean ascending) { List\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(map.entrySet()); if (ascending) { Collections.sort(list, Map.Entry.comparingByValue()); } else { Collections.sort(list, Map.Entry.\u0026lt;K, V\u0026gt;comparingByValue().reversed()); } return list.stream() .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } 實作方法二：Stream API 1. 基礎 Stream 排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * 使用 Stream API 進行排序 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValueUsingStream( Map\u0026lt;K, V\u0026gt; map, boolean ascending) { return map.entrySet() .stream() .sorted(ascending ? Map.Entry.comparingByValue() : Map.Entry.\u0026lt;K, V\u0026gt;comparingByValue().reversed()) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } /** * 支援自訂比較器的 Stream 排序 */ public static \u0026lt;K, V\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValueWithCustomComparator( Map\u0026lt;K, V\u0026gt; map, Comparator\u0026lt;V\u0026gt; valueComparator) { return map.entrySet() .stream() .sorted(Map.Entry.comparingByValue(valueComparator)) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } 2. 並行 Stream 排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * 使用並行 Stream 提升大資料集的排序效能 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValueParallel( Map\u0026lt;K, V\u0026gt; map, boolean ascending) { return map.entrySet() .parallelStream() .sorted(ascending ? Map.Entry.comparingByValue() : Map.Entry.\u0026lt;K, V\u0026gt;comparingByValue().reversed()) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } 實作方法三：使用 TreeMap 1. Value-to-Key 反轉策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 /** * 使用 TreeMap 實現按 Value 排序 * 注意：此方法適用於 Value 值唯一的情況 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValueUsingTreeMap(Map\u0026lt;K, V\u0026gt; map) { // 創建一個以 Value 為 Key 的 TreeMap TreeMap\u0026lt;V, K\u0026gt; reversedMap = new TreeMap\u0026lt;\u0026gt;(Collections.reverseOrder()); for (Map.Entry\u0026lt;K, V\u0026gt; entry : map.entrySet()) { reversedMap.put(entry.getValue(), entry.getKey()); } // 重新構建原始格式的 Map Map\u0026lt;K, V\u0026gt; sortedMap = new LinkedHashMap\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;V, K\u0026gt; entry : reversedMap.entrySet()) { sortedMap.put(entry.getValue(), entry.getKey()); } return sortedMap; } /** * 處理重複 Value 的 TreeMap 排序 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValueWithDuplicates(Map\u0026lt;K, V\u0026gt; map) { // 使用 TreeMap，Key 為複合鍵：Value + 原始Key TreeMap\u0026lt;String, Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; sortedTreeMap = new TreeMap\u0026lt;\u0026gt;((key1, key2) -\u0026gt; { String[] parts1 = key1.split(\u0026#34;###\u0026#34;); String[] parts2 = key2.split(\u0026#34;###\u0026#34;); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value1 = (V) parts1[0]; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value2 = (V) parts2[0]; int valueComparison = value2.compareTo(value1); // 降序 if (valueComparison != 0) { return valueComparison; } return parts1[1].compareTo(parts2[1]); // 按原始 Key 排序 }); for (Map.Entry\u0026lt;K, V\u0026gt; entry : map.entrySet()) { String compositeKey = entry.getValue() + \u0026#34;###\u0026#34; + entry.getKey(); sortedTreeMap.put(compositeKey, entry); } Map\u0026lt;K, V\u0026gt; result = new LinkedHashMap\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;K, V\u0026gt; entry : sortedTreeMap.values()) { result.put(entry.getKey(), entry.getValue()); } return result; } 實作方法四：Key List 排序 1. 基於 Key 的間接排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * 通過排序 Key 列表實現間接排序 * 適用於需要保留原始 Map 的場景 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; List\u0026lt;K\u0026gt; sortKeysByValue( Map\u0026lt;K, V\u0026gt; map, boolean ascending) { List\u0026lt;K\u0026gt; keys = new ArrayList\u0026lt;\u0026gt;(map.keySet()); Collections.sort(keys, (key1, key2) -\u0026gt; { V value1 = map.get(key1); V value2 = map.get(key2); if (ascending) { return value1.compareTo(value2); } else { return value2.compareTo(value1); } }); return keys; } /** * 使用排序後的 Key 列表創建新的有序 Map */ public static \u0026lt;K, V\u0026gt; Map\u0026lt;K, V\u0026gt; createSortedMapFromKeys(Map\u0026lt;K, V\u0026gt; originalMap, List\u0026lt;K\u0026gt; sortedKeys) { Map\u0026lt;K, V\u0026gt; sortedMap = new LinkedHashMap\u0026lt;\u0026gt;(); for (K key : sortedKeys) { sortedMap.put(key, originalMap.get(key)); } return sortedMap; } 複雜排序場景 1. 多級排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 多級排序：先按 Value 排序，Value 相同時按 Key 排序 */ public static \u0026lt;K extends Comparable\u0026lt;K\u0026gt;, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; multiLevelSort(Map\u0026lt;K, V\u0026gt; map) { return map.entrySet() .stream() .sorted(Map.Entry.\u0026lt;K, V\u0026gt;comparingByValue().reversed() .thenComparing(Map.Entry.comparingByKey())) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } 2. 自訂物件排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * 自訂物件作為 Value 的排序 */ public static class ScoreData implements Comparable\u0026lt;ScoreData\u0026gt; { private final int score; private final String level; public ScoreData(int score, String level) { this.score = score; this.level = level; } @Override public int compareTo(ScoreData other) { int scoreComparison = Integer.compare(other.score, this.score); // 分數降序 if (scoreComparison != 0) { return scoreComparison; } return this.level.compareTo(other.level); // 等級升序 } // getter, setter, toString 方法 public int getScore() { return score; } public String getLevel() { return level; } @Override public String toString() { return String.format(\u0026#34;ScoreData{score=%d, level=\u0026#39;%s\u0026#39;}\u0026#34;, score, level); } } /** * 排序包含自訂物件的 Map */ public static Map\u0026lt;String, ScoreData\u0026gt; sortByScoreData(Map\u0026lt;String, ScoreData\u0026gt; map) { return map.entrySet() .stream() .sorted(Map.Entry.comparingByValue()) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } 效能分析與比較 1. 效能測試框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package com.example.performance; import java.util.*; import java.util.concurrent.TimeUnit; public class MapSortingPerformanceTest { private static final int[] DATA_SIZES = {1000, 10000, 100000, 1000000}; public static void main(String[] args) { System.out.println(\u0026#34;Map Sorting Performance Comparison\u0026#34;); System.out.println(\u0026#34;=====================================\u0026#34;); for (int size : DATA_SIZES) { System.out.printf(\u0026#34;\\nTesting with %d elements:\\n\u0026#34;, size); Map\u0026lt;String, Integer\u0026gt; testData = generateTestData(size); runPerformanceTest(\u0026#34;Collections.sort\u0026#34;, testData, MapSortingExample::sortByValueUsingCollections); runPerformanceTest(\u0026#34;Stream API\u0026#34;, testData, map -\u0026gt; sortByValueUsingStream(map, false)); runPerformanceTest(\u0026#34;Parallel Stream\u0026#34;, testData, map -\u0026gt; sortByValueParallel(map, false)); } } private static void runPerformanceTest(String method, Map\u0026lt;String, Integer\u0026gt; data, SortingFunction\u0026lt;String, Integer\u0026gt; sortFunction) { // 預熱 for (int i = 0; i \u0026lt; 3; i++) { sortFunction.sort(new HashMap\u0026lt;\u0026gt;(data)); } // 正式測試 long startTime = System.nanoTime(); Map\u0026lt;String, Integer\u0026gt; result = sortFunction.sort(new HashMap\u0026lt;\u0026gt;(data)); long endTime = System.nanoTime(); long duration = TimeUnit.NANOSECONDS.toMillis(endTime - startTime); System.out.printf(\u0026#34; %-15s: %4d ms (result size: %d)\\n\u0026#34;, method, duration, result.size()); } private static Map\u0026lt;String, Integer\u0026gt; generateTestData(int size) { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Random random = new Random(42); // 固定種子確保可重現性 for (int i = 0; i \u0026lt; size; i++) { String key = \u0026#34;key\u0026#34; + i; Integer value = random.nextInt(1000); map.put(key, value); } return map; } @FunctionalInterface interface SortingFunction\u0026lt;K, V\u0026gt; { Map\u0026lt;K, V\u0026gt; sort(Map\u0026lt;K, V\u0026gt; map); } } 2. 效能分析結果 方法 時間複雜度 空間複雜度 適用場景 Collections.sort O(n log n) O(n) 小到中型資料集，需要穩定排序 Stream API O(n log n) O(n) 函數式程式設計風格，程式碼簡潔 Parallel Stream O(n log n) O(n) 大型資料集，多核心處理器 TreeMap 反轉 O(n log n) O(n) Value 值唯一，需要持續有序 3. 記憶體使用分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 記憶體使用監控工具 */ public class MemoryAnalyzer { public static void analyzeMemoryUsage(String testName, Runnable test) { System.gc(); // 建議垃圾回收 Runtime runtime = Runtime.getRuntime(); long beforeMemory = runtime.totalMemory() - runtime.freeMemory(); test.run(); long afterMemory = runtime.totalMemory() - runtime.freeMemory(); long memoryUsed = afterMemory - beforeMemory; System.out.printf(\u0026#34;%s - Memory used: %.2f MB\\n\u0026#34;, testName, memoryUsed / (1024.0 * 1024.0)); } } 實際應用範例 1. 字頻統計和排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * 文本字頻統計與排序應用 */ public class WordFrequencyAnalyzer { /** * 統計文本中的字頻並排序 */ public static Map\u0026lt;String, Integer\u0026gt; analyzeWordFrequency(String text, int topN) { // 文本預處理和字頻統計 Map\u0026lt;String, Integer\u0026gt; wordCount = Arrays.stream(text.toLowerCase() .replaceAll(\u0026#34;[^a-zA-Z\\\\s]\u0026#34;, \u0026#34;\u0026#34;) .split(\u0026#34;\\\\s+\u0026#34;)) .filter(word -\u0026gt; !word.isEmpty()) .collect(Collectors.toMap( word -\u0026gt; word, word -\u0026gt; 1, Integer::sum, HashMap::new )); // 按頻率排序並取前 N 個 return wordCount.entrySet() .stream() .sorted(Map.Entry.\u0026lt;String, Integer\u0026gt;comparingByValue().reversed()) .limit(topN) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } public static void main(String[] args) { String sampleText = \u0026#34;The quick brown fox jumps over the lazy dog. \u0026#34; + \u0026#34;The dog was really lazy and the fox was very quick.\u0026#34;; Map\u0026lt;String, Integer\u0026gt; topWords = analyzeWordFrequency(sampleText, 5); System.out.println(\u0026#34;Top 5 most frequent words:\u0026#34;); topWords.forEach((word, count) -\u0026gt; System.out.printf(\u0026#34; %s: %d times\\n\u0026#34;, word, count)); } } 2. 使用者評分排序系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /** * 使用者評分排序系統 */ public class UserRatingSystem { public static class UserRating { private final String userId; private final double averageRating; private final int totalReviews; public UserRating(String userId, double averageRating, int totalReviews) { this.userId = userId; this.averageRating = averageRating; this.totalReviews = totalReviews; } public double getWeightedScore() { // 加權評分：考慮評論數量 return averageRating * Math.log(totalReviews + 1); } // getter 方法 public String getUserId() { return userId; } public double getAverageRating() { return averageRating; } public int getTotalReviews() { return totalReviews; } @Override public String toString() { return String.format(\u0026#34;UserRating{userId=\u0026#39;%s\u0026#39;, avgRating=%.2f, reviews=%d, weighted=%.2f}\u0026#34;, userId, averageRating, totalReviews, getWeightedScore()); } } /** * 根據加權評分排序用戶 */ public static Map\u0026lt;String, UserRating\u0026gt; sortUsersByRating(Map\u0026lt;String, UserRating\u0026gt; users) { return users.entrySet() .stream() .sorted(Map.Entry.\u0026lt;String, UserRating\u0026gt;comparingByValue( (r1, r2) -\u0026gt; Double.compare(r2.getWeightedScore(), r1.getWeightedScore()))) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } public static void main(String[] args) { Map\u0026lt;String, UserRating\u0026gt; users = new HashMap\u0026lt;\u0026gt;(); users.put(\u0026#34;user1\u0026#34;, new UserRating(\u0026#34;user1\u0026#34;, 4.5, 100)); users.put(\u0026#34;user2\u0026#34;, new UserRating(\u0026#34;user2\u0026#34;, 4.8, 50)); users.put(\u0026#34;user3\u0026#34;, new UserRating(\u0026#34;user3\u0026#34;, 4.2, 200)); users.put(\u0026#34;user4\u0026#34;, new UserRating(\u0026#34;user4\u0026#34;, 4.9, 25)); Map\u0026lt;String, UserRating\u0026gt; sortedUsers = sortUsersByRating(users); System.out.println(\u0026#34;Users sorted by weighted rating:\u0026#34;); sortedUsers.values().forEach(System.out::println); } } 最佳實踐與建議 1. 選擇合適的排序方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * 排序方法選擇指南 */ public class SortingMethodSelector { /** * 根據資料特徵選擇最佳排序方法 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; smartSort( Map\u0026lt;K, V\u0026gt; map, SortingContext context) { int size = map.size(); // 小資料集：使用 Collections.sort if (size \u0026lt; 1000) { return sortByValueUsingCollections(map); } // 大資料集且有多核心：使用並行 Stream if (size \u0026gt; 100000 \u0026amp;\u0026amp; context.isParallelProcessingAvailable()) { return sortByValueParallel(map, context.isAscending()); } // 中等資料集：使用 Stream API return sortByValueUsingStream(map, context.isAscending()); } public static class SortingContext { private final boolean ascending; private final boolean parallelProcessingAvailable; public SortingContext(boolean ascending, boolean parallelProcessingAvailable) { this.ascending = ascending; this.parallelProcessingAvailable = parallelProcessingAvailable; } public boolean isAscending() { return ascending; } public boolean isParallelProcessingAvailable() { return parallelProcessingAvailable; } } } 2. 避免常見陷阱 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * 常見錯誤和解決方案 */ public class CommonPitfalls { /** * 錯誤：使用 HashMap 儲存排序結果（會丟失順序） */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; wrongApproach(Map\u0026lt;K, V\u0026gt; map) { // ❌ 錯誤：HashMap 不保證順序 return map.entrySet() .stream() .sorted(Map.Entry.comparingByValue()) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, HashMap::new // ❌ 這裡應該使用 LinkedHashMap )); } /** * 正確：使用 LinkedHashMap 保持順序 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; correctApproach(Map\u0026lt;K, V\u0026gt; map) { // ✅ 正確：LinkedHashMap 保持插入順序 return map.entrySet() .stream() .sorted(Map.Entry.comparingByValue()) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new // ✅ 正確 )); } /** * 處理 null 值的排序 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortWithNulls(Map\u0026lt;K, V\u0026gt; map) { return map.entrySet() .stream() .sorted(Map.Entry.comparingByValue( Comparator.nullsLast(Comparator.naturalOrder()))) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } } 3. 執行緒安全考量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * 執行緒安全的 Map 排序 */ public class ThreadSafeSorting { /** * 對 ConcurrentHashMap 進行安全排序 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortConcurrentMap( ConcurrentHashMap\u0026lt;K, V\u0026gt; concurrentMap) { // 創建快照避免併發修改 Map\u0026lt;K, V\u0026gt; snapshot = new HashMap\u0026lt;\u0026gt;(concurrentMap); return snapshot.entrySet() .stream() .sorted(Map.Entry.comparingByValue()) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } /** * 返回執行緒安全的排序結果 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortAndMakeThreadSafe(Map\u0026lt;K, V\u0026gt; map) { Map\u0026lt;K, V\u0026gt; sortedMap = sortByValueUsingStream(map, false); return Collections.synchronizedMap(sortedMap); } } 總結 Map 按 Value 排序是 Java 開發中的常見需求，本文介紹了四種主要實作方法：\nCollections.sort：傳統方法，適合小到中型資料集 Stream API：現代函數式方法，程式碼簡潔易讀 Parallel Stream：適合大型資料集的並行處理 TreeMap 策略：適合特殊場景，如 Value 唯一的情況 選擇建議 小資料集（\u0026lt; 1000）：使用 Collections.sort 中等資料集（1000-100000）：使用 Stream API 大資料集（\u0026gt; 100000）：使用 Parallel Stream 需要持續有序：考慮使用 TreeMap 或 LinkedHashMap 函數式程式設計：優先選擇 Stream API 關鍵要點 保持順序：使用 LinkedHashMap 儲存排序結果 效能考量：根據資料大小選擇合適的方法 執行緒安全：併發環境下注意同步問題 null 處理：使用 Comparator.nullsLast() 處理 null 值 記憶體管理：大資料集時注意記憶體使用 通過掌握這些技術和最佳實踐，您可以在各種場景下高效地實現 Map 按 Value 排序功能。\n","permalink":"https://xinqilin.github.io/post/backend/map-sort-by-value/","tags":["Java","Map","Sorting","Collections","Stream API","Performance","Lambda","TreeMap","LinkedHashMap","Comparator"],"title":"Java Map 按 Value 排序：完整實作與效能優化指南"},{"content":"Git tag\n1 2 3 4 5 6 7 8 9 git tag deploy/{env_name}/{feature_name} git push origin deploy/{env_name}/{feature_name} git tag -d/--delete deploy/{env_name}/{feature_name} git push origin --delete deploy/{env_name}/{feature_name} git push origin :{tagname} git describe --always HEAD remote info\n1 2 git remote show origin ","permalink":"https://xinqilin.github.io/post/tools/git/","tags":[],"title":"Git"},{"content":"概述 dig（Domain Information Groper）是一個功能強大的命令行 DNS 查詢工具，用於執行 DNS 查詢並顯示詳細的查詢結果。它是網路管理員、系統管理員和開發者進行 DNS 診斷、網路故障排除和域名解析分析的必備工具。\n核心特徵 靈活的查詢選項：支援各種 DNS 記錄類型查詢 詳細的輸出資訊：提供完整的 DNS 響應詳情 多種輸出格式：支援簡潔、詳細和自訂格式 強大的診斷功能：追蹤查詢路徑和效能分析 腳本友好：適合自動化和批次處理 安裝與環境準備 各系統安裝方法 1 2 3 4 5 6 7 8 9 10 11 12 # Ubuntu/Debian sudo apt-get install dnsutils # CentOS/RHEL/Fedora sudo yum install bind-utils # CentOS 7 及以下 sudo dnf install bind-utils # Fedora/CentOS 8+ # macOS (通常已預裝) brew install bind # 驗證安裝 dig -v 基本語法 1 dig [@server] [domain] [type] [options] 基本使用 簡單 DNS 查詢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 基本查詢（A 記錄） dig google.com # 指定記錄類型 dig google.com A dig google.com AAAA dig google.com MX dig google.com NS dig google.com TXT # 簡潔輸出 dig google.com +short # 只顯示答案部分 dig google.com +noall +answer 查詢結果解析 標準 dig 輸出包含以下部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 dig www.google.com ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.16.1 \u0026lt;\u0026lt;\u0026gt;\u0026gt; www.google.com ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 12345 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: # 查詢問題 ;www.google.com. IN A ;; ANSWER SECTION: # 查詢答案 www.google.com. 299 IN A 142.250.191.68 ;; Query time: 15 msec # 查詢時間 ;; SERVER: 8.8.8.8#53(8.8.8.8) # DNS 伺服器 ;; WHEN: Mon Jan 08 21:40:50 CST 2024 ;; MSG SIZE rcvd: 59 # 響應大小 DNS 記錄類型查詢 A 和 AAAA 記錄 1 2 3 4 5 6 7 8 9 10 # IPv4 地址記錄（A） dig example.com A dig example.com A +short # IPv6 地址記錄（AAAA） dig example.com AAAA dig example.com AAAA +short # 同時查詢 A 和 AAAA dig example.com A AAAA MX 記錄（郵件交換） 1 2 3 4 5 6 7 8 9 # 查詢郵件伺服器 dig google.com MX dig google.com MX +short # 查詢特定域名的郵件配置 dig gmail.com MX +noall +answer # 顯示優先級和郵件伺服器 dig yahoo.com MX | grep -E \u0026#34;^[^;].*MX\u0026#34; NS 記錄（名稱伺服器） 1 2 3 4 5 6 7 8 9 # 查詢域名伺服器 dig google.com NS dig google.com NS +short # 查詢根域名伺服器 dig . NS +short # 查詢特定 TLD 的名稱伺服器 dig com NS +short TXT 記錄（文本記錄） 1 2 3 4 5 6 7 8 9 10 11 12 # 查詢 TXT 記錄 dig google.com TXT dig google.com TXT +short # 查詢 SPF 記錄 dig _spf.google.com TXT # 查詢 DKIM 記錄 dig selector1._domainkey.example.com TXT # 查詢 DMARC 記錄 dig _dmarc.example.com TXT SOA 記錄（授權起始） 1 2 3 4 5 6 # 查詢 SOA 記錄 dig google.com SOA dig google.com SOA +short # 詳細 SOA 信息 dig google.com SOA +noall +answer +multiline CNAME 記錄（別名） 1 2 3 4 5 6 # 查詢 CNAME 記錄 dig www.github.com CNAME dig www.github.com CNAME +short # 追蹤 CNAME 鏈 dig www.example.com +trace PTR 記錄（反向查詢） 1 2 3 4 5 6 7 8 9 # 反向 DNS 查詢 dig -x 8.8.8.8 dig -x 8.8.8.8 +short # 手動 PTR 查詢 dig 8.8.8.8.in-addr.arpa PTR # IPv6 反向查詢 dig -x 2001:4860:4860::8888 進階查詢選項 指定 DNS 伺服器 1 2 3 4 5 6 7 8 9 10 # 使用 Google DNS dig @8.8.8.8 google.com # 使用 Cloudflare DNS dig @1.1.1.1 google.com # 使用多個 DNS 伺服器比較 dig @8.8.8.8 google.com +short dig @1.1.1.1 google.com +short dig @208.67.222.222 google.com +short # OpenDNS 查詢追蹤 1 2 3 4 5 6 7 8 9 10 11 # 追蹤 DNS 解析路徑 dig google.com +trace # 追蹤特定記錄類型 dig google.com MX +trace # 簡化追蹤輸出 dig google.com +trace +short # 追蹤並顯示所有步驟 dig google.com +trace +additional +all 輸出格式控制 1 2 3 4 5 6 7 8 9 10 11 12 # 簡潔輸出 dig google.com +short dig google.com +noall +answer # 多行格式化輸出 dig google.com SOA +multiline # 隱藏特定部分 dig google.com +nocomments +noquestion +noauthority +noadditional +nostats # 自訂輸出組合 dig google.com +nocmd +noall +answer +multiline 網路診斷與故障排除 DNS 效能測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 測量查詢時間 dig google.com | grep \u0026#34;Query time\u0026#34; # 批次效能測試 for i in {1..10}; do dig google.com +stats | grep \u0026#34;Query time\u0026#34; done # 比較不同 DNS 伺服器效能 dns_servers=(\u0026#34;8.8.8.8\u0026#34; \u0026#34;1.1.1.1\u0026#34; \u0026#34;208.67.222.222\u0026#34;) for server in \u0026#34;${dns_servers[@]}\u0026#34;; do echo \u0026#34;Testing $server:\u0026#34; dig @$server google.com +stats | grep \u0026#34;Query time\u0026#34; done DNS 快取分析 1 2 3 4 5 6 7 8 # 檢查 TTL 值 dig google.com +noall +answer # 監控 TTL 變化 watch -n 5 \u0026#39;dig google.com +noall +answer\u0026#39; # 檢查快取狀態 dig google.com +norecurse 域名可用性檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 檢查域名是否存在 dig example.com ANY +short # 檢查域名狀態 dig example.com +short \u0026gt; /dev/null \u0026amp;\u0026amp; echo \u0026#34;Domain exists\u0026#34; || echo \u0026#34;Domain not found\u0026#34; # 批次域名檢查 domains=(\u0026#34;google.com\u0026#34; \u0026#34;example.com\u0026#34; \u0026#34;nonexistent-domain-12345.com\u0026#34;) for domain in \u0026#34;${domains[@]}\u0026#34;; do if dig \u0026#34;$domain\u0026#34; +short \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;$domain: EXISTS\u0026#34; else echo \u0026#34;$domain: NOT FOUND\u0026#34; fi done DNSSEC 驗證 1 2 3 4 5 6 7 8 9 10 11 # 檢查 DNSSEC 支援 dig google.com +dnssec +multiline # 驗證 DNSSEC 簽名 dig google.com DNSKEY +dnssec # 檢查 DS 記錄 dig google.com DS +dnssec # 驗證鏈 dig +trace +dnssec google.com 實戰應用場景 1. 郵件伺服器診斷 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/bin/bash # mail_server_check.sh - 郵件伺服器診斷腳本 check_mail_server() { local domain=\u0026#34;$1\u0026#34; echo \u0026#34;=== Mail Server Diagnosis for $domain ===\u0026#34; # 檢查 MX 記錄 echo \u0026#34;MX Records:\u0026#34; dig \u0026#34;$domain\u0026#34; MX +noall +answer # 檢查 SPF 記錄 echo -e \u0026#34;\\nSPF Record:\u0026#34; dig \u0026#34;$domain\u0026#34; TXT +short | grep -i spf # 檢查 DMARC 記錄 echo -e \u0026#34;\\nDMARC Record:\u0026#34; dig \u0026#34;_dmarc.$domain\u0026#34; TXT +short # 檢查常見 DKIM 選擇器 echo -e \u0026#34;\\nDKIM Records:\u0026#34; selectors=(\u0026#34;default\u0026#34; \u0026#34;selector1\u0026#34; \u0026#34;selector2\u0026#34; \u0026#34;google\u0026#34; \u0026#34;k1\u0026#34;) for selector in \u0026#34;${selectors[@]}\u0026#34;; do result=$(dig \u0026#34;${selector}._domainkey.$domain\u0026#34; TXT +short 2\u0026gt;/dev/null) if [ -n \u0026#34;$result\u0026#34; ]; then echo \u0026#34;$selector: $result\u0026#34; fi done } # 使用範例 check_mail_server \u0026#34;gmail.com\u0026#34; 2. 網站可用性監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #!/bin/bash # website_dns_monitor.sh - 網站 DNS 監控腳本 monitor_website() { local domain=\u0026#34;$1\u0026#34; local log_file=\u0026#34;${2:-dns_monitor.log}\u0026#34; timestamp=$(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;) # 檢查 A 記錄 a_record=$(dig \u0026#34;$domain\u0026#34; A +short | head -1) # 檢查 AAAA 記錄 aaaa_record=$(dig \u0026#34;$domain\u0026#34; AAAA +short | head -1) # 測量查詢時間 query_time=$(dig \u0026#34;$domain\u0026#34; | grep \u0026#34;Query time\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) # 檢查 DNS 伺服器響應 dns_server=$(dig \u0026#34;$domain\u0026#34; | grep \u0026#34;SERVER:\u0026#34; | awk \u0026#39;{print $2}\u0026#39;) # 記錄結果 log_entry=\u0026#34;$timestamp | $domain | A: $a_record | AAAA: $aaaa_record | Time: ${query_time}ms | Server: $dns_server\u0026#34; echo \u0026#34;$log_entry\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; # 檢查異常 if [ -z \u0026#34;$a_record\u0026#34; ]; then echo \u0026#34;WARNING: No A record found for $domain\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; fi if [ \u0026#34;${query_time:-0}\u0026#34; -gt 1000 ]; then echo \u0026#34;WARNING: Slow DNS response (${query_time}ms) for $domain\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; fi } # 監控多個網站 websites=(\u0026#34;google.com\u0026#34; \u0026#34;github.com\u0026#34; \u0026#34;stackoverflow.com\u0026#34;) for site in \u0026#34;${websites[@]}\u0026#34;; do monitor_website \u0026#34;$site\u0026#34; done 3. DNS 伺服器效能比較 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #!/bin/bash # dns_performance_test.sh - DNS 效能測試腳本 dns_performance_test() { local domain=\u0026#34;${1:-google.com}\u0026#34; local test_count=\u0026#34;${2:-10}\u0026#34; # DNS 伺服器列表 declare -A dns_servers=( [\u0026#34;Google\u0026#34;]=\u0026#34;8.8.8.8\u0026#34; [\u0026#34;Cloudflare\u0026#34;]=\u0026#34;1.1.1.1\u0026#34; [\u0026#34;OpenDNS\u0026#34;]=\u0026#34;208.67.222.222\u0026#34; [\u0026#34;Quad9\u0026#34;]=\u0026#34;9.9.9.9\u0026#34; ) echo \u0026#34;DNS Performance Test for $domain\u0026#34; echo \u0026#34;==================================\u0026#34; for name in \u0026#34;${!dns_servers[@]}\u0026#34;; do server=\u0026#34;${dns_servers[$name]}\u0026#34; echo -e \u0026#34;\\nTesting $name ($server):\u0026#34; total_time=0 successful_queries=0 for i in $(seq 1 $test_count); do query_time=$(dig @\u0026#34;$server\u0026#34; \u0026#34;$domain\u0026#34; +stats 2\u0026gt;/dev/null | grep \u0026#34;Query time\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) if [ -n \u0026#34;$query_time\u0026#34; ]; then total_time=$((total_time + query_time)) successful_queries=$((successful_queries + 1)) echo -n \u0026#34;.\u0026#34; else echo -n \u0026#34;x\u0026#34; fi done if [ $successful_queries -gt 0 ]; then average_time=$((total_time / successful_queries)) echo -e \u0026#34;\\nAverage: ${average_time}ms (${successful_queries}/${test_count} successful)\u0026#34; else echo -e \u0026#34;\\nFailed: No successful queries\u0026#34; fi done } # 執行測試 dns_performance_test \u0026#34;google.com\u0026#34; 5 4. 域名變更追蹤 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #!/bin/bash # dns_change_tracker.sh - DNS 變更追蹤腳本 track_dns_changes() { local domain=\u0026#34;$1\u0026#34; local record_type=\u0026#34;${2:-A}\u0026#34; local interval=\u0026#34;${3:-300}\u0026#34; # 5分鐘 local log_file=\u0026#34;dns_changes_${domain}_${record_type}.log\u0026#34; echo \u0026#34;Tracking DNS changes for $domain ($record_type record)\u0026#34; echo \u0026#34;Log file: $log_file\u0026#34; previous_result=\u0026#34;\u0026#34; while true; do timestamp=$(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;) current_result=$(dig \u0026#34;$domain\u0026#34; \u0026#34;$record_type\u0026#34; +short | sort | tr \u0026#39;\\n\u0026#39; \u0026#39; \u0026#39;) if [ \u0026#34;$current_result\u0026#34; != \u0026#34;$previous_result\u0026#34; ]; then if [ -n \u0026#34;$previous_result\u0026#34; ]; then echo \u0026#34;$timestamp | CHANGE DETECTED\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; echo \u0026#34;$timestamp | Old: $previous_result\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; echo \u0026#34;$timestamp | New: $current_result\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; echo \u0026#34;$timestamp | ---\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; else echo \u0026#34;$timestamp | Initial: $current_result\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; fi previous_result=\u0026#34;$current_result\u0026#34; else echo \u0026#34;$timestamp | No change: $current_result\u0026#34; fi sleep \u0026#34;$interval\u0026#34; done } # 使用範例 # track_dns_changes \u0026#34;example.com\u0026#34; \u0026#34;A\u0026#34; 60 5. 批次域名分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #!/bin/bash # batch_domain_analysis.sh - 批次域名分析腳本 analyze_domains() { local domain_file=\u0026#34;$1\u0026#34; local output_file=\u0026#34;${2:-domain_analysis_$(date +%Y%m%d_%H%M%S).csv}\u0026#34; # CSV 標題 echo \u0026#34;Domain,A_Record,MX_Record,NS_Record,TXT_Count,Query_Time_ms,Status\u0026#34; \u0026gt; \u0026#34;$output_file\u0026#34; while IFS= read -r domain; do # 跳過空行和註解 [[ -z \u0026#34;$domain\u0026#34; || \u0026#34;$domain\u0026#34; =~ ^[[:space:]]*# ]] \u0026amp;\u0026amp; continue echo \u0026#34;Analyzing: $domain\u0026#34; # 查詢各種記錄 a_record=$(dig \u0026#34;$domain\u0026#34; A +short | head -1) mx_record=$(dig \u0026#34;$domain\u0026#34; MX +short | head -1 | awk \u0026#39;{print $2}\u0026#39;) ns_record=$(dig \u0026#34;$domain\u0026#34; NS +short | head -1) txt_count=$(dig \u0026#34;$domain\u0026#34; TXT +short | wc -l) # 測量查詢時間 query_time=$(dig \u0026#34;$domain\u0026#34; | grep \u0026#34;Query time\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) # 判斷狀態 if [ -n \u0026#34;$a_record\u0026#34; ]; then status=\u0026#34;Active\u0026#34; elif dig \u0026#34;$domain\u0026#34; +short \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then status=\u0026#34;Registered\u0026#34; else status=\u0026#34;Not Found\u0026#34; fi # 寫入 CSV echo \u0026#34;$domain,$a_record,$mx_record,$ns_record,$txt_count,$query_time,$status\u0026#34; \u0026gt;\u0026gt; \u0026#34;$output_file\u0026#34; done \u0026lt; \u0026#34;$domain_file\u0026#34; echo \u0026#34;Analysis complete. Results saved to: $output_file\u0026#34; } # 建立範例域名列表 cat \u0026gt; domains.txt \u0026lt;\u0026lt; EOF google.com github.com stackoverflow.com example.com nonexistent-domain-12345.com EOF # 執行分析 analyze_domains \u0026#34;domains.txt\u0026#34; 進階技巧與最佳化 1. 自訂查詢腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #!/bin/bash # dig_wrapper.sh - dig 包裝器腳本 # 彩色輸出 RED=\u0026#39;\\033[0;31m\u0026#39; GREEN=\u0026#39;\\033[0;32m\u0026#39; YELLOW=\u0026#39;\\033[1;33m\u0026#39; BLUE=\u0026#39;\\033[0;34m\u0026#39; NC=\u0026#39;\\033[0m\u0026#39; # No Color enhanced_dig() { local domain=\u0026#34;$1\u0026#34; local record_type=\u0026#34;${2:-A}\u0026#34; echo -e \u0026#34;${BLUE}=== Enhanced DNS Query: $domain ($record_type) ===${NC}\u0026#34; # 基本查詢 echo -e \u0026#34;\\n${GREEN}Basic Query:${NC}\u0026#34; dig \u0026#34;$domain\u0026#34; \u0026#34;$record_type\u0026#34; +noall +answer # 查詢時間和伺服器資訊 echo -e \u0026#34;\\n${GREEN}Performance Info:${NC}\u0026#34; dig \u0026#34;$domain\u0026#34; \u0026#34;$record_type\u0026#34; | grep -E \u0026#34;(Query time|SERVER:)\u0026#34; # 權威伺服器查詢 echo -e \u0026#34;\\n${GREEN}Authoritative Servers:${NC}\u0026#34; dig \u0026#34;$domain\u0026#34; NS +short # 如果是 A 記錄，也顯示反向查詢 if [ \u0026#34;$record_type\u0026#34; = \u0026#34;A\u0026#34; ]; then echo -e \u0026#34;\\n${GREEN}Reverse DNS:${NC}\u0026#34; ip=$(dig \u0026#34;$domain\u0026#34; A +short | head -1) if [ -n \u0026#34;$ip\u0026#34; ]; then dig -x \u0026#34;$ip\u0026#34; +short fi fi } # 使用範例 enhanced_dig \u0026#34;google.com\u0026#34; \u0026#34;A\u0026#34; 2. DNS 健康檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #!/bin/bash # dns_health_check.sh - DNS 健康檢查腳本 dns_health_check() { local domain=\u0026#34;$1\u0026#34; echo \u0026#34;DNS Health Check for: $domain\u0026#34; echo \u0026#34;=============================\u0026#34; # 檢查項目計數 local total_checks=0 local passed_checks=0 # 1. 檢查 A 記錄 echo -n \u0026#34;Checking A record... \u0026#34; total_checks=$((total_checks + 1)) if dig \u0026#34;$domain\u0026#34; A +short \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;✓ PASS\u0026#34; passed_checks=$((passed_checks + 1)) else echo \u0026#34;✗ FAIL\u0026#34; fi # 2. 檢查 NS 記錄 echo -n \u0026#34;Checking NS records... \u0026#34; total_checks=$((total_checks + 1)) ns_count=$(dig \u0026#34;$domain\u0026#34; NS +short | wc -l) if [ \u0026#34;$ns_count\u0026#34; -ge 2 ]; then echo \u0026#34;✓ PASS ($ns_count nameservers)\u0026#34; passed_checks=$((passed_checks + 1)) else echo \u0026#34;✗ FAIL (only $ns_count nameserver)\u0026#34; fi # 3. 檢查 SOA 記錄 echo -n \u0026#34;Checking SOA record... \u0026#34; total_checks=$((total_checks + 1)) if dig \u0026#34;$domain\u0026#34; SOA +short \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;✓ PASS\u0026#34; passed_checks=$((passed_checks + 1)) else echo \u0026#34;✗ FAIL\u0026#34; fi # 4. 檢查查詢時間 echo -n \u0026#34;Checking query performance... \u0026#34; total_checks=$((total_checks + 1)) query_time=$(dig \u0026#34;$domain\u0026#34; | grep \u0026#34;Query time\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) if [ \u0026#34;${query_time:-9999}\u0026#34; -lt 1000 ]; then echo \u0026#34;✓ PASS (${query_time}ms)\u0026#34; passed_checks=$((passed_checks + 1)) else echo \u0026#34;✗ FAIL (${query_time}ms - too slow)\u0026#34; fi # 5. 檢查權威伺服器一致性 echo -n \u0026#34;Checking authoritative server consistency... \u0026#34; total_checks=$((total_checks + 1)) ns_servers=$(dig \u0026#34;$domain\u0026#34; NS +short) consistent=true if [ -n \u0026#34;$ns_servers\u0026#34; ]; then first_result=$(dig @$(echo \u0026#34;$ns_servers\u0026#34; | head -1) \u0026#34;$domain\u0026#34; A +short | sort) while IFS= read -r server; do current_result=$(dig @\u0026#34;$server\u0026#34; \u0026#34;$domain\u0026#34; A +short | sort) if [ \u0026#34;$current_result\u0026#34; != \u0026#34;$first_result\u0026#34; ]; then consistent=false break fi done \u0026lt;\u0026lt;\u0026lt; \u0026#34;$ns_servers\u0026#34; if $consistent; then echo \u0026#34;✓ PASS\u0026#34; passed_checks=$((passed_checks + 1)) else echo \u0026#34;✗ FAIL (inconsistent results)\u0026#34; fi else echo \u0026#34;✗ FAIL (no nameservers found)\u0026#34; fi # 總結 echo echo \u0026#34;Health Check Summary: $passed_checks/$total_checks passed\u0026#34; if [ \u0026#34;$passed_checks\u0026#34; -eq \u0026#34;$total_checks\u0026#34; ]; then echo \u0026#34;Status: ✓ HEALTHY\u0026#34; return 0 else echo \u0026#34;Status: ✗ ISSUES DETECTED\u0026#34; return 1 fi } # 使用範例 dns_health_check \u0026#34;google.com\u0026#34; 3. 配置檔案管理 建立 ~/.digrc 配置檔案：\n1 2 3 4 # ~/.digrc - dig 預設配置 +noall +answer +time=5 +tries=3 或使用環境變數：\n1 2 3 4 5 6 7 # 在 ~/.bashrc 或 ~/.zshrc 中添加 export DIG_DEFAULT_OPTS=\u0026#34;+short +time=3\u0026#34; # 使用別名 alias digs=\u0026#39;dig +short\u0026#39; alias digt=\u0026#39;dig +trace\u0026#39; alias digx=\u0026#39;dig +short +time=1\u0026#39; 常見問題與解決方案 1. 查詢超時問題 1 2 3 4 5 6 7 8 # 調整超時設定 dig google.com +time=10 +tries=3 # 使用 TCP 查詢 dig google.com +tcp # 檢查網路連接 dig google.com +trace | grep -E \u0026#34;(SERVFAIL|TIMEOUT)\u0026#34; 2. DNS 伺服器問題 1 2 3 4 5 6 7 8 # 測試多個 DNS 伺服器 dns_test() { local domain=\u0026#34;$1\u0026#34; for server in 8.8.8.8 1.1.1.1 208.67.222.222; do echo \u0026#34;Testing $server:\u0026#34; dig @$server \u0026#34;$domain\u0026#34; +short +time=3 || echo \u0026#34;Failed\u0026#34; done } 3. 記錄解析問題 1 2 3 4 5 6 7 8 # 檢查完整的解析路徑 dig google.com +trace +all # 驗證 DNSSEC dig google.com +dnssec +multiline # 檢查快取污染 dig google.com @8.8.8.8 +norecurse 與其他工具整合 1. 與 nslookup 比較 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # dig 格式 dig google.com A +short # nslookup 格式 nslookup google.com | grep \u0026#34;Address:\u0026#34; | tail -1 | awk \u0026#39;{print $2}\u0026#39; # 轉換腳本 dig2nslookup() { local domain=\u0026#34;$1\u0026#34; echo \u0026#34;Server: $(dig google.com | grep SERVER | awk \u0026#39;{print $2}\u0026#39; | cut -d# -f1)\u0026#34; echo \u0026#34;Address: $(dig google.com | grep SERVER | awk \u0026#39;{print $2}\u0026#39;)\u0026#34; echo echo \u0026#34;Name: $domain\u0026#34; dig \u0026#34;$domain\u0026#34; A +short | while read ip; do echo \u0026#34;Address: $ip\u0026#34; done } 2. 與監控系統整合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # Nagios 檢查腳本 check_dns_record() { local domain=\u0026#34;$1\u0026#34; local expected=\u0026#34;$2\u0026#34; local timeout=\u0026#34;${3:-5}\u0026#34; result=$(dig \u0026#34;$domain\u0026#34; A +short +time=\u0026#34;$timeout\u0026#34; 2\u0026gt;/dev/null | head -1) if [ \u0026#34;$result\u0026#34; = \u0026#34;$expected\u0026#34; ]; then echo \u0026#34;OK - DNS record matches: $result\u0026#34; exit 0 elif [ -z \u0026#34;$result\u0026#34; ]; then echo \u0026#34;CRITICAL - No DNS record found\u0026#34; exit 2 else echo \u0026#34;WARNING - DNS record mismatch. Expected: $expected, Got: $result\u0026#34; exit 1 fi } # Prometheus 指標生成 generate_dns_metrics() { local domain=\u0026#34;$1\u0026#34; query_time=$(dig \u0026#34;$domain\u0026#34; | grep \u0026#34;Query time\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) record_count=$(dig \u0026#34;$domain\u0026#34; A +short | wc -l) echo \u0026#34;dns_query_duration_ms{domain=\\\u0026#34;$domain\\\u0026#34;} $query_time\u0026#34; echo \u0026#34;dns_record_count{domain=\\\u0026#34;$domain\\\u0026#34;,type=\\\u0026#34;A\\\u0026#34;} $record_count\u0026#34; } 總結 核心優勢 功能完整：支援所有 DNS 記錄類型和查詢選項 輸出詳細：提供完整的 DNS 響應資訊 診斷能力：強大的網路故障排除功能 腳本友好：適合自動化和批次處理 標準工具：廣泛支援和良好的文檔 最佳實踐 適當的超時設定：避免查詢掛起 使用追蹤功能：診斷複雜的 DNS 問題 驗證多個來源：比較不同 DNS 伺服器的結果 記錄和監控：建立 DNS 變更的歷史記錄 安全考慮：驗證 DNSSEC 和檢查 DNS 劫持 常用命令速查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 基本查詢 dig domain.com # 標準查詢 dig domain.com +short # 簡潔輸出 dig domain.com +trace # 追蹤解析路徑 # 記錄類型 dig domain.com A # IPv4 地址 dig domain.com AAAA # IPv6 地址 dig domain.com MX # 郵件交換 dig domain.com NS # 名稱伺服器 dig domain.com TXT # 文本記錄 # 進階選項 dig @8.8.8.8 domain.com # 指定 DNS 伺服器 dig -x 8.8.8.8 # 反向查詢 dig domain.com +dnssec # DNSSEC 驗證 dig domain.com +norecurse # 非遞歸查詢 dig 是網路管理和 DNS 診斷的核心工具，掌握其使用技巧能夠大幅提升網路問題診斷和域名管理的效率。記住：理解 DNS 系統的工作原理是有效使用 dig 的基礎。\n參考資料 BIND 9 Administrator Reference Manual RFC 1035 - Domain Names DNS and BIND on IPv6 DNSSEC Guide Linux dig Command Tutorial ","permalink":"https://xinqilin.github.io/post/tools/dig/","tags":["Linux","Dig","DNS","Network","Debugging","System Administration","Command Line"],"title":"Dig 命令完整指南：DNS 查詢與網路診斷的強大工具"},{"content":"SFTP 企業級工具類實作指南 簡介 在現代企業應用中，安全的文件傳輸是不可或缺的功能。SFTP（SSH File Transfer Protocol）提供了一種安全、可靠的文件傳輸方案。本文將詳細介紹如何在 Spring Boot 中實作企業級的 SFTP 工具類，包含連線池管理、錯誤處理、效能優化等關鍵功能。\n核心依賴配置 Maven 依賴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;dependencies\u0026gt; \u0026lt;!-- SFTP 核心依賴 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.jcraft\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsch\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1.55\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Apache Commons Pool2 連線池 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-pool2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.11.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot Starter --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot Configuration Processor --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Micrometer 監控 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.micrometer\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;micrometer-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Gradle 依賴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 dependencies { // SFTP 核心依賴 implementation \u0026#39;com.jcraft:jsch:0.1.55\u0026#39; // Apache Commons Pool2 連線池 implementation \u0026#39;org.apache.commons:commons-pool2:2.11.1\u0026#39; // Spring Boot Starter implementation \u0026#39;org.springframework.boot:spring-boot-starter\u0026#39; // Spring Boot Configuration Processor annotationProcessor \u0026#39;org.springframework.boot:spring-boot-configuration-processor\u0026#39; // Micrometer 監控 implementation \u0026#39;io.micrometer:micrometer-core\u0026#39; } 配置類別 SFTP 配置屬性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Configuration; import lombok.Data; @Data @Configuration @ConfigurationProperties(prefix = \u0026#34;sftp\u0026#34;) public class SftpProperties { // 連線配置 private String host; private int port = 22; private String username; private String password; private String privateKeyPath; private String passphrase; // 連線池配置 private Pool pool = new Pool(); // 超時配置 private int connectTimeout = 30000; private int sessionTimeout = 30000; private int channelTimeout = 30000; // 重試配置 private int maxRetries = 3; private int retryDelay = 1000; // 安全配置 private boolean strictHostKeyChecking = false; private String knownHostsFile; private String hostKeyAlgorithms; @Data public static class Pool { private int maxActive = 10; private int maxIdle = 5; private int minIdle = 1; private long maxWait = 10000; private boolean testOnBorrow = true; private boolean testOnReturn = true; private boolean testWhileIdle = true; private long timeBetweenEvictionRuns = 60000; private long minEvictableIdleTime = 300000; } } application.yml 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 sftp: host: sftp.example.com port: 22 username: ${SFTP_USERNAME:sftpuser} password: ${SFTP_PASSWORD:} private-key-path: ${SFTP_PRIVATE_KEY_PATH:} passphrase: ${SFTP_PASSPHRASE:} # 連線池配置 pool: max-active: 20 max-idle: 10 min-idle: 2 max-wait: 15000 test-on-borrow: true test-on-return: true test-while-idle: true time-between-eviction-runs: 60000 min-evictable-idle-time: 300000 # 超時配置 connect-timeout: 30000 session-timeout: 30000 channel-timeout: 30000 # 重試配置 max-retries: 3 retry-delay: 1000 # 安全配置 strict-host-key-checking: false known-hosts-file: ~/.ssh/known_hosts host-key-algorithms: ssh-rsa,ssh-dss # 監控配置 management: endpoints: web: exposure: include: health,metrics,info,sftp metrics: tags: application: sftp-service 核心實作類別 SFTP 連線工廠 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 import com.jcraft.jsch.*; import lombok.extern.slf4j.Slf4j; import org.apache.commons.pool2.BasePooledObjectFactory; import org.apache.commons.pool2.PooledObject; import org.apache.commons.pool2.impl.DefaultPooledObject; import org.springframework.stereotype.Component; import java.io.File; import java.util.Properties; @Slf4j @Component public class SftpConnectionFactory extends BasePooledObjectFactory\u0026lt;ChannelSftp\u0026gt; { private final SftpProperties sftpProperties; private final JSch jsch; public SftpConnectionFactory(SftpProperties sftpProperties) { this.sftpProperties = sftpProperties; this.jsch = new JSch(); initializeJSch(); } private void initializeJSch() { try { // 設定私鑰 if (sftpProperties.getPrivateKeyPath() != null) { if (sftpProperties.getPassphrase() != null) { jsch.addIdentity(sftpProperties.getPrivateKeyPath(), sftpProperties.getPassphrase()); } else { jsch.addIdentity(sftpProperties.getPrivateKeyPath()); } } // 設定 known_hosts if (sftpProperties.getKnownHostsFile() != null) { jsch.setKnownHosts(sftpProperties.getKnownHostsFile()); } log.info(\u0026#34;SFTP JSch 初始化完成\u0026#34;); } catch (JSchException e) { log.error(\u0026#34;SFTP JSch 初始化失敗\u0026#34;, e); throw new RuntimeException(\u0026#34;SFTP JSch 初始化失敗\u0026#34;, e); } } @Override public ChannelSftp create() throws Exception { log.debug(\u0026#34;創建新的 SFTP 連線到 {}:{}\u0026#34;, sftpProperties.getHost(), sftpProperties.getPort()); Session session = jsch.getSession( sftpProperties.getUsername(), sftpProperties.getHost(), sftpProperties.getPort() ); // 設定密碼（如果有） if (sftpProperties.getPassword() != null) { session.setPassword(sftpProperties.getPassword()); } // 設定連線屬性 Properties config = new Properties(); config.put(\u0026#34;StrictHostKeyChecking\u0026#34;, sftpProperties.isStrictHostKeyChecking() ? \u0026#34;yes\u0026#34; : \u0026#34;no\u0026#34;); if (sftpProperties.getHostKeyAlgorithms() != null) { config.put(\u0026#34;server_host_key\u0026#34;, sftpProperties.getHostKeyAlgorithms()); } session.setConfig(config); session.setTimeout(sftpProperties.getSessionTimeout()); // 建立連線 session.connect(sftpProperties.getConnectTimeout()); Channel channel = session.openChannel(\u0026#34;sftp\u0026#34;); channel.connect(sftpProperties.getChannelTimeout()); ChannelSftp channelSftp = (ChannelSftp) channel; log.debug(\u0026#34;SFTP 連線創建成功\u0026#34;); return channelSftp; } @Override public PooledObject\u0026lt;ChannelSftp\u0026gt; wrap(ChannelSftp channelSftp) { return new DefaultPooledObject\u0026lt;\u0026gt;(channelSftp); } @Override public boolean validateObject(PooledObject\u0026lt;ChannelSftp\u0026gt; pooledObject) { ChannelSftp channelSftp = pooledObject.getObject(); return channelSftp != null \u0026amp;\u0026amp; channelSftp.isConnected(); } @Override public void destroyObject(PooledObject\u0026lt;ChannelSftp\u0026gt; pooledObject) throws Exception { ChannelSftp channelSftp = pooledObject.getObject(); if (channelSftp != null) { Session session = channelSftp.getSession(); if (channelSftp.isConnected()) { channelSftp.disconnect(); } if (session != null \u0026amp;\u0026amp; session.isConnected()) { session.disconnect(); } } log.debug(\u0026#34;SFTP 連線已銷毀\u0026#34;); } } SFTP 連線池管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import org.apache.commons.pool2.ObjectPool; import org.apache.commons.pool2.impl.GenericObjectPool; import org.apache.commons.pool2.impl.GenericObjectPoolConfig; import org.springframework.stereotype.Component; import lombok.extern.slf4j.Slf4j; @Slf4j @Component public class SftpConnectionPoolManager { private final ObjectPool\u0026lt;ChannelSftp\u0026gt; sftpPool; private final SftpProperties sftpProperties; public SftpConnectionPoolManager(SftpConnectionFactory factory, SftpProperties sftpProperties) { this.sftpProperties = sftpProperties; this.sftpPool = createPool(factory); } private ObjectPool\u0026lt;ChannelSftp\u0026gt; createPool(SftpConnectionFactory factory) { GenericObjectPoolConfig\u0026lt;ChannelSftp\u0026gt; config = new GenericObjectPoolConfig\u0026lt;\u0026gt;(); config.setMaxTotal(sftpProperties.getPool().getMaxActive()); config.setMaxIdle(sftpProperties.getPool().getMaxIdle()); config.setMinIdle(sftpProperties.getPool().getMinIdle()); config.setMaxWaitMillis(sftpProperties.getPool().getMaxWait()); config.setTestOnBorrow(sftpProperties.getPool().isTestOnBorrow()); config.setTestOnReturn(sftpProperties.getPool().isTestOnReturn()); config.setTestWhileIdle(sftpProperties.getPool().isTestWhileIdle()); config.setTimeBetweenEvictionRunsMillis(sftpProperties.getPool().getTimeBetweenEvictionRuns()); config.setMinEvictableIdleTimeMillis(sftpProperties.getPool().getMinEvictableIdleTime()); return new GenericObjectPool\u0026lt;\u0026gt;(factory, config); } public ChannelSftp borrowConnection() throws Exception { return sftpPool.borrowObject(); } public void returnConnection(ChannelSftp channelSftp) { if (channelSftp != null) { try { sftpPool.returnObject(channelSftp); } catch (Exception e) { log.error(\u0026#34;歸還 SFTP 連線失敗\u0026#34;, e); } } } public void invalidateConnection(ChannelSftp channelSftp) { if (channelSftp != null) { try { sftpPool.invalidateObject(channelSftp); } catch (Exception e) { log.error(\u0026#34;無效化 SFTP 連線失敗\u0026#34;, e); } } } public int getActiveConnections() { return sftpPool.getNumActive(); } public int getIdleConnections() { return sftpPool.getNumIdle(); } } 企業級 SFTP 工具類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 import com.jcraft.jsch.ChannelSftp; import com.jcraft.jsch.SftpException; import io.micrometer.core.instrument.Counter; import io.micrometer.core.instrument.MeterRegistry; import io.micrometer.core.instrument.Timer; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; import java.io.*; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.ArrayList; import java.util.List; import java.util.Vector; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.function.Function; @Slf4j @Component public class SftpUtil { private final SftpConnectionPoolManager connectionPoolManager; private final SftpProperties sftpProperties; private final ExecutorService executorService; // 監控指標 private final Counter uploadCounter; private final Counter downloadCounter; private final Counter deleteCounter; private final Counter errorCounter; private final Timer uploadTimer; private final Timer downloadTimer; public SftpUtil(SftpConnectionPoolManager connectionPoolManager, SftpProperties sftpProperties, MeterRegistry meterRegistry) { this.connectionPoolManager = connectionPoolManager; this.sftpProperties = sftpProperties; this.executorService = Executors.newFixedThreadPool(10); // 初始化監控指標 this.uploadCounter = Counter.builder(\u0026#34;sftp.upload.total\u0026#34;) .description(\u0026#34;Total number of file uploads\u0026#34;) .register(meterRegistry); this.downloadCounter = Counter.builder(\u0026#34;sftp.download.total\u0026#34;) .description(\u0026#34;Total number of file downloads\u0026#34;) .register(meterRegistry); this.deleteCounter = Counter.builder(\u0026#34;sftp.delete.total\u0026#34;) .description(\u0026#34;Total number of file deletions\u0026#34;) .register(meterRegistry); this.errorCounter = Counter.builder(\u0026#34;sftp.error.total\u0026#34;) .description(\u0026#34;Total number of errors\u0026#34;) .register(meterRegistry); this.uploadTimer = Timer.builder(\u0026#34;sftp.upload.duration\u0026#34;) .description(\u0026#34;File upload duration\u0026#34;) .register(meterRegistry); this.downloadTimer = Timer.builder(\u0026#34;sftp.download.duration\u0026#34;) .description(\u0026#34;File download duration\u0026#34;) .register(meterRegistry); } /** * 上傳文件 */ public boolean uploadFile(String localFilePath, String remoteFilePath) { return uploadTimer.recordCallable(() -\u0026gt; { boolean success = executeWithRetry(channelSftp -\u0026gt; { try { createRemoteDirectoryIfNotExists(channelSftp, getParentPath(remoteFilePath)); try (FileInputStream fis = new FileInputStream(localFilePath)) { channelSftp.put(fis, remoteFilePath); log.info(\u0026#34;文件上傳成功: {} -\u0026gt; {}\u0026#34;, localFilePath, remoteFilePath); uploadCounter.increment(); return true; } } catch (Exception e) { log.error(\u0026#34;文件上傳失敗: {} -\u0026gt; {}\u0026#34;, localFilePath, remoteFilePath, e); errorCounter.increment(); throw new RuntimeException(\u0026#34;文件上傳失敗\u0026#34;, e); } }); return success; }); } /** * 批量上傳文件 */ public List\u0026lt;CompletableFuture\u0026lt;Boolean\u0026gt;\u0026gt; uploadFilesAsync(List\u0026lt;FileTransferRequest\u0026gt; requests) { List\u0026lt;CompletableFuture\u0026lt;Boolean\u0026gt;\u0026gt; futures = new ArrayList\u0026lt;\u0026gt;(); for (FileTransferRequest request : requests) { CompletableFuture\u0026lt;Boolean\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; uploadFile(request.getLocalPath(), request.getRemotePath()), executorService); futures.add(future); } return futures; } /** * 下載文件 */ public boolean downloadFile(String remoteFilePath, String localFilePath) { return downloadTimer.recordCallable(() -\u0026gt; { boolean success = executeWithRetry(channelSftp -\u0026gt; { try { createLocalDirectoryIfNotExists(getParentPath(localFilePath)); try (FileOutputStream fos = new FileOutputStream(localFilePath)) { channelSftp.get(remoteFilePath, fos); log.info(\u0026#34;文件下載成功: {} -\u0026gt; {}\u0026#34;, remoteFilePath, localFilePath); downloadCounter.increment(); return true; } } catch (Exception e) { log.error(\u0026#34;文件下載失敗: {} -\u0026gt; {}\u0026#34;, remoteFilePath, localFilePath, e); errorCounter.increment(); throw new RuntimeException(\u0026#34;文件下載失敗\u0026#34;, e); } }); return success; }); } /** * 下載文件到輸出流 */ public void downloadFileToStream(String remoteFilePath, OutputStream outputStream) { executeWithRetry(channelSftp -\u0026gt; { try { channelSftp.get(remoteFilePath, outputStream); log.info(\u0026#34;文件下載到流成功: {}\u0026#34;, remoteFilePath); downloadCounter.increment(); return true; } catch (Exception e) { log.error(\u0026#34;文件下載到流失敗: {}\u0026#34;, remoteFilePath, e); errorCounter.increment(); throw new RuntimeException(\u0026#34;文件下載到流失敗\u0026#34;, e); } }); } /** * 獲取文件內容為字符串 */ public String getFileContent(String remoteFilePath) { return executeWithRetry(channelSftp -\u0026gt; { try (InputStream inputStream = channelSftp.get(remoteFilePath); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) { StringBuilder content = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { content.append(line).append(\u0026#34;\\n\u0026#34;); } log.info(\u0026#34;獲取文件內容成功: {}\u0026#34;, remoteFilePath); return content.toString(); } catch (Exception e) { log.error(\u0026#34;獲取文件內容失敗: {}\u0026#34;, remoteFilePath, e); errorCounter.increment(); throw new RuntimeException(\u0026#34;獲取文件內容失敗\u0026#34;, e); } }); } /** * 刪除文件 */ public boolean deleteFile(String remoteFilePath) { return executeWithRetry(channelSftp -\u0026gt; { try { channelSftp.rm(remoteFilePath); log.info(\u0026#34;文件刪除成功: {}\u0026#34;, remoteFilePath); deleteCounter.increment(); return true; } catch (Exception e) { log.error(\u0026#34;文件刪除失敗: {}\u0026#34;, remoteFilePath, e); errorCounter.increment(); throw new RuntimeException(\u0026#34;文件刪除失敗\u0026#34;, e); } }); } /** * 列出目錄文件 */ public List\u0026lt;SftpFileInfo\u0026gt; listFiles(String remotePath) { return executeWithRetry(channelSftp -\u0026gt; { try { Vector\u0026lt;ChannelSftp.LsEntry\u0026gt; entries = channelSftp.ls(remotePath); List\u0026lt;SftpFileInfo\u0026gt; fileInfos = new ArrayList\u0026lt;\u0026gt;(); for (ChannelSftp.LsEntry entry : entries) { if (!entry.getFilename().equals(\u0026#34;.\u0026#34;) \u0026amp;\u0026amp; !entry.getFilename().equals(\u0026#34;..\u0026#34;)) { SftpFileInfo fileInfo = new SftpFileInfo(); fileInfo.setFilename(entry.getFilename()); fileInfo.setSize(entry.getAttrs().getSize()); fileInfo.setModifiedTime(entry.getAttrs().getMTime()); fileInfo.setDirectory(entry.getAttrs().isDir()); fileInfos.add(fileInfo); } } log.info(\u0026#34;列出目錄文件成功: {}, 共 {} 個文件\u0026#34;, remotePath, fileInfos.size()); return fileInfos; } catch (Exception e) { log.error(\u0026#34;列出目錄文件失敗: {}\u0026#34;, remotePath, e); errorCounter.increment(); throw new RuntimeException(\u0026#34;列出目錄文件失敗\u0026#34;, e); } }); } /** * 檢查文件是否存在 */ public boolean fileExists(String remoteFilePath) { return executeWithRetry(channelSftp -\u0026gt; { try { channelSftp.stat(remoteFilePath); return true; } catch (SftpException e) { if (e.id == ChannelSftp.SSH_FX_NO_SUCH_FILE) { return false; } throw new RuntimeException(\u0026#34;檢查文件存在性失敗\u0026#34;, e); } }); } /** * 創建遠端目錄 */ public void createRemoteDirectory(String remotePath) { executeWithRetry(channelSftp -\u0026gt; { try { createRemoteDirectoryIfNotExists(channelSftp, remotePath); log.info(\u0026#34;創建遠端目錄成功: {}\u0026#34;, remotePath); return true; } catch (Exception e) { log.error(\u0026#34;創建遠端目錄失敗: {}\u0026#34;, remotePath, e); errorCounter.increment(); throw new RuntimeException(\u0026#34;創建遠端目錄失敗\u0026#34;, e); } }); } /** * 帶重試機制的執行器 */ private \u0026lt;T\u0026gt; T executeWithRetry(Function\u0026lt;ChannelSftp, T\u0026gt; operation) { int attempts = 0; Exception lastException = null; while (attempts \u0026lt; sftpProperties.getMaxRetries()) { ChannelSftp channelSftp = null; try { channelSftp = connectionPoolManager.borrowConnection(); return operation.apply(channelSftp); } catch (Exception e) { lastException = e; attempts++; if (channelSftp != null) { connectionPoolManager.invalidateConnection(channelSftp); channelSftp = null; } if (attempts \u0026lt; sftpProperties.getMaxRetries()) { log.warn(\u0026#34;SFTP 操作失敗，第 {} 次重試\u0026#34;, attempts, e); try { Thread.sleep(sftpProperties.getRetryDelay()); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); throw new RuntimeException(\u0026#34;操作被中斷\u0026#34;, ie); } } } finally { if (channelSftp != null) { connectionPoolManager.returnConnection(channelSftp); } } } throw new RuntimeException(\u0026#34;SFTP 操作失敗，已重試 \u0026#34; + sftpProperties.getMaxRetries() + \u0026#34; 次\u0026#34;, lastException); } /** * 創建遠端目錄（如果不存在） */ private void createRemoteDirectoryIfNotExists(ChannelSftp channelSftp, String remotePath) throws SftpException { if (remotePath == null || remotePath.trim().isEmpty()) { return; } String[] dirs = remotePath.split(\u0026#34;/\u0026#34;); String currentPath = \u0026#34;\u0026#34;; for (String dir : dirs) { if (dir.isEmpty()) continue; currentPath += \u0026#34;/\u0026#34; + dir; try { channelSftp.stat(currentPath); } catch (SftpException e) { if (e.id == ChannelSftp.SSH_FX_NO_SUCH_FILE) { channelSftp.mkdir(currentPath); } else { throw e; } } } } /** * 創建本地目錄（如果不存在） */ private void createLocalDirectoryIfNotExists(String localPath) throws IOException { if (localPath != null \u0026amp;\u0026amp; !localPath.trim().isEmpty()) { Path path = Paths.get(localPath); if (!Files.exists(path)) { Files.createDirectories(path); } } } /** * 獲取父路徑 */ private String getParentPath(String filePath) { if (filePath == null) return null; int lastSlashIndex = filePath.lastIndexOf(\u0026#39;/\u0026#39;); if (lastSlashIndex \u0026gt; 0) { return filePath.substring(0, lastSlashIndex); } return null; } /** * 獲取連線池狀態 */ public SftpConnectionPoolStatus getConnectionPoolStatus() { SftpConnectionPoolStatus status = new SftpConnectionPoolStatus(); status.setActiveConnections(connectionPoolManager.getActiveConnections()); status.setIdleConnections(connectionPoolManager.getIdleConnections()); return status; } } 支援類別 文件傳輸請求類 1 2 3 4 5 6 7 8 9 10 11 import lombok.Data; import lombok.AllArgsConstructor; import lombok.NoArgsConstructor; @Data @NoArgsConstructor @AllArgsConstructor public class FileTransferRequest { private String localPath; private String remotePath; } SFTP 文件信息類 1 2 3 4 5 6 7 8 9 import lombok.Data; @Data public class SftpFileInfo { private String filename; private long size; private int modifiedTime; private boolean directory; } 連線池狀態類 1 2 3 4 5 6 7 import lombok.Data; @Data public class SftpConnectionPoolStatus { private int activeConnections; private int idleConnections; } 服務層整合 SFTP 服務類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 import org.springframework.stereotype.Service; import org.springframework.web.multipart.MultipartFile; import lombok.extern.slf4j.Slf4j; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.List; import java.util.UUID; @Slf4j @Service public class SftpService { private final SftpUtil sftpUtil; private static final String TEMP_DIR = System.getProperty(\u0026#34;java.io.tmpdir\u0026#34;); public SftpService(SftpUtil sftpUtil) { this.sftpUtil = sftpUtil; } /** * 上傳 MultipartFile 到 SFTP */ public boolean uploadMultipartFile(MultipartFile file, String remoteDirectory) { String tempFilePath = null; try { // 創建臨時文件 tempFilePath = createTempFile(file); // 構建遠端路徑 String remoteFilePath = remoteDirectory + \u0026#34;/\u0026#34; + file.getOriginalFilename(); // 上傳文件 boolean success = sftpUtil.uploadFile(tempFilePath, remoteFilePath); if (success) { log.info(\u0026#34;MultipartFile 上傳成功: {}\u0026#34;, file.getOriginalFilename()); } return success; } catch (Exception e) { log.error(\u0026#34;MultipartFile 上傳失敗: {}\u0026#34;, file.getOriginalFilename(), e); return false; } finally { // 清理臨時文件 if (tempFilePath != null) { cleanupTempFile(tempFilePath); } } } /** * 批量上傳文件 */ public void uploadFiles(List\u0026lt;MultipartFile\u0026gt; files, String remoteDirectory) { for (MultipartFile file : files) { uploadMultipartFile(file, remoteDirectory); } } /** * 下載文件並返回字節數組 */ public byte[] downloadFileAsBytes(String remoteFilePath) { String tempFilePath = null; try { // 創建臨時文件路徑 tempFilePath = TEMP_DIR + \u0026#34;/\u0026#34; + UUID.randomUUID() + \u0026#34;_download\u0026#34;; // 下載文件 boolean success = sftpUtil.downloadFile(remoteFilePath, tempFilePath); if (success) { Path path = Paths.get(tempFilePath); return Files.readAllBytes(path); } return null; } catch (Exception e) { log.error(\u0026#34;下載文件失敗: {}\u0026#34;, remoteFilePath, e); return null; } finally { // 清理臨時文件 if (tempFilePath != null) { cleanupTempFile(tempFilePath); } } } /** * 獲取目錄文件列表 */ public List\u0026lt;SftpFileInfo\u0026gt; listDirectoryFiles(String remotePath) { return sftpUtil.listFiles(remotePath); } /** * 刪除文件 */ public boolean deleteFile(String remoteFilePath) { return sftpUtil.deleteFile(remoteFilePath); } /** * 檢查文件是否存在 */ public boolean checkFileExists(String remoteFilePath) { return sftpUtil.fileExists(remoteFilePath); } /** * 創建臨時文件 */ private String createTempFile(MultipartFile file) throws IOException { String tempFileName = UUID.randomUUID() + \u0026#34;_\u0026#34; + file.getOriginalFilename(); Path tempPath = Paths.get(TEMP_DIR, tempFileName); Files.write(tempPath, file.getBytes()); return tempPath.toString(); } /** * 清理臨時文件 */ private void cleanupTempFile(String tempFilePath) { try { Files.deleteIfExists(Paths.get(tempFilePath)); } catch (IOException e) { log.warn(\u0026#34;清理臨時文件失敗: {}\u0026#34;, tempFilePath, e); } } } 控制器層 SFTP 控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import org.springframework.web.multipart.MultipartFile; import lombok.extern.slf4j.Slf4j; import java.util.List; @Slf4j @RestController @RequestMapping(\u0026#34;/api/sftp\u0026#34;) public class SftpController { private final SftpService sftpService; public SftpController(SftpService sftpService) { this.sftpService = sftpService; } /** * 上傳文件 */ @PostMapping(\u0026#34;/upload\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; uploadFile(@RequestParam(\u0026#34;file\u0026#34;) MultipartFile file, @RequestParam(\u0026#34;directory\u0026#34;) String directory) { try { boolean success = sftpService.uploadMultipartFile(file, directory); if (success) { return ResponseEntity.ok(\u0026#34;文件上傳成功\u0026#34;); } else { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(\u0026#34;文件上傳失敗\u0026#34;); } } catch (Exception e) { log.error(\u0026#34;上傳文件異常\u0026#34;, e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(\u0026#34;上傳文件異常: \u0026#34; + e.getMessage()); } } /** * 批量上傳文件 */ @PostMapping(\u0026#34;/upload/batch\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; uploadFiles(@RequestParam(\u0026#34;files\u0026#34;) List\u0026lt;MultipartFile\u0026gt; files, @RequestParam(\u0026#34;directory\u0026#34;) String directory) { try { sftpService.uploadFiles(files, directory); return ResponseEntity.ok(\u0026#34;批量上傳成功\u0026#34;); } catch (Exception e) { log.error(\u0026#34;批量上傳文件異常\u0026#34;, e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(\u0026#34;批量上傳異常: \u0026#34; + e.getMessage()); } } /** * 下載文件 */ @GetMapping(\u0026#34;/download\u0026#34;) public ResponseEntity\u0026lt;byte[]\u0026gt; downloadFile(@RequestParam(\u0026#34;filePath\u0026#34;) String filePath) { try { byte[] fileBytes = sftpService.downloadFileAsBytes(filePath); if (fileBytes != null) { return ResponseEntity.ok() .header(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment; filename=\\\u0026#34;\u0026#34; + filePath.substring(filePath.lastIndexOf(\u0026#34;/\u0026#34;) + 1) + \u0026#34;\\\u0026#34;\u0026#34;) .body(fileBytes); } else { return ResponseEntity.notFound().build(); } } catch (Exception e) { log.error(\u0026#34;下載文件異常\u0026#34;, e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); } } /** * 列出目錄文件 */ @GetMapping(\u0026#34;/list\u0026#34;) public ResponseEntity\u0026lt;List\u0026lt;SftpFileInfo\u0026gt;\u0026gt; listFiles(@RequestParam(\u0026#34;directory\u0026#34;) String directory) { try { List\u0026lt;SftpFileInfo\u0026gt; files = sftpService.listDirectoryFiles(directory); return ResponseEntity.ok(files); } catch (Exception e) { log.error(\u0026#34;列出目錄文件異常\u0026#34;, e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); } } /** * 刪除文件 */ @DeleteMapping(\u0026#34;/delete\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; deleteFile(@RequestParam(\u0026#34;filePath\u0026#34;) String filePath) { try { boolean success = sftpService.deleteFile(filePath); if (success) { return ResponseEntity.ok(\u0026#34;文件刪除成功\u0026#34;); } else { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(\u0026#34;文件刪除失敗\u0026#34;); } } catch (Exception e) { log.error(\u0026#34;刪除文件異常\u0026#34;, e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(\u0026#34;刪除文件異常: \u0026#34; + e.getMessage()); } } /** * 檢查文件是否存在 */ @GetMapping(\u0026#34;/exists\u0026#34;) public ResponseEntity\u0026lt;Boolean\u0026gt; checkFileExists(@RequestParam(\u0026#34;filePath\u0026#34;) String filePath) { try { boolean exists = sftpService.checkFileExists(filePath); return ResponseEntity.ok(exists); } catch (Exception e) { log.error(\u0026#34;檢查文件存在性異常\u0026#34;, e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); } } } 監控與健康檢查 SFTP 健康檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import org.springframework.boot.actuator.health.Health; import org.springframework.boot.actuator.health.HealthIndicator; import org.springframework.stereotype.Component; import lombok.extern.slf4j.Slf4j; @Slf4j @Component public class SftpHealthIndicator implements HealthIndicator { private final SftpUtil sftpUtil; public SftpHealthIndicator(SftpUtil sftpUtil) { this.sftpUtil = sftpUtil; } @Override public Health health() { try { // 檢查連線池狀態 SftpConnectionPoolStatus poolStatus = sftpUtil.getConnectionPoolStatus(); Health.Builder builder = Health.up() .withDetail(\u0026#34;activeConnections\u0026#34;, poolStatus.getActiveConnections()) .withDetail(\u0026#34;idleConnections\u0026#34;, poolStatus.getIdleConnections()) .withDetail(\u0026#34;status\u0026#34;, \u0026#34;SFTP 服務正常運行\u0026#34;); return builder.build(); } catch (Exception e) { log.error(\u0026#34;SFTP 健康檢查失敗\u0026#34;, e); return Health.down() .withDetail(\u0026#34;error\u0026#34;, e.getMessage()) .withDetail(\u0026#34;status\u0026#34;, \u0026#34;SFTP 服務異常\u0026#34;) .build(); } } } 自訂監控端點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import org.springframework.boot.actuate.endpoint.annotation.Endpoint; import org.springframework.boot.actuator.endpoint.annotation.ReadOperation; import org.springframework.stereotype.Component; import java.util.HashMap; import java.util.Map; @Component @Endpoint(id = \u0026#34;sftp\u0026#34;) public class SftpEndpoint { private final SftpUtil sftpUtil; public SftpEndpoint(SftpUtil sftpUtil) { this.sftpUtil = sftpUtil; } @ReadOperation public Map\u0026lt;String, Object\u0026gt; sftpInfo() { Map\u0026lt;String, Object\u0026gt; info = new HashMap\u0026lt;\u0026gt;(); try { SftpConnectionPoolStatus poolStatus = sftpUtil.getConnectionPoolStatus(); info.put(\u0026#34;connectionPool\u0026#34;, poolStatus); info.put(\u0026#34;status\u0026#34;, \u0026#34;healthy\u0026#34;); } catch (Exception e) { info.put(\u0026#34;status\u0026#34;, \u0026#34;unhealthy\u0026#34;); info.put(\u0026#34;error\u0026#34;, e.getMessage()); } return info; } } 測試 單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 import org.junit.jupiter.api.Test; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.Mock; import org.mockito.junit.jupiter.MockitoExtension; import org.springframework.test.context.junit.jupiter.SpringJUnitConfig; import java.io.ByteArrayInputStream; import java.io.InputStream; import static org.junit.jupiter.api.Assertions.*; import static org.mockito.Mockito.*; @ExtendWith(MockitoExtension.class) @SpringJUnitConfig class SftpUtilTest { @Mock private SftpConnectionPoolManager mockConnectionPoolManager; @Mock private ChannelSftp mockChannelSftp; @Mock private SftpProperties mockSftpProperties; private SftpUtil sftpUtil; @BeforeEach void setUp() { when(mockSftpProperties.getMaxRetries()).thenReturn(3); when(mockSftpProperties.getRetryDelay()).thenReturn(1000); sftpUtil = new SftpUtil(mockConnectionPoolManager, mockSftpProperties, null); } @Test void testUploadFile_Success() throws Exception { // Given String localPath = \u0026#34;test.txt\u0026#34;; String remotePath = \u0026#34;/remote/test.txt\u0026#34;; when(mockConnectionPoolManager.borrowConnection()).thenReturn(mockChannelSftp); // When boolean result = sftpUtil.uploadFile(localPath, remotePath); // Then assertTrue(result); verify(mockChannelSftp, times(1)).put(any(InputStream.class), eq(remotePath)); verify(mockConnectionPoolManager, times(1)).returnConnection(mockChannelSftp); } @Test void testDownloadFile_Success() throws Exception { // Given String remotePath = \u0026#34;/remote/test.txt\u0026#34;; String localPath = \u0026#34;test.txt\u0026#34;; InputStream mockInputStream = new ByteArrayInputStream(\u0026#34;test content\u0026#34;.getBytes()); when(mockConnectionPoolManager.borrowConnection()).thenReturn(mockChannelSftp); when(mockChannelSftp.get(remotePath)).thenReturn(mockInputStream); // When boolean result = sftpUtil.downloadFile(remotePath, localPath); // Then assertTrue(result); verify(mockChannelSftp, times(1)).get(eq(remotePath), any()); verify(mockConnectionPoolManager, times(1)).returnConnection(mockChannelSftp); } @Test void testFileExists_FileExists() throws Exception { // Given String remotePath = \u0026#34;/remote/test.txt\u0026#34;; when(mockConnectionPoolManager.borrowConnection()).thenReturn(mockChannelSftp); when(mockChannelSftp.stat(remotePath)).thenReturn(null); // 不拋出異常表示文件存在 // When boolean result = sftpUtil.fileExists(remotePath); // Then assertTrue(result); verify(mockChannelSftp, times(1)).stat(remotePath); verify(mockConnectionPoolManager, times(1)).returnConnection(mockChannelSftp); } } 整合測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.ActiveProfiles; import org.springframework.test.context.junit.jupiter.SpringJUnitConfig; import org.springframework.beans.factory.annotation.Autowired; @SpringBootTest @ActiveProfiles(\u0026#34;test\u0026#34;) @SpringJUnitConfig class SftpIntegrationTest { @Autowired private SftpService sftpService; @Test void testSftpServiceIntegration() { // 整合測試應該使用測試 SFTP 服務器 // 這裡只是展示測試結構 // Given String testDirectory = \u0026#34;/test\u0026#34;; // When \u0026amp; Then // 執行實際的 SFTP 操作測試 assertDoesNotThrow(() -\u0026gt; { sftpService.listDirectoryFiles(testDirectory); }); } } 最佳實踐 1. 安全性考慮 1 2 3 4 5 6 7 8 9 10 11 12 13 # 生產環境配置 sftp: # 使用環境變數或 Vault 管理敏感信息 username: ${SFTP_USERNAME} password: ${SFTP_PASSWORD} private-key-path: ${SFTP_PRIVATE_KEY_PATH} # 啟用嚴格的主機密鑰檢查 strict-host-key-checking: true known-hosts-file: /etc/ssh/ssh_known_hosts # 使用安全的主機密鑰算法 host-key-algorithms: rsa-sha2-512,rsa-sha2-256 2. 效能優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 使用批量操作 @Component public class SftpBatchProcessor { public void processBatchUpload(List\u0026lt;FileTransferRequest\u0026gt; requests) { // 分批處理大量文件 int batchSize = 10; for (int i = 0; i \u0026lt; requests.size(); i += batchSize) { List\u0026lt;FileTransferRequest\u0026gt; batch = requests.subList(i, Math.min(i + batchSize, requests.size())); processBatch(batch); } } private void processBatch(List\u0026lt;FileTransferRequest\u0026gt; batch) { // 並行處理批次 List\u0026lt;CompletableFuture\u0026lt;Boolean\u0026gt;\u0026gt; futures = sftpUtil.uploadFilesAsync(batch); // 等待所有任務完成 CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join(); } } 3. 錯誤處理策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Component public class SftpErrorHandler { public void handleSftpError(Exception e, String operation, String filePath) { if (e instanceof SftpException) { SftpException sftpException = (SftpException) e; switch (sftpException.id) { case ChannelSftp.SSH_FX_NO_SUCH_FILE: log.warn(\u0026#34;文件不存在: {}\u0026#34;, filePath); break; case ChannelSftp.SSH_FX_PERMISSION_DENIED: log.error(\u0026#34;權限不足: {}\u0026#34;, filePath); break; case ChannelSftp.SSH_FX_CONNECTION_LOST: log.error(\u0026#34;連線中斷: {}\u0026#34;, filePath); // 觸發重連 break; default: log.error(\u0026#34;SFTP 操作失敗: {} - {}\u0026#34;, operation, filePath, e); } } else { log.error(\u0026#34;一般錯誤: {} - {}\u0026#34;, operation, filePath, e); } } } 總結 本文詳細介紹了企業級 SFTP 工具類的完整實作，包含以下關鍵特性：\n連線池管理：提供高效的連線復用機制 錯誤處理：完善的重試機制和錯誤處理策略 監控機制：整合 Micrometer 提供完整的監控指標 安全配置：支援多種認證方式和安全配置選項 批量操作：支援大量文件的並行處理 健康檢查：整合 Spring Boot Actuator 提供健康檢查 測試覆蓋：提供完整的單元測試和整合測試 這個 SFTP 工具類適用於各種企業級應用場景，能夠穩定、高效地處理文件傳輸任務，同時提供良好的可觀測性和維護性。\n","permalink":"https://xinqilin.github.io/post/backend/sftputil/","tags":["SFTP","Spring Boot","File Transfer","JSch","Security","Java","Connection Pool","Enterprise","File Management","SSH","Secure Transfer","Best Practices","Error Handling","Performance","Monitoring","Configuration"],"title":"Spring Boot SFTP 工具類：企業級安全文件傳輸系統實作指南"},{"content":"概述 在處理大量資料時，分頁查詢是必不可少的功能。Spring Data JPA 提供了強大的 Pageable 接口，配合 Specification 可以輕鬆實現靈活的分頁查詢功能。本文將深入介紹如何使用這些功能來構建高效的分頁系統。\n核心概念 Pageable：分頁參數接口，定義頁面大小、頁碼和排序規則 Page：分頁結果接口，包含資料和分頁資訊 Specification：查詢規格接口，用於動態構建查詢條件 Criteria API：JPA 標準的類型安全查詢 API 架構優勢 類型安全：Criteria API 提供編譯時檢查 動態查詢：根據條件動態構建 SQL 自動計數：自動執行 COUNT 查詢計算總數 靈活排序：支援多欄位排序 效能優化：支援各種優化策略 基礎配置 1. 依賴設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;!-- Spring Boot Starter Data JPA --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot Starter Web --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Database Driver (以 MySQL 為例) --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot Starter Validation --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 2. 實體類定義 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 package com.example.pagination.entity; import jakarta.persistence.*; import jakarta.validation.constraints.NotBlank; import jakarta.validation.constraints.Email; import org.hibernate.annotations.CreationTimestamp; import org.hibernate.annotations.UpdateTimestamp; import java.time.LocalDateTime; @Entity @Table(name = \u0026#34;users\u0026#34;, indexes = { @Index(name = \u0026#34;idx_username\u0026#34;, columnList = \u0026#34;username\u0026#34;), @Index(name = \u0026#34;idx_email\u0026#34;, columnList = \u0026#34;email\u0026#34;), @Index(name = \u0026#34;idx_status\u0026#34;, columnList = \u0026#34;status\u0026#34;), @Index(name = \u0026#34;idx_created_at\u0026#34;, columnList = \u0026#34;created_at\u0026#34;) }) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotBlank @Column(unique = true, nullable = false, length = 50) private String username; @NotBlank @Email @Column(unique = true, nullable = false, length = 100) private String email; @Column(name = \u0026#34;first_name\u0026#34;, length = 50) private String firstName; @Column(name = \u0026#34;last_name\u0026#34;, length = 50) private String lastName; @Enumerated(EnumType.STRING) @Column(nullable = false) private UserStatus status = UserStatus.ACTIVE; @Column(name = \u0026#34;age\u0026#34;) private Integer age; @Column(name = \u0026#34;city\u0026#34;, length = 100) private String city; @CreationTimestamp @Column(name = \u0026#34;created_at\u0026#34;, nullable = false, updatable = false) private LocalDateTime createdAt; @UpdateTimestamp @Column(name = \u0026#34;updated_at\u0026#34;, nullable = false) private LocalDateTime updatedAt; // 建構子 public User() {} public User(String username, String email, String firstName, String lastName) { this.username = username; this.email = email; this.firstName = firstName; this.lastName = lastName; } // Getters and Setters public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public UserStatus getStatus() { return status; } public void setStatus(UserStatus status) { this.status = status; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } public LocalDateTime getCreatedAt() { return createdAt; } public LocalDateTime getUpdatedAt() { return updatedAt; } } enum UserStatus { ACTIVE, INACTIVE, SUSPENDED, DELETED } 3. Repository 接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package com.example.pagination.repository; import com.example.pagination.entity.User; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.jpa.domain.Specification; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.JpaSpecificationExecutor; import org.springframework.data.jpa.repository.Query; import org.springframework.data.repository.query.Param; import org.springframework.stereotype.Repository; import java.time.LocalDateTime; import java.util.List; @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt;, JpaSpecificationExecutor\u0026lt;User\u0026gt; { // 基本分頁查詢 Page\u0026lt;User\u0026gt; findByStatus(UserStatus status, Pageable pageable); // 複合條件分頁查詢 Page\u0026lt;User\u0026gt; findByStatusAndAgeGreaterThan(UserStatus status, Integer age, Pageable pageable); // 模糊查詢分頁 Page\u0026lt;User\u0026gt; findByUsernameContainingIgnoreCase(String username, Pageable pageable); // 時間範圍查詢 Page\u0026lt;User\u0026gt; findByCreatedAtBetween(LocalDateTime start, LocalDateTime end, Pageable pageable); // 自訂查詢分頁 @Query(\u0026#34;SELECT u FROM User u WHERE u.city = :city AND u.age BETWEEN :minAge AND :maxAge\u0026#34;) Page\u0026lt;User\u0026gt; findByCityAndAgeBetween(@Param(\u0026#34;city\u0026#34;) String city, @Param(\u0026#34;minAge\u0026#34;) Integer minAge, @Param(\u0026#34;maxAge\u0026#34;) Integer maxAge, Pageable pageable); // 原生 SQL 分頁查詢 @Query(value = \u0026#34;SELECT * FROM users u WHERE u.email LIKE %:emailDomain%\u0026#34;, countQuery = \u0026#34;SELECT COUNT(*) FROM users u WHERE u.email LIKE %:emailDomain%\u0026#34;, nativeQuery = true) Page\u0026lt;User\u0026gt; findByEmailDomain(@Param(\u0026#34;emailDomain\u0026#34;) String emailDomain, Pageable pageable); // 投影查詢（只查詢部分欄位） @Query(\u0026#34;SELECT new com.example.pagination.dto.UserSummaryDto(u.id, u.username, u.email, u.status) \u0026#34; + \u0026#34;FROM User u WHERE u.status = :status\u0026#34;) Page\u0026lt;UserSummaryDto\u0026gt; findUserSummariesByStatus(@Param(\u0026#34;status\u0026#34;) UserStatus status, Pageable pageable); } Specification 動態查詢 1. 基礎 Specification 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 package com.example.pagination.specification; import com.example.pagination.entity.User; import com.example.pagination.entity.UserStatus; import org.springframework.data.jpa.domain.Specification; import jakarta.persistence.criteria.*; import java.time.LocalDateTime; import java.util.ArrayList; import java.util.List; public class UserSpecification { /** * 根據使用者名稱模糊查詢 */ public static Specification\u0026lt;User\u0026gt; usernameContains(String username) { return (root, query, criteriaBuilder) -\u0026gt; { if (username == null || username.trim().isEmpty()) { return criteriaBuilder.conjunction(); } return criteriaBuilder.like( criteriaBuilder.lower(root.get(\u0026#34;username\u0026#34;)), \u0026#34;%\u0026#34; + username.toLowerCase() + \u0026#34;%\u0026#34; ); }; } /** * 根據郵箱模糊查詢 */ public static Specification\u0026lt;User\u0026gt; emailContains(String email) { return (root, query, criteriaBuilder) -\u0026gt; { if (email == null || email.trim().isEmpty()) { return criteriaBuilder.conjunction(); } return criteriaBuilder.like( criteriaBuilder.lower(root.get(\u0026#34;email\u0026#34;)), \u0026#34;%\u0026#34; + email.toLowerCase() + \u0026#34;%\u0026#34; ); }; } /** * 根據狀態查詢 */ public static Specification\u0026lt;User\u0026gt; statusEquals(UserStatus status) { return (root, query, criteriaBuilder) -\u0026gt; { if (status == null) { return criteriaBuilder.conjunction(); } return criteriaBuilder.equal(root.get(\u0026#34;status\u0026#34;), status); }; } /** * 根據年齡範圍查詢 */ public static Specification\u0026lt;User\u0026gt; ageBetween(Integer minAge, Integer maxAge) { return (root, query, criteriaBuilder) -\u0026gt; { List\u0026lt;Predicate\u0026gt; predicates = new ArrayList\u0026lt;\u0026gt;(); if (minAge != null) { predicates.add(criteriaBuilder.greaterThanOrEqualTo(root.get(\u0026#34;age\u0026#34;), minAge)); } if (maxAge != null) { predicates.add(criteriaBuilder.lessThanOrEqualTo(root.get(\u0026#34;age\u0026#34;), maxAge)); } return criteriaBuilder.and(predicates.toArray(new Predicate[0])); }; } /** * 根據城市查詢 */ public static Specification\u0026lt;User\u0026gt; cityEquals(String city) { return (root, query, criteriaBuilder) -\u0026gt; { if (city == null || city.trim().isEmpty()) { return criteriaBuilder.conjunction(); } return criteriaBuilder.equal(root.get(\u0026#34;city\u0026#34;), city); }; } /** * 根據創建時間範圍查詢 */ public static Specification\u0026lt;User\u0026gt; createdAtBetween(LocalDateTime startDate, LocalDateTime endDate) { return (root, query, criteriaBuilder) -\u0026gt; { List\u0026lt;Predicate\u0026gt; predicates = new ArrayList\u0026lt;\u0026gt;(); if (startDate != null) { predicates.add(criteriaBuilder.greaterThanOrEqualTo(root.get(\u0026#34;createdAt\u0026#34;), startDate)); } if (endDate != null) { predicates.add(criteriaBuilder.lessThanOrEqualTo(root.get(\u0026#34;createdAt\u0026#34;), endDate)); } return criteriaBuilder.and(predicates.toArray(new Predicate[0])); }; } /** * 複合查詢 - 根據多個條件 */ public static Specification\u0026lt;User\u0026gt; withFilters(String username, String email, UserStatus status, Integer minAge, Integer maxAge, String city) { return Specification.where(usernameContains(username)) .and(emailContains(email)) .and(statusEquals(status)) .and(ageBetween(minAge, maxAge)) .and(cityEquals(city)); } /** * 進階查詢 - 支援 OR 條件 */ public static Specification\u0026lt;User\u0026gt; searchByKeyword(String keyword) { return (root, query, criteriaBuilder) -\u0026gt; { if (keyword == null || keyword.trim().isEmpty()) { return criteriaBuilder.conjunction(); } String likePattern = \u0026#34;%\u0026#34; + keyword.toLowerCase() + \u0026#34;%\u0026#34;; return criteriaBuilder.or( criteriaBuilder.like(criteriaBuilder.lower(root.get(\u0026#34;username\u0026#34;)), likePattern), criteriaBuilder.like(criteriaBuilder.lower(root.get(\u0026#34;email\u0026#34;)), likePattern), criteriaBuilder.like(criteriaBuilder.lower(root.get(\u0026#34;firstName\u0026#34;)), likePattern), criteriaBuilder.like(criteriaBuilder.lower(root.get(\u0026#34;lastName\u0026#34;)), likePattern), criteriaBuilder.like(criteriaBuilder.lower(root.get(\u0026#34;city\u0026#34;)), likePattern) ); }; } } 2. 動態 Specification 建構器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 package com.example.pagination.specification; import org.springframework.data.jpa.domain.Specification; import jakarta.persistence.criteria.CriteriaBuilder; import jakarta.persistence.criteria.Predicate; import jakarta.persistence.criteria.Root; import java.util.ArrayList; import java.util.List; public class DynamicSpecificationBuilder\u0026lt;T\u0026gt; { private List\u0026lt;Specification\u0026lt;T\u0026gt;\u0026gt; specifications = new ArrayList\u0026lt;\u0026gt;(); public DynamicSpecificationBuilder\u0026lt;T\u0026gt; with(String field, String operation, Object value) { if (value != null) { specifications.add(createSpecification(field, operation, value)); } return this; } public DynamicSpecificationBuilder\u0026lt;T\u0026gt; with(Specification\u0026lt;T\u0026gt; specification) { if (specification != null) { specifications.add(specification); } return this; } public Specification\u0026lt;T\u0026gt; build() { if (specifications.isEmpty()) { return null; } Specification\u0026lt;T\u0026gt; result = specifications.get(0); for (int i = 1; i \u0026lt; specifications.size(); i++) { result = Specification.where(result).and(specifications.get(i)); } return result; } private Specification\u0026lt;T\u0026gt; createSpecification(String field, String operation, Object value) { return (root, query, criteriaBuilder) -\u0026gt; { switch (operation.toLowerCase()) { case \u0026#34;eq\u0026#34;: case \u0026#34;equals\u0026#34;: return criteriaBuilder.equal(root.get(field), value); case \u0026#34;ne\u0026#34;: case \u0026#34;not_equals\u0026#34;: return criteriaBuilder.notEqual(root.get(field), value); case \u0026#34;gt\u0026#34;: case \u0026#34;greater_than\u0026#34;: return criteriaBuilder.greaterThan(root.get(field), (Comparable) value); case \u0026#34;gte\u0026#34;: case \u0026#34;greater_than_or_equal\u0026#34;: return criteriaBuilder.greaterThanOrEqualTo(root.get(field), (Comparable) value); case \u0026#34;lt\u0026#34;: case \u0026#34;less_than\u0026#34;: return criteriaBuilder.lessThan(root.get(field), (Comparable) value); case \u0026#34;lte\u0026#34;: case \u0026#34;less_than_or_equal\u0026#34;: return criteriaBuilder.lessThanOrEqualTo(root.get(field), (Comparable) value); case \u0026#34;like\u0026#34;: case \u0026#34;contains\u0026#34;: return criteriaBuilder.like( criteriaBuilder.lower(root.get(field)), \u0026#34;%\u0026#34; + value.toString().toLowerCase() + \u0026#34;%\u0026#34; ); case \u0026#34;starts_with\u0026#34;: return criteriaBuilder.like( criteriaBuilder.lower(root.get(field)), value.toString().toLowerCase() + \u0026#34;%\u0026#34; ); case \u0026#34;ends_with\u0026#34;: return criteriaBuilder.like( criteriaBuilder.lower(root.get(field)), \u0026#34;%\u0026#34; + value.toString().toLowerCase() ); case \u0026#34;in\u0026#34;: if (value instanceof List) { return root.get(field).in((List\u0026lt;?\u0026gt;) value); } return criteriaBuilder.equal(root.get(field), value); case \u0026#34;is_null\u0026#34;: return criteriaBuilder.isNull(root.get(field)); case \u0026#34;is_not_null\u0026#34;: return criteriaBuilder.isNotNull(root.get(field)); default: throw new IllegalArgumentException(\u0026#34;不支援的操作: \u0026#34; + operation); } }; } } DTO 和分頁請求處理 1. 分頁請求 DTO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 package com.example.pagination.dto; import com.example.pagination.entity.UserStatus; import jakarta.validation.constraints.Min; import jakarta.validation.constraints.Max; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.data.domain.Sort; import java.time.LocalDateTime; public class UserPageRequest { @Min(value = 0, message = \u0026#34;頁碼不能小於 0\u0026#34;) private int page = 0; @Min(value = 1, message = \u0026#34;每頁大小不能小於 1\u0026#34;) @Max(value = 100, message = \u0026#34;每頁大小不能超過 100\u0026#34;) private int size = 20; private String sortBy = \u0026#34;id\u0026#34;; private String sortDirection = \u0026#34;DESC\u0026#34;; // 查詢條件 private String username; private String email; private UserStatus status; private Integer minAge; private Integer maxAge; private String city; private String keyword; // 關鍵字搜索 private LocalDateTime startDate; private LocalDateTime endDate; // 建構子 public UserPageRequest() {} public UserPageRequest(int page, int size) { this.page = page; this.size = size; } /** * 轉換為 Pageable 物件 */ public Pageable toPageable() { Sort.Direction direction = Sort.Direction.fromString(sortDirection); Sort sort = Sort.by(direction, sortBy); return PageRequest.of(page, size, sort); } /** * 檢查是否有查詢條件 */ public boolean hasFilters() { return username != null || email != null || status != null || minAge != null || maxAge != null || city != null || keyword != null || startDate != null || endDate != null; } // Getters and Setters public int getPage() { return page; } public void setPage(int page) { this.page = page; } public int getSize() { return size; } public void setSize(int size) { this.size = size; } public String getSortBy() { return sortBy; } public void setSortBy(String sortBy) { this.sortBy = sortBy; } public String getSortDirection() { return sortDirection; } public void setSortDirection(String sortDirection) { this.sortDirection = sortDirection; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public UserStatus getStatus() { return status; } public void setStatus(UserStatus status) { this.status = status; } public Integer getMinAge() { return minAge; } public void setMinAge(Integer minAge) { this.minAge = minAge; } public Integer getMaxAge() { return maxAge; } public void setMaxAge(Integer maxAge) { this.maxAge = maxAge; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } public String getKeyword() { return keyword; } public void setKeyword(String keyword) { this.keyword = keyword; } public LocalDateTime getStartDate() { return startDate; } public void setStartDate(LocalDateTime startDate) { this.startDate = startDate; } public LocalDateTime getEndDate() { return endDate; } public void setEndDate(LocalDateTime endDate) { this.endDate = endDate; } } 2. 分頁回應 DTO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package com.example.pagination.dto; import org.springframework.data.domain.Page; import java.util.List; public class PageResponse\u0026lt;T\u0026gt; { private List\u0026lt;T\u0026gt; content; private int page; private int size; private long totalElements; private int totalPages; private boolean first; private boolean last; private boolean hasNext; private boolean hasPrevious; private int numberOfElements; // 建構子 public PageResponse() {} public PageResponse(Page\u0026lt;T\u0026gt; page) { this.content = page.getContent(); this.page = page.getNumber(); this.size = page.getSize(); this.totalElements = page.getTotalElements(); this.totalPages = page.getTotalPages(); this.first = page.isFirst(); this.last = page.isLast(); this.hasNext = page.hasNext(); this.hasPrevious = page.hasPrevious(); this.numberOfElements = page.getNumberOfElements(); } public static \u0026lt;T\u0026gt; PageResponse\u0026lt;T\u0026gt; of(Page\u0026lt;T\u0026gt; page) { return new PageResponse\u0026lt;\u0026gt;(page); } // Getters and Setters public List\u0026lt;T\u0026gt; getContent() { return content; } public void setContent(List\u0026lt;T\u0026gt; content) { this.content = content; } public int getPage() { return page; } public void setPage(int page) { this.page = page; } public int getSize() { return size; } public void setSize(int size) { this.size = size; } public long getTotalElements() { return totalElements; } public void setTotalElements(long totalElements) { this.totalElements = totalElements; } public int getTotalPages() { return totalPages; } public void setTotalPages(int totalPages) { this.totalPages = totalPages; } public boolean isFirst() { return first; } public void setFirst(boolean first) { this.first = first; } public boolean isLast() { return last; } public void setLast(boolean last) { this.last = last; } public boolean isHasNext() { return hasNext; } public void setHasNext(boolean hasNext) { this.hasNext = hasNext; } public boolean isHasPrevious() { return hasPrevious; } public void setHasPrevious(boolean hasPrevious) { this.hasPrevious = hasPrevious; } public int getNumberOfElements() { return numberOfElements; } public void setNumberOfElements(int numberOfElements) { this.numberOfElements = numberOfElements; } } 3. 使用者摘要 DTO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.example.pagination.dto; import com.example.pagination.entity.UserStatus; public class UserSummaryDto { private Long id; private String username; private String email; private UserStatus status; // 建構子 public UserSummaryDto() {} public UserSummaryDto(Long id, String username, String email, UserStatus status) { this.id = id; this.username = username; this.email = email; this.status = status; } // Getters and Setters public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public UserStatus getStatus() { return status; } public void setStatus(UserStatus status) { this.status = status; } } Service 層實作 1. 使用者服務介面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package com.example.pagination.service; import com.example.pagination.dto.PageResponse; import com.example.pagination.dto.UserPageRequest; import com.example.pagination.dto.UserSummaryDto; import com.example.pagination.entity.User; import com.example.pagination.entity.UserStatus; import org.springframework.data.domain.Page; public interface UserService { /** * 分頁查詢使用者 */ PageResponse\u0026lt;User\u0026gt; findUsers(UserPageRequest request); /** * 關鍵字搜索使用者 */ PageResponse\u0026lt;User\u0026gt; searchUsers(String keyword, UserPageRequest request); /** * 根據狀態分頁查詢使用者摘要 */ PageResponse\u0026lt;UserSummaryDto\u0026gt; findUserSummariesByStatus(UserStatus status, UserPageRequest request); /** * 高級搜索 */ PageResponse\u0026lt;User\u0026gt; advancedSearch(UserPageRequest request); } 2. 使用者服務實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 package com.example.pagination.service.impl; import com.example.pagination.dto.PageResponse; import com.example.pagination.dto.UserPageRequest; import com.example.pagination.dto.UserSummaryDto; import com.example.pagination.entity.User; import com.example.pagination.entity.UserStatus; import com.example.pagination.repository.UserRepository; import com.example.pagination.service.UserService; import com.example.pagination.specification.DynamicSpecificationBuilder; import com.example.pagination.specification.UserSpecification; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.jpa.domain.Specification; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; @Service @Transactional(readOnly = true) public class UserServiceImpl implements UserService { @Autowired private UserRepository userRepository; @Override public PageResponse\u0026lt;User\u0026gt; findUsers(UserPageRequest request) { Pageable pageable = request.toPageable(); if (!request.hasFilters()) { // 沒有過濾條件，直接分頁查詢 Page\u0026lt;User\u0026gt; page = userRepository.findAll(pageable); return PageResponse.of(page); } // 有過濾條件，使用 Specification Specification\u0026lt;User\u0026gt; spec = UserSpecification.withFilters( request.getUsername(), request.getEmail(), request.getStatus(), request.getMinAge(), request.getMaxAge(), request.getCity() ); Page\u0026lt;User\u0026gt; page = userRepository.findAll(spec, pageable); return PageResponse.of(page); } @Override public PageResponse\u0026lt;User\u0026gt; searchUsers(String keyword, UserPageRequest request) { Pageable pageable = request.toPageable(); Specification\u0026lt;User\u0026gt; spec = UserSpecification.searchByKeyword(keyword); Page\u0026lt;User\u0026gt; page = userRepository.findAll(spec, pageable); return PageResponse.of(page); } @Override public PageResponse\u0026lt;UserSummaryDto\u0026gt; findUserSummariesByStatus(UserStatus status, UserPageRequest request) { Pageable pageable = request.toPageable(); Page\u0026lt;UserSummaryDto\u0026gt; page = userRepository.findUserSummariesByStatus(status, pageable); return PageResponse.of(page); } @Override public PageResponse\u0026lt;User\u0026gt; advancedSearch(UserPageRequest request) { Pageable pageable = request.toPageable(); // 使用動態 Specification 建構器 DynamicSpecificationBuilder\u0026lt;User\u0026gt; builder = new DynamicSpecificationBuilder\u0026lt;\u0026gt;(); builder.with(\u0026#34;username\u0026#34;, \u0026#34;contains\u0026#34;, request.getUsername()) .with(\u0026#34;email\u0026#34;, \u0026#34;contains\u0026#34;, request.getEmail()) .with(\u0026#34;status\u0026#34;, \u0026#34;equals\u0026#34;, request.getStatus()) .with(\u0026#34;age\u0026#34;, \u0026#34;gte\u0026#34;, request.getMinAge()) .with(\u0026#34;age\u0026#34;, \u0026#34;lte\u0026#34;, request.getMaxAge()) .with(\u0026#34;city\u0026#34;, \u0026#34;equals\u0026#34;, request.getCity()) .with(\u0026#34;createdAt\u0026#34;, \u0026#34;gte\u0026#34;, request.getStartDate()) .with(\u0026#34;createdAt\u0026#34;, \u0026#34;lte\u0026#34;, request.getEndDate()); // 如果有關鍵字，添加關鍵字搜索 if (request.getKeyword() != null \u0026amp;\u0026amp; !request.getKeyword().trim().isEmpty()) { builder.with(UserSpecification.searchByKeyword(request.getKeyword())); } Specification\u0026lt;User\u0026gt; spec = builder.build(); Page\u0026lt;User\u0026gt; page = userRepository.findAll(spec, pageable); return PageResponse.of(page); } } Controller 層實作 1. 使用者控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package com.example.pagination.controller; import com.example.pagination.dto.PageResponse; import com.example.pagination.dto.UserPageRequest; import com.example.pagination.dto.UserSummaryDto; import com.example.pagination.entity.User; import com.example.pagination.entity.UserStatus; import com.example.pagination.service.UserService; import jakarta.validation.Valid; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) @CrossOrigin(origins = \u0026#34;*\u0026#34;, maxAge = 3600) public class UserController { @Autowired private UserService userService; /** * 分頁查詢使用者 */ @GetMapping public ResponseEntity\u0026lt;PageResponse\u0026lt;User\u0026gt;\u0026gt; getUsers(@Valid UserPageRequest request) { PageResponse\u0026lt;User\u0026gt; response = userService.findUsers(request); return ResponseEntity.ok(response); } /** * 關鍵字搜索使用者 */ @GetMapping(\u0026#34;/search\u0026#34;) public ResponseEntity\u0026lt;PageResponse\u0026lt;User\u0026gt;\u0026gt; searchUsers( @RequestParam String keyword, @Valid UserPageRequest request) { PageResponse\u0026lt;User\u0026gt; response = userService.searchUsers(keyword, request); return ResponseEntity.ok(response); } /** * 高級搜索 */ @PostMapping(\u0026#34;/advanced-search\u0026#34;) public ResponseEntity\u0026lt;PageResponse\u0026lt;User\u0026gt;\u0026gt; advancedSearch(@Valid @RequestBody UserPageRequest request) { PageResponse\u0026lt;User\u0026gt; response = userService.advancedSearch(request); return ResponseEntity.ok(response); } /** * 根據狀態查詢使用者摘要 */ @GetMapping(\u0026#34;/summaries\u0026#34;) public ResponseEntity\u0026lt;PageResponse\u0026lt;UserSummaryDto\u0026gt;\u0026gt; getUserSummaries( @RequestParam UserStatus status, @Valid UserPageRequest request) { PageResponse\u0026lt;UserSummaryDto\u0026gt; response = userService.findUserSummariesByStatus(status, request); return ResponseEntity.ok(response); } /** * 使用路徑參數的分頁查詢 */ @GetMapping(\u0026#34;/page/{page}/size/{size}\u0026#34;) public ResponseEntity\u0026lt;PageResponse\u0026lt;User\u0026gt;\u0026gt; getUsersWithPathParams( @PathVariable int page, @PathVariable int size, @RequestParam(required = false) String sortBy, @RequestParam(required = false) String sortDirection) { UserPageRequest request = new UserPageRequest(page, size); if (sortBy != null) request.setSortBy(sortBy); if (sortDirection != null) request.setSortDirection(sortDirection); PageResponse\u0026lt;User\u0026gt; response = userService.findUsers(request); return ResponseEntity.ok(response); } } 2. 分頁配置控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package com.example.pagination.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.data.domain.Sort; import org.springframework.data.web.PageableDefault; import org.springframework.data.web.SortDefault; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import java.util.HashMap; import java.util.Map; @RestController @RequestMapping(\u0026#34;/api/config\u0026#34;) public class PageConfigController { /** * 使用 Spring 自動解析的 Pageable 參數 */ @GetMapping(\u0026#34;/users\u0026#34;) public ResponseEntity\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; getUsersWithSpringPageable( @PageableDefault(page = 0, size = 20) @SortDefault(sort = \u0026#34;id\u0026#34;, direction = Sort.Direction.DESC) Pageable pageable) { Map\u0026lt;String, Object\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); result.put(\u0026#34;page\u0026#34;, pageable.getPageNumber()); result.put(\u0026#34;size\u0026#34;, pageable.getPageSize()); result.put(\u0026#34;sort\u0026#34;, pageable.getSort().toString()); return ResponseEntity.ok(result); } /** * 動態排序欄位驗證 */ @GetMapping(\u0026#34;/users/validated\u0026#34;) public ResponseEntity\u0026lt;Pageable\u0026gt; getValidatedPageable( @RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @RequestParam(defaultValue = \u0026#34;20\u0026#34;) int size, @RequestParam(defaultValue = \u0026#34;id\u0026#34;) String sortBy, @RequestParam(defaultValue = \u0026#34;DESC\u0026#34;) String sortDirection) { // 驗證排序欄位 String[] allowedSortFields = {\u0026#34;id\u0026#34;, \u0026#34;username\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;createdAt\u0026#34;, \u0026#34;updatedAt\u0026#34;}; boolean isValidSortField = false; for (String field : allowedSortFields) { if (field.equals(sortBy)) { isValidSortField = true; break; } } if (!isValidSortField) { sortBy = \u0026#34;id\u0026#34;; // 預設排序欄位 } Sort.Direction direction = Sort.Direction.fromString(sortDirection); Sort sort = Sort.by(direction, sortBy); Pageable pageable = PageRequest.of(page, size, sort); return ResponseEntity.ok(pageable); } } 效能優化技巧 1. 資料庫索引優化 1 2 3 4 5 6 7 8 9 10 11 12 13 -- 為常用查詢欄位建立索引 CREATE INDEX idx_users_username ON users(username); CREATE INDEX idx_users_email ON users(email); CREATE INDEX idx_users_status ON users(status); CREATE INDEX idx_users_created_at ON users(created_at); CREATE INDEX idx_users_city_status ON users(city, status); -- 複合索引優化多條件查詢 CREATE INDEX idx_users_status_age ON users(status, age); CREATE INDEX idx_users_city_age_status ON users(city, age, status); -- 分析查詢執行計畫 EXPLAIN SELECT * FROM users WHERE status = \u0026#39;ACTIVE\u0026#39; AND age \u0026gt; 25 ORDER BY created_at DESC LIMIT 20; 2. JPA 查詢優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package com.example.pagination.config; import org.springframework.context.annotation.Configuration; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.data.web.PageableHandlerMethodArgumentResolver; import org.springframework.data.web.config.EnableSpringDataWebSupport; import org.springframework.web.method.support.HandlerMethodArgumentResolver; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import java.util.List; @Configuration @EnableSpringDataWebSupport public class PaginationConfig implements WebMvcConfigurer { @Override public void addArgumentResolvers(List\u0026lt;HandlerMethodArgumentResolver\u0026gt; resolvers) { PageableHandlerMethodArgumentResolver resolver = new PageableHandlerMethodArgumentResolver(); // 設定預設分頁參數 resolver.setFallbackPageable(PageRequest.of(0, 20)); // 設定最大分頁大小 resolver.setMaxPageSize(100); // 設定一頁為 1 的參數（而不是 0） resolver.setOneIndexedParameters(false); resolvers.add(resolver); } } 3. 快取優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.example.pagination.service.impl; import org.springframework.cache.annotation.Cacheable; import org.springframework.stereotype.Service; @Service public class CachedUserService { @Autowired private UserRepository userRepository; /** * 快取熱門查詢結果 */ @Cacheable(value = \u0026#34;userPages\u0026#34;, key = \u0026#34;#status + \u0026#39;_\u0026#39; + #pageable.pageNumber + \u0026#39;_\u0026#39; + #pageable.pageSize\u0026#34;) public Page\u0026lt;User\u0026gt; findUsersByStatusCached(UserStatus status, Pageable pageable) { return userRepository.findByStatus(status, pageable); } /** * 快取總數查詢 */ @Cacheable(value = \u0026#34;userCounts\u0026#34;, key = \u0026#34;#status\u0026#34;) public long countUsersByStatus(UserStatus status) { return userRepository.countByStatus(status); } } 4. 批次查詢優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package com.example.pagination.service.impl; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageImpl; import org.springframework.data.domain.Pageable; import org.springframework.stereotype.Service; import java.util.List; @Service public class OptimizedUserService { @Autowired private UserRepository userRepository; /** * 避免 N+1 查詢問題 */ public Page\u0026lt;User\u0026gt; findUsersWithOptimization(Pageable pageable) { // 只查詢當前頁的資料 List\u0026lt;User\u0026gt; users = userRepository.findUsersWithPagination( pageable.getOffset(), pageable.getPageSize() ); // 單獨查詢總數（可以快取） long total = userRepository.countAllUsers(); return new PageImpl\u0026lt;\u0026gt;(users, pageable, total); } /** * 使用原生 SQL 優化大資料查詢 */ @Query(value = \u0026#34;\u0026#34;\u0026#34; SELECT u.* FROM users u WHERE u.status = :status ORDER BY u.id DESC LIMIT :limit OFFSET :offset \u0026#34;\u0026#34;\u0026#34;, nativeQuery = true) public List\u0026lt;User\u0026gt; findUsersWithNativeQuery( @Param(\u0026#34;status\u0026#34;) String status, @Param(\u0026#34;limit\u0026#34;) int limit, @Param(\u0026#34;offset\u0026#34;) long offset ); } 實戰範例 1. 電商訂單分頁查詢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 package com.example.pagination.example; import com.example.pagination.entity.Order; import com.example.pagination.entity.OrderStatus; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.jpa.domain.Specification; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.JpaSpecificationExecutor; import org.springframework.web.bind.annotation.*; import java.math.BigDecimal; import java.time.LocalDateTime; import java.util.List; // 訂單實體 @Entity @Table(name = \u0026#34;orders\u0026#34;) public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long orderId; @Column(name = \u0026#34;customer_id\u0026#34;) private String customerId; @Column(name = \u0026#34;total_amount\u0026#34;) private BigDecimal totalAmount; @Enumerated(EnumType.STRING) private OrderStatus status; @CreationTimestamp @Column(name = \u0026#34;created_at\u0026#34;) private LocalDateTime createdAt; // Getters and Setters... } // Repository 介面 public interface OrderRepository extends JpaRepository\u0026lt;Order, Long\u0026gt;, JpaSpecificationExecutor\u0026lt;Order\u0026gt; { Page\u0026lt;Order\u0026gt; findByCustomerId(String customerId, Pageable pageable); Page\u0026lt;Order\u0026gt; findByStatusAndCreatedAtBetween( OrderStatus status, LocalDateTime startDate, LocalDateTime endDate, Pageable pageable ); } // 訂單 Specification public class OrderSpecification { public static Specification\u0026lt;Order\u0026gt; hasCustomerId(String customerId) { return (root, query, cb) -\u0026gt; customerId == null ? cb.conjunction() : cb.equal(root.get(\u0026#34;customerId\u0026#34;), customerId); } public static Specification\u0026lt;Order\u0026gt; hasStatus(OrderStatus status) { return (root, query, cb) -\u0026gt; status == null ? cb.conjunction() : cb.equal(root.get(\u0026#34;status\u0026#34;), status); } public static Specification\u0026lt;Order\u0026gt; amountBetween(BigDecimal minAmount, BigDecimal maxAmount) { return (root, query, cb) -\u0026gt; { if (minAmount == null \u0026amp;\u0026amp; maxAmount == null) return cb.conjunction(); if (minAmount != null \u0026amp;\u0026amp; maxAmount != null) { return cb.between(root.get(\u0026#34;totalAmount\u0026#34;), minAmount, maxAmount); } else if (minAmount != null) { return cb.greaterThanOrEqualTo(root.get(\u0026#34;totalAmount\u0026#34;), minAmount); } else { return cb.lessThanOrEqualTo(root.get(\u0026#34;totalAmount\u0026#34;), maxAmount); } }; } public static Specification\u0026lt;Order\u0026gt; createdBetween(LocalDateTime start, LocalDateTime end) { return (root, query, cb) -\u0026gt; { if (start == null \u0026amp;\u0026amp; end == null) return cb.conjunction(); if (start != null \u0026amp;\u0026amp; end != null) { return cb.between(root.get(\u0026#34;createdAt\u0026#34;), start, end); } else if (start != null) { return cb.greaterThanOrEqualTo(root.get(\u0026#34;createdAt\u0026#34;), start); } else { return cb.lessThanOrEqualTo(root.get(\u0026#34;createdAt\u0026#34;), end); } }; } } // 控制器實作 @RestController @RequestMapping(\u0026#34;/api/orders\u0026#34;) public class OrderController { @Autowired private OrderRepository orderRepository; /** * 分頁查詢訂單 */ @GetMapping public ResponseEntity\u0026lt;Page\u0026lt;Order\u0026gt;\u0026gt; getOrders( @RequestParam(required = false) String customerId, @RequestParam(required = false) OrderStatus status, @RequestParam(required = false) BigDecimal minAmount, @RequestParam(required = false) BigDecimal maxAmount, @RequestParam(required = false) LocalDateTime startDate, @RequestParam(required = false) LocalDateTime endDate, Pageable pageable) { Specification\u0026lt;Order\u0026gt; spec = Specification .where(OrderSpecification.hasCustomerId(customerId)) .and(OrderSpecification.hasStatus(status)) .and(OrderSpecification.amountBetween(minAmount, maxAmount)) .and(OrderSpecification.createdBetween(startDate, endDate)); Page\u0026lt;Order\u0026gt; orders = orderRepository.findAll(spec, pageable); return ResponseEntity.ok(orders); } /** * 客戶訂單查詢 */ @GetMapping(\u0026#34;/customer/{customerId}\u0026#34;) public ResponseEntity\u0026lt;Page\u0026lt;Order\u0026gt;\u0026gt; getCustomerOrders( @PathVariable String customerId, @PageableDefault(size = 10, sort = \u0026#34;createdAt\u0026#34;, direction = Sort.Direction.DESC) Pageable pageable) { Page\u0026lt;Order\u0026gt; orders = orderRepository.findByCustomerId(customerId, pageable); return ResponseEntity.ok(orders); } } 2. 統計報表分頁查詢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package com.example.pagination.example; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.jpa.repository.Query; import org.springframework.data.repository.query.Param; import org.springframework.web.bind.annotation.*; import java.time.LocalDate; // 統計 DTO public class OrderStatistics { private String customerId; private String customerName; private Long orderCount; private BigDecimal totalAmount; private LocalDate lastOrderDate; public OrderStatistics(String customerId, String customerName, Long orderCount, BigDecimal totalAmount, LocalDate lastOrderDate) { this.customerId = customerId; this.customerName = customerName; this.orderCount = orderCount; this.totalAmount = totalAmount; this.lastOrderDate = lastOrderDate; } // Getters and Setters... } // Repository 統計查詢 public interface OrderStatisticsRepository extends JpaRepository\u0026lt;Order, Long\u0026gt; { @Query(\u0026#34;\u0026#34;\u0026#34; SELECT new com.example.pagination.example.OrderStatistics( o.customerId, c.name, COUNT(o.orderId), SUM(o.totalAmount), MAX(CAST(o.createdAt AS LocalDate)) ) FROM Order o JOIN Customer c ON o.customerId = c.customerId WHERE o.createdAt BETWEEN :startDate AND :endDate GROUP BY o.customerId, c.name HAVING COUNT(o.orderId) \u0026gt;= :minOrderCount \u0026#34;\u0026#34;\u0026#34;) Page\u0026lt;OrderStatistics\u0026gt; findOrderStatistics( @Param(\u0026#34;startDate\u0026#34;) LocalDateTime startDate, @Param(\u0026#34;endDate\u0026#34;) LocalDateTime endDate, @Param(\u0026#34;minOrderCount\u0026#34;) Long minOrderCount, Pageable pageable ); } // 統計報表控制器 @RestController @RequestMapping(\u0026#34;/api/reports\u0026#34;) public class ReportController { @Autowired private OrderStatisticsRepository statisticsRepository; @GetMapping(\u0026#34;/customer-statistics\u0026#34;) public ResponseEntity\u0026lt;Page\u0026lt;OrderStatistics\u0026gt;\u0026gt; getCustomerStatistics( @RequestParam LocalDate startDate, @RequestParam LocalDate endDate, @RequestParam(defaultValue = \u0026#34;1\u0026#34;) Long minOrderCount, @PageableDefault(size = 20, sort = \u0026#34;totalAmount\u0026#34;, direction = Sort.Direction.DESC) Pageable pageable) { LocalDateTime startDateTime = startDate.atStartOfDay(); LocalDateTime endDateTime = endDate.atTime(23, 59, 59); Page\u0026lt;OrderStatistics\u0026gt; statistics = statisticsRepository.findOrderStatistics( startDateTime, endDateTime, minOrderCount, pageable ); return ResponseEntity.ok(statistics); } } 測試實作 1. 單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 package com.example.pagination.service; import com.example.pagination.dto.PageResponse; import com.example.pagination.dto.UserPageRequest; import com.example.pagination.entity.User; import com.example.pagination.entity.UserStatus; import com.example.pagination.repository.UserRepository; import com.example.pagination.service.impl.UserServiceImpl; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.junit.jupiter.MockitoExtension; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageImpl; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import java.util.Arrays; import java.util.List; import static org.junit.jupiter.api.Assertions.*; import static org.mockito.ArgumentMatchers.any; import static org.mockito.Mockito.*; @ExtendWith(MockitoExtension.class) public class UserServiceTest { @Mock private UserRepository userRepository; @InjectMocks private UserServiceImpl userService; private List\u0026lt;User\u0026gt; testUsers; @BeforeEach public void setUp() { User user1 = new User(\u0026#34;john\u0026#34;, \u0026#34;john@example.com\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;); User user2 = new User(\u0026#34;jane\u0026#34;, \u0026#34;jane@example.com\u0026#34;, \u0026#34;Jane\u0026#34;, \u0026#34;Smith\u0026#34;); testUsers = Arrays.asList(user1, user2); } @Test public void testFindUsersWithoutFilters() { // Given UserPageRequest request = new UserPageRequest(0, 10); Pageable pageable = PageRequest.of(0, 10); Page\u0026lt;User\u0026gt; page = new PageImpl\u0026lt;\u0026gt;(testUsers, pageable, testUsers.size()); when(userRepository.findAll(pageable)).thenReturn(page); // When PageResponse\u0026lt;User\u0026gt; result = userService.findUsers(request); // Then assertEquals(2, result.getContent().size()); assertEquals(0, result.getPage()); assertEquals(10, result.getSize()); assertEquals(2, result.getTotalElements()); verify(userRepository).findAll(pageable); verify(userRepository, never()).findAll(any(Specification.class), any(Pageable.class)); } @Test public void testFindUsersWithFilters() { // Given UserPageRequest request = new UserPageRequest(0, 10); request.setUsername(\u0026#34;john\u0026#34;); request.setStatus(UserStatus.ACTIVE); Pageable pageable = PageRequest.of(0, 10); Page\u0026lt;User\u0026gt; page = new PageImpl\u0026lt;\u0026gt;(Arrays.asList(testUsers.get(0)), pageable, 1); when(userRepository.findAll(any(Specification.class), eq(pageable))).thenReturn(page); // When PageResponse\u0026lt;User\u0026gt; result = userService.findUsers(request); // Then assertEquals(1, result.getContent().size()); assertEquals(\u0026#34;john\u0026#34;, result.getContent().get(0).getUsername()); verify(userRepository).findAll(any(Specification.class), eq(pageable)); verify(userRepository, never()).findAll(pageable); } @Test public void testSearchUsers() { // Given String keyword = \u0026#34;john\u0026#34;; UserPageRequest request = new UserPageRequest(0, 10); Pageable pageable = PageRequest.of(0, 10); Page\u0026lt;User\u0026gt; page = new PageImpl\u0026lt;\u0026gt;(Arrays.asList(testUsers.get(0)), pageable, 1); when(userRepository.findAll(any(Specification.class), eq(pageable))).thenReturn(page); // When PageResponse\u0026lt;User\u0026gt; result = userService.searchUsers(keyword, request); // Then assertEquals(1, result.getContent().size()); verify(userRepository).findAll(any(Specification.class), eq(pageable)); } } 2. 整合測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 package com.example.pagination.integration; import com.example.pagination.entity.User; import com.example.pagination.entity.UserStatus; import com.example.pagination.repository.UserRepository; import com.fasterxml.jackson.databind.ObjectMapper; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureWebMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.http.MediaType; import org.springframework.test.context.ActiveProfiles; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.setup.MockMvcBuilders; import org.springframework.transaction.annotation.Transactional; import org.springframework.web.context.WebApplicationContext; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; @SpringBootTest @AutoConfigureWebMvc @ActiveProfiles(\u0026#34;test\u0026#34;) @Transactional public class UserControllerIntegrationTest { @Autowired private WebApplicationContext webApplicationContext; @Autowired private UserRepository userRepository; @Autowired private ObjectMapper objectMapper; private MockMvc mockMvc; @BeforeEach public void setUp() { mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build(); // 建立測試資料 for (int i = 1; i \u0026lt;= 50; i++) { User user = new User(\u0026#34;user\u0026#34; + i, \u0026#34;user\u0026#34; + i + \u0026#34;@example.com\u0026#34;, \u0026#34;User\u0026#34;, String.valueOf(i)); user.setAge(20 + (i % 40)); user.setCity(i % 2 == 0 ? \u0026#34;Taipei\u0026#34; : \u0026#34;Kaohsiung\u0026#34;); user.setStatus(i % 3 == 0 ? UserStatus.INACTIVE : UserStatus.ACTIVE); userRepository.save(user); } } @Test public void testGetUsersWithDefaultPagination() throws Exception { mockMvc.perform(get(\u0026#34;/api/users\u0026#34;)) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.content\u0026#34;).isArray()) .andExpect(jsonPath(\u0026#34;$.page\u0026#34;).value(0)) .andExpect(jsonPath(\u0026#34;$.size\u0026#34;).value(20)) .andExpect(jsonPath(\u0026#34;$.totalElements\u0026#34;).value(50)) .andExpected(jsonPath(\u0026#34;$.totalPages\u0026#34;).value(3)); } @Test public void testGetUsersWithCustomPagination() throws Exception { mockMvc.perform(get(\u0026#34;/api/users\u0026#34;) .param(\u0026#34;page\u0026#34;, \u0026#34;1\u0026#34;) .param(\u0026#34;size\u0026#34;, \u0026#34;10\u0026#34;) .param(\u0026#34;sortBy\u0026#34;, \u0026#34;username\u0026#34;) .param(\u0026#34;sortDirection\u0026#34;, \u0026#34;ASC\u0026#34;)) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.content\u0026#34;).isArray()) .andExpect(jsonPath(\u0026#34;$.page\u0026#34;).value(1)) .andExpect(jsonPath(\u0026#34;$.size\u0026#34;).value(10)) .andExpect(jsonPath(\u0026#34;$.content.length()\u0026#34;).value(10)); } @Test public void testGetUsersWithFilters() throws Exception { mockMvc.perform(get(\u0026#34;/api/users\u0026#34;) .param(\u0026#34;status\u0026#34;, \u0026#34;ACTIVE\u0026#34;) .param(\u0026#34;city\u0026#34;, \u0026#34;Taipei\u0026#34;) .param(\u0026#34;minAge\u0026#34;, \u0026#34;25\u0026#34;) .param(\u0026#34;maxAge\u0026#34;, \u0026#34;35\u0026#34;)) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.content\u0026#34;).isArray()); } @Test public void testSearchUsers() throws Exception { mockMvc.perform(get(\u0026#34;/api/users/search\u0026#34;) .param(\u0026#34;keyword\u0026#34;, \u0026#34;user1\u0026#34;)) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.content\u0026#34;).isArray()); } } 常見問題與解決方案 1. 效能問題 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 問題：大資料量分頁查詢緩慢 // 解決方案：使用覆蓋索引和遊標分頁 @Repository public class OptimizedRepository { @PersistenceContext private EntityManager entityManager; /** * 使用遊標分頁避免 OFFSET 效能問題 */ public List\u0026lt;User\u0026gt; findUsersWithCursor(Long lastId, int limit) { return entityManager.createQuery( \u0026#34;SELECT u FROM User u WHERE u.id \u0026gt; :lastId ORDER BY u.id ASC\u0026#34;, User.class) .setParameter(\u0026#34;lastId\u0026#34;, lastId) .setMaxResults(limit) .getResultList(); } /** * 分離計數查詢和資料查詢 */ public Page\u0026lt;User\u0026gt; findUsersOptimized(Specification\u0026lt;User\u0026gt; spec, Pageable pageable) { // 先查詢資料 List\u0026lt;User\u0026gt; content = entityManager.createQuery(buildQuery(spec, pageable)) .setFirstResult((int) pageable.getOffset()) .setMaxResults(pageable.getPageSize()) .getResultList(); // 再查詢總數（可以快取） Long total = getCountFromCache(spec); return new PageImpl\u0026lt;\u0026gt;(content, pageable, total); } } 2. 記憶體問題 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 問題：大結果集導致記憶體溢出 // 解決方案：使用流式查詢和投影 @Service public class StreamingService { /** * 流式處理大資料集 */ @Transactional(readOnly = true) public void processLargeDataset(Specification\u0026lt;User\u0026gt; spec) { try (Stream\u0026lt;User\u0026gt; stream = userRepository.streamBySpec(spec)) { stream.forEach(this::processUser); } } /** * 只查詢必要欄位 */ @Query(\u0026#34;SELECT new com.example.dto.UserProjection(u.id, u.username, u.email) FROM User u\u0026#34;) Page\u0026lt;UserProjection\u0026gt; findUserProjections(Pageable pageable); } 3. 並發問題 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 問題：分頁過程中資料變化導致重複或遺漏 // 解決方案：使用快照隔離或版本控制 @Service public class ConsistentPaginationService { /** * 使用時間戳確保一致性 */ public Page\u0026lt;User\u0026gt; findUsersConsistently(UserPageRequest request, LocalDateTime snapshot) { Specification\u0026lt;User\u0026gt; spec = UserSpecification.withFilters( request.getUsername(), request.getEmail(), request.getStatus(), request.getMinAge(), request.getMaxAge(), request.getCity() ).and((root, query, cb) -\u0026gt; cb.lessThanOrEqualTo(root.get(\u0026#34;createdAt\u0026#34;), snapshot) ); return userRepository.findAll(spec, request.toPageable()); } } 總結 核心優勢 類型安全：Criteria API 提供編譯時檢查 動態查詢：根據條件靈活構建查詢 自動分頁：自動處理分頁邏輯和計數 效能優化：支援索引、快取和查詢優化 易於維護：結構化的查詢構建方式 最佳實踐 合理設定分頁大小：避免過大的頁面大小 建立適當索引：為查詢條件和排序欄位建立索引 使用投影查詢：只查詢需要的欄位 快取熱門查詢：快取頻繁查詢的結果 驗證輸入參數：防止 SQL 注入和無效查詢 監控查詢效能：定期檢查慢查詢 使用連接池：合理配置資料庫連接池 常用模式速查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 基本分頁 PageRequest.of(page, size, Sort.by(\u0026#34;fieldName\u0026#34;).descending()) // Specification 組合 Specification.where(spec1).and(spec2).or(spec3) // 動態條件 if (condition != null) { spec = spec.and(customSpec(condition)); } // 自訂排序 Sort.by(Sort.Order.desc(\u0026#34;field1\u0026#34;), Sort.Order.asc(\u0026#34;field2\u0026#34;)) // 投影查詢 @Query(\u0026#34;SELECT new dto.UserDto(u.id, u.name) FROM User u\u0026#34;) Page\u0026lt;UserDto\u0026gt; findUserDtos(Pageable pageable); Spring Data JPA 的 Pageable 和 Specification 提供了強大而靈活的分頁查詢功能，正確使用能夠大幅提升應用程式的查詢效能和使用者體驗。記住：理解底層的 SQL 生成機制有助於寫出更高效的查詢代碼。\n參考資料 Spring Data JPA 官方文檔 JPA Criteria API 規範 Spring Data Web Support Hibernate Performance Guide Database Indexing Best Practices ","permalink":"https://xinqilin.github.io/post/backend/jpapageable/","tags":["Spring Data JPA","Pageable","Pagination","Spring Boot","Database","Performance","Specification","Criteria API"],"title":"Spring Data JPA Pageable 分頁查詢：完整實作與效能優化指南"},{"content":"Side Project 企業級專案配置指南 簡介 在現代軟體開發中，一個良好的專案配置是成功的關鍵。本文將深入介紹如何從零開始建立一個企業級的 Side Project，包含完整的開發環境設定、專案結構規劃、依賴管理、容器化部署、監控系統與 CI/CD 流程。\n專案結構規劃 標準 Maven 專案結構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 project-root/ ├── src/ │ ├── main/ │ │ ├── java/ │ │ │ └── com/ │ │ │ └── company/ │ │ │ └── project/ │ │ │ ├── Application.java │ │ │ ├── config/ │ │ │ │ ├── AppConfig.java │ │ │ │ ├── SecurityConfig.java │ │ │ │ └── DatabaseConfig.java │ │ │ ├── controller/ │ │ │ ├── service/ │ │ │ │ ├── impl/ │ │ │ │ └── dto/ │ │ │ ├── repository/ │ │ │ ├── entity/ │ │ │ ├── exception/ │ │ │ └── util/ │ │ └── resources/ │ │ ├── application.yml │ │ ├── application-dev.yml │ │ ├── application-prod.yml │ │ ├── logback-spring.xml │ │ ├── banner.txt │ │ └── db/ │ │ └── migration/ │ └── test/ │ ├── java/ │ │ └── com/ │ │ └── company/ │ │ └── project/ │ │ ├── integration/ │ │ ├── unit/ │ │ └── TestApplication.java │ └── resources/ │ └── application-test.yml ├── docker/ │ ├── Dockerfile │ ├── docker-compose.yml │ └── docker-compose.prod.yml ├── .github/ │ └── workflows/ │ ├── ci.yml │ └── cd.yml ├── docs/ │ ├── api/ │ └── setup/ ├── scripts/ │ ├── build.sh │ ├── deploy.sh │ └── setup.sh ├── pom.xml ├── README.md └── .gitignore 核心依賴管理 完整的 Maven 依賴配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.company\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;side-project\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;Side Project\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Enterprise Side Project Configuration\u0026lt;/description\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;spring-cloud.version\u0026gt;2022.0.4\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;springdoc.version\u0026gt;2.2.0\u0026lt;/springdoc.version\u0026gt; \u0026lt;mapstruct.version\u0026gt;1.5.5.Final\u0026lt;/mapstruct.version\u0026gt; \u0026lt;testcontainers.version\u0026gt;1.19.0\u0026lt;/testcontainers.version\u0026gt; \u0026lt;jackson.version\u0026gt;2.15.2\u0026lt;/jackson.version\u0026gt; \u0026lt;guava.version\u0026gt;32.1.2-jre\u0026lt;/guava.version\u0026gt; \u0026lt;commons-lang3.version\u0026gt;3.13.0\u0026lt;/commons-lang3.version\u0026gt; \u0026lt;liquibase.version\u0026gt;4.23.2\u0026lt;/liquibase.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- Spring Boot Starters --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-cache\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Database --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.33\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Database Migration --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.liquibase\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;liquibase-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${liquibase.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Documentation --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-starter-webmvc-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${springdoc.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- JSON Processing --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jackson.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jackson.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.datatype\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-datatype-jsr310\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jackson.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Utilities --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang3\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${commons-lang3.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.guava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;guava\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${guava.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Mapping --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mapstruct\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mapstruct\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mapstruct.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Monitoring --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.micrometer\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;micrometer-registry-prometheus\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.logstash.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logstash-logback-encoder\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;7.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- JWT --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.11.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-impl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.11.5\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-jackson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.11.5\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Test Dependencies --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${testcontainers.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${testcontainers.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;redis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${testcontainers.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.11.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;17\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;17\u0026lt;/target\u0026gt; \u0026lt;annotationProcessorPaths\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;org.mapstruct\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mapstruct-processor\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mapstruct.version}\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok-mapstruct-binding\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.2.0\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;/annotationProcessorPaths\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.liquibase\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;liquibase-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${liquibase.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;propertyFile\u0026gt;src/main/resources/liquibase.properties\u0026lt;/propertyFile\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.jacoco\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jacoco-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.8.10\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;prepare-agent\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;report\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;test\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;report\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;com.google.cloud.tools\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jib-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;from\u0026gt; \u0026lt;image\u0026gt;eclipse-temurin:17-jre-alpine\u0026lt;/image\u0026gt; \u0026lt;/from\u0026gt; \u0026lt;to\u0026gt; \u0026lt;image\u0026gt;your-registry/side-project:${project.version}\u0026lt;/image\u0026gt; \u0026lt;/to\u0026gt; \u0026lt;container\u0026gt; \u0026lt;jvmFlags\u0026gt; \u0026lt;jvmFlag\u0026gt;-Xms512m\u0026lt;/jvmFlag\u0026gt; \u0026lt;jvmFlag\u0026gt;-Xmx2g\u0026lt;/jvmFlag\u0026gt; \u0026lt;/jvmFlags\u0026gt; \u0026lt;mainClass\u0026gt;com.company.project.Application\u0026lt;/mainClass\u0026gt; \u0026lt;ports\u0026gt; \u0026lt;port\u0026gt;8080\u0026lt;/port\u0026gt; \u0026lt;/ports\u0026gt; \u0026lt;/container\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 應用程式配置 主要配置檔案 - application.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 # 應用程式配置 spring: application: name: side-project profiles: active: ${SPRING_PROFILES_ACTIVE:dev} # 資料庫配置 datasource: url: jdbc:mysql://${DB_HOST:localhost}:${DB_PORT:3306}/${DB_NAME:side_project}?useSSL=false\u0026amp;serverTimezone=Asia/Taipei\u0026amp;allowPublicKeyRetrieval=true username: ${DB_USERNAME:root} password: ${DB_PASSWORD:password} driver-class-name: com.mysql.cj.jdbc.Driver hikari: minimum-idle: 5 maximum-pool-size: 20 idle-timeout: 30000 connection-timeout: 30000 max-lifetime: 1800000 pool-name: HikariCP # JPA 配置 jpa: hibernate: ddl-auto: validate show-sql: false properties: hibernate: dialect: org.hibernate.dialect.MySQL8Dialect format_sql: true use_sql_comments: true jdbc: batch_size: 25 order_inserts: true order_updates: true connection: provider_disables_autocommit: true query: in_clause_parameter_padding: true cache: use_second_level_cache: true use_query_cache: true region: factory_class: org.hibernate.cache.jcache.JCacheRegionFactory # Redis 配置 redis: host: ${REDIS_HOST:localhost} port: ${REDIS_PORT:6379} password: ${REDIS_PASSWORD:} database: 0 timeout: 10000ms lettuce: pool: max-active: 200 max-idle: 20 min-idle: 5 max-wait: 10000ms # Cache 配置 cache: type: redis redis: time-to-live: 600000 cache-null-values: false # Security 配置 security: oauth2: client: registration: google: client-id: ${GOOGLE_CLIENT_ID:your-google-client-id} client-secret: ${GOOGLE_CLIENT_SECRET:your-google-client-secret} scope: openid,profile,email # Liquibase 配置 liquibase: change-log: classpath:db/changelog/db.changelog-master.xml enabled: true # Jackson 配置 jackson: serialization: write-dates-as-timestamps: false indent-output: true deserialization: fail-on-unknown-properties: false time-zone: Asia/Taipei default-property-inclusion: non_null # 服務器配置 server: port: ${SERVER_PORT:8080} servlet: context-path: /api compression: enabled: true mime-types: text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json min-response-size: 1024 error: include-stacktrace: never include-message: always # 日誌配置 logging: level: root: INFO com.company.project: DEBUG org.springframework.security: DEBUG org.hibernate.SQL: DEBUG org.hibernate.type.descriptor.sql.BasicBinder: TRACE pattern: console: \u0026#34;%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\u0026#34; file: \u0026#34;%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\u0026#34; file: name: logs/application.log logback: rollingpolicy: max-file-size: 10MB max-history: 30 # 管理端點配置 management: endpoints: web: exposure: include: health,info,metrics,prometheus,liquibase,caches endpoint: health: show-details: always health: redis: enabled: true db: enabled: true metrics: export: prometheus: enabled: true tags: application: ${spring.application.name} environment: ${spring.profiles.active} # SpringDoc 配置 springdoc: api-docs: path: /api-docs swagger-ui: path: /swagger-ui.html operations-sorter: method tags-sorter: alpha packages-to-scan: com.company.project.controller # 應用程式自訂配置 app: jwt: secret: ${JWT_SECRET:your-secret-key-must-be-at-least-256-bits} expiration: ${JWT_EXPIRATION:86400000} # 24 hours refresh-expiration: ${JWT_REFRESH_EXPIRATION:604800000} # 7 days cors: allowed-origins: ${CORS_ALLOWED_ORIGINS:http://localhost:3000,http://localhost:8080} allowed-methods: ${CORS_ALLOWED_METHODS:GET,POST,PUT,DELETE,OPTIONS} allowed-headers: ${CORS_ALLOWED_HEADERS:*} allow-credentials: true rate-limit: enabled: true requests-per-minute: 60 burst-capacity: 100 file-storage: upload-dir: ${FILE_UPLOAD_DIR:uploads/} max-file-size: ${MAX_FILE_SIZE:10MB} allowed-extensions: ${ALLOWED_EXTENSIONS:jpg,jpeg,png,gif,pdf,docx,xlsx} 開發環境配置 - application-dev.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 spring: datasource: url: jdbc:mysql://localhost:3306/side_project_dev?useSSL=false\u0026amp;serverTimezone=Asia/Taipei username: root password: mysql jpa: hibernate: ddl-auto: update show-sql: true redis: host: localhost port: 6379 liquibase: enabled: false logging: level: root: DEBUG com.company.project: DEBUG org.springframework.web: DEBUG org.springframework.security: DEBUG management: endpoints: web: exposure: include: \u0026#34;*\u0026#34; app: jwt: secret: dev-secret-key-for-development-only-not-for-production expiration: 86400000 cors: allowed-origins: \u0026#34;http://localhost:3000,http://localhost:8080\u0026#34; 生產環境配置 - application-prod.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 spring: datasource: url: jdbc:mysql://${DB_HOST}:${DB_PORT}/${DB_NAME}?useSSL=true\u0026amp;serverTimezone=Asia/Taipei username: ${DB_USERNAME} password: ${DB_PASSWORD} hikari: minimum-idle: 10 maximum-pool-size: 50 idle-timeout: 60000 connection-timeout: 30000 max-lifetime: 1800000 jpa: hibernate: ddl-auto: validate show-sql: false redis: host: ${REDIS_HOST} port: ${REDIS_PORT} password: ${REDIS_PASSWORD} ssl: true liquibase: enabled: true logging: level: root: WARN com.company.project: INFO file: name: /var/log/side-project/application.log management: endpoints: web: exposure: include: health,info,metrics,prometheus endpoint: health: show-details: when-authorized app: jwt: secret: ${JWT_SECRET} expiration: ${JWT_EXPIRATION:3600000} cors: allowed-origins: ${CORS_ALLOWED_ORIGINS} 核心配置類別 主要應用程式配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.company.project.config; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Configuration; import lombok.Data; @Data @Configuration @ConfigurationProperties(prefix = \u0026#34;app\u0026#34;) public class AppProperties { private Jwt jwt = new Jwt(); private Cors cors = new Cors(); private RateLimit rateLimit = new RateLimit(); private FileStorage fileStorage = new FileStorage(); @Data public static class Jwt { private String secret; private long expiration; private long refreshExpiration; } @Data public static class Cors { private String allowedOrigins; private String allowedMethods; private String allowedHeaders; private boolean allowCredentials; } @Data public static class RateLimit { private boolean enabled; private int requestsPerMinute; private int burstCapacity; } @Data public static class FileStorage { private String uploadDir; private String maxFileSize; private String allowedExtensions; } } 資料庫配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.company.project.config; import com.zaxxer.hikari.HikariConfig; import com.zaxxer.hikari.HikariDataSource; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.data.jpa.repository.config.EnableJpaAuditing; import org.springframework.data.jpa.repository.config.EnableJpaRepositories; import org.springframework.transaction.annotation.EnableTransactionManagement; import javax.sql.DataSource; @Configuration @EnableJpaRepositories(basePackages = \u0026#34;com.company.project.repository\u0026#34;) @EnableJpaAuditing @EnableTransactionManagement public class DatabaseConfig { @Bean @Primary @ConfigurationProperties(\u0026#34;spring.datasource.hikari\u0026#34;) public HikariConfig hikariConfig() { return new HikariConfig(); } @Bean @Primary public DataSource dataSource() { return new HikariDataSource(hikariConfig()); } } Redis 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package com.company.project.config; import org.springframework.boot.autoconfigure.data.redis.RedisProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; import org.springframework.cache.annotation.EnableCaching; import org.springframework.cache.CacheManager; import org.springframework.data.redis.cache.RedisCacheManager; import org.springframework.data.redis.cache.RedisCacheConfiguration; import java.time.Duration; @Configuration @EnableCaching public class RedisConfig { @Bean public RedisConnectionFactory redisConnectionFactory(RedisProperties redisProperties) { return new LettuceConnectionFactory(redisProperties.getHost(), redisProperties.getPort()); } @Bean public RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate(RedisConnectionFactory connectionFactory) { RedisTemplate\u0026lt;String, Object\u0026gt; template = new RedisTemplate\u0026lt;\u0026gt;(); template.setConnectionFactory(connectionFactory); // 設定序列化器 template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(new GenericJackson2JsonRedisSerializer()); template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer()); template.afterPropertiesSet(); return template; } @Bean public CacheManager cacheManager(RedisConnectionFactory connectionFactory) { RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofMinutes(10)) .serializeKeysWith(org.springframework.data.redis.serializer.RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer())) .serializeValuesWith(org.springframework.data.redis.serializer.RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer())); return RedisCacheManager.builder(connectionFactory) .cacheDefaults(config) .build(); } } 安全配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package com.company.project.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.security.web.SecurityFilterChain; import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.CorsConfigurationSource; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import java.util.Arrays; @Configuration @EnableWebSecurity public class SecurityConfig { private final AppProperties appProperties; private final JwtAuthenticationFilter jwtAuthenticationFilter; public SecurityConfig(AppProperties appProperties, JwtAuthenticationFilter jwtAuthenticationFilter) { this.appProperties = appProperties; this.jwtAuthenticationFilter = jwtAuthenticationFilter; } @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http.csrf(csrf -\u0026gt; csrf.disable()) .cors(cors -\u0026gt; cors.configurationSource(corsConfigurationSource())) .sessionManagement(session -\u0026gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) .authorizeHttpRequests(authz -\u0026gt; authz .requestMatchers(\u0026#34;/api/auth/**\u0026#34;, \u0026#34;/api/public/**\u0026#34;).permitAll() .requestMatchers(\u0026#34;/api-docs/**\u0026#34;, \u0026#34;/swagger-ui/**\u0026#34;, \u0026#34;/swagger-ui.html\u0026#34;).permitAll() .requestMatchers(\u0026#34;/actuator/health\u0026#34;, \u0026#34;/actuator/info\u0026#34;).permitAll() .anyRequest().authenticated() ) .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class); return http.build(); } @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Bean public CorsConfigurationSource corsConfigurationSource() { CorsConfiguration configuration = new CorsConfiguration(); configuration.setAllowedOrigins(Arrays.asList(appProperties.getCors().getAllowedOrigins().split(\u0026#34;,\u0026#34;))); configuration.setAllowedMethods(Arrays.asList(appProperties.getCors().getAllowedMethods().split(\u0026#34;,\u0026#34;))); configuration.setAllowedHeaders(Arrays.asList(appProperties.getCors().getAllowedHeaders().split(\u0026#34;,\u0026#34;))); configuration.setAllowCredentials(appProperties.getCors().isAllowCredentials()); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\u0026#34;/**\u0026#34;, configuration); return source; } } OpenAPI 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package com.company.project.config; import io.swagger.v3.oas.models.OpenAPI; import io.swagger.v3.oas.models.info.Info; import io.swagger.v3.oas.models.info.Contact; import io.swagger.v3.oas.models.info.License; import io.swagger.v3.oas.models.security.SecurityRequirement; import io.swagger.v3.oas.models.security.SecurityScheme; import io.swagger.v3.oas.models.Components; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class OpenApiConfig { @Bean public OpenAPI customOpenAPI() { return new OpenAPI() .info(new Info() .title(\u0026#34;Side Project API\u0026#34;) .version(\u0026#34;1.0.0\u0026#34;) .description(\u0026#34;Enterprise Side Project API Documentation\u0026#34;) .contact(new Contact() .name(\u0026#34;Bill Lin\u0026#34;) .email(\u0026#34;bill@example.com\u0026#34;) .url(\u0026#34;https://github.com/yourhandle\u0026#34;)) .license(new License() .name(\u0026#34;MIT License\u0026#34;) .url(\u0026#34;https://opensource.org/licenses/MIT\u0026#34;))) .addSecurityItem(new SecurityRequirement().addList(\u0026#34;Bearer Authentication\u0026#34;)) .components(new Components() .addSecuritySchemes(\u0026#34;Bearer Authentication\u0026#34;, new SecurityScheme() .type(SecurityScheme.Type.HTTP) .scheme(\u0026#34;bearer\u0026#34;) .bearerFormat(\u0026#34;JWT\u0026#34;))); } } 容器化配置 Dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 # Multi-stage build FROM eclipse-temurin:17-jdk-alpine AS builder WORKDIR /app COPY pom.xml . COPY src ./src RUN ./mvnw clean package -DskipTests FROM eclipse-temurin:17-jre-alpine # 建立非 root 使用者 RUN addgroup -g 1001 -S appgroup \u0026amp;\u0026amp; \\ adduser -u 1001 -S appuser -G appgroup WORKDIR /app # 複製 JAR 檔案 COPY --from=builder /app/target/*.jar app.jar # 建立必要目錄 RUN mkdir -p /app/logs /app/uploads \u0026amp;\u0026amp; \\ chown -R appuser:appgroup /app # 切換到非 root 使用者 USER appuser # 健康檢查 HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \\ CMD curl -f http://localhost:8080/actuator/health || exit 1 # 暴露埠號 EXPOSE 8080 # JVM 調優參數 ENV JAVA_OPTS=\u0026#34;-Xms512m -Xmx2g -XX:+UseG1GC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/app/logs/\u0026#34; # 啟動應用程式 ENTRYPOINT [\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;java $JAVA_OPTS -jar app.jar\u0026#34;] docker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 version: \u0026#39;3.8\u0026#39; services: app: build: . ports: - \u0026#34;8080:8080\u0026#34; environment: - SPRING_PROFILES_ACTIVE=docker - DB_HOST=mysql - DB_PORT=3306 - DB_NAME=side_project - DB_USERNAME=root - DB_PASSWORD=mysql - REDIS_HOST=redis - REDIS_PORT=6379 depends_on: - mysql - redis volumes: - ./logs:/app/logs - ./uploads:/app/uploads networks: - app-network restart: unless-stopped mysql: image: mysql:8.0 environment: - MYSQL_ROOT_PASSWORD=mysql - MYSQL_DATABASE=side_project - MYSQL_USER=app - MYSQL_PASSWORD=app ports: - \u0026#34;3306:3306\u0026#34; volumes: - mysql_data:/var/lib/mysql - ./docker/mysql/init.sql:/docker-entrypoint-initdb.d/init.sql networks: - app-network restart: unless-stopped redis: image: redis:7-alpine ports: - \u0026#34;6379:6379\u0026#34; volumes: - redis_data:/data networks: - app-network restart: unless-stopped prometheus: image: prom/prometheus:latest ports: - \u0026#34;9090:9090\u0026#34; volumes: - ./docker/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml networks: - app-network restart: unless-stopped grafana: image: grafana/grafana:latest ports: - \u0026#34;3000:3000\u0026#34; environment: - GF_SECURITY_ADMIN_PASSWORD=admin volumes: - grafana_data:/var/lib/grafana - ./docker/grafana/dashboards:/etc/grafana/provisioning/dashboards - ./docker/grafana/datasources:/etc/grafana/provisioning/datasources networks: - app-network restart: unless-stopped nginx: image: nginx:alpine ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; volumes: - ./docker/nginx/nginx.conf:/etc/nginx/nginx.conf - ./docker/nginx/ssl:/etc/nginx/ssl depends_on: - app networks: - app-network restart: unless-stopped volumes: mysql_data: redis_data: grafana_data: networks: app-network: driver: bridge 生產環境 docker-compose.prod.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 version: \u0026#39;3.8\u0026#39; services: app: image: your-registry/side-project:latest deploy: replicas: 3 resources: limits: memory: 2G cpus: \u0026#39;1\u0026#39; reservations: memory: 1G cpus: \u0026#39;0.5\u0026#39; restart_policy: condition: on-failure delay: 10s max_attempts: 3 environment: - SPRING_PROFILES_ACTIVE=prod - DB_HOST=mysql-prod - DB_PORT=3306 - DB_NAME=side_project_prod - DB_USERNAME=${DB_USERNAME} - DB_PASSWORD=${DB_PASSWORD} - REDIS_HOST=redis-prod - REDIS_PORT=6379 - REDIS_PASSWORD=${REDIS_PASSWORD} - JWT_SECRET=${JWT_SECRET} secrets: - db_password - jwt_secret networks: - app-network logging: driver: \u0026#34;json-file\u0026#34; options: max-size: \u0026#34;10m\u0026#34; max-file: \u0026#34;3\u0026#34; mysql-prod: image: mysql:8.0 environment: - MYSQL_ROOT_PASSWORD_FILE=/run/secrets/db_password - MYSQL_DATABASE=side_project_prod volumes: - mysql_prod_data:/var/lib/mysql secrets: - db_password networks: - app-network deploy: resources: limits: memory: 2G cpus: \u0026#39;1\u0026#39; redis-prod: image: redis:7-alpine command: redis-server --requirepass ${REDIS_PASSWORD} volumes: - redis_prod_data:/data networks: - app-network deploy: resources: limits: memory: 512M cpus: \u0026#39;0.5\u0026#39; secrets: db_password: external: true jwt_secret: external: true volumes: mysql_prod_data: redis_prod_data: networks: app-network: driver: overlay 監控配置 logback-spring.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;include resource=\u0026#34;org/springframework/boot/logging/logback/defaults.xml\u0026#34;/\u0026gt; \u0026lt;springProfile name=\u0026#34;!prod\u0026#34;\u0026gt; \u0026lt;include resource=\u0026#34;org/springframework/boot/logging/logback/console-appender.xml\u0026#34;/\u0026gt; \u0026lt;root level=\u0026#34;INFO\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;CONSOLE\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/springProfile\u0026gt; \u0026lt;springProfile name=\u0026#34;prod\u0026#34;\u0026gt; \u0026lt;appender name=\u0026#34;FILE\u0026#34; class=\u0026#34;ch.qos.logback.core.rolling.RollingFileAppender\u0026#34;\u0026gt; \u0026lt;file\u0026gt;/var/log/side-project/application.log\u0026lt;/file\u0026gt; \u0026lt;encoder class=\u0026#34;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder\u0026#34;\u0026gt; \u0026lt;providers\u0026gt; \u0026lt;timestamp/\u0026gt; \u0026lt;logLevel/\u0026gt; \u0026lt;loggerName/\u0026gt; \u0026lt;mdc/\u0026gt; \u0026lt;message/\u0026gt; \u0026lt;stackTrace/\u0026gt; \u0026lt;/providers\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;rollingPolicy class=\u0026#34;ch.qos.logback.core.rolling.TimeBasedRollingPolicy\u0026#34;\u0026gt; \u0026lt;fileNamePattern\u0026gt;/var/log/side-project/application.%d{yyyy-MM-dd}.%i.log\u0026lt;/fileNamePattern\u0026gt; \u0026lt;timeBasedFileNamingAndTriggeringPolicy class=\u0026#34;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\u0026#34;\u0026gt; \u0026lt;maxFileSize\u0026gt;100MB\u0026lt;/maxFileSize\u0026gt; \u0026lt;/timeBasedFileNamingAndTriggeringPolicy\u0026gt; \u0026lt;maxHistory\u0026gt;30\u0026lt;/maxHistory\u0026gt; \u0026lt;totalSizeCap\u0026gt;3GB\u0026lt;/totalSizeCap\u0026gt; \u0026lt;/rollingPolicy\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;appender name=\u0026#34;METRICS\u0026#34; class=\u0026#34;ch.qos.logback.core.rolling.RollingFileAppender\u0026#34;\u0026gt; \u0026lt;file\u0026gt;/var/log/side-project/metrics.log\u0026lt;/file\u0026gt; \u0026lt;encoder class=\u0026#34;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder\u0026#34;\u0026gt; \u0026lt;providers\u0026gt; \u0026lt;timestamp/\u0026gt; \u0026lt;logLevel/\u0026gt; \u0026lt;loggerName/\u0026gt; \u0026lt;mdc/\u0026gt; \u0026lt;message/\u0026gt; \u0026lt;/providers\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;rollingPolicy class=\u0026#34;ch.qos.logback.core.rolling.TimeBasedRollingPolicy\u0026#34;\u0026gt; \u0026lt;fileNamePattern\u0026gt;/var/log/side-project/metrics.%d{yyyy-MM-dd}.log\u0026lt;/fileNamePattern\u0026gt; \u0026lt;maxHistory\u0026gt;7\u0026lt;/maxHistory\u0026gt; \u0026lt;/rollingPolicy\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;logger name=\u0026#34;metrics\u0026#34; level=\u0026#34;INFO\u0026#34; additivity=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;METRICS\u0026#34;/\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;root level=\u0026#34;INFO\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;FILE\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/springProfile\u0026gt; \u0026lt;/configuration\u0026gt; Prometheus 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # docker/prometheus/prometheus.yml global: scrape_interval: 15s evaluation_interval: 15s scrape_configs: - job_name: \u0026#39;side-project\u0026#39; static_configs: - targets: [\u0026#39;app:8080\u0026#39;] metrics_path: \u0026#39;/actuator/prometheus\u0026#39; scrape_interval: 10s - job_name: \u0026#39;mysql\u0026#39; static_configs: - targets: [\u0026#39;mysql:3306\u0026#39;] - job_name: \u0026#39;redis\u0026#39; static_configs: - targets: [\u0026#39;redis:6379\u0026#39;] CI/CD 配置 GitHub Actions - CI 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 # .github/workflows/ci.yml name: CI on: push: branches: [ main, develop ] pull_request: branches: [ main ] jobs: test: runs-on: ubuntu-latest services: mysql: image: mysql:8.0 env: MYSQL_ROOT_PASSWORD: mysql MYSQL_DATABASE: side_project_test ports: - 3306:3306 options: \u0026gt;- --health-cmd=\u0026#34;mysqladmin ping\u0026#34; --health-interval=10s --health-timeout=5s --health-retries=3 redis: image: redis:7-alpine ports: - 6379:6379 options: \u0026gt;- --health-cmd=\u0026#34;redis-cli ping\u0026#34; --health-interval=10s --health-timeout=5s --health-retries=3 steps: - uses: actions/checkout@v3 - name: Set up JDK 17 uses: actions/setup-java@v3 with: java-version: \u0026#39;17\u0026#39; distribution: \u0026#39;temurin\u0026#39; - name: Cache Maven dependencies uses: actions/cache@v3 with: path: ~/.m2 key: ${{ runner.os }}-m2-${{ hashFiles(\u0026#39;**/pom.xml\u0026#39;) }} restore-keys: ${{ runner.os }}-m2 - name: Run tests run: mvn clean test env: SPRING_PROFILES_ACTIVE: test DB_HOST: localhost DB_PORT: 3306 DB_NAME: side_project_test DB_USERNAME: root DB_PASSWORD: mysql REDIS_HOST: localhost REDIS_PORT: 6379 - name: Generate test report uses: dorny/test-reporter@v1 if: success() || failure() with: name: Maven Tests path: target/surefire-reports/*.xml reporter: java-junit - name: Upload coverage to Codecov uses: codecov/codecov-action@v3 with: file: ./target/site/jacoco/jacoco.xml - name: SonarCloud Scan uses: SonarSource/sonarcloud-github-action@master env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }} GitHub Actions - CD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # .github/workflows/cd.yml name: CD on: push: branches: [ main ] tags: [ \u0026#39;v*\u0026#39; ] jobs: deploy: runs-on: ubuntu-latest if: github.ref == \u0026#39;refs/heads/main\u0026#39; steps: - uses: actions/checkout@v3 - name: Set up JDK 17 uses: actions/setup-java@v3 with: java-version: \u0026#39;17\u0026#39; distribution: \u0026#39;temurin\u0026#39; - name: Build with Maven run: mvn clean package -DskipTests - name: Build Docker image run: | docker build -t ${{ secrets.REGISTRY_URL }}/side-project:${{ github.sha }} . docker tag ${{ secrets.REGISTRY_URL }}/side-project:${{ github.sha }} ${{ secrets.REGISTRY_URL }}/side-project:latest - name: Login to Container Registry uses: docker/login-action@v2 with: registry: ${{ secrets.REGISTRY_URL }} username: ${{ secrets.REGISTRY_USERNAME }} password: ${{ secrets.REGISTRY_PASSWORD }} - name: Push Docker image run: | docker push ${{ secrets.REGISTRY_URL }}/side-project:${{ github.sha }} docker push ${{ secrets.REGISTRY_URL }}/side-project:latest - name: Deploy to production uses: appleboy/ssh-action@v0.1.5 with: host: ${{ secrets.HOST }} username: ${{ secrets.USERNAME }} key: ${{ secrets.SSH_KEY }} script: | cd /opt/side-project docker-compose pull docker-compose up -d docker system prune -f 部署腳本 建構腳本 - scripts/build.sh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #!/bin/bash # 建構腳本 set -e echo \u0026#34;開始建構 Side Project...\u0026#34; # 清理舊的建構檔案 echo \u0026#34;清理舊的建構檔案...\u0026#34; mvn clean # 執行測試 echo \u0026#34;執行測試...\u0026#34; mvn test # 建構應用程式 echo \u0026#34;建構應用程式...\u0026#34; mvn package -DskipTests # 建構 Docker 映像 echo \u0026#34;建構 Docker 映像...\u0026#34; docker build -t side-project:latest . echo \u0026#34;建構完成！\u0026#34; 部署腳本 - scripts/deploy.sh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #!/bin/bash # 部署腳本 set -e ENVIRONMENT=${1:-dev} VERSION=${2:-latest} echo \u0026#34;部署 Side Project 到 $ENVIRONMENT 環境...\u0026#34; case $ENVIRONMENT in \u0026#34;dev\u0026#34;) echo \u0026#34;部署到開發環境...\u0026#34; docker-compose -f docker-compose.yml up -d ;; \u0026#34;staging\u0026#34;) echo \u0026#34;部署到測試環境...\u0026#34; docker-compose -f docker-compose.staging.yml up -d ;; \u0026#34;prod\u0026#34;) echo \u0026#34;部署到生產環境...\u0026#34; docker-compose -f docker-compose.prod.yml up -d ;; *) echo \u0026#34;未知環境: $ENVIRONMENT\u0026#34; exit 1 ;; esac echo \u0026#34;部署完成！\u0026#34; echo \u0026#34;健康檢查中...\u0026#34; sleep 30 # 健康檢查 for i in {1..5}; do if curl -f http://localhost:8080/actuator/health \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;應用程式健康狀態正常\u0026#34; break else echo \u0026#34;健康檢查失敗，重試中... ($i/5)\u0026#34; sleep 10 fi done 自訂 Banner resources/banner.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 _____ _ _ _____ _ _ / ____(_) | | | __ \\ (_) | | | (___ _ __| | ___ | |__) |____ ___ _ ___ ___| |_ \\___ \\| |/ _` |/ _ \\ | ___/ \u0026#39;__/ _ \\ |/ _ \\/ __| __| ____) | | (_| | __/ | | | | | (_) | | __/ (__| |_ |_____/|_|\\__,_|\\___| |_| |_| \\___/| |\\___|\\___|\\__| _/ | |__/ :: Spring Boot :: (v3.1.5) :: Application Version :: 1.0.0 :: Environment :: ${spring.profiles.active} :: Port :: ${server.port} 最佳實踐與建議 1. 安全性最佳實踐 1 2 3 4 5 6 7 8 9 10 11 12 13 # 生產環境安全配置 security: headers: frame-options: DENY content-type-options: nosniff xss-protection: 1; mode=block referrer-policy: strict-origin-when-cross-origin ssl: enabled: true key-store: /etc/ssl/keystore.p12 key-store-password: ${SSL_KEYSTORE_PASSWORD} key-store-type: PKCS12 2. 效能優化配置 1 2 3 4 5 6 7 8 9 10 11 # JVM 調優 JAVA_OPTS: \u0026gt; -server -Xms1g -Xmx2g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+UseStringDeduplication -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/side-project/ -Dspring.profiles.active=prod 3. 監控與告警 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 自訂監控指標 management: metrics: export: prometheus: enabled: true cloudwatch: enabled: true namespace: SideProject step: 1m distribution: percentiles: http.server.requests: 0.5, 0.95, 0.99 spring.data.repository.invocations: 0.5, 0.95, 0.99 4. 資料庫優化 1 2 3 4 5 6 7 8 9 10 11 # 資料庫連線池優化 spring: datasource: hikari: minimum-idle: 10 maximum-pool-size: 50 idle-timeout: 600000 connection-timeout: 30000 max-lifetime: 1800000 leak-detection-threshold: 60000 connection-test-query: SELECT 1 總結 本文提供了一個完整的 Side Project 企業級配置指南，包含：\n完整的專案結構：標準化的 Maven 專案結構 現代化依賴管理：使用最新的 Spring Boot 3.x 和 Java 17 多環境配置：開發、測試、生產環境的完整配置 安全性配置：JWT、CORS、OAuth2 等安全機制 容器化部署：Docker 和 docker-compose 配置 監控系統：Prometheus、Grafana 監控配置 CI/CD 流程：GitHub Actions 自動化部署 最佳實踐：安全性、效能、監控等方面的建議 這個配置可以作為任何 Side Project 的起點，提供了企業級的可擴展性和可維護性。通過遵循這些最佳實踐，您可以快速建立一個穩定、安全、高效的應用程式。\n","permalink":"https://xinqilin.github.io/post/backend/sideprojectconfig/","tags":["Project Setup","Configuration","Development","Best Practices","Spring Boot","Docker","DevOps","Microservices","CI/CD","Production","Architecture","Infrastructure","Environment","Deployment"],"title":"Side Project 企業級專案配置指南：完整開發環境設定與最佳實踐"},{"content":"概述 Spring Framework 廣泛使用註解（Annotations）來簡化配置和提升開發效率。從 Spring 2.5 開始引入註解驅動配置，到 Spring Boot 的自動配置，註解已成為現代 Spring 應用程式開發的核心。本文將系統性地整理 Spring 生態系統中的重要註解，並提供實用的程式碼範例。\n核心容器註解 1. Bean 定義與管理 @Component 系列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // 通用組件 @Component public class UserValidator { public boolean validate(User user) { return user != null \u0026amp;\u0026amp; user.getEmail() != null; } } // 服務層組件 @Service public class UserService { @Autowired private UserRepository userRepository; public User findById(Long id) { return userRepository.findById(id).orElse(null); } } // 資料存取層組件 @Repository public class UserRepositoryImpl implements UserRepository { @PersistenceContext private EntityManager entityManager; @Override public Optional\u0026lt;User\u0026gt; findById(Long id) { User user = entityManager.find(User.class, id); return Optional.ofNullable(user); } } // Web 層組件 @Controller public class UserController { @Autowired private UserService userService; @GetMapping(\u0026#34;/users/{id}\u0026#34;) @ResponseBody public User getUser(@PathVariable Long id) { return userService.findById(id); } } // RESTful API 控制器 @RestController // 等同於 @Controller + @ResponseBody @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserRestController { @Autowired private UserService userService; @GetMapping(\u0026#34;/{id}\u0026#34;) public User getUser(@PathVariable Long id) { return userService.findById(id); } } @Configuration 和 @Bean 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Configuration @EnableTransactionManagement @ComponentScan(basePackages = \u0026#34;com.example\u0026#34;) public class AppConfiguration { @Bean @Primary // 當有多個相同類型的 Bean 時，優先使用這個 public DataSource primaryDataSource() { HikariDataSource dataSource = new HikariDataSource(); dataSource.setJdbcUrl(\u0026#34;jdbc:mysql://localhost:3306/primary\u0026#34;); dataSource.setUsername(\u0026#34;user\u0026#34;); dataSource.setPassword(\u0026#34;password\u0026#34;); return dataSource; } @Bean @Qualifier(\u0026#34;secondary\u0026#34;) // 使用限定符區分 public DataSource secondaryDataSource() { HikariDataSource dataSource = new HikariDataSource(); dataSource.setJdbcUrl(\u0026#34;jdbc:mysql://localhost:3306/secondary\u0026#34;); dataSource.setUsername(\u0026#34;user\u0026#34;); dataSource.setPassword(\u0026#34;password\u0026#34;); return dataSource; } @Bean @Scope(\u0026#34;prototype\u0026#34;) // 每次注入都創建新實例 public OrderProcessor orderProcessor() { return new OrderProcessor(); } @Bean @Lazy // 延遲初始化 public ExpensiveService expensiveService() { return new ExpensiveService(); } } 2. 依賴注入註解 @Autowired 和相關註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Service public class OrderService { // 建構子注入（推薦） private final PaymentService paymentService; private final EmailService emailService; @Autowired public OrderService(PaymentService paymentService, EmailService emailService) { this.paymentService = paymentService; this.emailService = emailService; } // 可選依賴 @Autowired(required = false) private Optional\u0026lt;SmsService\u0026gt; smsService; // 集合注入 @Autowired private List\u0026lt;NotificationProvider\u0026gt; notificationProviders; // 使用限定符 @Autowired @Qualifier(\u0026#34;primary\u0026#34;) private DataSource primaryDataSource; // JSR-330 標準註解 @Inject // 等同於 @Autowired private AuditService auditService; @Named(\u0026#34;cache\u0026#34;) // 等同於 @Qualifier private CacheManager cacheManager; } @Value 屬性注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @Component public class ConfigurationService { // 基本屬性注入 @Value(\u0026#34;${app.name}\u0026#34;) private String appName; // 預設值 @Value(\u0026#34;${app.timeout:30}\u0026#34;) private int timeout; // 系統屬性 @Value(\u0026#34;#{systemProperties[\u0026#39;user.home\u0026#39;]}\u0026#34;) private String userHome; // SpEL 表達式 @Value(\u0026#34;#{T(java.lang.Math).random() * 100}\u0026#34;) private double randomNumber; // 陣列注入 @Value(\u0026#34;${app.allowed-origins}\u0026#34;) private String[] allowedOrigins; // List 注入 @Value(\u0026#34;#{\u0026#39;${app.features}\u0026#39;.split(\u0026#39;,\u0026#39;)}\u0026#34;) private List\u0026lt;String\u0026gt; features; // Map 注入 @Value(\u0026#34;#{${app.database-config}}\u0026#34;) private Map\u0026lt;String, String\u0026gt; databaseConfig; // 建構子參數注入 public ConfigurationService(@Value(\u0026#34;${app.version}\u0026#34;) String version) { this.version = version; } } Web 相關註解 1. MVC 控制器註解 @RequestMapping 系列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @RestController @RequestMapping(\u0026#34;/api/v1/orders\u0026#34;) @CrossOrigin(origins = \u0026#34;http://localhost:3000\u0026#34;) // CORS 設定 public class OrderController { @Autowired private OrderService orderService; // GET 請求 @GetMapping public Page\u0026lt;Order\u0026gt; getOrders( @RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @RequestParam(defaultValue = \u0026#34;20\u0026#34;) int size, @RequestParam(required = false) String status, Pageable pageable) { return orderService.findOrders(status, pageable); } // 路徑變數 @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;Order\u0026gt; getOrder(@PathVariable Long id) { return orderService.findById(id) .map(order -\u0026gt; ResponseEntity.ok(order)) .orElse(ResponseEntity.notFound().build()); } // POST 請求 @PostMapping @ResponseStatus(HttpStatus.CREATED) public Order createOrder(@RequestBody @Valid CreateOrderRequest request) { return orderService.createOrder(request); } // PUT 請求 @PutMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;Order\u0026gt; updateOrder( @PathVariable Long id, @RequestBody @Valid UpdateOrderRequest request) { return orderService.updateOrder(id, request) .map(order -\u0026gt; ResponseEntity.ok(order)) .orElse(ResponseEntity.notFound().build()); } // DELETE 請求 @DeleteMapping(\u0026#34;/{id}\u0026#34;) @ResponseStatus(HttpStatus.NO_CONTENT) public void deleteOrder(@PathVariable Long id) { orderService.deleteOrder(id); } // 檔案上傳 @PostMapping(\u0026#34;/{id}/attachments\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; uploadAttachment( @PathVariable Long id, @RequestParam(\u0026#34;file\u0026#34;) MultipartFile file) { String fileUrl = orderService.uploadAttachment(id, file); return ResponseEntity.ok(fileUrl); } // 自訂 HTTP 方法 @RequestMapping(value = \u0026#34;/{id}/status\u0026#34;, method = RequestMethod.PATCH) public Order updateOrderStatus( @PathVariable Long id, @RequestBody OrderStatusUpdate statusUpdate) { return orderService.updateStatus(id, statusUpdate); } } 參數處理註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @RestController public class UserController { // 請求頭處理 @GetMapping(\u0026#34;/profile\u0026#34;) public UserProfile getProfile( @RequestHeader(\u0026#34;Authorization\u0026#34;) String authToken, @RequestHeader(value = \u0026#34;User-Agent\u0026#34;, required = false) String userAgent) { return userService.getProfile(authToken); } // Cookie 處理 @GetMapping(\u0026#34;/preferences\u0026#34;) public UserPreferences getPreferences( @CookieValue(name = \u0026#34;sessionId\u0026#34;, required = false) String sessionId) { return userService.getPreferences(sessionId); } // Session 屬性 @PostMapping(\u0026#34;/login\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; login( @RequestBody LoginRequest request, @SessionAttribute(required = false) String captcha, HttpSession session) { if (userService.validateLogin(request, captcha)) { session.setAttribute(\u0026#34;userId\u0026#34;, request.getUsername()); return ResponseEntity.ok(\u0026#34;Login successful\u0026#34;); } return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(\u0026#34;Login failed\u0026#34;); } // Model 屬性 @ModelAttribute(\u0026#34;commonData\u0026#34;) public CommonData getCommonData() { return new CommonData(); } @GetMapping(\u0026#34;/dashboard\u0026#34;) public String dashboard(@ModelAttribute(\u0026#34;commonData\u0026#34;) CommonData commonData) { return \u0026#34;dashboard\u0026#34;; } } 2. 驗證註解 Bean Validation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @RestController @Validated // 開啟驗證 public class UserController { @PostMapping(\u0026#34;/users\u0026#34;) public ResponseEntity\u0026lt;User\u0026gt; createUser(@RequestBody @Valid CreateUserRequest request) { User user = userService.createUser(request); return ResponseEntity.ok(user); } @GetMapping(\u0026#34;/users/{id}\u0026#34;) public User getUser(@PathVariable @Min(1) Long id) { return userService.findById(id); } } // 請求 DTO 與驗證 public class CreateUserRequest { @NotBlank(message = \u0026#34;姓名不能為空\u0026#34;) @Size(min = 2, max = 50, message = \u0026#34;姓名長度必須在 2-50 字元之間\u0026#34;) private String name; @NotBlank(message = \u0026#34;信箱不能為空\u0026#34;) @Email(message = \u0026#34;信箱格式不正確\u0026#34;) private String email; @NotNull(message = \u0026#34;年齡不能為空\u0026#34;) @Min(value = 18, message = \u0026#34;年齡必須大於等於 18\u0026#34;) @Max(value = 120, message = \u0026#34;年齡必須小於等於 120\u0026#34;) private Integer age; @Pattern(regexp = \u0026#34;^\\\\+?[1-9]\\\\d{1,14}$\u0026#34;, message = \u0026#34;電話號碼格式不正確\u0026#34;) private String phone; @Valid // 巢狀物件驗證 private Address address; @NotEmpty(message = \u0026#34;至少要有一個興趣\u0026#34;) private List\u0026lt;@NotBlank String\u0026gt; interests; // getters and setters... } // 自訂驗證註解 @Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) @Constraint(validatedBy = UniqueEmailValidator.class) public @interface UniqueEmail { String message() default \u0026#34;信箱已被使用\u0026#34;; Class\u0026lt;?\u0026gt;[] groups() default {}; Class\u0026lt;? extends Payload\u0026gt;[] payload() default {}; } @Component public class UniqueEmailValidator implements ConstraintValidator\u0026lt;UniqueEmail, String\u0026gt; { @Autowired private UserRepository userRepository; @Override public boolean isValid(String email, ConstraintValidatorContext context) { return email == null || !userRepository.existsByEmail(email); } } 資料存取註解 1. JPA 和 Hibernate 註解 實體定義 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @Entity @Table(name = \u0026#34;users\u0026#34;, indexes = { @Index(name = \u0026#34;idx_email\u0026#34;, columnList = \u0026#34;email\u0026#34;), @Index(name = \u0026#34;idx_created_at\u0026#34;, columnList = \u0026#34;created_at\u0026#34;) }) @EntityListeners(AuditingEntityListener.class) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = \u0026#34;full_name\u0026#34;, nullable = false, length = 100) private String name; @Column(unique = true, nullable = false) private String email; @Enumerated(EnumType.STRING) @Column(name = \u0026#34;user_status\u0026#34;) private UserStatus status = UserStatus.ACTIVE; @CreatedDate @Column(name = \u0026#34;created_at\u0026#34;, updatable = false) private LocalDateTime createdAt; @LastModifiedDate @Column(name = \u0026#34;updated_at\u0026#34;) private LocalDateTime updatedAt; @CreatedBy @Column(name = \u0026#34;created_by\u0026#34;, updatable = false) private String createdBy; @LastModifiedBy @Column(name = \u0026#34;updated_by\u0026#34;) private String updatedBy; // 一對多關係 @OneToMany(mappedBy = \u0026#34;user\u0026#34;, cascade = CascadeType.ALL, orphanRemoval = true) @JsonIgnore private List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;(); // 多對一關係 @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;department_id\u0026#34;) private Department department; // 多對多關係 @ManyToMany @JoinTable( name = \u0026#34;user_roles\u0026#34;, joinColumns = @JoinColumn(name = \u0026#34;user_id\u0026#34;), inverseJoinColumns = @JoinColumn(name = \u0026#34;role_id\u0026#34;) ) private Set\u0026lt;Role\u0026gt; roles = new HashSet\u0026lt;\u0026gt;(); // 版本控制（樂觀鎖定） @Version private Long version; // getters and setters... } Repository 介面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt;, JpaSpecificationExecutor\u0026lt;User\u0026gt; { // 查詢方法名稱規則 Optional\u0026lt;User\u0026gt; findByEmail(String email); List\u0026lt;User\u0026gt; findByStatusAndCreatedAtAfter(UserStatus status, LocalDateTime date); Page\u0026lt;User\u0026gt; findByNameContainingIgnoreCase(String name, Pageable pageable); // 自訂查詢 @Query(\u0026#34;SELECT u FROM User u WHERE u.email = ?1 AND u.status = ?2\u0026#34;) Optional\u0026lt;User\u0026gt; findByEmailAndStatus(String email, UserStatus status); // 命名參數 @Query(\u0026#34;SELECT u FROM User u WHERE u.name LIKE %:name% ORDER BY u.createdAt DESC\u0026#34;) List\u0026lt;User\u0026gt; findByNameContaining(@Param(\u0026#34;name\u0026#34;) String name); // 原生 SQL @Query(value = \u0026#34;SELECT * FROM users WHERE email = ?1\u0026#34;, nativeQuery = true) User findByEmailNative(String email); // 更新查詢 @Modifying @Query(\u0026#34;UPDATE User u SET u.status = :status WHERE u.id = :id\u0026#34;) int updateUserStatus(@Param(\u0026#34;id\u0026#34;) Long id, @Param(\u0026#34;status\u0026#34;) UserStatus status); // 刪除查詢 @Modifying @Query(\u0026#34;DELETE FROM User u WHERE u.status = :status\u0026#34;) void deleteByStatus(@Param(\u0026#34;status\u0026#34;) UserStatus status); // 投影查詢 @Query(\u0026#34;SELECT new com.example.dto.UserSummary(u.id, u.name, u.email) FROM User u\u0026#34;) List\u0026lt;UserSummary\u0026gt; findUserSummaries(); // 計數查詢 long countByStatus(UserStatus status); boolean existsByEmail(String email); } 2. 交易管理 @Transactional 註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Service @Transactional // 類別層級的交易設定 public class OrderService { @Autowired private OrderRepository orderRepository; @Autowired private PaymentService paymentService; @Autowired private InventoryService inventoryService; // 預設交易設定 public Order createOrder(CreateOrderRequest request) { Order order = new Order(request); order = orderRepository.save(order); // 這些操作都在同一個交易中 paymentService.processPayment(order); inventoryService.updateStock(order.getItems()); return order; } // 唯讀交易（效能優化） @Transactional(readOnly = true) public List\u0026lt;Order\u0026gt; findOrdersByUser(Long userId) { return orderRepository.findByUserId(userId); } // 指定傳播行為 @Transactional(propagation = Propagation.REQUIRES_NEW) public void logOrderEvent(Long orderId, String event) { // 這個方法總是在新的交易中執行 OrderEvent orderEvent = new OrderEvent(orderId, event); orderEventRepository.save(orderEvent); } // 指定隔離級別 @Transactional(isolation = Isolation.SERIALIZABLE) public void processHighValueOrder(Order order) { // 序列化隔離級別，避免併發問題 processOrder(order); } // 異常回滾設定 @Transactional(rollbackFor = {Exception.class}, noRollbackFor = {ValidationException.class}) public void complexOperation() { // 遇到任何 Exception 都回滾，除了 ValidationException } // 超時設定 @Transactional(timeout = 30) // 30 秒超時 public void longRunningOperation() { // 長時間運行的操作 } // 指定交易管理器 @Transactional(transactionManager = \u0026#34;secondaryTransactionManager\u0026#34;) public void operationOnSecondaryDatabase() { // 使用指定的交易管理器 } } 排程和非同步處理 1. 排程任務註解 @Scheduled 和 @EnableScheduling 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 @Configuration @EnableScheduling public class SchedulingConfig { @Bean public TaskScheduler taskScheduler() { ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.setPoolSize(10); scheduler.setThreadNamePrefix(\u0026#34;scheduled-task-\u0026#34;); scheduler.initialize(); return scheduler; } } @Component @Slf4j public class ScheduledTasks { @Autowired private OrderService orderService; @Autowired private EmailService emailService; // 固定延遲執行（上次執行完成後多久再執行） @Scheduled(fixedDelay = 5000) // 5 秒 public void processOrders() { log.info(\u0026#34;處理待處理訂單\u0026#34;); orderService.processePendingOrders(); } // 固定頻率執行（固定間隔執行） @Scheduled(fixedRate = 10000) // 10 秒 public void heartbeat() { log.info(\u0026#34;系統心跳檢查\u0026#34;); // 系統健康檢查邏輯 } // 初始延遲 @Scheduled(fixedDelay = 30000, initialDelay = 60000) // 1 分鐘後開始，然後每 30 秒執行 public void cleanupTempFiles() { log.info(\u0026#34;清理暫存檔案\u0026#34;); // 清理邏輯 } // Cron 表達式 - 每分鐘執行 @Scheduled(cron = \u0026#34;0 * * * * *\u0026#34;) public void everyMinute() { log.info(\u0026#34;每分鐘執行的任務\u0026#34;); } // Cron 表達式 - 每天凌晨 2 點執行 @Scheduled(cron = \u0026#34;0 0 2 * * *\u0026#34;) public void dailyReport() { log.info(\u0026#34;產生每日報告\u0026#34;); emailService.sendDailyReport(); } // Cron 表達式 - 工作日上午 9 點執行 @Scheduled(cron = \u0026#34;0 0 9 * * MON-FRI\u0026#34;) public void workdayMorningTask() { log.info(\u0026#34;工作日早晨任務\u0026#34;); } // Cron 表達式 - 每月最後一天執行 @Scheduled(cron = \u0026#34;0 0 0 L * *\u0026#34;) public void monthlyTask() { log.info(\u0026#34;月末任務\u0026#34;); } // 使用配置屬性 @Scheduled(cron = \u0026#34;${app.cleanup.cron:0 0 3 * * *}\u0026#34;) // 預設每天凌晨 3 點 public void configuredTask() { log.info(\u0026#34;可配置的排程任務\u0026#34;); } // 條件性排程 @Scheduled(fixedDelay = 60000) @ConditionalOnProperty(name = \u0026#34;app.monitoring.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public void monitoringTask() { log.info(\u0026#34;監控任務\u0026#34;); } } Cron 表達式詳解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /** * Cron 表達式格式：秒 分 時 日 月 週 * * 欄位說明： * - 秒：0-59 * - 分：0-59 * - 時：0-23 * - 日：1-31 * - 月：1-12 或 JAN-DEC * - 週：0-7 或 SUN-SAT (0 和 7 都代表週日) * * 特殊字符： * * : 匹配任意值 * ? : 只能用在日和週，表示不指定值 * - : 表示範圍 (例如：1-5) * , : 表示列舉 (例如：1,3,5) * / : 表示增量 (例如：0/15 表示從 0 開始每 15 分鐘) * L : 表示最後 (例如：L 在日欄位表示該月最後一天) * W : 表示工作日 (例如：15W 表示距離 15 號最近的工作日) * # : 表示第幾個週幾 (例如：6#3 表示第三個週五) */ @Component public class CronExamples { @Scheduled(cron = \u0026#34;0 0 * * * *\u0026#34;) // 每小時整點執行 public void hourly() {} @Scheduled(cron = \u0026#34;*/10 * * * * *\u0026#34;) // 每 10 秒執行 public void every10Seconds() {} @Scheduled(cron = \u0026#34;0 0 8-18 * * *\u0026#34;) // 每天 8-18 點整點執行 public void businessHours() {} @Scheduled(cron = \u0026#34;0 0/30 8-18 * * *\u0026#34;) // 每天 8-18 點每半小時執行 public void businessHalfHour() {} @Scheduled(cron = \u0026#34;0 0 9-17 * * MON-FRI\u0026#34;) // 工作日 9-17 點整點執行 public void workingHours() {} @Scheduled(cron = \u0026#34;0 0 0 25 12 ?\u0026#34;) // 每年聖誕節 00:00 執行 public void christmas() {} @Scheduled(cron = \u0026#34;0 0 0 L * *\u0026#34;) // 每月最後一天 00:00 執行 public void lastDayOfMonth() {} @Scheduled(cron = \u0026#34;0 0 0 LW * *\u0026#34;) // 每月最後一個工作日 00:00 執行 public void lastWorkdayOfMonth() {} @Scheduled(cron = \u0026#34;0 0 0 * * 1#1\u0026#34;) // 每月第一個週一 00:00 執行 public void firstMondayOfMonth() {} } 2. 非同步處理註解 @Async 和 @EnableAsync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 @Configuration @EnableAsync public class AsyncConfig implements AsyncConfigurer { @Override @Bean(name = \u0026#34;taskExecutor\u0026#34;) public Executor getAsyncExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(5); executor.setMaxPoolSize(20); executor.setQueueCapacity(100); executor.setThreadNamePrefix(\u0026#34;async-task-\u0026#34;); executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); executor.initialize(); return executor; } @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() { return (ex, method, params) -\u0026gt; { log.error(\u0026#34;非同步方法 {} 執行異常\u0026#34;, method.getName(), ex); }; } } @Service @Slf4j public class NotificationService { // 簡單非同步方法 @Async public void sendEmail(String to, String subject, String content) { log.info(\u0026#34;發送郵件到 {}\u0026#34;, to); // 模擬郵件發送 try { Thread.sleep(2000); log.info(\u0026#34;郵件發送完成\u0026#34;); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } // 返回 CompletableFuture @Async public CompletableFuture\u0026lt;String\u0026gt; sendSms(String phone, String message) { log.info(\u0026#34;發送簡訊到 {}\u0026#34;, phone); try { Thread.sleep(1000); return CompletableFuture.completedFuture(\u0026#34;簡訊發送成功\u0026#34;); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return CompletableFuture.failedFuture(e); } } // 指定執行器 @Async(\u0026#34;taskExecutor\u0026#34;) public CompletableFuture\u0026lt;Boolean\u0026gt; processLargeFile(String filePath) { log.info(\u0026#34;開始處理大檔案：{}\u0026#34;, filePath); try { // 模擬檔案處理 Thread.sleep(5000); log.info(\u0026#34;檔案處理完成：{}\u0026#34;, filePath); return CompletableFuture.completedFuture(true); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return CompletableFuture.failedFuture(e); } } // 批量非同步處理 public CompletableFuture\u0026lt;Void\u0026gt; sendBulkNotifications(List\u0026lt;User\u0026gt; users, String message) { List\u0026lt;CompletableFuture\u0026lt;Void\u0026gt;\u0026gt; futures = users.stream() .map(user -\u0026gt; sendNotificationAsync(user, message)) .collect(Collectors.toList()); return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])); } @Async private CompletableFuture\u0026lt;Void\u0026gt; sendNotificationAsync(User user, String message) { // 發送通知邏輯 return CompletableFuture.completedFuture(null); } } Spring Boot 特定註解 1. 自動配置註解 @SpringBootApplication 分解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // @SpringBootApplication 等同於以下三個註解的組合： // @Configuration + @EnableAutoConfiguration + @ComponentScan @SpringBootApplication // 等同於： // @Configuration // @EnableAutoConfiguration // @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), // @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } // 自訂掃描配置 @SpringBootApplication( scanBasePackages = {\u0026#34;com.example.app\u0026#34;, \u0026#34;com.example.shared\u0026#34;}, exclude = {DataSourceAutoConfiguration.class} // 排除特定自動配置 ) public class CustomApplication { public static void main(String[] args) { SpringApplication.run(CustomApplication.class, args); } } 條件註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @Configuration public class ConditionalConfiguration { // 當類別存在時 @Bean @ConditionalOnClass(RedisTemplate.class) public RedisService redisService() { return new RedisService(); } // 當類別不存在時 @Bean @ConditionalOnMissingClass(\u0026#34;com.example.CustomService\u0026#34;) public DefaultService defaultService() { return new DefaultService(); } // 當 Bean 存在時 @Bean @ConditionalOnBean(DataSource.class) public JdbcTemplate jdbcTemplate(DataSource dataSource) { return new JdbcTemplate(dataSource); } // 當 Bean 不存在時 @Bean @ConditionalOnMissingBean(EmailService.class) public EmailService mockEmailService() { return new MockEmailService(); } // 當屬性存在且符合條件時 @Bean @ConditionalOnProperty(name = \u0026#34;app.cache.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;, matchIfMissing = false) public CacheManager cacheManager() { return new ConcurrentMapCacheManager(); } // 當 Web 應用程式時 @Bean @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) public WebMvcConfigurer webMvcConfigurer() { return new CustomWebMvcConfigurer(); } // 當非 Web 應用程式時 @Bean @ConditionalOnNotWebApplication public CommandLineRunner commandLineRunner() { return args -\u0026gt; System.out.println(\u0026#34;Non-web application started\u0026#34;); } // 當特定 Profile 啟用時 @Bean @Profile(\u0026#34;development\u0026#34;) public DataSource devDataSource() { return new H2DataSource(); } @Bean @Profile(\u0026#34;production\u0026#34;) public DataSource prodDataSource() { return new MySQLDataSource(); } // 自訂條件 @Bean @ConditionalOnCustomCondition public CustomService customService() { return new CustomService(); } } // 自訂條件實作 public class CustomCondition implements Condition { @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { // 自訂條件邏輯 String osName = context.getEnvironment().getProperty(\u0026#34;os.name\u0026#34;); return osName != null \u0026amp;\u0026amp; osName.toLowerCase().contains(\u0026#34;windows\u0026#34;); } } @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Conditional(CustomCondition.class) public @interface ConditionalOnCustomCondition { } 2. 配置屬性註解 @ConfigurationProperties 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @ConfigurationProperties(prefix = \u0026#34;app\u0026#34;) @Component @Validated @Data public class AppProperties { @NotBlank private String name; @NotBlank private String version; @Valid private Database database = new Database(); @Valid private Cache cache = new Cache(); private List\u0026lt;String\u0026gt; allowedOrigins = new ArrayList\u0026lt;\u0026gt;(); private Map\u0026lt;String, String\u0026gt; headers = new HashMap\u0026lt;\u0026gt;(); @Data public static class Database { @NotBlank private String url; @NotBlank private String username; @NotBlank private String password; @Min(1) @Max(100) private int maxConnections = 10; @DurationMin(seconds = 1) @DurationMax(minutes = 5) private Duration timeout = Duration.ofSeconds(30); } @Data public static class Cache { private boolean enabled = true; @Positive private int maxSize = 1000; @DurationMin(minutes = 1) private Duration ttl = Duration.ofMinutes(10); private CacheType type = CacheType.MEMORY; } public enum CacheType { MEMORY, REDIS, HAZELCAST } } // 使用配置 @Service @RequiredArgsConstructor public class AppService { private final AppProperties appProperties; public void printConfig() { System.out.println(\u0026#34;App Name: \u0026#34; + appProperties.getName()); System.out.println(\u0026#34;Database URL: \u0026#34; + appProperties.getDatabase().getUrl()); System.out.println(\u0026#34;Cache Enabled: \u0026#34; + appProperties.getCache().isEnabled()); } } 快取註解 @EnableCaching 和快取操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 @Configuration @EnableCaching public class CacheConfig { @Bean public CacheManager cacheManager() { ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager(); cacheManager.setAllowNullValues(false); return cacheManager; } } @Service @Slf4j public class UserService { @Autowired private UserRepository userRepository; // 快取結果 @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;) public User findById(Long id) { log.info(\u0026#34;從資料庫載入使用者：{}\u0026#34;, id); return userRepository.findById(id).orElse(null); } // 條件快取 @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#email\u0026#34;, condition = \u0026#34;#email.length() \u0026gt; 5\u0026#34;) public User findByEmail(String email) { return userRepository.findByEmail(email).orElse(null); } // 快取多個值 @Cacheable(value = \u0026#34;userProfiles\u0026#34;, key = \u0026#34;#user.id\u0026#34;, unless = \u0026#34;#result.isEmpty()\u0026#34;) public List\u0026lt;UserProfile\u0026gt; getUserProfiles(User user) { return userProfileRepository.findByUserId(user.getId()); } // 更新快取 @CachePut(value = \u0026#34;users\u0026#34;, key = \u0026#34;#user.id\u0026#34;) public User updateUser(User user) { log.info(\u0026#34;更新使用者並刷新快取：{}\u0026#34;, user.getId()); return userRepository.save(user); } // 清除快取 @CacheEvict(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;) public void deleteUser(Long id) { log.info(\u0026#34;刪除使用者並清除快取：{}\u0026#34;, id); userRepository.deleteById(id); } // 清除所有快取 @CacheEvict(value = \u0026#34;users\u0026#34;, allEntries = true) public void clearUserCache() { log.info(\u0026#34;清除所有使用者快取\u0026#34;); } // 組合快取操作 @Caching( cacheable = @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;), evict = @CacheEvict(value = \u0026#34;userStats\u0026#34;, key = \u0026#34;#id\u0026#34;) ) public User findAndUpdateStats(Long id) { User user = userRepository.findById(id).orElse(null); if (user != null) { updateUserStats(user); } return user; } // 自訂快取鍵生成器 @Cacheable(value = \u0026#34;userSearch\u0026#34;, keyGenerator = \u0026#34;customKeyGenerator\u0026#34;) public List\u0026lt;User\u0026gt; searchUsers(UserSearchCriteria criteria) { return userRepository.findByCriteria(criteria); } } @Component(\u0026#34;customKeyGenerator\u0026#34;) public class CustomKeyGenerator implements KeyGenerator { @Override public Object generate(Object target, Method method, Object... params) { return method.getName() + \u0026#34;_\u0026#34; + Arrays.toString(params); } } 測試註解 Spring Boot 測試註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 // 完整的 Spring Boot 測試 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @TestPropertySource(properties = { \u0026#34;spring.datasource.url=jdbc:h2:mem:testdb\u0026#34;, \u0026#34;spring.jpa.hibernate.ddl-auto=create-drop\u0026#34; }) class IntegrationTest { @Autowired private TestRestTemplate restTemplate; @Autowired private UserService userService; @Test void testCreateUser() { CreateUserRequest request = new CreateUserRequest(\u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.postForEntity(\u0026#34;/api/users\u0026#34;, request, User.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED); assertThat(response.getBody().getName()).isEqualTo(\u0026#34;John\u0026#34;); } } // Web 層測試 @WebMvcTest(UserController.class) class UserControllerTest { @Autowired private MockMvc mockMvc; @MockBean private UserService userService; @Test void testGetUser() throws Exception { User user = new User(1L, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); when(userService.findById(1L)).thenReturn(user); mockMvc.perform(get(\u0026#34;/api/users/1\u0026#34;)) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.name\u0026#34;).value(\u0026#34;John\u0026#34;)) .andExpect(jsonPath(\u0026#34;$.email\u0026#34;).value(\u0026#34;john@example.com\u0026#34;)); } } // 資料層測試 @DataJpaTest class UserRepositoryTest { @Autowired private TestEntityManager entityManager; @Autowired private UserRepository userRepository; @Test void testFindByEmail() { // Given User user = new User(\u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); entityManager.persistAndFlush(user); // When Optional\u0026lt;User\u0026gt; found = userRepository.findByEmail(\u0026#34;john@example.com\u0026#34;); // Then assertThat(found).isPresent(); assertThat(found.get().getName()).isEqualTo(\u0026#34;John\u0026#34;); } } // JSON 序列化測試 @JsonTest class UserJsonTest { @Autowired private JacksonTester\u0026lt;User\u0026gt; json; @Test void testSerialize() throws Exception { User user = new User(1L, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); assertThat(json.write(user)).isEqualToJson(\u0026#34;user.json\u0026#34;); assertThat(json.write(user)).hasJsonPathStringValue(\u0026#34;@.name\u0026#34;); assertThat(json.write(user)).extractingJsonPathStringValue(\u0026#34;@.name\u0026#34;).isEqualTo(\u0026#34;John\u0026#34;); } @Test void testDeserialize() throws Exception { String content = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34; } \u0026#34;\u0026#34;\u0026#34;; assertThat(json.parse(content)).usingRecursiveComparison() .isEqualTo(new User(1L, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;)); } } 事件處理註解 @EventListener 和 @TransactionalEventListener 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // 事件定義 public class OrderCreatedEvent { private final Order order; private final LocalDateTime timestamp; public OrderCreatedEvent(Order order) { this.order = order; this.timestamp = LocalDateTime.now(); } // getters... } // 事件發布 @Service @RequiredArgsConstructor public class OrderService { private final OrderRepository orderRepository; private final ApplicationEventPublisher eventPublisher; @Transactional public Order createOrder(CreateOrderRequest request) { Order order = new Order(request); order = orderRepository.save(order); // 發布事件 eventPublisher.publishEvent(new OrderCreatedEvent(order)); return order; } } // 事件監聽 @Component @Slf4j public class OrderEventListener { @Autowired private EmailService emailService; @Autowired private InventoryService inventoryService; // 基本事件監聽 @EventListener public void handleOrderCreated(OrderCreatedEvent event) { log.info(\u0026#34;訂單創建事件：{}\u0026#34;, event.getOrder().getId()); } // 條件事件監聽 @EventListener(condition = \u0026#34;#event.order.amount \u0026gt; 1000\u0026#34;) public void handleHighValueOrder(OrderCreatedEvent event) { log.info(\u0026#34;高價值訂單創建：{}\u0026#34;, event.getOrder().getId()); // 特殊處理邏輯 } // 非同步事件處理 @EventListener @Async public void sendOrderConfirmationEmail(OrderCreatedEvent event) { log.info(\u0026#34;發送訂單確認郵件：{}\u0026#34;, event.getOrder().getId()); emailService.sendOrderConfirmation(event.getOrder()); } // 交易事件監聽（在交易提交後執行） @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT) public void updateInventoryAfterOrderCreated(OrderCreatedEvent event) { log.info(\u0026#34;交易提交後更新庫存：{}\u0026#34;, event.getOrder().getId()); inventoryService.updateStock(event.getOrder().getItems()); } // 交易回滾時執行 @TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK) public void handleOrderCreationRollback(OrderCreatedEvent event) { log.warn(\u0026#34;訂單創建回滾：{}\u0026#34;, event.getOrder().getId()); // 回滾處理邏輯 } // 監聽多種事件類型 @EventListener({OrderCreatedEvent.class, OrderUpdatedEvent.class}) public void handleOrderEvents(Object event) { log.info(\u0026#34;處理訂單事件：{}\u0026#34;, event.getClass().getSimpleName()); } } 總結 Spring Framework 的註解系統為開發者提供了強大且靈活的配置方式。透過合理使用這些註解，可以大幅簡化配置工作並提升開發效率。\n最佳實踐建議 優先使用註解配置：相比 XML 配置，註解更直觀且易於維護 組合使用註解：善用 @SpringBootApplication 等組合註解 適當使用條件註解：根據環境動態配置 Bean 驗證配置屬性：使用 @Validated 確保配置正確性 合理使用快取：在適當的地方使用快取提升效能 測試覆蓋：使用專門的測試註解進行各層測試 事件驅動設計：使用事件機制降低組件耦合度 注意事項 註解過載：避免在單一類別或方法上使用過多註解 配置外部化：敏感配置應使用外部屬性檔案 效能考量：注意代理模式可能帶來的效能影響 測試友善：設計時考慮測試的便利性 掌握這些註解的正確使用方式，將能大幅提升 Spring 應用程式的開發效率和程式碼品質。\n參考資料 Spring Framework Reference Documentation Spring Boot Reference Guide Spring Data JPA Reference Bean Validation Specification Cron Expression Generator ","permalink":"https://xinqilin.github.io/post/backend/springannotation/","tags":["Java","Spring","Annotation","Spring-Boot","Configuration","Web","Data","Security"],"title":"Spring Framework 註解完整指南：從基礎到進階應用"},{"content":"概述 AWK 是一種強大的模式掃描和處理語言，由 Alfred Aho、Peter Weinberger 和 Brian Kernighan 於 1977 年在貝爾實驗室開發。AWK 特別適合處理結構化文本資料，能夠進行複雜的文本分析、報表生成和資料提取。\n核心特徵 模式-動作程式設計：基於模式匹配執行相應動作 自動欄位分割：自動將輸入行分割為欄位 強大的內建變數：提供豐富的環境資訊 數學運算能力：支援完整的算術和字串操作 正規表達式支援：強大的模式匹配功能 基本語法 1 2 3 awk \u0026#39;pattern { action }\u0026#39; file(s) awk -f script.awk file(s) command | awk \u0026#39;pattern { action }\u0026#39; AWK 程式結構 1 2 3 awk \u0026#39;BEGIN { 初始化動作 } pattern { 主要處理動作 } END { 結束動作 }\u0026#39; file 基本範例 1 2 3 4 5 6 7 8 9 10 11 # 列印整個檔案 awk \u0026#39;{print}\u0026#39; file.txt # 等同於 awk \u0026#39;{print $0}\u0026#39; file.txt # 列印特定欄位 awk \u0026#39;{print $1, $3}\u0026#39; file.txt # 列印第1和第3欄位 # 簡單過濾 awk \u0026#39;/pattern/ {print}\u0026#39; file.txt # 列印包含 pattern 的行 # 計算統計 awk \u0026#39;{sum += $1} END {print sum}\u0026#39; file.txt # 計算第1欄位總和 欄位和記錄 欄位處理 AWK 自動將每行輸入分割為欄位，預設分隔符為空白字元：\n1 2 3 4 5 6 7 8 9 10 11 # 欄位變數 $0 # 整行內容 $1 # 第1個欄位 $2 # 第2個欄位 $NF # 最後一個欄位 $(NF-1) # 倒數第2個欄位 # 實際範例 echo \u0026#34;apple banana cherry\u0026#34; | awk \u0026#39;{print $2}\u0026#39; # banana echo \u0026#34;1 2 3 4 5\u0026#34; | awk \u0026#39;{print $NF}\u0026#39; # 5 echo \u0026#34;a:b:c:d\u0026#34; | awk -F: \u0026#39;{print $3}\u0026#39; # c 自訂分隔符 1 2 3 4 5 6 7 8 # 使用 -F 選項 awk -F: \u0026#39;{print $1, $3}\u0026#39; /etc/passwd # 使用冒號作分隔符 awk -F\u0026#39;,\u0026#39; \u0026#39;{print $2}\u0026#39; data.csv # CSV 檔案處理 awk -F\u0026#39;[,:]\u0026#39; \u0026#39;{print $1, $3}\u0026#39; file.txt # 多個分隔符 # 在程式中設定 awk \u0026#39;BEGIN {FS=\u0026#34;,\u0026#34;} {print $1, $2}\u0026#39; data.csv # 在 BEGIN 中設定 awk \u0026#39;{FS=\u0026#34;,\u0026#34;} NR\u0026gt;1 {print $1, $2}\u0026#39; data.csv # 動態改變分隔符 輸出欄位分隔符 1 2 3 4 5 6 7 # 設定輸出分隔符 awk \u0026#39;BEGIN {OFS=\u0026#34;\\t\u0026#34;} {print $1, $2, $3}\u0026#39; file.txt # 使用 tab 分隔輸出 awk \u0026#39;BEGIN {OFS=\u0026#34; | \u0026#34;} {print $1, $2}\u0026#39; file.txt # 使用 \u0026#34; | \u0026#34; 分隔 # 重建行 awk \u0026#39;{$1=$1; print}\u0026#39; file.txt # 重新格式化空白 awk \u0026#39;BEGIN {OFS=\u0026#34;,\u0026#34;} {$1=$1; print}\u0026#39; file.txt # 轉換為 CSV 格式 內建變數 核心內建變數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 記錄相關 NR # 總記錄數（行號） FNR # 當前檔案的記錄數 NF # 當前記錄的欄位數 # 分隔符相關 FS # 輸入欄位分隔符 OFS # 輸出欄位分隔符 RS # 輸入記錄分隔符 ORS # 輸出記錄分隔符 # 檔案相關 FILENAME # 當前處理的檔案名 ARGC # 命令行參數個數 ARGV # 命令行參數陣列 實用範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 使用 NR 添加行號 awk \u0026#39;{print NR, $0}\u0026#39; file.txt # 使用 NF 檢查欄位數 awk \u0026#39;NF != 3 {print \u0026#34;Line \u0026#34; NR \u0026#34; has \u0026#34; NF \u0026#34; fields\u0026#34;}\u0026#39; file.txt # 處理多個檔案時使用 FNR awk \u0026#39;{print FILENAME, FNR, $0}\u0026#39; file1.txt file2.txt # 使用 ARGC 和 ARGV awk \u0026#39;BEGIN { print \u0026#34;Total arguments:\u0026#34;, ARGC for (i=0; i\u0026lt;ARGC; i++) print \u0026#34;ARGV[\u0026#34; i \u0026#34;]:\u0026#34;, ARGV[i] }\u0026#39; file1 file2 特殊變數 1 2 3 4 5 6 7 8 9 10 11 # 數字格式 OFMT # 數字輸出格式（預設 \u0026#34;%.6g\u0026#34;） CONVFMT # 字串轉換格式 # 模式匹配 RSTART # match() 函數匹配的起始位置 RLENGTH # match() 函數匹配的長度 # 其他 SUBSEP # 下標分隔符（用於多維陣列） ENVIRON # 環境變數陣列 模式匹配 基本模式 1 2 3 4 5 6 7 8 9 10 11 12 13 # 正規表達式模式 awk \u0026#39;/pattern/ {print}\u0026#39; file.txt # 匹配包含 pattern 的行 awk \u0026#39;/^[0-9]/ {print}\u0026#39; file.txt # 匹配以數字開頭的行 awk \u0026#39;/\\.txt$/ {print}\u0026#39; file.txt # 匹配以 .txt 結尾的行 # 關係表達式模式 awk \u0026#39;$1 \u0026gt; 100 {print}\u0026#39; file.txt # 第1欄位 \u0026gt; 100 awk \u0026#39;NF == 5 {print}\u0026#39; file.txt # 有5個欄位的行 awk \u0026#39;length($0) \u0026gt; 80 {print}\u0026#39; file.txt # 行長度 \u0026gt; 80 # 範圍模式 awk \u0026#39;/start/,/end/ {print}\u0026#39; file.txt # 從 start 到 end 的行 awk \u0026#39;NR==5,NR==10 {print}\u0026#39; file.txt # 第5到10行 進階模式 1 2 3 4 5 6 7 8 9 10 11 # 組合模式 awk \u0026#39;/error/ \u0026amp;\u0026amp; $3 \u0026gt; 100 {print}\u0026#39; file.txt # AND 條件 awk \u0026#39;/warn/ || /error/ {print}\u0026#39; file.txt # OR 條件 awk \u0026#39;!/debug/ {print}\u0026#39; file.txt # NOT 條件 # 欄位模式匹配 awk \u0026#39;$2 ~ /pattern/ {print}\u0026#39; file.txt # 第2欄位匹配 pattern awk \u0026#39;$1 !~ /^[0-9]/ {print}\u0026#39; file.txt # 第1欄位不以數字開頭 # 複雜條件 awk \u0026#39;$1==\u0026#34;ERROR\u0026#34; \u0026amp;\u0026amp; $3\u0026gt;threshold {count++} END {print count}\u0026#39; file.txt 動作和控制結構 基本動作 1 2 3 4 5 6 7 8 # 列印動作 awk \u0026#39;{print}\u0026#39; file.txt # 列印整行 awk \u0026#39;{print $1, $2}\u0026#39; file.txt # 列印特定欄位 awk \u0026#39;{printf \u0026#34;%s: %d\\n\u0026#34;, $1, $2}\u0026#39; file.txt # 格式化列印 # 賦值動作 awk \u0026#39;{$1=\u0026#34;NEW\u0026#34;; print}\u0026#39; file.txt # 修改欄位值 awk \u0026#39;{sum += $1} END {print sum}\u0026#39; file.txt # 累加計算 控制結構 if-else 語句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 基本 if 語句 awk \u0026#39;{ if ($1 \u0026gt; 100) print \u0026#34;Large:\u0026#34;, $0 else print \u0026#34;Small:\u0026#34;, $0 }\u0026#39; file.txt # 多重條件 awk \u0026#39;{ if ($1 \u0026gt;= 90) grade = \u0026#34;A\u0026#34; else if ($1 \u0026gt;= 80) grade = \u0026#34;B\u0026#34; else if ($1 \u0026gt;= 70) grade = \u0026#34;C\u0026#34; else grade = \u0026#34;F\u0026#34; print $0, grade }\u0026#39; scores.txt 迴圈結構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # for 迴圈 awk \u0026#39;{ for (i=1; i\u0026lt;=NF; i++) { print \u0026#34;Field \u0026#34; i \u0026#34;:\u0026#34;, $i } }\u0026#39; file.txt # while 迴圈 awk \u0026#39;{ i = 1 while (i \u0026lt;= NF) { print $i i++ } }\u0026#39; file.txt # for-in 迴圈（陣列） awk \u0026#39;{ for (i in array) { print i, array[i] } }\u0026#39; file.txt 函數應用 字串函數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # length() - 字串長度 awk \u0026#39;{print length($0)}\u0026#39; file.txt # 每行長度 awk \u0026#39;length($0) \u0026gt; 80\u0026#39; file.txt # 長度超過80的行 # substr() - 子字串 awk \u0026#39;{print substr($1, 1, 3)}\u0026#39; file.txt # 第1欄位前3個字元 awk \u0026#39;{print substr($0, 5)}\u0026#39; file.txt # 從第5個字元開始 # index() - 查找位置 awk \u0026#39;{print index($0, \u0026#34;pattern\u0026#34;)}\u0026#39; file.txt # pattern 的位置 # split() - 分割字串 awk \u0026#39;{n=split($0, array, \u0026#34;,\u0026#34;); print n}\u0026#39; file.txt # 用逗號分割 # gsub() 和 sub() - 替換 awk \u0026#39;{gsub(/old/, \u0026#34;new\u0026#34;); print}\u0026#39; file.txt # 全域替換 awk \u0026#39;{sub(/old/, \u0026#34;new\u0026#34;); print}\u0026#39; file.txt # 只替換第一個 # tolower() 和 toupper() - 大小寫轉換 awk \u0026#39;{print tolower($0)}\u0026#39; file.txt # 轉小寫 awk \u0026#39;{print toupper($1)}\u0026#39; file.txt # 第1欄位轉大寫 數學函數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 基本數學函數 awk \u0026#39;{print sqrt($1)}\u0026#39; file.txt # 平方根 awk \u0026#39;{print int($1)}\u0026#39; file.txt # 取整數 awk \u0026#39;{print sin($1), cos($1)}\u0026#39; file.txt # 三角函數 # 統計函數 awk \u0026#39;{ sum += $1 count++ } END { print \u0026#34;Average:\u0026#34;, sum/count print \u0026#34;Total:\u0026#34;, sum }\u0026#39; file.txt # 最大值和最小值 awk \u0026#39;{ if (NR==1 || $1 \u0026gt; max) max = $1 if (NR==1 || $1 \u0026lt; min) min = $1 } END { print \u0026#34;Max:\u0026#34;, max, \u0026#34;Min:\u0026#34;, min }\u0026#39; file.txt 自訂函數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 定義函數 awk \u0026#39; function factorial(n) { if (n \u0026lt;= 1) return 1 return n * factorial(n-1) } { print $1, factorial($1) }\u0026#39; file.txt # 字串處理函數 awk \u0026#39; function trim(str) { gsub(/^[ \\t]+|[ \\t]+$/, \u0026#34;\u0026#34;, str) return str } { print trim($0) }\u0026#39; file.txt 陣列應用 一維陣列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 基本陣列操作 awk \u0026#39;{ arr[NR] = $0 } END { for (i=1; i\u0026lt;=NR; i++) { print i, arr[i] } }\u0026#39; file.txt # 關聯陣列 awk \u0026#39;{ count[$1]++ } END { for (item in count) { print item, count[item] } }\u0026#39; file.txt # 陣列排序 awk \u0026#39;{ arr[NR] = $1 } END { n = asort(arr) # 排序值 for (i=1; i\u0026lt;=n; i++) { print arr[i] } }\u0026#39; file.txt 多維陣列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 使用 SUBSEP 分隔多維索引 awk \u0026#39;BEGIN {SUBSEP = \u0026#34;:\u0026#34;} { matrix[$1,$2] = $3 } END { for (key in matrix) { print key, matrix[key] } }\u0026#39; file.txt # 二維統計 awk \u0026#39;{ sales[$1][$2] += $3 } END { for (region in sales) { for (product in sales[region]) { print region, product, sales[region][product] } } }\u0026#39; sales_data.txt 實戰應用場景 1. 日誌分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 存取日誌分析 awk \u0026#39;{ # 統計狀態碼 status[$9]++ # 統計 IP 地址 ip[$1]++ # 計算總流量 if ($10 != \u0026#34;-\u0026#34;) bytes += $10 } END { print \u0026#34;=== Status Code Statistics ===\u0026#34; for (code in status) { print code, status[code] } print \u0026#34;\\n=== Top 10 IP Addresses ===\u0026#34; PROCINFO[\u0026#34;sorted_in\u0026#34;] = \u0026#34;@val_num_desc\u0026#34; n = 0 for (addr in ip) { if (++n \u0026lt;= 10) print addr, ip[addr] } print \u0026#34;\\nTotal Bytes:\u0026#34;, bytes }\u0026#39; access.log # 錯誤日誌監控 awk \u0026#39; BEGIN { print \u0026#34;Error Analysis Report\u0026#34; } /ERROR|FATAL/ { split($1, date, \u0026#34;-\u0026#34;) errors[date[1] \u0026#34;-\u0026#34; date[2]]++ error_details[NR] = $0 } END { print \u0026#34;Errors by Month:\u0026#34; for (month in errors) { print month, errors[month] } }\u0026#39; error.log 2. 資料處理和統計 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # CSV 資料分析 awk -F, \u0026#39; NR==1 { # 跳過標題行 next } { # 銷售資料統計 total_sales += $3 sales_by_region[$2] += $3 if ($3 \u0026gt; max_sale) { max_sale = $3 max_sale_record = $0 } } END { print \u0026#34;Total Sales: $\u0026#34; total_sales print \u0026#34;Average Sale: $\u0026#34; total_sales/(NR-1) print \u0026#34;Largest Sale: $\u0026#34; max_sale print \u0026#34;Record:\u0026#34;, max_sale_record print \u0026#34;\\nSales by Region:\u0026#34; for (region in sales_by_region) { print region \u0026#34;: $\u0026#34; sales_by_region[region] } }\u0026#39; sales.csv # 成績統計 awk \u0026#39;{ # 計算每個學生的平均分 sum = 0 for (i=2; i\u0026lt;=NF; i++) { sum += $i subject_total[i-1] += $i } avg = sum / (NF-1) print $1, avg if (avg \u0026gt;= 90) grade_count[\u0026#34;A\u0026#34;]++ else if (avg \u0026gt;= 80) grade_count[\u0026#34;B\u0026#34;]++ else if (avg \u0026gt;= 70) grade_count[\u0026#34;C\u0026#34;]++ else grade_count[\u0026#34;F\u0026#34;]++ student_count++ } END { print \u0026#34;\\nGrade Distribution:\u0026#34; for (grade in grade_count) { printf \u0026#34;%s: %d (%.1f%%)\\n\u0026#34;, grade, grade_count[grade], grade_count[grade]/student_count*100 } }\u0026#39; grades.txt 3. 系統監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 程序監控 ps aux | awk \u0026#39; NR\u0026gt;1 { # 跳過標題行 cpu[$11] += $3 # 依程式名稱累加 CPU 使用率 mem[$11] += $4 # 依程式名稱累加記憶體使用率 proc_count[$11]++ } END { print \u0026#34;Process Resource Usage:\u0026#34; printf \u0026#34;%-20s %s %s %s\\n\u0026#34;, \u0026#34;PROCESS\u0026#34;, \u0026#34;COUNT\u0026#34;, \u0026#34;CPU%\u0026#34;, \u0026#34;MEM%\u0026#34; for (proc in cpu) { printf \u0026#34;%-20s %5d %6.1f %6.1f\\n\u0026#34;, proc, proc_count[proc], cpu[proc], mem[proc] } }\u0026#39; # 磁碟使用分析 df -h | awk \u0026#39; NR\u0026gt;1 { # 解析使用百分比 gsub(/%/, \u0026#34;\u0026#34;, $5) usage = $5 if (usage \u0026gt;= 90) { critical[++crit_count] = $6 \u0026#34; (\u0026#34; usage \u0026#34;%)\u0026#34; } else if (usage \u0026gt;= 80) { warning[++warn_count] = $6 \u0026#34; (\u0026#34; usage \u0026#34;%)\u0026#34; } } END { if (crit_count \u0026gt; 0) { print \u0026#34;CRITICAL: High disk usage detected!\u0026#34; for (i=1; i\u0026lt;=crit_count; i++) { print \u0026#34; \u0026#34; critical[i] } } if (warn_count \u0026gt; 0) { print \u0026#34;WARNING: Moderate disk usage:\u0026#34; for (i=1; i\u0026lt;=warn_count; i++) { print \u0026#34; \u0026#34; warning[i] } } }\u0026#39; 4. 文件格式轉換 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # JSON 簡單生成 awk -F, \u0026#39; BEGIN { print \u0026#34;{\u0026#34; } NR\u0026gt;1 { printf \u0026#34; \\\u0026#34;%s\\\u0026#34;: {\\n\u0026#34;, $1 printf \u0026#34; \\\u0026#34;name\\\u0026#34;: \\\u0026#34;%s\\\u0026#34;,\\n\u0026#34;, $2 printf \u0026#34; \\\u0026#34;age\\\u0026#34;: %d,\\n\u0026#34;, $3 printf \u0026#34; \\\u0026#34;city\\\u0026#34;: \\\u0026#34;%s\\\u0026#34;\\n\u0026#34;, $4 printf \u0026#34; }%s\\n\u0026#34;, (NR\u0026lt;total_lines ? \u0026#34;,\u0026#34; : \u0026#34;\u0026#34;) } END { print \u0026#34;}\u0026#34; }\u0026#39; data.csv # HTML 表格生成 awk -F, \u0026#39; BEGIN { print \u0026#34;\u0026lt;table border=\\\u0026#34;1\\\u0026#34;\u0026gt;\u0026#34; } NR==1 { print \u0026#34;\u0026lt;tr\u0026gt;\u0026#34; for (i=1; i\u0026lt;=NF; i++) { print \u0026#34;\u0026lt;th\u0026gt;\u0026#34; $i \u0026#34;\u0026lt;/th\u0026gt;\u0026#34; } print \u0026#34;\u0026lt;/tr\u0026gt;\u0026#34; } NR\u0026gt;1 { print \u0026#34;\u0026lt;tr\u0026gt;\u0026#34; for (i=1; i\u0026lt;=NF; i++) { print \u0026#34;\u0026lt;td\u0026gt;\u0026#34; $i \u0026#34;\u0026lt;/td\u0026gt;\u0026#34; } print \u0026#34;\u0026lt;/tr\u0026gt;\u0026#34; } END { print \u0026#34;\u0026lt;/table\u0026gt;\u0026#34; }\u0026#39; data.csv # 配置檔轉換 awk \u0026#39; /^[^#]/ \u0026amp;\u0026amp; /=/ { split($0, pair, \u0026#34;=\u0026#34;) key = pair[1] value = pair[2] gsub(/^[ \\t]+|[ \\t]+$/, \u0026#34;\u0026#34;, key) # trim gsub(/^[ \\t]+|[ \\t]+$/, \u0026#34;\u0026#34;, value) print key \u0026#34;: \\\u0026#34;\u0026#34; value \u0026#34;\\\u0026#34;\u0026#34; }\u0026#39; config.ini 5. 報表生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 # 銷售報表 awk -F, \u0026#39; BEGIN { print \u0026#34;Sales Report\u0026#34; print \u0026#34;============\u0026#34; total = 0 } NR\u0026gt;1 { date = $1 product = $2 amount = $3 # 按日期統計 daily_sales[date] += amount # 按產品統計 product_sales[product] += amount total += amount } END { print \u0026#34;\\nDaily Sales:\u0026#34; PROCINFO[\u0026#34;sorted_in\u0026#34;] = \u0026#34;@ind_str_asc\u0026#34; for (date in daily_sales) { printf \u0026#34;%-12s: $%8.2f\\n\u0026#34;, date, daily_sales[date] } print \u0026#34;\\nProduct Sales:\u0026#34; PROCINFO[\u0026#34;sorted_in\u0026#34;] = \u0026#34;@val_num_desc\u0026#34; for (product in product_sales) { printf \u0026#34;%-15s: $%8.2f (%4.1f%%)\\n\u0026#34;, product, product_sales[product], product_sales[product]/total*100 } printf \u0026#34;\\nTotal Sales: $%.2f\\n\u0026#34;, total }\u0026#39; sales.csv # 網站流量報表 awk \u0026#39;{ # 解析日期時間 gsub(/\\[|\\]/, \u0026#34;\u0026#34;, $4) split($4, datetime, \u0026#34;:\u0026#34;) date = datetime[1] hour = datetime[2] # 統計 daily_hits[date]++ hourly_hits[hour]++ if ($9 == \u0026#34;404\u0026#34;) not_found++ if ($9 ~ /^[45]/) errors++ total_hits++ } END { print \u0026#34;Website Traffic Report\u0026#34; print \u0026#34;=====================\u0026#34; print \u0026#34;\\nDaily Traffic:\u0026#34; for (date in daily_hits) { printf \u0026#34;%s: %d hits\\n\u0026#34;, date, daily_hits[date] } print \u0026#34;\\nHourly Distribution:\u0026#34; for (h=0; h\u0026lt;24; h++) { printf \u0026#34;%02d:00: %d hits\\n\u0026#34;, h, hourly_hits[h] } printf \u0026#34;\\nError Summary:\\n\u0026#34; printf \u0026#34;404 Errors: %d (%.1f%%)\\n\u0026#34;, not_found, not_found/total_hits*100 printf \u0026#34;5xx Errors: %d (%.1f%%)\\n\u0026#34;, errors, errors/total_hits*100 }\u0026#39; access.log 進階技巧 1. 多檔案處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 比較兩個檔案 awk \u0026#39; FNR==NR { # 處理第一個檔案 file1[FNR] = $0 next } { # 處理第二個檔案 if (file1[FNR] != $0) { print \u0026#34;Line \u0026#34; FNR \u0026#34; differs:\u0026#34; print \u0026#34;File1: \u0026#34; file1[FNR] print \u0026#34;File2: \u0026#34; $0 } }\u0026#39; file1.txt file2.txt # 合併檔案資料 awk \u0026#39; FNR==NR { # 第一個檔案：建立索引 lookup[$1] = $2 next } { # 第二個檔案：查找並合併 if ($1 in lookup) { print $0, lookup[$1] } }\u0026#39; lookup.txt data.txt 2. 複雜文本解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # XML 簡單解析 awk \u0026#39; /\u0026lt;([^\u0026gt;]+)\u0026gt;([^\u0026lt;]*)\u0026lt;\\/\\1\u0026gt;/ { match($0, /\u0026lt;([^\u0026gt;]+)\u0026gt;([^\u0026lt;]*)\u0026lt;\\/\\1\u0026gt;/, arr) print \u0026#34;Tag:\u0026#34;, arr[1], \u0026#34;Content:\u0026#34;, arr[2] }\u0026#39; simple.xml # 配置檔解析 awk \u0026#39; /^\\[.*\\]$/ { # 區段標題 gsub(/\\[|\\]/, \u0026#34;\u0026#34;) section = $0 next } /^[^#].*=/ { # 鍵值對 split($0, kv, \u0026#34;=\u0026#34;) key = kv[1] value = kv[2] gsub(/^[ \\t]+|[ \\t]+$/, \u0026#34;\u0026#34;, key) gsub(/^[ \\t]+|[ \\t]+$/, \u0026#34;\u0026#34;, value) config[section][key] = value } END { for (sect in config) { print \u0026#34;[\u0026#34; sect \u0026#34;]\u0026#34; for (k in config[sect]) { print k \u0026#34; = \u0026#34; config[sect][k] } print \u0026#34;\u0026#34; } }\u0026#39; config.ini 3. 效能優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 避免重複計算 awk \u0026#39;{ # 好的做法：儲存計算結果 len = length($0) if (len \u0026gt; max_len) { max_len = len longest_line = $0 } }\u0026#39; file.txt # 使用陣列而非字串連接 awk \u0026#39;{ # 好的做法：使用陣列 lines[NR] = $0 } END { for (i=NR; i\u0026gt;=1; i--) { print lines[i] } }\u0026#39; file.txt # 提早退出 awk \u0026#39;{ if (found_count \u0026gt;= 10) exit if (/pattern/) { print found_count++ } }\u0026#39; large_file.txt 腳本檔案 建立 script.awk 檔案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #!/usr/bin/awk -f BEGIN { FS = \u0026#34;,\u0026#34; OFS = \u0026#34;\\t\u0026#34; print \u0026#34;Processing CSV file...\u0026#34; } # 跳過空行 /^$/ { next } # 處理標題行 NR == 1 { print \u0026#34;Headers:\u0026#34;, $0 next } # 主要處理邏輯 { # 資料驗證 if (NF != 4) { print \u0026#34;Warning: Line \u0026#34; NR \u0026#34; has \u0026#34; NF \u0026#34; fields\u0026#34; \u0026gt; \u0026#34;/dev/stderr\u0026#34; next } # 處理資料 name = $1 age = $2 salary = $3 department = $4 # 統計 total_salary += salary dept_count[department]++ employee_count++ # 輸出處理結果 print name, age, salary, department } END { print \u0026#34;\\n=== Summary ===\u0026#34; print \u0026#34;Total employees:\u0026#34;, employee_count print \u0026#34;Average salary:\u0026#34;, total_salary/employee_count print \u0026#34;\\nDepartment distribution:\u0026#34; for (dept in dept_count) { printf \u0026#34;%-15s: %d\\n\u0026#34;, dept, dept_count[dept] } } 使用腳本：\n1 2 3 4 chmod +x script.awk ./script.awk data.csv # 或 awk -f script.awk data.csv 常見錯誤與除錯 1. 常見錯誤 1 2 3 4 5 6 7 8 9 10 # 錯誤：字串比較使用數值運算子 awk \u0026#39;$1 \u0026gt; \u0026#34;50\u0026#34;\u0026#39; file.txt # 錯誤：字串比較 awk \u0026#39;$1 + 0 \u0026gt; 50\u0026#39; file.txt # 正確：強制數值比較 # 錯誤：陣列索引問題 awk \u0026#39;{arr[0] = $1}\u0026#39; file.txt # 注意：AWK 陣列從1開始習慣使用 # 錯誤：未初始化變數 awk \u0026#39;{sum += $1} END {print sum/count}\u0026#39; file.txt # count 未初始化 awk \u0026#39;{sum += $1; count++} END {print sum/count}\u0026#39; file.txt # 正確 2. 除錯技巧 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 添加除錯輸出 awk \u0026#39;{ print \u0026#34;Debug: NR=\u0026#34; NR \u0026#34;, NF=\u0026#34; NF \u0026#34;, $0=\u0026#34; $0 \u0026gt; \u0026#34;/dev/stderr\u0026#34; # 主要邏輯 }\u0026#39; file.txt # 使用條件除錯 awk \u0026#39;{ if (debug) print \u0026#34;Processing:\u0026#34;, $0 # 主要邏輯 }\u0026#39; debug=1 file.txt # 分步驗證 awk \u0026#39;{print \u0026#34;Line \u0026#34; NR \u0026#34;: \u0026#34; $1}\u0026#39; file.txt | head -5 與其他工具整合 1. 與 grep 和 sed 組合 1 2 3 4 5 # 過濾後處理 grep \u0026#34;ERROR\u0026#34; log.txt | awk \u0026#39;{print $1, $3}\u0026#39; # 多步處理 cat data.txt | grep -v \u0026#34;^#\u0026#34; | sed \u0026#39;s/,/ /g\u0026#39; | awk \u0026#39;{print $1, $2}\u0026#39; 2. 與 sort 組合 1 2 3 4 5 # 排序後統計 awk \u0026#39;{print $1}\u0026#39; file.txt | sort | uniq -c | awk \u0026#39;{print $2, $1}\u0026#39; # 管道處理 awk \u0026#39;{print $3, $0}\u0026#39; file.txt | sort -nr | awk \u0026#39;{$1=\u0026#34;\u0026#34;; print}\u0026#39; 3. 與資料庫整合 1 2 3 4 5 6 7 8 9 10 11 # 生成 SQL 插入語句 awk -F, \u0026#39; NR\u0026gt;1 { printf \u0026#34;INSERT INTO users (name, age, city) VALUES (\\\u0026#34;%s\\\u0026#34;, %d, \\\u0026#34;%s\\\u0026#34;);\\n\u0026#34;, $1, $2, $3 }\u0026#39; data.csv # 生成批次更新腳本 awk \u0026#39;{ print \u0026#34;UPDATE table SET status=1 WHERE id=\u0026#34; $1 \u0026#34;;\u0026#34; }\u0026#39; ids.txt 總結 核心優勢 強大的模式匹配：支援複雜的正規表達式 豐富的內建功能：字串處理、數學運算、陣列操作 高效的文本處理：適合大量資料處理 靈活的程式結構：支援完整的程式設計概念 最佳實踐 善用 BEGIN 和 END：初始化和清理工作 合理使用陣列：避免記憶體過度使用 模式化程式設計：將常用邏輯封裝為函數 輸入驗證：檢查資料格式和欄位數量 錯誤處理：適當的錯誤檢查和恢復機制 學習路徑 1 2 3 4 5 6 7 8 9 10 11 12 # 基礎階段 awk \u0026#39;{print $1}\u0026#39; file.txt # 欄位處理 awk \u0026#39;/pattern/ {print}\u0026#39; file.txt # 模式匹配 awk \u0026#39;{sum += $1} END {print sum}\u0026#39; file.txt # 基本統計 # 進階階段 awk -F, \u0026#39;{arr[$1] += $2} END {for(i in arr) print i, arr[i]}\u0026#39; file.csv # 陣列應用 awk \u0026#39;function f(x) {return x*x} {print f($1)}\u0026#39; file.txt # 自訂函數 # 專家階段 awk \u0026#39;/start/,/end/ {if(/important/) print}\u0026#39; file.txt # 複雜模式 awk \u0026#39;BEGIN{PROCINFO[\u0026#34;sorted_in\u0026#34;]=\u0026#34;@val_num_desc\u0026#34;} ...\u0026#39; # 高級特性 AWK 是文本處理和資料分析的強大工具，掌握其核心概念和常用技巧，能夠大幅提升資料處理的效率和準確性。記住：AWK 的核心在於模式-動作程式設計思維，善用這個特性能夠解決複雜的文本處理問題。\n參考資料 GAWK Manual The AWK Programming Language Advanced Bash-Scripting Guide POSIX AWK Specification ","permalink":"https://xinqilin.github.io/post/tools/awk/","tags":["Linux","AWK","Text Processing","Data Analysis","Pattern Scanning","Shell","Unix"],"title":"AWK 程式設計完整指南：Linux 文本處理與資料分析利器"},{"content":"概述 Java 8 引入了多個強大的 Map 計算方法，這些方法提供了原子性的讀取-計算-寫入操作，不僅簡化了程式碼，也提高了執行效率和執行緒安全性。本文將深入探討這些方法的使用場景、效能特性和最佳實踐。\n核心計算方法 putIfAbsent：條件式插入，僅在 Key 不存在時插入值 compute：基於 Key 和現有 Value 計算新值 computeIfAbsent：Key 不存在時執行計算並插入 computeIfPresent：Key 存在時執行計算並更新 merge：合併現有值與新值 優勢與特點 原子性操作：避免 Check-Then-Act 競態條件 效能優化：減少重複的查找操作 簡潔語法：使用 Lambda 表達式簡化程式碼 執行緒安全：與 ConcurrentHashMap 結合提供執行緒安全 基礎使用範例 1. 環境設定與初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.example.mapcompute; import java.util.*; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ThreadLocalRandom; import java.util.function.Function; import java.util.stream.Collectors; import java.util.stream.IntStream; public class MapComputeExample { public static void main(String[] args) { // 初始化測試資料 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;apple\u0026#34;, 5); map.put(\u0026#34;banana\u0026#34;, 10); map.put(\u0026#34;cherry\u0026#34;, 3); System.out.println(\u0026#34;初始 Map: \u0026#34; + map); demonstratePutIfAbsent(new HashMap\u0026lt;\u0026gt;(map)); demonstrateCompute(new HashMap\u0026lt;\u0026gt;(map)); demonstrateComputeIfAbsent(new HashMap\u0026lt;\u0026gt;(map)); demonstrateComputeIfPresent(new HashMap\u0026lt;\u0026gt;(map)); demonstrateMerge(new HashMap\u0026lt;\u0026gt;(map)); } } 方法一：putIfAbsent 1. 基礎用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * putIfAbsent: 僅在 Key 不存在時插入值 * 返回值：Key 存在時返回現有值，不存在時返回 null（插入後） */ public static void demonstratePutIfAbsent(Map\u0026lt;String, Integer\u0026gt; map) { System.out.println(\u0026#34;\\n=== putIfAbsent 示範 ===\u0026#34;); // Case 1: Key 已存在 - 不插入，返回現有值 Integer result1 = map.putIfAbsent(\u0026#34;apple\u0026#34;, 99); System.out.println(\u0026#34;putIfAbsent(\u0026#39;apple\u0026#39;, 99) 返回: \u0026#34; + result1); // 5 System.out.println(\u0026#34;map 內容: \u0026#34; + map); // apple 仍為 5 // Case 2: Key 不存在 - 插入新值，返回 null Integer result2 = map.putIfAbsent(\u0026#34;orange\u0026#34;, 8); System.out.println(\u0026#34;putIfAbsent(\u0026#39;orange\u0026#39;, 8) 返回: \u0026#34; + result2); // null System.out.println(\u0026#34;map 內容: \u0026#34; + map); // 新增了 orange=8 // Case 3: Value 為 null 的情況 map.put(\u0026#34;grape\u0026#34;, null); Integer result3 = map.putIfAbsent(\u0026#34;grape\u0026#34;, 15); System.out.println(\u0026#34;putIfAbsent(\u0026#39;grape\u0026#39;, 15) 返回: \u0026#34; + result3); // null System.out.println(\u0026#34;map 內容: \u0026#34; + map); // grape 被設為 15 } 2. 實際應用：快取初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /** * 快取初始化模式：確保每個 Key 只初始化一次 */ public class CacheInitializationExample { private final Map\u0026lt;String, ExpensiveObject\u0026gt; cache = new ConcurrentHashMap\u0026lt;\u0026gt;(); /** * 使用 putIfAbsent 實現執行緒安全的快取初始化 */ public ExpensiveObject getOrCreateObject(String key) { ExpensiveObject existing = cache.get(key); if (existing != null) { return existing; } // 創建昂貴對象 ExpensiveObject newObject = new ExpensiveObject(key); // 原子性插入，避免重複創建 ExpensiveObject result = cache.putIfAbsent(key, newObject); return result != null ? result : newObject; } /** * 更簡潔的寫法（但可能創建多餘物件） */ public ExpensiveObject getOrCreateObjectSimple(String key) { return cache.putIfAbsent(key, new ExpensiveObject(key)); } public static class ExpensiveObject { private final String id; private final long creationTime; public ExpensiveObject(String id) { this.id = id; this.creationTime = System.currentTimeMillis(); // 模擬昂貴的初始化過程 try { Thread.sleep(10); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } @Override public String toString() { return String.format(\u0026#34;ExpensiveObject{id=\u0026#39;%s\u0026#39;, created=%d}\u0026#34;, id, creationTime); } } } 方法二：compute 1. 基礎用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * compute: 無條件執行計算，可處理 Key 存在或不存在的情況 * 計算函數接收 (key, value) 參數，value 可能為 null */ public static void demonstrateCompute(Map\u0026lt;String, Integer\u0026gt; map) { System.out.println(\u0026#34;\\n=== compute 示範 ===\u0026#34;); // Case 1: Key 存在 - 基於現有值計算 Integer result1 = map.compute(\u0026#34;apple\u0026#34;, (key, value) -\u0026gt; value + 10); System.out.println(\u0026#34;compute(\u0026#39;apple\u0026#39;, v -\u0026gt; v + 10) 返回: \u0026#34; + result1); // 15 System.out.println(\u0026#34;map 內容: \u0026#34; + map); // Case 2: Key 不存在 - value 為 null Integer result2 = map.compute(\u0026#34;orange\u0026#34;, (key, value) -\u0026gt; { System.out.println(\u0026#34;計算 \u0026#34; + key + \u0026#34;, 當前值: \u0026#34; + value); return value == null ? 1 : value + 1; }); System.out.println(\u0026#34;compute(\u0026#39;orange\u0026#39;, ...) 返回: \u0026#34; + result2); // 1 // Case 3: 計算結果為 null - 移除該 Key Integer result3 = map.compute(\u0026#34;cherry\u0026#34;, (key, value) -\u0026gt; { return value \u0026lt; 5 ? null : value; // cherry=3 \u0026lt; 5，返回 null }); System.out.println(\u0026#34;compute(\u0026#39;cherry\u0026#39;, ...) 返回: \u0026#34; + result3); // null System.out.println(\u0026#34;map 內容: \u0026#34; + map); // cherry 被移除 } 2. 複雜計算範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 /** * 複雜計算應用：統計和聚合操作 */ public class ComputeAdvancedExample { /** * 實現計數器功能 */ public static Map\u0026lt;String, Integer\u0026gt; updateCounters(Map\u0026lt;String, Integer\u0026gt; counters, List\u0026lt;String\u0026gt; events) { for (String event : events) { counters.compute(event, (key, count) -\u0026gt; count == null ? 1 : count + 1); } return counters; } /** * 實現累加器功能 */ public static Map\u0026lt;String, Double\u0026gt; updateAccumulators(Map\u0026lt;String, Double\u0026gt; accumulators, Map\u0026lt;String, Double\u0026gt; newValues) { for (Map.Entry\u0026lt;String, Double\u0026gt; entry : newValues.entrySet()) { accumulators.compute(entry.getKey(), (key, current) -\u0026gt; { double newValue = entry.getValue(); return current == null ? newValue : current + newValue; }); } return accumulators; } /** * 條件式更新：基於複雜邏輯的值計算 */ public static Map\u0026lt;String, String\u0026gt; updateStatus(Map\u0026lt;String, String\u0026gt; statusMap, String key, String newStatus) { return Map.of(key, statusMap.compute(key, (k, currentStatus) -\u0026gt; { if (currentStatus == null) { return newStatus; } // 狀態轉換邏輯 switch (currentStatus) { case \u0026#34;PENDING\u0026#34;: return List.of(\u0026#34;PROCESSING\u0026#34;, \u0026#34;CANCELLED\u0026#34;).contains(newStatus) ? newStatus : currentStatus; case \u0026#34;PROCESSING\u0026#34;: return List.of(\u0026#34;COMPLETED\u0026#34;, \u0026#34;FAILED\u0026#34;).contains(newStatus) ? newStatus : currentStatus; default: return currentStatus; // 不允許從終態轉換 } })); } public static void main(String[] args) { // 測試計數器 Map\u0026lt;String, Integer\u0026gt; counters = new HashMap\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; events = Arrays.asList(\u0026#34;login\u0026#34;, \u0026#34;logout\u0026#34;, \u0026#34;login\u0026#34;, \u0026#34;error\u0026#34;, \u0026#34;login\u0026#34;); updateCounters(counters, events); System.out.println(\u0026#34;事件計數: \u0026#34; + counters); // 測試累加器 Map\u0026lt;String, Double\u0026gt; accumulators = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;String, Double\u0026gt; newValues = Map.of(\u0026#34;sales\u0026#34;, 100.5, \u0026#34;costs\u0026#34;, 75.2); updateAccumulators(accumulators, newValues); System.out.println(\u0026#34;累加結果: \u0026#34; + accumulators); } } 方法三：computeIfAbsent 1. 基礎用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * computeIfAbsent: 僅在 Key 不存在時執行計算 * 是 putIfAbsent 的計算版本，支援 Lambda 表達式 */ public static void demonstrateComputeIfAbsent(Map\u0026lt;String, Integer\u0026gt; map) { System.out.println(\u0026#34;\\n=== computeIfAbsent 示範 ===\u0026#34;); // Case 1: Key 存在 - 不執行計算，返回現有值 Integer result1 = map.computeIfAbsent(\u0026#34;apple\u0026#34;, key -\u0026gt; { System.out.println(\u0026#34;為 \u0026#34; + key + \u0026#34; 執行計算\u0026#34;); // 不會列印 return 999; }); System.out.println(\u0026#34;computeIfAbsent(\u0026#39;apple\u0026#39;, ...) 返回: \u0026#34; + result1); // 5 // Case 2: Key 不存在 - 執行計算並插入 Integer result2 = map.computeIfAbsent(\u0026#34;orange\u0026#34;, key -\u0026gt; { System.out.println(\u0026#34;為 \u0026#34; + key + \u0026#34; 執行計算\u0026#34;); // 會列印 return key.length() * 10; // 基於 key 計算值 }); System.out.println(\u0026#34;computeIfAbsent(\u0026#39;orange\u0026#39;, ...) 返回: \u0026#34; + result2); // 60 // Case 3: 計算結果為 null - 不插入 Integer result3 = map.computeIfAbsent(\u0026#34;grape\u0026#34;, key -\u0026gt; null); System.out.println(\u0026#34;computeIfAbsent(\u0026#39;grape\u0026#39;, -\u0026gt; null) 返回: \u0026#34; + result3); // null System.out.println(\u0026#34;map 內容: \u0026#34; + map); // grape 不會被插入 } 2. 實際應用：延遲初始化集合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 /** * 延遲初始化應用：動態創建集合和複雜對象 */ public class LazyInitializationExample { private final Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; groupMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final Map\u0026lt;String, Set\u0026lt;Integer\u0026gt;\u0026gt; categoryMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final Map\u0026lt;String, Map\u0026lt;String, Object\u0026gt;\u0026gt; configMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); /** * 延遲初始化 List 集合 */ public void addToGroup(String groupName, String item) { groupMap.computeIfAbsent(groupName, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(item); } /** * 延遲初始化 Set 集合 */ public void addToCategory(String category, Integer value) { categoryMap.computeIfAbsent(category, k -\u0026gt; new HashSet\u0026lt;\u0026gt;()).add(value); } /** * 延遲初始化巢狀 Map */ public void setConfig(String module, String key, Object value) { configMap.computeIfAbsent(module, k -\u0026gt; new ConcurrentHashMap\u0026lt;\u0026gt;()).put(key, value); } /** * 複雜對象的延遲初始化 */ private final Map\u0026lt;String, DatabaseConnection\u0026gt; connectionPool = new ConcurrentHashMap\u0026lt;\u0026gt;(); public DatabaseConnection getConnection(String database) { return connectionPool.computeIfAbsent(database, dbName -\u0026gt; { System.out.println(\u0026#34;創建新的資料庫連接: \u0026#34; + dbName); return new DatabaseConnection(dbName); }); } /** * 基於外部資源的延遲載入 */ private final Map\u0026lt;String, UserProfile\u0026gt; userCache = new ConcurrentHashMap\u0026lt;\u0026gt;(); public UserProfile getUserProfile(String userId) { return userCache.computeIfAbsent(userId, id -\u0026gt; { // 模擬從資料庫載入用戶資料 System.out.println(\u0026#34;從資料庫載入用戶: \u0026#34; + id); return loadUserFromDatabase(id); }); } // 輔助類別和方法 public static class DatabaseConnection { private final String database; private final long createdAt; public DatabaseConnection(String database) { this.database = database; this.createdAt = System.currentTimeMillis(); } @Override public String toString() { return String.format(\u0026#34;Connection{db=\u0026#39;%s\u0026#39;, created=%d}\u0026#34;, database, createdAt); } } public static class UserProfile { private final String userId; private final String name; public UserProfile(String userId, String name) { this.userId = userId; this.name = name; } @Override public String toString() { return String.format(\u0026#34;UserProfile{id=\u0026#39;%s\u0026#39;, name=\u0026#39;%s\u0026#39;}\u0026#34;, userId, name); } } private UserProfile loadUserFromDatabase(String userId) { // 模擬資料庫查詢延遲 try { Thread.sleep(50); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } return new UserProfile(userId, \u0026#34;User-\u0026#34; + userId); } public static void main(String[] args) { LazyInitializationExample example = new LazyInitializationExample(); // 測試群組管理 example.addToGroup(\u0026#34;admins\u0026#34;, \u0026#34;alice\u0026#34;); example.addToGroup(\u0026#34;admins\u0026#34;, \u0026#34;bob\u0026#34;); example.addToGroup(\u0026#34;users\u0026#34;, \u0026#34;charlie\u0026#34;); System.out.println(\u0026#34;群組: \u0026#34; + example.groupMap); // 測試連接池 DatabaseConnection conn1 = example.getConnection(\u0026#34;user_db\u0026#34;); DatabaseConnection conn2 = example.getConnection(\u0026#34;user_db\u0026#34;); // 同一個實例 System.out.println(\u0026#34;連接1: \u0026#34; + conn1); System.out.println(\u0026#34;連接2: \u0026#34; + conn2); System.out.println(\u0026#34;是否為同一個連接: \u0026#34; + (conn1 == conn2)); } } 方法四：computeIfPresent 1. 基礎用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * computeIfPresent: 僅在 Key 存在且值不為 null 時執行計算 */ public static void demonstrateComputeIfPresent(Map\u0026lt;String, Integer\u0026gt; map) { System.out.println(\u0026#34;\\n=== computeIfPresent 示範 ===\u0026#34;); // Case 1: Key 存在且值不為 null - 執行計算 Integer result1 = map.computeIfPresent(\u0026#34;apple\u0026#34;, (key, value) -\u0026gt; { System.out.println(\u0026#34;為 \u0026#34; + key + \u0026#34; 執行計算，當前值: \u0026#34; + value); return value * 2; }); System.out.println(\u0026#34;computeIfPresent(\u0026#39;apple\u0026#39;, v -\u0026gt; v * 2) 返回: \u0026#34; + result1); // 10 // Case 2: Key 不存在 - 不執行計算 Integer result2 = map.computeIfPresent(\u0026#34;orange\u0026#34;, (key, value) -\u0026gt; { System.out.println(\u0026#34;這行不會執行\u0026#34;); return 999; }); System.out.println(\u0026#34;computeIfPresent(\u0026#39;orange\u0026#39;, ...) 返回: \u0026#34; + result2); // null // Case 3: Key 存在但值為 null - 不執行計算 map.put(\u0026#34;grape\u0026#34;, null); Integer result3 = map.computeIfPresent(\u0026#34;grape\u0026#34;, (key, value) -\u0026gt; { System.out.println(\u0026#34;這行也不會執行\u0026#34;); return 123; }); System.out.println(\u0026#34;computeIfPresent(\u0026#39;grape\u0026#39;, ...) 返回: \u0026#34; + result3); // null // Case 4: 計算結果為 null - 移除該 Key Integer result4 = map.computeIfPresent(\u0026#34;banana\u0026#34;, (key, value) -\u0026gt; { return value \u0026gt; 15 ? null : value + 5; // banana=10 \u0026lt;= 15，返回 15 }); System.out.println(\u0026#34;computeIfPresent(\u0026#39;banana\u0026#39;, ...) 返回: \u0026#34; + result4); // 15 System.out.println(\u0026#34;map 內容: \u0026#34; + map); } 2. 實際應用：條件式更新 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 /** * 條件式更新應用：基於現有值的智能更新 */ public class ConditionalUpdateExample { /** * 分數系統：只更新有效分數 */ public static Map\u0026lt;String, Integer\u0026gt; updateScores(Map\u0026lt;String, Integer\u0026gt; scores, Map\u0026lt;String, Integer\u0026gt; scoreChanges) { for (Map.Entry\u0026lt;String, Integer\u0026gt; change : scoreChanges.entrySet()) { scores.computeIfPresent(change.getKey(), (player, currentScore) -\u0026gt; { int newScore = currentScore + change.getValue(); // 分數不能低於 0 return Math.max(0, newScore); }); } return scores; } /** * 庫存管理：只減少現有庫存 */ public static Map\u0026lt;String, Integer\u0026gt; reduceInventory(Map\u0026lt;String, Integer\u0026gt; inventory, Map\u0026lt;String, Integer\u0026gt; orders) { Map\u0026lt;String, Integer\u0026gt; processed = new HashMap\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;String, Integer\u0026gt; order : orders.entrySet()) { Integer newStock = inventory.computeIfPresent(order.getKey(), (item, stock) -\u0026gt; { int orderQuantity = order.getValue(); if (stock \u0026gt;= orderQuantity) { return stock - orderQuantity; } else { // 庫存不足，不處理訂單 return stock; } }); if (newStock != null) { int originalStock = newStock + order.getValue(); if (originalStock \u0026gt;= order.getValue()) { processed.put(order.getKey(), order.getValue()); } } } return processed; } /** * 過期資料清理：基於時間戳的條件更新 */ public static class TimestampCache { private final Map\u0026lt;String, Long\u0026gt; timestampMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final long TTL_MILLIS = 300_000; // 5 分鐘 public void touch(String key) { timestampMap.put(key, System.currentTimeMillis()); } public boolean isValid(String key) { return timestampMap.computeIfPresent(key, (k, timestamp) -\u0026gt; { long now = System.currentTimeMillis(); if (now - timestamp \u0026gt; TTL_MILLIS) { return null; // 過期，移除 } return timestamp; // 仍有效 }) != null; } public int cleanupExpired() { int removed = 0; long now = System.currentTimeMillis(); Iterator\u0026lt;Map.Entry\u0026lt;String, Long\u0026gt;\u0026gt; iterator = timestampMap.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry\u0026lt;String, Long\u0026gt; entry = iterator.next(); if (now - entry.getValue() \u0026gt; TTL_MILLIS) { iterator.remove(); removed++; } } return removed; } } public static void main(String[] args) { // 測試分數更新 Map\u0026lt;String, Integer\u0026gt; scores = new HashMap\u0026lt;\u0026gt;(); scores.put(\u0026#34;Alice\u0026#34;, 100); scores.put(\u0026#34;Bob\u0026#34;, 150); Map\u0026lt;String, Integer\u0026gt; changes = new HashMap\u0026lt;\u0026gt;(); changes.put(\u0026#34;Alice\u0026#34;, 50); // 有效玩家 changes.put(\u0026#34;Charlie\u0026#34;, 25); // 不存在的玩家 changes.put(\u0026#34;Bob\u0026#34;, -200); // 會觸發最小值限制 updateScores(scores, changes); System.out.println(\u0026#34;更新後分數: \u0026#34; + scores); // 測試時間戳快取 TimestampCache cache = new TimestampCache(); cache.touch(\u0026#34;session1\u0026#34;); System.out.println(\u0026#34;session1 是否有效: \u0026#34; + cache.isValid(\u0026#34;session1\u0026#34;)); try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } System.out.println(\u0026#34;session1 是否仍有效: \u0026#34; + cache.isValid(\u0026#34;session1\u0026#34;)); } } 方法五：merge 1. 基礎用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** * merge: 合併現有值與新值 * 如果 Key 不存在或值為 null，直接使用新值 * 如果 Key 存在且值不為 null，使用合併函數計算結果 */ public static void demonstrateMerge(Map\u0026lt;String, Integer\u0026gt; map) { System.out.println(\u0026#34;\\n=== merge 示範 ===\u0026#34;); // Case 1: Key 存在 - 執行合併操作 Integer result1 = map.merge(\u0026#34;apple\u0026#34;, 20, (oldValue, newValue) -\u0026gt; { System.out.println(\u0026#34;合併 apple: \u0026#34; + oldValue + \u0026#34; + \u0026#34; + newValue); return oldValue + newValue; }); System.out.println(\u0026#34;merge(\u0026#39;apple\u0026#39;, 20, sum) 返回: \u0026#34; + result1); // 25 // Case 2: Key 不存在 - 直接使用新值 Integer result2 = map.merge(\u0026#34;orange\u0026#34;, 15, (oldValue, newValue) -\u0026gt; { System.out.println(\u0026#34;這行不會執行，因為 orange 不存在\u0026#34;); return oldValue + newValue; }); System.out.println(\u0026#34;merge(\u0026#39;orange\u0026#39;, 15, sum) 返回: \u0026#34; + result2); // 15 // Case 3: 合併結果為 null - 移除該 Key Integer result3 = map.merge(\u0026#34;banana\u0026#34;, 5, (oldValue, newValue) -\u0026gt; { return oldValue == newValue ? null : oldValue + newValue; }); System.out.println(\u0026#34;merge(\u0026#39;banana\u0026#39;, 5, ...) 返回: \u0026#34; + result3); // null（banana=10 != 5） System.out.println(\u0026#34;map 內容: \u0026#34; + map); // Case 4: 值為 null 的情況 map.put(\u0026#34;grape\u0026#34;, null); Integer result4 = map.merge(\u0026#34;grape\u0026#34;, 30, Integer::sum); System.out.println(\u0026#34;merge(\u0026#39;grape\u0026#39;, 30, sum) 返回: \u0026#34; + result4); // 30 } 2. 高級合併應用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 /** * 高級合併應用：資料聚合和統計分析 */ public class AdvancedMergeExample { /** * 統計資料合併：累加計數器 */ public static Map\u0026lt;String, Integer\u0026gt; mergeCounters(List\u0026lt;Map\u0026lt;String, Integer\u0026gt;\u0026gt; counterMaps) { Map\u0026lt;String, Integer\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); for (Map\u0026lt;String, Integer\u0026gt; counterMap : counterMaps) { for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : counterMap.entrySet()) { result.merge(entry.getKey(), entry.getValue(), Integer::sum); } } return result; } /** * 字串合併：拼接文字 */ public static Map\u0026lt;String, String\u0026gt; mergeMessages(Map\u0026lt;String, String\u0026gt; base, Map\u0026lt;String, String\u0026gt; additional) { Map\u0026lt;String, String\u0026gt; result = new HashMap\u0026lt;\u0026gt;(base); for (Map.Entry\u0026lt;String, String\u0026gt; entry : additional.entrySet()) { result.merge(entry.getKey(), entry.getValue(), (old, new_) -\u0026gt; old + \u0026#34;; \u0026#34; + new_); } return result; } /** * 複雜對象合併：銷售資料聚合 */ public static class SalesData { private double revenue; private int quantity; public SalesData(double revenue, int quantity) { this.revenue = revenue; this.quantity = quantity; } public SalesData merge(SalesData other) { return new SalesData(this.revenue + other.revenue, this.quantity + other.quantity); } public double getAveragePrice() { return quantity \u0026gt; 0 ? revenue / quantity : 0; } @Override public String toString() { return String.format(\u0026#34;SalesData{revenue=%.2f, quantity=%d, avgPrice=%.2f}\u0026#34;, revenue, quantity, getAveragePrice()); } // getter 和 setter public double getRevenue() { return revenue; } public int getQuantity() { return quantity; } } public static Map\u0026lt;String, SalesData\u0026gt; mergeSalesData(List\u0026lt;Map\u0026lt;String, SalesData\u0026gt;\u0026gt; salesMaps) { Map\u0026lt;String, SalesData\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); for (Map\u0026lt;String, SalesData\u0026gt; salesMap : salesMaps) { for (Map.Entry\u0026lt;String, SalesData\u0026gt; entry : salesMap.entrySet()) { result.merge(entry.getKey(), entry.getValue(), SalesData::merge); } } return result; } /** * 集合合併：Set 和 List 的合併操作 */ public static Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; mergeSets(Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; map1, Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; map2) { Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); // 複製第一個 map for (Map.Entry\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; entry : map1.entrySet()) { result.put(entry.getKey(), new HashSet\u0026lt;\u0026gt;(entry.getValue())); } // 合併第二個 map for (Map.Entry\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; entry : map2.entrySet()) { result.merge(entry.getKey(), entry.getValue(), (set1, set2) -\u0026gt; { Set\u0026lt;String\u0026gt; merged = new HashSet\u0026lt;\u0026gt;(set1); merged.addAll(set2); return merged; }); } return result; } public static void main(String[] args) { // 測試計數器合併 List\u0026lt;Map\u0026lt;String, Integer\u0026gt;\u0026gt; counters = Arrays.asList( Map.of(\u0026#34;A\u0026#34;, 10, \u0026#34;B\u0026#34;, 20), Map.of(\u0026#34;A\u0026#34;, 5, \u0026#34;C\u0026#34;, 15), Map.of(\u0026#34;B\u0026#34;, 8, \u0026#34;C\u0026#34;, 12) ); Map\u0026lt;String, Integer\u0026gt; mergedCounters = mergeCounters(counters); System.out.println(\u0026#34;合併後計數器: \u0026#34; + mergedCounters); // 測試銷售資料合併 List\u0026lt;Map\u0026lt;String, SalesData\u0026gt;\u0026gt; salesList = Arrays.asList( Map.of(\u0026#34;Product1\u0026#34;, new SalesData(1000.0, 10)), Map.of(\u0026#34;Product1\u0026#34;, new SalesData(500.0, 5), \u0026#34;Product2\u0026#34;, new SalesData(800.0, 8)) ); Map\u0026lt;String, SalesData\u0026gt; mergedSales = mergeSalesData(salesList); System.out.println(\u0026#34;合併後銷售資料:\u0026#34;); mergedSales.forEach((product, data) -\u0026gt; System.out.println(\u0026#34; \u0026#34; + product + \u0026#34;: \u0026#34; + data)); } } 執行緒安全與 ConcurrentHashMap 1. 原子操作的重要性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 /** * 執行緒安全的計算操作 */ public class ThreadSafeComputeExample { private final ConcurrentHashMap\u0026lt;String, Integer\u0026gt; concurrentCounters = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final Map\u0026lt;String, Integer\u0026gt; unsafeCounters = new HashMap\u0026lt;\u0026gt;(); /** * 執行緒安全的計數器增量 */ public void incrementCounterSafe(String key) { concurrentCounters.compute(key, (k, v) -\u0026gt; v == null ? 1 : v + 1); } /** * 非執行緒安全的計數器增量（可能導致資料競爭） */ public synchronized void incrementCounterUnsafe(String key) { Integer current = unsafeCounters.get(key); unsafeCounters.put(key, current == null ? 1 : current + 1); } /** * 並發測試 */ public static void testConcurrency() throws InterruptedException { ThreadSafeComputeExample example = new ThreadSafeComputeExample(); int threadCount = 10; int incrementsPerThread = 1000; String testKey = \u0026#34;counter\u0026#34;; // 測試執行緒安全版本 Thread[] safeThreads = new Thread[threadCount]; for (int i = 0; i \u0026lt; threadCount; i++) { safeThreads[i] = new Thread(() -\u0026gt; { for (int j = 0; j \u0026lt; incrementsPerThread; j++) { example.incrementCounterSafe(testKey); } }); } long startTime = System.currentTimeMillis(); for (Thread thread : safeThreads) { thread.start(); } for (Thread thread : safeThreads) { thread.join(); } long safeTime = System.currentTimeMillis() - startTime; Integer safeResult = example.concurrentCounters.get(testKey); System.out.printf(\u0026#34;執行緒安全版本: 期望=%d, 實際=%d, 耗時=%dms\\n\u0026#34;, threadCount * incrementsPerThread, safeResult, safeTime); // 測試非執行緒安全版本 Thread[] unsafeThreads = new Thread[threadCount]; for (int i = 0; i \u0026lt; threadCount; i++) { unsafeThreads[i] = new Thread(() -\u0026gt; { for (int j = 0; j \u0026lt; incrementsPerThread; j++) { example.incrementCounterUnsafe(testKey); } }); } startTime = System.currentTimeMillis(); for (Thread thread : unsafeThreads) { thread.start(); } for (Thread thread : unsafeThreads) { thread.join(); } long unsafeTime = System.currentTimeMillis() - startTime; Integer unsafeResult = example.unsafeCounters.get(testKey); System.out.printf(\u0026#34;非執行緒安全版本: 期望=%d, 實際=%d, 耗時=%dms\\n\u0026#34;, threadCount * incrementsPerThread, unsafeResult, unsafeTime); } public static void main(String[] args) throws InterruptedException { testConcurrency(); } } 2. 高效能並發應用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 /** * 高效能並發統計系統 */ public class HighPerformanceStats { private final ConcurrentHashMap\u0026lt;String, Long\u0026gt; metrics = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final ConcurrentHashMap\u0026lt;String, Double\u0026gt; averages = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final ConcurrentHashMap\u0026lt;String, Integer\u0026gt; counts = new ConcurrentHashMap\u0026lt;\u0026gt;(); /** * 記錄指標值並更新平均值 */ public void recordMetric(String metricName, double value) { // 原子性更新計數 counts.compute(metricName, (k, v) -\u0026gt; v == null ? 1 : v + 1); // 原子性更新平均值 averages.compute(metricName, (k, currentAvg) -\u0026gt; { if (currentAvg == null) { return value; } int count = counts.get(metricName); return ((currentAvg * (count - 1)) + value) / count; }); } /** * 批量更新指標 */ public void recordBatch(Map\u0026lt;String, Double\u0026gt; batchMetrics) { batchMetrics.forEach(this::recordMetric); } /** * 獲取統計摘要 */ public Map\u0026lt;String, String\u0026gt; getStatsSummary() { Map\u0026lt;String, String\u0026gt; summary = new HashMap\u0026lt;\u0026gt;(); averages.forEach((metric, avg) -\u0026gt; { int count = counts.getOrDefault(metric, 0); summary.put(metric, String.format(\u0026#34;avg=%.2f, count=%d\u0026#34;, avg, count)); }); return summary; } /** * 重置特定指標 */ public void resetMetric(String metricName) { averages.remove(metricName); counts.remove(metricName); } /** * 條件式重置：僅重置低活躍度指標 */ public int cleanupLowActivityMetrics(int minCount) { int removed = 0; for (String metric : new HashSet\u0026lt;\u0026gt;(counts.keySet())) { Integer count = counts.computeIfPresent(metric, (k, v) -\u0026gt; v \u0026gt;= minCount ? v : null); if (count == null) { averages.remove(metric); removed++; } } return removed; } } 效能分析與優化 1. 效能比較測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 /** * Map 計算方法的效能比較 */ public class PerformanceComparison { private static final int OPERATIONS = 1_000_000; private static final String[] KEYS = IntStream.range(0, 1000) .mapToObj(i -\u0026gt; \u0026#34;key\u0026#34; + i) .toArray(String[]::new); /** * 傳統方式：檢查-計算-更新 */ public static long testTraditionalApproach() { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Random random = new Random(42); long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; OPERATIONS; i++) { String key = KEYS[random.nextInt(KEYS.length)]; Integer current = map.get(key); if (current == null) { map.put(key, 1); } else { map.put(key, current + 1); } } return System.nanoTime() - startTime; } /** * 使用 compute 方法 */ public static long testComputeApproach() { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Random random = new Random(42); long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; OPERATIONS; i++) { String key = KEYS[random.nextInt(KEYS.length)]; map.compute(key, (k, v) -\u0026gt; v == null ? 1 : v + 1); } return System.nanoTime() - startTime; } /** * 使用 merge 方法 */ public static long testMergeApproach() { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Random random = new Random(42); long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; OPERATIONS; i++) { String key = KEYS[random.nextInt(KEYS.length)]; map.merge(key, 1, Integer::sum); } return System.nanoTime() - startTime; } /** * 使用 computeIfAbsent + computeIfPresent 組合 */ public static long testComputeIfApproach() { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Random random = new Random(42); long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; OPERATIONS; i++) { String key = KEYS[random.nextInt(KEYS.length)]; if (map.computeIfAbsent(key, k -\u0026gt; 0) != null) { map.computeIfPresent(key, (k, v) -\u0026gt; v + 1); } } return System.nanoTime() - startTime; } public static void main(String[] args) { System.out.println(\u0026#34;Map 計算方法效能比較 (\u0026#34; + OPERATIONS + \u0026#34; 操作)\u0026#34;); System.out.println(\u0026#34;================================================\u0026#34;); // 預熱 JVM for (int i = 0; i \u0026lt; 5; i++) { testTraditionalApproach(); testComputeApproach(); testMergeApproach(); testComputeIfApproach(); } // 正式測試 long traditional = testTraditionalApproach(); long compute = testComputeApproach(); long merge = testMergeApproach(); long computeIf = testComputeIfApproach(); System.out.printf(\u0026#34;傳統方式: %8.2f ms\\n\u0026#34;, traditional / 1_000_000.0); System.out.printf(\u0026#34;compute 方法: %8.2f ms\\n\u0026#34;, compute / 1_000_000.0); System.out.printf(\u0026#34;merge 方法: %8.2f ms\\n\u0026#34;, merge / 1_000_000.0); System.out.printf(\u0026#34;computeIf 組合: %8.2f ms\\n\u0026#34;, computeIf / 1_000_000.0); System.out.println(\u0026#34;\\n相對效能 (以傳統方式為基準):\u0026#34;); System.out.printf(\u0026#34;compute 方法: %.2fx\\n\u0026#34;, (double) traditional / compute); System.out.printf(\u0026#34;merge 方法: %.2fx\\n\u0026#34;, (double) traditional / merge); System.out.printf(\u0026#34;computeIf 組合: %.2fx\\n\u0026#34;, (double) traditional / computeIf); } } 2. 記憶體使用分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 /** * 記憶體使用分析工具 */ public class MemoryAnalysis { /** * 分析不同實作方式的記憶體使用 */ public static void analyzeMemoryUsage() { Runtime runtime = Runtime.getRuntime(); // 測試資料大小 int dataSize = 100_000; System.out.println(\u0026#34;記憶體使用分析 (資料大小: \u0026#34; + dataSize + \u0026#34;)\u0026#34;); System.out.println(\u0026#34;=========================================\u0026#34;); // 測試 HashMap + compute System.gc(); long beforeHashMap = runtime.totalMemory() - runtime.freeMemory(); Map\u0026lt;String, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; dataSize; i++) { hashMap.compute(\u0026#34;key\u0026#34; + (i % 1000), (k, v) -\u0026gt; v == null ? 1 : v + 1); } long afterHashMap = runtime.totalMemory() - runtime.freeMemory(); long hashMapMemory = afterHashMap - beforeHashMap; // 測試 ConcurrentHashMap + compute System.gc(); long beforeConcurrent = runtime.totalMemory() - runtime.freeMemory(); ConcurrentHashMap\u0026lt;String, Integer\u0026gt; concurrentMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; dataSize; i++) { concurrentMap.compute(\u0026#34;key\u0026#34; + (i % 1000), (k, v) -\u0026gt; v == null ? 1 : v + 1); } long afterConcurrent = runtime.totalMemory() - runtime.freeMemory(); long concurrentMemory = afterConcurrent - beforeConcurrent; System.out.printf(\u0026#34;HashMap 記憶體使用: %.2f MB\\n\u0026#34;, hashMapMemory / (1024.0 * 1024.0)); System.out.printf(\u0026#34;ConcurrentHashMap 記憶體使用: %.2f MB\\n\u0026#34;, concurrentMemory / (1024.0 * 1024.0)); System.out.printf(\u0026#34;記憶體使用比例: %.2fx\\n\u0026#34;, (double) concurrentMemory / hashMapMemory); // 保持引用避免被垃圾回收 System.out.println(\u0026#34;HashMap 大小: \u0026#34; + hashMap.size()); System.out.println(\u0026#34;ConcurrentHashMap 大小: \u0026#34; + concurrentMap.size()); } public static void main(String[] args) { analyzeMemoryUsage(); } } 實際應用案例 1. 網站訪問統計系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 /** * 網站訪問統計系統 */ public class WebTrafficAnalyzer { private final ConcurrentHashMap\u0026lt;String, Long\u0026gt; pageViews = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final ConcurrentHashMap\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; uniqueVisitors = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final ConcurrentHashMap\u0026lt;String, Long\u0026gt; totalBandwidth = new ConcurrentHashMap\u0026lt;\u0026gt;(); /** * 記錄頁面訪問 */ public void recordPageView(String page, String visitorId, long bandwidthBytes) { // 增加頁面瀏覽量 pageViews.merge(page, 1L, Long::sum); // 記錄唯一訪客 uniqueVisitors.computeIfAbsent(page, k -\u0026gt; ConcurrentHashMap.newKeySet()).add(visitorId); // 累加頻寬使用 totalBandwidth.merge(page, bandwidthBytes, Long::sum); } /** * 獲取頁面統計報告 */ public Map\u0026lt;String, PageStats\u0026gt; getPageStats() { Map\u0026lt;String, PageStats\u0026gt; stats = new HashMap\u0026lt;\u0026gt;(); for (String page : pageViews.keySet()) { long views = pageViews.getOrDefault(page, 0L); int uniqueCount = uniqueVisitors.getOrDefault(page, Collections.emptySet()).size(); long bandwidth = totalBandwidth.getOrDefault(page, 0L); stats.put(page, new PageStats(views, uniqueCount, bandwidth)); } return stats; } /** * 清理低活躍度頁面數據 */ public int cleanupLowActivityPages(long minViews) { int removed = 0; Iterator\u0026lt;Map.Entry\u0026lt;String, Long\u0026gt;\u0026gt; iterator = pageViews.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry\u0026lt;String, Long\u0026gt; entry = iterator.next(); if (entry.getValue() \u0026lt; minViews) { String page = entry.getKey(); iterator.remove(); uniqueVisitors.remove(page); totalBandwidth.remove(page); removed++; } } return removed; } public static class PageStats { private final long pageViews; private final int uniqueVisitors; private final long totalBandwidth; public PageStats(long pageViews, int uniqueVisitors, long totalBandwidth) { this.pageViews = pageViews; this.uniqueVisitors = uniqueVisitors; this.totalBandwidth = totalBandwidth; } public double getAverageBandwidthPerView() { return pageViews \u0026gt; 0 ? (double) totalBandwidth / pageViews : 0; } @Override public String toString() { return String.format(\u0026#34;PageStats{views=%d, unique=%d, bandwidth=%d bytes, avg=%.2f bytes/view}\u0026#34;, pageViews, uniqueVisitors, totalBandwidth, getAverageBandwidthPerView()); } // getter 方法 public long getPageViews() { return pageViews; } public int getUniqueVisitors() { return uniqueVisitors; } public long getTotalBandwidth() { return totalBandwidth; } } } 2. 分散式快取管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 /** * 分散式快取管理系統 */ public class DistributedCacheManager { private final ConcurrentHashMap\u0026lt;String, CacheEntry\u0026gt; cache = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final long defaultTTL = 300_000; // 5 分鐘預設 TTL /** * 放入快取項目 */ public void put(String key, Object value, long ttlMillis) { long expireTime = System.currentTimeMillis() + ttlMillis; cache.put(key, new CacheEntry(value, expireTime)); } public void put(String key, Object value) { put(key, value, defaultTTL); } /** * 獲取快取項目（自動清理過期項目） */ public Object get(String key) { return cache.computeIfPresent(key, (k, entry) -\u0026gt; { if (entry.isExpired()) { return null; // 過期，移除 } entry.updateAccessTime(); return entry; })?.getValue(); } /** * 條件式更新：僅在值存在且未過期時更新 */ public boolean updateIfPresent(String key, Function\u0026lt;Object, Object\u0026gt; updater) { CacheEntry updated = cache.computeIfPresent(key, (k, entry) -\u0026gt; { if (entry.isExpired()) { return null; // 過期，移除 } Object newValue = updater.apply(entry.getValue()); return new CacheEntry(newValue, entry.getExpireTime()); }); return updated != null; } /** * 獲取或計算值（延遲載入模式） */ public Object getOrCompute(String key, Function\u0026lt;String, Object\u0026gt; valueComputer, long ttlMillis) { return cache.compute(key, (k, entry) -\u0026gt; { if (entry != null \u0026amp;\u0026amp; !entry.isExpired()) { entry.updateAccessTime(); return entry; } // 快取未命中或已過期，重新計算 Object newValue = valueComputer.apply(key); long expireTime = System.currentTimeMillis() + ttlMillis; return new CacheEntry(newValue, expireTime); }).getValue(); } /** * 批量清理過期項目 */ public int cleanupExpired() { int removed = 0; long now = System.currentTimeMillis(); Iterator\u0026lt;Map.Entry\u0026lt;String, CacheEntry\u0026gt;\u0026gt; iterator = cache.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry\u0026lt;String, CacheEntry\u0026gt; entry = iterator.next(); if (entry.getValue().getExpireTime() \u0026lt;= now) { iterator.remove(); removed++; } } return removed; } /** * 獲取快取統計資訊 */ public CacheStats getStats() { long now = System.currentTimeMillis(); int totalEntries = cache.size(); int expiredEntries = 0; long totalSize = 0; for (CacheEntry entry : cache.values()) { if (entry.getExpireTime() \u0026lt;= now) { expiredEntries++; } totalSize += entry.getEstimatedSize(); } return new CacheStats(totalEntries, expiredEntries, totalSize); } /** * 快取項目類別 */ public static class CacheEntry { private final Object value; private final long expireTime; private volatile long lastAccessTime; public CacheEntry(Object value, long expireTime) { this.value = value; this.expireTime = expireTime; this.lastAccessTime = System.currentTimeMillis(); } public boolean isExpired() { return System.currentTimeMillis() \u0026gt; expireTime; } public void updateAccessTime() { this.lastAccessTime = System.currentTimeMillis(); } public long getEstimatedSize() { // 簡單的大小估算 if (value instanceof String) { return ((String) value).length() * 2L; // Unicode 字元 } else if (value instanceof byte[]) { return ((byte[]) value).length; } else { return 100L; // 預設估算 } } // getter 方法 public Object getValue() { return value; } public long getExpireTime() { return expireTime; } public long getLastAccessTime() { return lastAccessTime; } } /** * 快取統計資訊 */ public static class CacheStats { private final int totalEntries; private final int expiredEntries; private final long totalSize; public CacheStats(int totalEntries, int expiredEntries, long totalSize) { this.totalEntries = totalEntries; this.expiredEntries = expiredEntries; this.totalSize = totalSize; } public int getActiveEntries() { return totalEntries - expiredEntries; } public double getHitRatio() { return totalEntries \u0026gt; 0 ? (double) getActiveEntries() / totalEntries : 0; } @Override public String toString() { return String.format(\u0026#34;CacheStats{total=%d, active=%d, expired=%d, size=%d bytes, hitRatio=%.2f%%}\u0026#34;, totalEntries, getActiveEntries(), expiredEntries, totalSize, getHitRatio() * 100); } // getter 方法 public int getTotalEntries() { return totalEntries; } public int getExpiredEntries() { return expiredEntries; } public long getTotalSize() { return totalSize; } } } 最佳實踐與建議 1. 方法選擇指南 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /** * Map 計算方法選擇指南 */ public class MethodSelectionGuide { /** * 基於使用場景選擇最適合的方法 */ public static void demonstrateMethodSelection() { System.out.println(\u0026#34;Map 計算方法選擇指南\u0026#34;); System.out.println(\u0026#34;==================\u0026#34;); // 場景 1: 簡單的 Key 存在性檢查與插入 System.out.println(\u0026#34;場景 1: 初始化集合元素\u0026#34;); System.out.println(\u0026#34;推薦: putIfAbsent 或 computeIfAbsent\u0026#34;); Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; groups = new ConcurrentHashMap\u0026lt;\u0026gt;(); // 使用 computeIfAbsent（推薦） groups.computeIfAbsent(\u0026#34;admins\u0026#34;, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(\u0026#34;alice\u0026#34;); // 場景 2: 累加計數器 System.out.println(\u0026#34;場景 2: 計數器累加\u0026#34;); System.out.println(\u0026#34;推薦: merge 或 compute\u0026#34;); Map\u0026lt;String, Integer\u0026gt; counters = new ConcurrentHashMap\u0026lt;\u0026gt;(); // 使用 merge（推薦） counters.merge(\u0026#34;clicks\u0026#34;, 1, Integer::sum); // 場景 3: 條件式更新現有值 System.out.println(\u0026#34;場景 3: 條件式更新\u0026#34;); System.out.println(\u0026#34;推薦: computeIfPresent\u0026#34;); Map\u0026lt;String, Integer\u0026gt; scores = new ConcurrentHashMap\u0026lt;\u0026gt;(); scores.put(\u0026#34;player1\u0026#34;, 100); // 使用 computeIfPresent（推薦） scores.computeIfPresent(\u0026#34;player1\u0026#34;, (k, v) -\u0026gt; v \u0026gt; 50 ? v + 10 : v); // 場景 4: 複雜的計算邏輯 System.out.println(\u0026#34;場景 4: 複雜計算\u0026#34;); System.out.println(\u0026#34;推薦: compute\u0026#34;); Map\u0026lt;String, String\u0026gt; stateMachine = new ConcurrentHashMap\u0026lt;\u0026gt;(); // 使用 compute（推薦） stateMachine.compute(\u0026#34;task1\u0026#34;, (k, currentState) -\u0026gt; { if (currentState == null) return \u0026#34;CREATED\u0026#34;; switch (currentState) { case \u0026#34;CREATED\u0026#34;: return \u0026#34;PROCESSING\u0026#34;; case \u0026#34;PROCESSING\u0026#34;: return \u0026#34;COMPLETED\u0026#34;; default: return currentState; } }); System.out.println(\u0026#34;結果展示:\u0026#34;); System.out.println(\u0026#34;群組: \u0026#34; + groups); System.out.println(\u0026#34;計數器: \u0026#34; + counters); System.out.println(\u0026#34;分數: \u0026#34; + scores); System.out.println(\u0026#34;狀態: \u0026#34; + stateMachine); } } 2. 常見陷阱與解決方案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 /** * 常見陷阱與解決方案 */ public class CommonPitfalls { /** * 陷阱 1: 在計算函數中執行耗時操作 */ public static void demonstrateExpensiveOperationPitfall() { System.out.println(\u0026#34;陷阱 1: 計算函數中的耗時操作\u0026#34;); ConcurrentHashMap\u0026lt;String, String\u0026gt; cache = new ConcurrentHashMap\u0026lt;\u0026gt;(); // ❌ 錯誤做法：在計算函數中執行耗時操作 String badResult = cache.computeIfAbsent(\u0026#34;user123\u0026#34;, key -\u0026gt; { try { Thread.sleep(1000); // 模擬耗時的資料庫查詢 return \u0026#34;User data for \u0026#34; + key; } catch (InterruptedException e) { Thread.currentThread().interrupt(); return null; } }); // ✅ 正確做法：預先計算或使用異步載入 CompletableFuture\u0026lt;String\u0026gt; futureResult = CompletableFuture.supplyAsync(() -\u0026gt; { try { Thread.sleep(1000); // 模擬耗時操作 return \u0026#34;User data for user456\u0026#34;; } catch (InterruptedException e) { Thread.currentThread().interrupt(); return null; } }); // 只在快取中存儲已計算的結果 try { String goodResult = cache.putIfAbsent(\u0026#34;user456\u0026#34;, futureResult.get()); System.out.println(\u0026#34;預計算結果: \u0026#34; + goodResult); } catch (Exception e) { System.err.println(\u0026#34;計算失敗: \u0026#34; + e.getMessage()); } } /** * 陷阱 2: 在計算函數中修改 Map 本身 */ public static void demonstrateRecursiveModificationPitfall() { System.out.println(\u0026#34;陷阱 2: 遞迴修改陷阱\u0026#34;); ConcurrentHashMap\u0026lt;String, Integer\u0026gt; map = new ConcurrentHashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;a\u0026#34;, 1); try { // ❌ 錯誤做法：在計算函數中修改同一個 Map map.compute(\u0026#34;a\u0026#34;, (key, value) -\u0026gt; { map.put(\u0026#34;b\u0026#34;, 2); // 這可能導致死鎖或異常 return value + 1; }); } catch (Exception e) { System.err.println(\u0026#34;遞迴修改錯誤: \u0026#34; + e.getMessage()); } // ✅ 正確做法：分離計算和修改操作 Integer currentValue = map.get(\u0026#34;a\u0026#34;); if (currentValue != null) { map.put(\u0026#34;a\u0026#34;, currentValue + 1); map.put(\u0026#34;b\u0026#34;, 2); } System.out.println(\u0026#34;安全修改後的 Map: \u0026#34; + map); } /** * 陷阱 3: 計算函數拋出異常 */ public static void demonstrateExceptionHandlingPitfall() { System.out.println(\u0026#34;陷阱 3: 異常處理陷阱\u0026#34;); ConcurrentHashMap\u0026lt;String, Integer\u0026gt; map = new ConcurrentHashMap\u0026lt;\u0026gt;(); // ❌ 可能有問題：未處理計算函數中的異常 try { map.compute(\u0026#34;risky\u0026#34;, (key, value) -\u0026gt; { if (Math.random() \u0026gt; 0.5) { throw new RuntimeException(\u0026#34;隨機失敗\u0026#34;); } return value == null ? 1 : value + 1; }); } catch (RuntimeException e) { System.err.println(\u0026#34;計算失敗: \u0026#34; + e.getMessage()); } // ✅ 正確做法：在計算函數內部處理異常 map.compute(\u0026#34;safe\u0026#34;, (key, value) -\u0026gt; { try { // 可能拋出異常的操作 if (Math.random() \u0026gt; 0.5) { throw new RuntimeException(\u0026#34;隨機失敗\u0026#34;); } return value == null ? 1 : value + 1; } catch (Exception e) { System.err.println(\u0026#34;內部處理異常: \u0026#34; + e.getMessage()); return value; // 返回原值或預設值 } }); System.out.println(\u0026#34;異常處理後的 Map: \u0026#34; + map); } /** * 陷阱 4: null 值處理不當 */ public static void demonstrateNullHandlingPitfall() { System.out.println(\u0026#34;陷阱 4: null 值處理陷阱\u0026#34;); ConcurrentHashMap\u0026lt;String, String\u0026gt; map = new ConcurrentHashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34;); map.put(\u0026#34;key2\u0026#34;, null); // ConcurrentHashMap 不允許 null 值，這會拋出異常 // ✅ 正確做法：避免 null 值 map.compute(\u0026#34;key3\u0026#34;, (key, value) -\u0026gt; { if (value == null) { return \u0026#34;default_value\u0026#34;; } return value.toUpperCase(); }); // 使用 Optional 處理可能的 null 值 String result = Optional.ofNullable(map.get(\u0026#34;key3\u0026#34;)) .map(String::toUpperCase) .orElse(\u0026#34;DEFAULT\u0026#34;); System.out.println(\u0026#34;安全處理 null 後的結果: \u0026#34; + result); } public static void main(String[] args) { demonstrateExpensiveOperationPitfall(); demonstrateRecursiveModificationPitfall(); demonstrateExceptionHandlingPitfall(); // demonstrateNullHandlingPitfall(); // 會拋出異常 } } 總結 Java Map 的計算方法為開發者提供了強大的工具來進行高效的資料操作：\n方法特性總結 方法 適用場景 執行條件 返回值 putIfAbsent 條件式插入 Key 不存在 現有值或 null compute 無條件計算 總是執行 計算結果 computeIfAbsent 延遲初始化 Key 不存在或值為 null 計算結果或現有值 computeIfPresent 條件式更新 Key 存在且值不為 null 計算結果或 null merge 值合併 總是執行合併邏輯 合併結果 最佳實踐要點 選擇合適的方法：根據具體需求選擇最合適的計算方法 避免耗時操作：在計算函數中避免執行耗時的 I/O 或網路操作 異常處理：妥善處理計算函數中可能出現的異常 執行緒安全：配合 ConcurrentHashMap 實現高效的併發操作 效能考量：合理使用這些方法可以顯著提升效能 關鍵優勢 原子性：避免 Check-Then-Act 競態條件 效能提升：減少重複的 Map 查找操作 程式碼簡潔：使用 Lambda 表達式簡化邏輯 執行緒安全：與併發集合完美配合 通過掌握這些 Map 計算方法，您可以寫出更高效、更安全、更簡潔的 Java 程式碼。\n","permalink":"https://xinqilin.github.io/post/backend/mapcompute/","tags":["Java","Map","HashMap","ConcurrentHashMap","Collections","Performance","Lambda","Atomic Operations","Thread Safety"],"title":"Java Map 計算方法完整指南：高效能數據操作與最佳實踐"},{"content":"概述 sed（Stream Editor，流編輯器）是 Unix/Linux 系統中功能強大的文本處理工具。它能夠對文本流進行非互動式的編輯操作，包括搜尋、替換、插入、刪除等功能。作為管道處理的重要工具，sed 在自動化腳本和批次文本處理中扮演關鍵角色。\n核心特徵 流式處理：逐行處理文本，適合大檔案操作 非互動式：可在腳本中自動執行 正規表達式：支援強大的模式匹配 原地編輯：可直接修改原始檔案 管道友好：適合與其他命令組合使用 基本語法 1 2 3 sed [選項] \u0026#39;地址定界command\u0026#39; file(s) sed [選項] -e \u0026#39;script1\u0026#39; -e \u0026#39;script2\u0026#39; file(s) sed [選項] -f script.sed file(s) 常用選項 1 2 3 4 5 6 7 -n # 安靜模式，不自動列印處理結果 -e script # 指定要執行的腳本命令 -f file # 從檔案讀取腳本命令 -i[suffix] # 直接修改檔案（可選備份後綴） -r 或 -E # 使用擴展正規表達式 -s # 將多個檔案視為獨立處理 --debug # 偵錯模式，顯示執行過程 基本範例 1 2 3 4 5 6 7 8 # 基本文本替換 sed \u0026#39;s/old/new/\u0026#39; file.txt # 替換每行第一個匹配 sed \u0026#39;s/old/new/g\u0026#39; file.txt # 替換所有匹配 sed \u0026#39;s/old/new/2\u0026#39; file.txt # 替換每行第二個匹配 # 直接修改檔案 sed -i \u0026#39;s/old/new/g\u0026#39; file.txt # 直接修改原檔案 sed -i.bak \u0026#39;s/old/new/g\u0026#39; file.txt # 修改前先備份 地址定界 地址定界用於指定 sed 命令作用的行範圍：\n基本地址類型 1 2 3 4 5 6 7 8 9 10 11 12 # 行號地址 sed \u0026#39;3d\u0026#39; file.txt # 刪除第3行 sed \u0026#39;1,5d\u0026#39; file.txt # 刪除第1到5行 sed \u0026#39;3,$d\u0026#39; file.txt # 刪除第3行到檔案結尾 # 模式地址 sed \u0026#39;/pattern/d\u0026#39; file.txt # 刪除包含pattern的行 sed \u0026#39;/start/,/end/d\u0026#39; file.txt # 刪除從start到end之間的行 # 特殊地址 sed \u0026#39;$d\u0026#39; file.txt # 刪除最後一行 sed \u0026#39;0,/pattern/d\u0026#39; file.txt # 刪除到第一個匹配pattern的行 進階地址定界 1 2 3 4 5 6 7 8 9 10 11 12 # 步進地址 sed -n \u0026#39;1~2p\u0026#39; file.txt # 列印奇數行（從第1行開始，每2行一次） sed -n \u0026#39;2~2p\u0026#39; file.txt # 列印偶數行 sed -n \u0026#39;1~3p\u0026#39; file.txt # 每三行列印一次 # 地址取反 sed \u0026#39;3!d\u0026#39; file.txt # 刪除除第3行外的所有行 sed \u0026#39;/pattern/!d\u0026#39; file.txt # 只保留包含pattern的行 # 複雜地址組合 sed \u0026#39;1,3d; 5,7d\u0026#39; file.txt # 刪除1-3行和5-7行 sed \u0026#39;/^#/d; /^$/d\u0026#39; file.txt # 刪除註釋行和空行 核心命令詳解 1. 替換命令 (s) sed 最常用的命令，語法：s/pattern/replacement/flags\n基本替換 1 2 3 4 5 6 7 8 9 10 # 基本替換語法 sed \u0026#39;s/pattern/replacement/\u0026#39; file.txt # 替換每行第一個匹配 sed \u0026#39;s/pattern/replacement/g\u0026#39; file.txt # 全域替換 sed \u0026#39;s/pattern/replacement/2\u0026#39; file.txt # 替換第二個匹配 sed \u0026#39;s/pattern/replacement/2g\u0026#39; file.txt # 從第二個開始全部替換 # 使用不同分隔符 sed \u0026#39;s#/old/path#/new/path#g\u0026#39; file.txt # 使用 # 作為分隔符 sed \u0026#39;s|old|new|g\u0026#39; file.txt # 使用 | 作為分隔符 sed \u0026#39;s@old@new@g\u0026#39; file.txt # 使用 @ 作為分隔符 進階替換功能 1 2 3 4 5 6 7 8 9 10 11 12 13 # 大小寫轉換 sed \u0026#39;s/.*/\\U\u0026amp;/\u0026#39; file.txt # 全部轉大寫 sed \u0026#39;s/.*/\\L\u0026amp;/\u0026#39; file.txt # 全部轉小寫 sed \u0026#39;s/\\([a-z]\\)/\\U\\1/g\u0026#39; file.txt # 每個字母轉大寫 sed \u0026#39;s/\\b\\w/\\U\u0026amp;/g\u0026#39; file.txt # 單詞首字母大寫 # 使用捕獲群組 sed \u0026#39;s/\\([0-9]*\\)-\\([0-9]*\\)/\\2-\\1/\u0026#39; file.txt # 交換數字順序 sed \u0026#39;s/\\(.*\\): \\(.*\\)/\\2 - \\1/\u0026#39; file.txt # 重新排列格式 # 條件替換 sed \u0026#39;/pattern/s/old/new/g\u0026#39; file.txt # 只在包含pattern的行中替換 sed \u0026#39;1,10s/old/new/g\u0026#39; file.txt # 只在第1-10行中替換 2. 刪除命令 (d) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 基本刪除 sed \u0026#39;3d\u0026#39; file.txt # 刪除第3行 sed \u0026#39;1,5d\u0026#39; file.txt # 刪除第1-5行 sed \u0026#39;$d\u0026#39; file.txt # 刪除最後一行 # 模式刪除 sed \u0026#39;/pattern/d\u0026#39; file.txt # 刪除包含pattern的行 sed \u0026#39;/^$/d\u0026#39; file.txt # 刪除空行 sed \u0026#39;/^#/d\u0026#39; file.txt # 刪除註釋行 sed \u0026#39;/^[[:space:]]*$/d\u0026#39; file.txt # 刪除空行和只有空白的行 # 範圍刪除 sed \u0026#39;/start/,/end/d\u0026#39; file.txt # 刪除start到end之間的行 sed \u0026#39;/BEGIN/,/END/d\u0026#39; file.txt # 刪除BEGIN到END區塊 3. 列印命令 (p) 1 2 3 4 5 6 7 8 9 10 11 12 # 基本列印（通常與-n一起使用） sed -n \u0026#39;3p\u0026#39; file.txt # 只列印第3行 sed -n \u0026#39;1,5p\u0026#39; file.txt # 只列印第1-5行 sed -n \u0026#39;$p\u0026#39; file.txt # 只列印最後一行 # 模式列印 sed -n \u0026#39;/pattern/p\u0026#39; file.txt # 只列印包含pattern的行 sed -n \u0026#39;/^#/p\u0026#39; file.txt # 只列印註釋行 # 複製列印 sed \u0026#39;p\u0026#39; file.txt # 每行列印兩次 sed \u0026#39;/pattern/p\u0026#39; file.txt # 匹配行列印兩次 4. 插入和附加命令 (i, a, c) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 插入命令 (i) - 在指定行前插入 sed \u0026#39;3i\\New line before line 3\u0026#39; file.txt # 在第3行前插入 sed \u0026#39;/pattern/i\\New line\u0026#39; file.txt # 在匹配行前插入 # 附加命令 (a) - 在指定行後附加 sed \u0026#39;3a\\New line after line 3\u0026#39; file.txt # 在第3行後附加 sed \u0026#39;/pattern/a\\New line\u0026#39; file.txt # 在匹配行後附加 sed \u0026#39;$a\\Last line\u0026#39; file.txt # 在檔案末尾附加 # 替換命令 (c) - 替換整行 sed \u0026#39;3c\\Replacement line\u0026#39; file.txt # 替換第3行 sed \u0026#39;/pattern/c\\New content\u0026#39; file.txt # 替換匹配行 # 多行操作 sed \u0026#39;3i\\Line 1\\nLine 2\\nLine 3\u0026#39; file.txt # 插入多行 5. 檔案操作命令 (r, w) 1 2 3 4 5 6 7 8 # 讀取檔案 (r) sed \u0026#39;3r insert.txt\u0026#39; file.txt # 在第3行後插入檔案內容 sed \u0026#39;/pattern/r header.txt\u0026#39; file.txt # 在匹配行後插入檔案 # 寫入檔案 (w) sed -n \u0026#39;1,10w output.txt\u0026#39; file.txt # 將第1-10行寫入檔案 sed -n \u0026#39;/pattern/w matches.txt\u0026#39; file.txt # 將匹配行寫入檔案 sed \u0026#39;/ERROR/w errors.log\u0026#39; file.txt # 將錯誤行寫入日誌 正規表達式進階應用 基本正規表達式 (BRE) 1 2 3 4 5 6 7 8 9 # 基本元字元 sed \u0026#39;s/^/\u0026gt; /\u0026#39; file.txt # 在每行開頭加上 \u0026#34;\u0026gt; \u0026#34; sed \u0026#39;s/$/!/\u0026#39; file.txt # 在每行結尾加上 \u0026#34;!\u0026#34; sed \u0026#39;s/./X/g\u0026#39; file.txt # 將每個字元替換為X # 字元類別 sed \u0026#39;s/[0-9]/X/g\u0026#39; file.txt # 替換所有數字 sed \u0026#39;s/[a-zA-Z]/X/g\u0026#39; file.txt # 替換所有字母 sed \u0026#39;s/[[:digit:]]/X/g\u0026#39; file.txt # 使用POSIX字元類別 擴展正規表達式 (ERE) 1 2 3 4 5 6 7 8 9 10 # 使用 -E 或 -r 選項 sed -E \u0026#39;s/([0-9]+)-([0-9]+)/\\2-\\1/\u0026#39; file.txt # 交換連字號分隔的數字 sed -E \u0026#39;s/\\b[a-z]+/\\U\u0026amp;/g\u0026#39; file.txt # 單詞首字母大寫 sed -E \u0026#39;s/(.*\\.)(jpg|png)/\\1webp/\u0026#39; file.txt # 改變檔案副檔名 # 量詞使用 sed -E \u0026#39;s/a+/A/g\u0026#39; file.txt # 一個或多個a sed -E \u0026#39;s/a?/A/g\u0026#39; file.txt # 零個或一個a sed -E \u0026#39;s/a{3}/AAA/g\u0026#39; file.txt # 恰好三個a sed -E \u0026#39;s/a{2,4}/A/g\u0026#39; file.txt # 2到4個a 實戰應用場景 1. 檔案內容清理 1 2 3 4 5 6 7 8 9 10 # 清理空行和註釋 sed \u0026#39;/^$/d; /^#/d\u0026#39; file.txt # 刪除空行和註釋行 sed \u0026#39;/^[[:space:]]*$/d\u0026#39; file.txt # 刪除空行和只有空白的行 sed \u0026#39;s/[[:space:]]*$//\u0026#39; file.txt # 刪除行尾空白 sed \u0026#39;s/^[[:space:]]*//\u0026#39; file.txt # 刪除行首空白 # 清理特殊字元 sed \u0026#39;s/\\r$//\u0026#39; file.txt # 刪除Windows換行符 sed \u0026#39;s/\\t/ /g\u0026#39; file.txt # 將tab替換為空格 sed \u0026#39;s/[[:cntrl:]]//g\u0026#39; file.txt # 刪除控制字元 2. 資料格式轉換 1 2 3 4 5 6 7 8 9 10 11 12 # CSV處理 sed \u0026#39;s/,/\\t/g\u0026#39; data.csv # CSV轉TSV sed \u0026#39;s/;/,/g\u0026#39; file.csv # 更改分隔符 sed \u0026#39;1d\u0026#39; data.csv # 刪除標題行 # 日期格式轉換 sed -E \u0026#39;s/([0-9]{4})-([0-9]{2})-([0-9]{2})/\\3\\/\\2\\/\\1/g\u0026#39; file.txt # 2023-12-25 -\u0026gt; 25/12/2023 # 電話號碼格式化 sed -E \u0026#39;s/([0-9]{3})([0-9]{3})([0-9]{4})/(\\1) \\2-\\3/\u0026#39; file.txt # 1234567890 -\u0026gt; (123) 456-7890 3. 程式碼處理 1 2 3 4 5 6 7 8 9 # 批次重構程式碼 find . -name \u0026#34;*.java\u0026#34; -exec sed -i \u0026#39;s/oldClassName/newClassName/g\u0026#39; {} \\; # 移除偵錯程式碼 sed \u0026#39;/console\\.log/d\u0026#39; script.js # 刪除console.log行 sed \u0026#39;/DEBUG/,/END_DEBUG/d\u0026#39; code.c # 刪除DEBUG區塊 # 添加授權標題 sed \u0026#39;1i\\// Copyright 2023 Company Name\u0026#39; *.js # 在每個JS檔案開頭添加版權 4. 日誌分析 1 2 3 4 5 6 7 8 9 10 # 提取特定時間範圍的日誌 sed -n \u0026#39;/2023-12-01/,/2023-12-31/p\u0026#39; access.log # 過濾錯誤日誌 sed -n \u0026#39;/ERROR\\|FATAL/p\u0026#39; application.log # 只顯示錯誤和致命錯誤 sed \u0026#39;/INFO\\|DEBUG/d\u0026#39; application.log # 隱藏資訊和偵錯訊息 # 日誌格式化 sed \u0026#39;s/\\[\\([^]]*\\)\\]/\\1/g\u0026#39; syslog # 移除方括號 sed -E \u0026#39;s/^([^ ]+) ([^ ]+)/[\\1] \\2:/\u0026#39; log.txt # 重新格式化時間戳 5. 設定檔管理 1 2 3 4 5 6 7 8 # 修改設定值 sed -i \u0026#39;s/^port=.*/port=8080/\u0026#39; config.ini # 修改連接埠設定 sed -i \u0026#39;/^#.*debug/s/^#//\u0026#39; config.conf # 取消註釋debug設定 sed -i \u0026#39;/^debug=/s/false/true/\u0026#39; config.conf # 啟用debug模式 # 添加設定項目 sed -i \u0026#39;/\\[database\\]/a\\timeout=30\u0026#39; config.ini # 在[database]段落後添加設定 sed -i \u0026#39;$a\\new_setting=value\u0026#39; config.conf # 在檔案末尾添加設定 進階技巧 1. 多命令處理 1 2 3 4 5 6 7 8 # 使用分號分隔命令 sed \u0026#39;1d; s/old/new/g; $a\\EOF\u0026#39; file.txt # 使用-e選項 sed -e \u0026#39;1d\u0026#39; -e \u0026#39;s/old/new/g\u0026#39; -e \u0026#39;$a\\EOF\u0026#39; file.txt # 使用大括號組合命令 sed \u0026#39;/pattern/{s/old/new/; p;}\u0026#39; file.txt 2. 條件處理 1 2 3 4 5 6 7 8 # 分支和標籤 sed \u0026#39;:label; s/\\([0-9]*\\),\\([0-9]\\)/\\1\\2,/; t label\u0026#39; file.txt # 移除數字中的逗號 # 測試命令 sed \u0026#39;s/old/new/; t end; s/fallback/replacement/; :end\u0026#39; file.txt # 複雜條件邏輯 sed \u0026#39;/pattern1/{s/old/new/; b}; /pattern2/s/old/different/\u0026#39; file.txt 3. 保持空間 (Hold Space) 1 2 3 4 5 6 # 基本保持空間操作 sed -n \u0026#39;1h; 2g; 2p\u0026#39; file.txt # 將第1行複製到第2行位置顯示 sed -n \u0026#39;1h; 1!H; $!d; x; p\u0026#39; file.txt # 反轉檔案行順序 # 複雜的保持空間範例 sed -n \u0026#39;/pattern/{h; n; s/old/new/; H; x; s/\\n/ - /; p;}\u0026#39; file.txt 4. 腳本檔案 建立 script.sed 檔案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 這是一個sed腳本檔案 # 刪除空行 /^$/d # 刪除註釋行 /^#/d # 替換特定模式 s/old_pattern/new_pattern/g # 在檔案末尾添加內容 $a\\ Processing completed. 使用腳本：\n1 sed -f script.sed input.txt 效能優化與最佳實踐 1. 效能優化技巧 1 2 3 4 5 6 7 8 9 10 # 使用quit命令提早退出 sed \u0026#39;10q\u0026#39; file.txt # 只處理前10行後退出 sed \u0026#39;/pattern/q\u0026#39; file.txt # 找到匹配後立即退出 # 避免不必要的處理 sed -n \u0026#39;/pattern/p\u0026#39; file.txt # 使用-n避免自動列印 sed \u0026#39;/pattern/!d\u0026#39; file.txt # 只保留匹配行 # 組合多個操作 sed \u0026#39;s/old1/new1/g; s/old2/new2/g\u0026#39; file.txt # 一次執行多個替換 2. 記憶體使用優化 1 2 3 4 5 6 # 處理大檔案時的注意事項 sed \u0026#39;1,1000d\u0026#39; hugefile.txt \u0026gt; output.txt # 分段處理大檔案 sed -n \u0026#39;1000,2000p\u0026#39; hugefile.txt # 只處理特定範圍 # 使用管道減少中間檔案 cat input.txt | sed \u0026#39;s/old/new/g\u0026#39; | sed \u0026#39;/pattern/d\u0026#39; \u0026gt; output.txt 3. 錯誤處理 1 2 3 4 5 6 7 8 9 # 備份重要檔案 sed -i.backup \u0026#39;s/old/new/g\u0026#39; important.txt # 自動備份 # 測試命令 sed \u0026#39;s/old/new/g\u0026#39; file.txt \u0026gt; test_output.txt # 先測試輸出 diff file.txt test_output.txt # 檢查差異 # 檢查檔案存在 [ -f file.txt ] \u0026amp;\u0026amp; sed -i \u0026#39;s/old/new/g\u0026#39; file.txt 常見錯誤與除錯 1. 常見錯誤 1 2 3 4 5 6 7 8 9 10 11 # 錯誤：未轉義特殊字元 sed \u0026#39;s/file.txt/newfile.txt/\u0026#39; file # 錯誤：.匹配任意字元 sed \u0026#39;s/file\\.txt/newfile.txt/\u0026#39; file # 正確：轉義.字元 # 錯誤：地址範圍問題 sed \u0026#39;1,$s/old/new/\u0026#39; file.txt # 可能造成混淆 sed \u0026#39;1,$ s/old/new/\u0026#39; file.txt # 更清楚的寫法 # 錯誤：忘記分隔符轉義 sed \u0026#39;s/http://old.com/http://new.com/\u0026#39; file # 錯誤：分隔符衝突 sed \u0026#39;s#http://old.com#http://new.com#\u0026#39; file # 正確：使用不同分隔符 2. 除錯技巧 1 2 3 4 5 6 7 8 9 # 使用偵錯模式 sed --debug \u0026#39;s/old/new/g\u0026#39; file.txt # 逐步測試 sed -n \u0026#39;l\u0026#39; file.txt # 顯示不可見字元 sed = file.txt | sed \u0026#39;N; s/\\n/\\t/\u0026#39; # 顯示行號 # 測試正規表達式 echo \u0026#34;test string\u0026#34; | sed \u0026#39;s/pattern/replacement/\u0026#39; 與其他工具整合 1. 與 find 組合 1 2 3 4 5 6 # 批次處理檔案 find . -name \u0026#34;*.txt\u0026#34; -exec sed -i \u0026#39;s/old/new/g\u0026#39; {} \\; find . -name \u0026#34;*.conf\u0026#34; -exec sed -i \u0026#39;/^#/d\u0026#39; {} \\; # 使用 xargs 提升效能 find . -name \u0026#34;*.txt\u0026#34; | xargs sed -i \u0026#39;s/old/new/g\u0026#39; 2. 與 awk 組合 1 2 3 4 5 # sed處理格式，awk處理邏輯 sed \u0026#39;s/,/ /g\u0026#39; data.csv | awk \u0026#39;{print $1, $3}\u0026#39; # 管道組合處理 cat log.txt | sed \u0026#39;/ERROR/!d\u0026#39; | awk \u0026#39;{print $1, $4}\u0026#39; 3. 與 grep 組合 1 2 3 4 5 # 先過濾再處理 grep \u0026#34;pattern\u0026#34; file.txt | sed \u0026#39;s/old/new/g\u0026#39; # 組合條件處理 sed -n \u0026#39;/start/,/end/p\u0026#39; file.txt | grep \u0026#34;important\u0026#34; 實用腳本範例 1. 日誌清理腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/bin/bash # log_cleanup.sh - 清理和格式化日誌檔案 LOG_FILE=\u0026#34;$1\u0026#34; OUTPUT_FILE=\u0026#34;${LOG_FILE}.clean\u0026#34; sed -e \u0026#39;/^$/d\u0026#39; \\ -e \u0026#39;/^#/d\u0026#39; \\ -e \u0026#39;s/[[:space:]]*$//\u0026#39; \\ -e \u0026#39;s/\\t/ /g\u0026#39; \\ -e \u0026#39;/DEBUG/d\u0026#39; \\ \u0026#34;$LOG_FILE\u0026#34; \u0026gt; \u0026#34;$OUTPUT_FILE\u0026#34; echo \u0026#34;清理完成：$OUTPUT_FILE\u0026#34; 2. 設定檔更新腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/bin/bash # config_update.sh - 批次更新設定檔 CONFIG_DIR=\u0026#34;/etc/myapp\u0026#34; BACKUP_DIR=\u0026#34;/etc/myapp/backup\u0026#34; # 備份設定檔 mkdir -p \u0026#34;$BACKUP_DIR\u0026#34; cp \u0026#34;$CONFIG_DIR\u0026#34;/*.conf \u0026#34;$BACKUP_DIR\u0026#34;/ # 更新設定 find \u0026#34;$CONFIG_DIR\u0026#34; -name \u0026#34;*.conf\u0026#34; -exec sed -i \\ -e \u0026#39;s/^port=.*/port=8080/\u0026#39; \\ -e \u0026#39;s/^debug=false/debug=true/\u0026#39; \\ -e \u0026#39;/^#.*logging/s/^#//\u0026#39; \\ {} \\; echo \u0026#34;設定更新完成\u0026#34; 3. 程式碼重構腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/bin/bash # refactor.sh - 批次重構程式碼 OLD_CLASS=\u0026#34;$1\u0026#34; NEW_CLASS=\u0026#34;$2\u0026#34; if [ $# -ne 2 ]; then echo \u0026#34;用法: $0 \u0026lt;舊類別名\u0026gt; \u0026lt;新類別名\u0026gt;\u0026#34; exit 1 fi # 更新Java檔案 find . -name \u0026#34;*.java\u0026#34; -exec sed -i \\ -e \u0026#34;s/class $OLD_CLASS/class $NEW_CLASS/g\u0026#34; \\ -e \u0026#34;s/new $OLD_CLASS(/new $NEW_CLASS(/g\u0026#34; \\ -e \u0026#34;s/$OLD_CLASS\\.class/$NEW_CLASS.class/g\u0026#34; \\ {} \\; echo \u0026#34;重構完成：$OLD_CLASS -\u0026gt; $NEW_CLASS\u0026#34; 總結 核心優勢 高效率：流式處理，記憶體使用量小 靈活性：支援複雜的文本操作 自動化：適合腳本和批次處理 標準化：跨平台一致性好 最佳實踐 測試先行：重要操作前先測試輸出 備份重要檔案：使用 -i.backup 選項 善用正規表達式：提升處理效率 組合工具：與其他命令協作使用 腳本化：將複雜操作封裝為腳本 學習建議 1 2 3 4 5 6 7 # 常用操作記憶口訣 sed \u0026#39;s/old/new/g\u0026#39; # 替換：substitute sed \u0026#39;3d\u0026#39; # 刪除：delete sed \u0026#39;3p\u0026#39; # 列印：print sed \u0026#39;3a\\text\u0026#39; # 附加：append sed \u0026#39;3i\\text\u0026#39; # 插入：insert sed \u0026#39;3c\\text\u0026#39; # 改變：change sed 是文本處理的瑞士軍刀，掌握其核心概念和常用操作，能夠大幅提升 Linux 系統管理和自動化腳本的效率。記住：實務中最重要的是理解模式空間的概念，並善用地址定界來精確控制操作範圍。\n參考資料 GNU sed Manual sed \u0026amp; awk by O\u0026rsquo;Reilly Advanced Bash-Scripting Guide Regular Expressions Info ","permalink":"https://xinqilin.github.io/post/tools/sed/","tags":["Linux","Sed","Stream Editor","Text Processing","Regular Expression","Shell","Unix"],"title":"Sed 流編輯器完整指南：Linux 文本處理的強大工具"},{"content":"Memento 當我們想要保存對象的狀態以便以後恢復它時，我們使用備忘錄設計模式。備忘錄模式有助於以這樣一種方式實現這一點，即對象的已保存狀態數據在對像外部無法訪問；這保護了已保存狀態數據的完整性。\n實現 Memento 模式的想法始於兩個對象—— Originator 和 Caretaker。Originator是需要保存和恢復狀態的對象，它使用一個內部類來保存Object的狀態。內部類稱為 Memento 及其私有，因此無法從其他對象訪問。\nCaretaker 是幫助類，負責通過 Memento 對象存儲和恢復 Originator 的狀態。由於 Memento 對 Originator 是私有的，因此 Caretaker 無法訪問它，並且它作為 Object 存儲在 caretaker 中。\n現實生活中最好的例子之一是 IDE, 我們可以隨時保存其數據並使用撤消將其恢復到以前保存的狀態。\n必須保存對象狀態（某些部分）的快照，以便以後可以將其恢復到該狀態，並且 獲取狀態的直接接口會暴露實現細節並破壞對象的封裝。 ","permalink":"https://xinqilin.github.io/post/architecture/memento/","tags":[],"title":"DesignPattern - Behavioral - Memento"},{"content":"Interpreter 用它來定義一種語言的語法表示，它提供了一個解釋器來處理語法。這種模式的最佳示例是 java 編譯器，它將 java 源代碼解釋為 JVM 可以理解的字節碼。google translation 也是Interpreter 的一個例子，其中輸入可以是任何語言，我們可以得到另一種語言的解釋輸出。\n為了 Interpreter，我們需要創建 Interpreter 上下文引擎來完成解釋工作。然後，我們需要創建不同的 Expression 實現，這些實現將使用解釋器上下文提供的功能。最後，我們需要創建客戶端，該客戶端將從用戶那裡獲取輸入並決定使用哪個表達式，然後為用戶生成輸出。\n語法很簡單。對於復雜的語法，語法的類層次結構變得龐大且難以管理。在這種情況下，解析器生成器等工具是更好的選擇。他們可以在不構建抽象語法樹 (AST) 的情況下解釋表達式，這也可以節省空間和時間。 效率不是關鍵問題。最有效的解釋器通常不是通過直接解釋解析樹來實現，而是首先將它們翻譯成另一種形式。例如，正則表達式經常被轉換為狀態機。但即便如此，我們也可以藉助解釋器模式來實現翻譯器，因此該模式仍然適用。 ","permalink":"https://xinqilin.github.io/post/architecture/interpreter/","tags":[],"title":"DesignPattern - Behavioral - Interpreter"},{"content":"迭代器模式 (Iterator Pattern) 現代化完整指南 模式概述 迭代器模式是一種行為設計模式，它提供一種統一的方式來遍歷聚合對象中的元素，而不需要暴露聚合對象的內部結構。在現代 Java 開發中，迭代器模式不僅包含傳統的 Iterator 接口實現，更擴展到 Stream API、Spring Data 分頁和企業級數據處理場景。\n核心概念 1. 迭代器模式解決的問題 統一遍歷接口：為不同類型的聚合對象提供一致的遍歷方式 封裝內部結構：隱藏集合內部實現細節 支持多種遍歷：同時支持多個迭代器並行遍歷 延遲加載：支持大數據集的分批處理和延遲加載 函數式編程：整合現代 Java 函數式編程特性 2. 現代迭代器架構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 /** * 現代化迭代器接口設計 */ public interface ModernIterator\u0026lt;T\u0026gt; extends Iterator\u0026lt;T\u0026gt; { /** * 傳統的下一個元素檢查 */ @Override boolean hasNext(); /** * 獲取下一個元素 */ @Override T next(); /** * 可選的移除操作 */ @Override default void remove() { throw new UnsupportedOperationException(\u0026#34;Remove not supported\u0026#34;); } /** * 批量獲取元素 */ default List\u0026lt;T\u0026gt; nextBatch(int size) { List\u0026lt;T\u0026gt; batch = new ArrayList\u0026lt;\u0026gt;(size); for (int i = 0; i \u0026lt; size \u0026amp;\u0026amp; hasNext(); i++) { batch.add(next()); } return batch; } /** * 轉換為 Stream */ default Stream\u0026lt;T\u0026gt; asStream() { return StreamSupport.stream( Spliterators.spliteratorUnknownSize(this, Spliterator.ORDERED), false ); } /** * 帶過濾的迭代 */ default ModernIterator\u0026lt;T\u0026gt; filter(Predicate\u0026lt;T\u0026gt; predicate) { return new FilteringIterator\u0026lt;\u0026gt;(this, predicate); } /** * 元素轉換 */ default \u0026lt;R\u0026gt; ModernIterator\u0026lt;R\u0026gt; map(Function\u0026lt;T, R\u0026gt; mapper) { return new MappingIterator\u0026lt;\u0026gt;(this, mapper); } } /** * 過濾迭代器實現 */ class FilteringIterator\u0026lt;T\u0026gt; implements ModernIterator\u0026lt;T\u0026gt; { private final ModernIterator\u0026lt;T\u0026gt; source; private final Predicate\u0026lt;T\u0026gt; predicate; private T nextElement; private boolean hasNextElement; public FilteringIterator(ModernIterator\u0026lt;T\u0026gt; source, Predicate\u0026lt;T\u0026gt; predicate) { this.source = source; this.predicate = predicate; advance(); } private void advance() { hasNextElement = false; while (source.hasNext()) { T element = source.next(); if (predicate.test(element)) { nextElement = element; hasNextElement = true; break; } } } @Override public boolean hasNext() { return hasNextElement; } @Override public T next() { if (!hasNextElement) { throw new NoSuchElementException(); } T result = nextElement; advance(); return result; } } /** * 映射迭代器實現 */ class MappingIterator\u0026lt;T, R\u0026gt; implements ModernIterator\u0026lt;R\u0026gt; { private final ModernIterator\u0026lt;T\u0026gt; source; private final Function\u0026lt;T, R\u0026gt; mapper; public MappingIterator(ModernIterator\u0026lt;T\u0026gt; source, Function\u0026lt;T, R\u0026gt; mapper) { this.source = source; this.mapper = mapper; } @Override public boolean hasNext() { return source.hasNext(); } @Override public R next() { return mapper.apply(source.next()); } } 基礎實作範例 1. 企業級客戶資料迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 /** * 客戶資料模型 */ public class Customer { private String customerId; private String name; private String email; private CustomerType type; private BigDecimal totalOrderAmount; private LocalDateTime createdAt; private boolean active; public Customer(String customerId, String name, String email, CustomerType type) { this.customerId = customerId; this.name = name; this.email = email; this.type = type; this.totalOrderAmount = BigDecimal.ZERO; this.createdAt = LocalDateTime.now(); this.active = true; } // Getters and setters public String getCustomerId() { return customerId; } public void setCustomerId(String customerId) { this.customerId = customerId; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public CustomerType getType() { return type; } public void setType(CustomerType type) { this.type = type; } public BigDecimal getTotalOrderAmount() { return totalOrderAmount; } public void setTotalOrderAmount(BigDecimal totalOrderAmount) { this.totalOrderAmount = totalOrderAmount; } public LocalDateTime getCreatedAt() { return createdAt; } public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; } public boolean isActive() { return active; } public void setActive(boolean active) { this.active = active; } @Override public String toString() { return String.format(\u0026#34;Customer{id=\u0026#39;%s\u0026#39;, name=\u0026#39;%s\u0026#39;, type=%s, amount=%s}\u0026#34;, customerId, name, type, totalOrderAmount); } } /** * 客戶類型枚舉 */ public enum CustomerType { REGULAR(\u0026#34;一般客戶\u0026#34;), VIP(\u0026#34;VIP客戶\u0026#34;), ENTERPRISE(\u0026#34;企業客戶\u0026#34;), PREMIUM(\u0026#34;高級客戶\u0026#34;); private final String description; CustomerType(String description) { this.description = description; } public String getDescription() { return description; } } /** * 分頁客戶迭代器 */ public class PagedCustomerIterator implements ModernIterator\u0026lt;Customer\u0026gt; { private final CustomerRepository customerRepository; private final Pageable pageable; private final CustomerCriteria criteria; private Page\u0026lt;Customer\u0026gt; currentPage; private Iterator\u0026lt;Customer\u0026gt; currentPageIterator; private int currentPageNumber = 0; public PagedCustomerIterator(CustomerRepository customerRepository, CustomerCriteria criteria, int pageSize) { this.customerRepository = customerRepository; this.criteria = criteria; this.pageable = PageRequest.of(0, pageSize, Sort.by(\u0026#34;createdAt\u0026#34;).descending()); loadNextPage(); } private void loadNextPage() { Pageable pageRequest = PageRequest.of(currentPageNumber, pageable.getPageSize(), pageable.getSort()); currentPage = customerRepository.findByCriteria(criteria, pageRequest); currentPageIterator = currentPage.getContent().iterator(); } @Override public boolean hasNext() { if (currentPageIterator.hasNext()) { return true; } // 檢查是否有下一頁 if (currentPage.hasNext()) { currentPageNumber++; loadNextPage(); return currentPageIterator.hasNext(); } return false; } @Override public Customer next() { if (!hasNext()) { throw new NoSuchElementException(\u0026#34;No more customers\u0026#34;); } return currentPageIterator.next(); } /** * 獲取總數量 */ public long getTotalElements() { return currentPage.getTotalElements(); } /** * 獲取總頁數 */ public int getTotalPages() { return currentPage.getTotalPages(); } } /** * 客戶查詢條件 */ public class CustomerCriteria { private CustomerType type; private BigDecimal minOrderAmount; private LocalDateTime createdAfter; private LocalDateTime createdBefore; private Boolean active; private String namePattern; public CustomerCriteria() {} // Builder pattern public static CustomerCriteria builder() { return new CustomerCriteria(); } public CustomerCriteria withType(CustomerType type) { this.type = type; return this; } public CustomerCriteria withMinOrderAmount(BigDecimal amount) { this.minOrderAmount = amount; return this; } public CustomerCriteria withCreatedAfter(LocalDateTime date) { this.createdAfter = date; return this; } public CustomerCriteria withCreatedBefore(LocalDateTime date) { this.createdBefore = date; return this; } public CustomerCriteria withActiveStatus(Boolean active) { this.active = active; return this; } public CustomerCriteria withNamePattern(String pattern) { this.namePattern = pattern; return this; } // Getters public CustomerType getType() { return type; } public BigDecimal getMinOrderAmount() { return minOrderAmount; } public LocalDateTime getCreatedAfter() { return createdAfter; } public LocalDateTime getCreatedBefore() { return createdBefore; } public Boolean getActive() { return active; } public String getNamePattern() { return namePattern; } } 2. 複合集合迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 /** * 複合集合迭代器 - 將多個集合統一迭代 */ public class CompositeIterator\u0026lt;T\u0026gt; implements ModernIterator\u0026lt;T\u0026gt; { private final List\u0026lt;ModernIterator\u0026lt;T\u0026gt;\u0026gt; iterators; private int currentIteratorIndex = 0; @SafeVarargs public CompositeIterator(ModernIterator\u0026lt;T\u0026gt;... iterators) { this.iterators = Arrays.asList(iterators); } public CompositeIterator(List\u0026lt;ModernIterator\u0026lt;T\u0026gt;\u0026gt; iterators) { this.iterators = new ArrayList\u0026lt;\u0026gt;(iterators); } @Override public boolean hasNext() { while (currentIteratorIndex \u0026lt; iterators.size()) { if (iterators.get(currentIteratorIndex).hasNext()) { return true; } currentIteratorIndex++; } return false; } @Override public T next() { if (!hasNext()) { throw new NoSuchElementException(); } return iterators.get(currentIteratorIndex).next(); } /** * 獲取當前迭代器索引 */ public int getCurrentIteratorIndex() { return currentIteratorIndex; } /** * 獲取迭代器總數 */ public int getIteratorCount() { return iterators.size(); } } /** * 延遲加載迭代器 */ public class LazyLoadingIterator\u0026lt;T\u0026gt; implements ModernIterator\u0026lt;T\u0026gt; { private final Supplier\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; dataProvider; private final int batchSize; private Iterator\u0026lt;T\u0026gt; currentBatch; private boolean dataLoaded = false; public LazyLoadingIterator(Supplier\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; dataProvider, int batchSize) { this.dataProvider = dataProvider; this.batchSize = batchSize; } private void ensureDataLoaded() { if (!dataLoaded) { List\u0026lt;T\u0026gt; data = dataProvider.get(); currentBatch = data.iterator(); dataLoaded = true; } } @Override public boolean hasNext() { ensureDataLoaded(); return currentBatch.hasNext(); } @Override public T next() { ensureDataLoaded(); return currentBatch.next(); } } 3. 使用範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 /** * 迭代器使用範例 */ public class IteratorUsageExample { public static void main(String[] args) { // 創建測試數據 List\u0026lt;Customer\u0026gt; customers = createTestCustomers(); // 1. 基本迭代器使用 System.out.println(\u0026#34;=== 基本迭代器使用 ===\u0026#34;); demonstrateBasicIteration(customers); // 2. 過濾和轉換 System.out.println(\u0026#34;\\n=== 過濾和轉換 ===\u0026#34;); demonstrateFilteringAndMapping(customers); // 3. 復合迭代器 System.out.println(\u0026#34;\\n=== 復合迭代器 ===\u0026#34;); demonstrateCompositeIterator(customers); // 4. Stream API 整合 System.out.println(\u0026#34;\\n=== Stream API 整合 ===\u0026#34;); demonstrateStreamIntegration(customers); } private static void demonstrateBasicIteration(List\u0026lt;Customer\u0026gt; customers) { ModernIterator\u0026lt;Customer\u0026gt; iterator = new ListIteratorAdapter\u0026lt;\u0026gt;(customers); int count = 0; while (iterator.hasNext() \u0026amp;\u0026amp; count \u0026lt; 3) { Customer customer = iterator.next(); System.out.println(\u0026#34;客戶: \u0026#34; + customer); count++; } } private static void demonstrateFilteringAndMapping(List\u0026lt;Customer\u0026gt; customers) { ModernIterator\u0026lt;Customer\u0026gt; iterator = new ListIteratorAdapter\u0026lt;\u0026gt;(customers); // 過濾 VIP 客戶並轉換為郵件地址 ModernIterator\u0026lt;String\u0026gt; emailIterator = iterator .filter(customer -\u0026gt; customer.getType() == CustomerType.VIP) .map(Customer::getEmail); System.out.println(\u0026#34;VIP 客戶郵件地址:\u0026#34;); while (emailIterator.hasNext()) { System.out.println(\u0026#34;- \u0026#34; + emailIterator.next()); } } private static void demonstrateCompositeIterator(List\u0026lt;Customer\u0026gt; customers) { // 將客戶按類型分組 List\u0026lt;Customer\u0026gt; regularCustomers = customers.stream() .filter(c -\u0026gt; c.getType() == CustomerType.REGULAR) .collect(Collectors.toList()); List\u0026lt;Customer\u0026gt; vipCustomers = customers.stream() .filter(c -\u0026gt; c.getType() == CustomerType.VIP) .collect(Collectors.toList()); // 創建復合迭代器 CompositeIterator\u0026lt;Customer\u0026gt; compositeIterator = new CompositeIterator\u0026lt;\u0026gt;( new ListIteratorAdapter\u0026lt;\u0026gt;(regularCustomers), new ListIteratorAdapter\u0026lt;\u0026gt;(vipCustomers) ); System.out.println(\u0026#34;復合迭代器遍歷:\u0026#34;); while (compositeIterator.hasNext()) { Customer customer = compositeIterator.next(); System.out.println(String.format(\u0026#34;迭代器 %d: %s\u0026#34;, compositeIterator.getCurrentIteratorIndex(), customer.getName())); } } private static void demonstrateStreamIntegration(List\u0026lt;Customer\u0026gt; customers) { ModernIterator\u0026lt;Customer\u0026gt; iterator = new ListIteratorAdapter\u0026lt;\u0026gt;(customers); // 轉換為 Stream 並進行複雜操作 Map\u0026lt;CustomerType, BigDecimal\u0026gt; totalByType = iterator.asStream() .collect(Collectors.groupingBy( Customer::getType, Collectors.reducing(BigDecimal.ZERO, Customer::getTotalOrderAmount, BigDecimal::add) )); System.out.println(\u0026#34;各類型客戶總訂單金額:\u0026#34;); totalByType.forEach((type, total) -\u0026gt; System.out.println(String.format(\u0026#34;%s: $%s\u0026#34;, type.getDescription(), total))); } private static List\u0026lt;Customer\u0026gt; createTestCustomers() { List\u0026lt;Customer\u0026gt; customers = new ArrayList\u0026lt;\u0026gt;(); Customer customer1 = new Customer(\u0026#34;C001\u0026#34;, \u0026#34;張三\u0026#34;, \u0026#34;zhangsan@example.com\u0026#34;, CustomerType.REGULAR); customer1.setTotalOrderAmount(new BigDecimal(\u0026#34;1500.00\u0026#34;)); Customer customer2 = new Customer(\u0026#34;C002\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;lisi@example.com\u0026#34;, CustomerType.VIP); customer2.setTotalOrderAmount(new BigDecimal(\u0026#34;5000.00\u0026#34;)); Customer customer3 = new Customer(\u0026#34;C003\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;wangwu@example.com\u0026#34;, CustomerType.ENTERPRISE); customer3.setTotalOrderAmount(new BigDecimal(\u0026#34;25000.00\u0026#34;)); Customer customer4 = new Customer(\u0026#34;C004\u0026#34;, \u0026#34;趙六\u0026#34;, \u0026#34;zhaoliu@example.com\u0026#34;, CustomerType.VIP); customer4.setTotalOrderAmount(new BigDecimal(\u0026#34;8000.00\u0026#34;)); customers.addAll(Arrays.asList(customer1, customer2, customer3, customer4)); return customers; } } /** * List 適配器 */ class ListIteratorAdapter\u0026lt;T\u0026gt; implements ModernIterator\u0026lt;T\u0026gt; { private final Iterator\u0026lt;T\u0026gt; iterator; public ListIteratorAdapter(List\u0026lt;T\u0026gt; list) { this.iterator = list.iterator(); } @Override public boolean hasNext() { return iterator.hasNext(); } @Override public T next() { return iterator.next(); } } Spring Boot 整合 1. Spring Data 分頁迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 /** * Spring Data Repository */ @Repository public interface CustomerRepository extends JpaRepository\u0026lt;Customer, String\u0026gt; { /** * 根據條件分頁查詢 */ @Query(\u0026#34;SELECT c FROM Customer c WHERE \u0026#34; + \u0026#34;(:#{#criteria.type} IS NULL OR c.type = :#{#criteria.type}) AND \u0026#34; + \u0026#34;(:#{#criteria.minOrderAmount} IS NULL OR c.totalOrderAmount \u0026gt;= :#{#criteria.minOrderAmount}) AND \u0026#34; + \u0026#34;(:#{#criteria.active} IS NULL OR c.active = :#{#criteria.active}) AND \u0026#34; + \u0026#34;(:#{#criteria.namePattern} IS NULL OR c.name LIKE %:#{#criteria.namePattern}%) AND \u0026#34; + \u0026#34;(:#{#criteria.createdAfter} IS NULL OR c.createdAt \u0026gt;= :#{#criteria.createdAfter}) AND \u0026#34; + \u0026#34;(:#{#criteria.createdBefore} IS NULL OR c.createdAt \u0026lt;= :#{#criteria.createdBefore})\u0026#34;) Page\u0026lt;Customer\u0026gt; findByCriteria(@Param(\u0026#34;criteria\u0026#34;) CustomerCriteria criteria, Pageable pageable); /** * 流式查詢 - 適合大數據量處理 */ @Query(\u0026#34;SELECT c FROM Customer c WHERE c.active = true\u0026#34;) Stream\u0026lt;Customer\u0026gt; findAllActiveCustomersAsStream(); /** * 按類型查詢 */ Page\u0026lt;Customer\u0026gt; findByType(CustomerType type, Pageable pageable); /** * 查詢訂單金額範圍內的客戶 */ Page\u0026lt;Customer\u0026gt; findByTotalOrderAmountBetween(BigDecimal min, BigDecimal max, Pageable pageable); } /** * Spring Boot 迭代器服務 */ @Service @Transactional(readOnly = true) public class CustomerIteratorService { private final CustomerRepository customerRepository; private final Logger logger = LoggerFactory.getLogger(CustomerIteratorService.class); public CustomerIteratorService(CustomerRepository customerRepository) { this.customerRepository = customerRepository; } /** * 創建分頁客戶迭代器 */ public PagedCustomerIterator createPagedIterator(CustomerCriteria criteria, int pageSize) { logger.info(\u0026#34;創建分頁迭代器: criteria={}, pageSize={}\u0026#34;, criteria, pageSize); return new PagedCustomerIterator(customerRepository, criteria, pageSize); } /** * 創建流式迭代器 */ public Stream\u0026lt;Customer\u0026gt; createStreamIterator() { logger.info(\u0026#34;創建流式迭代器\u0026#34;); return customerRepository.findAllActiveCustomersAsStream(); } /** * 批量處理客戶數據 */ public void processBatchCustomers(CustomerCriteria criteria, int batchSize, Consumer\u0026lt;List\u0026lt;Customer\u0026gt;\u0026gt; processor) { PagedCustomerIterator iterator = createPagedIterator(criteria, batchSize); while (iterator.hasNext()) { List\u0026lt;Customer\u0026gt; batch = iterator.nextBatch(batchSize); processor.accept(batch); logger.debug(\u0026#34;處理批次: {} 客戶\u0026#34;, batch.size()); } logger.info(\u0026#34;批次處理完成，總客戶數: {}\u0026#34;, iterator.getTotalElements()); } /** * 異步迭代處理 */ @Async public CompletableFuture\u0026lt;ProcessingResult\u0026gt; processCustomersAsync(CustomerCriteria criteria, Function\u0026lt;Customer, String\u0026gt; processor) { return CompletableFuture.supplyAsync(() -\u0026gt; { PagedCustomerIterator iterator = createPagedIterator(criteria, 100); List\u0026lt;String\u0026gt; results = new ArrayList\u0026lt;\u0026gt;(); int processedCount = 0; while (iterator.hasNext()) { Customer customer = iterator.next(); String result = processor.apply(customer); results.add(result); processedCount++; if (processedCount % 100 == 0) { logger.info(\u0026#34;已處理 {} 客戶\u0026#34;, processedCount); } } return new ProcessingResult(processedCount, results); }); } /** * 按類型並行處理 */ public Map\u0026lt;CustomerType, Long\u0026gt; countCustomersByTypeParallel() { return Arrays.stream(CustomerType.values()) .parallel() .collect(Collectors.toMap( type -\u0026gt; type, type -\u0026gt; { PagedCustomerIterator iterator = createPagedIterator( CustomerCriteria.builder().withType(type), 1000); return iterator.getTotalElements(); } )); } } /** * 處理結果 */ public class ProcessingResult { private final int processedCount; private final List\u0026lt;String\u0026gt; results; private final LocalDateTime timestamp; public ProcessingResult(int processedCount, List\u0026lt;String\u0026gt; results) { this.processedCount = processedCount; this.results = results; this.timestamp = LocalDateTime.now(); } // Getters public int getProcessedCount() { return processedCount; } public List\u0026lt;String\u0026gt; getResults() { return results; } public LocalDateTime getTimestamp() { return timestamp; } @Override public String toString() { return String.format(\u0026#34;ProcessingResult{processedCount=%d, resultsSize=%d, timestamp=%s}\u0026#34;, processedCount, results.size(), timestamp); } } 2. Spring Boot 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /** * 迭代器模式配置 */ @Configuration @EnableAsync @EnableConfigurationProperties(IteratorProperties.class) public class IteratorPatternConfig { /** * 異步執行器配置 */ @Bean(name = \u0026#34;customerProcessingExecutor\u0026#34;) public TaskExecutor customerProcessingExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(4); executor.setMaxPoolSize(8); executor.setQueueCapacity(100); executor.setThreadNamePrefix(\u0026#34;customer-processing-\u0026#34;); executor.initialize(); return executor; } /** * 分頁配置 */ @Bean public PageableExecutionUtils pageableExecutionUtils() { return new PageableExecutionUtils(); } } /** * 迭代器配置屬性 */ @ConfigurationProperties(prefix = \u0026#34;app.iterator\u0026#34;) @Data public class IteratorProperties { /** * 預設分頁大小 */ private int defaultPageSize = 50; /** * 最大分頁大小 */ private int maxPageSize = 1000; /** * 批次處理大小 */ private int batchSize = 100; /** * 是否啟用快取 */ private boolean cacheEnabled = true; /** * 快取過期時間（分鐘） */ private int cacheExpirationMinutes = 30; } 3. REST API 控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 /** * 客戶迭代器 REST API */ @RestController @RequestMapping(\u0026#34;/api/customers\u0026#34;) @Validated public class CustomerIteratorController { private final CustomerIteratorService customerIteratorService; private final IteratorProperties iteratorProperties; public CustomerIteratorController(CustomerIteratorService customerIteratorService, IteratorProperties iteratorProperties) { this.customerIteratorService = customerIteratorService; this.iteratorProperties = iteratorProperties; } /** * 分頁查詢客戶 */ @GetMapping(\u0026#34;/paged\u0026#34;) public ResponseEntity\u0026lt;PagedCustomerResponse\u0026gt; getPagedCustomers( @RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @RequestParam(required = false) Integer size, @RequestParam(required = false) String type, @RequestParam(required = false) String minAmount, @RequestParam(required = false) Boolean active, @RequestParam(required = false) String namePattern) { // 建構查詢條件 CustomerCriteria criteria = CustomerCriteria.builder(); if (type != null) { criteria.withType(CustomerType.valueOf(type.toUpperCase())); } if (minAmount != null) { criteria.withMinOrderAmount(new BigDecimal(minAmount)); } if (active != null) { criteria.withActiveStatus(active); } if (namePattern != null) { criteria.withNamePattern(namePattern); } int pageSize = size != null ? Math.min(size, iteratorProperties.getMaxPageSize()) : iteratorProperties.getDefaultPageSize(); PagedCustomerIterator iterator = customerIteratorService.createPagedIterator(criteria, pageSize); // 獲取當前頁面數據 List\u0026lt;Customer\u0026gt; customers = new ArrayList\u0026lt;\u0026gt;(); int currentPage = 0; // 跳到指定頁面 while (currentPage \u0026lt; page \u0026amp;\u0026amp; iterator.hasNext()) { iterator.nextBatch(pageSize); currentPage++; } // 獲取當前頁面數據 if (iterator.hasNext()) { customers = iterator.nextBatch(pageSize); } PagedCustomerResponse response = new PagedCustomerResponse( customers, page, pageSize, iterator.getTotalElements(), iterator.getTotalPages()); return ResponseEntity.ok(response); } /** * 批次處理客戶 */ @PostMapping(\u0026#34;/batch-process\u0026#34;) public ResponseEntity\u0026lt;BatchProcessResponse\u0026gt; batchProcessCustomers( @RequestBody @Valid BatchProcessRequest request) { CustomerCriteria criteria = buildCriteriaFromRequest(request); AtomicInteger processedCount = new AtomicInteger(0); List\u0026lt;String\u0026gt; results = new ArrayList\u0026lt;\u0026gt;(); customerIteratorService.processBatchCustomers(criteria, request.getBatchSize(), batch -\u0026gt; { batch.forEach(customer -\u0026gt; { // 執行處理邏輯 String result = processCustomer(customer, request.getProcessingType()); results.add(result); processedCount.incrementAndGet(); }); }); return ResponseEntity.ok(new BatchProcessResponse(processedCount.get(), results)); } /** * 異步處理客戶 */ @PostMapping(\u0026#34;/async-process\u0026#34;) public ResponseEntity\u0026lt;AsyncProcessResponse\u0026gt; asyncProcessCustomers( @RequestBody @Valid AsyncProcessRequest request) { CustomerCriteria criteria = buildCriteriaFromRequest(request); CompletableFuture\u0026lt;ProcessingResult\u0026gt; future = customerIteratorService.processCustomersAsync( criteria, customer -\u0026gt; processCustomer(customer, request.getProcessingType())); // 返回處理 ID 供客戶端查詢進度 String processId = UUID.randomUUID().toString(); // 這裡應該將 future 存儲起來以供後續查詢 return ResponseEntity.accepted().body(new AsyncProcessResponse(processId, \u0026#34;處理已開始\u0026#34;)); } /** * 獲取統計信息 */ @GetMapping(\u0026#34;/statistics\u0026#34;) public ResponseEntity\u0026lt;CustomerStatistics\u0026gt; getCustomerStatistics() { Map\u0026lt;CustomerType, Long\u0026gt; countsByType = customerIteratorService.countCustomersByTypeParallel(); CustomerStatistics statistics = new CustomerStatistics(countsByType); return ResponseEntity.ok(statistics); } private CustomerCriteria buildCriteriaFromRequest(Object request) { // 簡化實現，實際應根據請求類型構建條件 return CustomerCriteria.builder(); } private String processCustomer(Customer customer, String processingType) { // 根據處理類型執行不同邏輯 switch (processingType.toUpperCase()) { case \u0026#34;EMAIL_NOTIFICATION\u0026#34;: return \u0026#34;已發送郵件通知給: \u0026#34; + customer.getEmail(); case \u0026#34;LOYALTY_POINTS\u0026#34;: return \u0026#34;已計算忠誠度積分: \u0026#34; + customer.getCustomerId(); case \u0026#34;DATA_EXPORT\u0026#34;: return \u0026#34;已匯出數據: \u0026#34; + customer.toString(); default: return \u0026#34;已處理客戶: \u0026#34; + customer.getCustomerId(); } } } /** * 請求和回應 DTO */ @Data public class BatchProcessRequest { @NotNull private String processingType; @Min(1) @Max(1000) private int batchSize = 100; private String customerType; private String minOrderAmount; private Boolean active; private String namePattern; } @Data public class AsyncProcessRequest { @NotNull private String processingType; private String customerType; private String minOrderAmount; private Boolean active; private String namePattern; } @Data public class PagedCustomerResponse { private List\u0026lt;Customer\u0026gt; customers; private int currentPage; private int pageSize; private long totalElements; private int totalPages; private LocalDateTime timestamp; public PagedCustomerResponse(List\u0026lt;Customer\u0026gt; customers, int currentPage, int pageSize, long totalElements, int totalPages) { this.customers = customers; this.currentPage = currentPage; this.pageSize = pageSize; this.totalElements = totalElements; this.totalPages = totalPages; this.timestamp = LocalDateTime.now(); } } @Data public class BatchProcessResponse { private int processedCount; private List\u0026lt;String\u0026gt; results; private LocalDateTime timestamp; public BatchProcessResponse(int processedCount, List\u0026lt;String\u0026gt; results) { this.processedCount = processedCount; this.results = results; this.timestamp = LocalDateTime.now(); } } @Data public class AsyncProcessResponse { private String processId; private String message; private LocalDateTime timestamp; public AsyncProcessResponse(String processId, String message) { this.processId = processId; this.message = message; this.timestamp = LocalDateTime.now(); } } @Data public class CustomerStatistics { private Map\u0026lt;CustomerType, Long\u0026gt; countsByType; private long totalCustomers; private LocalDateTime timestamp; public CustomerStatistics(Map\u0026lt;CustomerType, Long\u0026gt; countsByType) { this.countsByType = countsByType; this.totalCustomers = countsByType.values().stream().mapToLong(Long::longValue).sum(); this.timestamp = LocalDateTime.now(); } } 進階主題 1. 效能優化策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 /** * 高效能迭代器實現 */ @Component public class OptimizedIteratorService { private final Cache\u0026lt;String, List\u0026lt;Customer\u0026gt;\u0026gt; iteratorCache; private final ExecutorService executorService; public OptimizedIteratorService() { this.iteratorCache = Caffeine.newBuilder() .maximumSize(1000) .expireAfterWrite(15, TimeUnit.MINUTES) .recordStats() .build(); this.executorService = ForkJoinPool.commonPool(); } /** * 帶快取的分頁迭代器 */ public ModernIterator\u0026lt;Customer\u0026gt; createCachedIterator(CustomerCriteria criteria, int pageSize) { String cacheKey = generateCacheKey(criteria, pageSize); List\u0026lt;Customer\u0026gt; cachedData = iteratorCache.getIfPresent(cacheKey); if (cachedData != null) { return new ListIteratorAdapter\u0026lt;\u0026gt;(cachedData); } return new CachingIterator\u0026lt;\u0026gt;(criteria, pageSize, iteratorCache, cacheKey); } /** * 並行處理迭代器 */ public \u0026lt;R\u0026gt; CompletableFuture\u0026lt;List\u0026lt;R\u0026gt;\u0026gt; processInParallel(ModernIterator\u0026lt;Customer\u0026gt; iterator, Function\u0026lt;Customer, R\u0026gt; processor, int parallelism) { return CompletableFuture.supplyAsync(() -\u0026gt; { List\u0026lt;Customer\u0026gt; customers = new ArrayList\u0026lt;\u0026gt;(); while (iterator.hasNext()) { customers.add(iterator.next()); } return customers.parallelStream() .map(processor) .collect(Collectors.toList()); }, executorService); } /** * 批次處理優化 */ public void processInBatchesOptimized(ModernIterator\u0026lt;Customer\u0026gt; iterator, Consumer\u0026lt;List\u0026lt;Customer\u0026gt;\u0026gt; processor, int batchSize) { List\u0026lt;Customer\u0026gt; batch = new ArrayList\u0026lt;\u0026gt;(batchSize); while (iterator.hasNext()) { batch.add(iterator.next()); if (batch.size() \u0026gt;= batchSize) { processor.accept(new ArrayList\u0026lt;\u0026gt;(batch)); batch.clear(); } } // 處理剩餘元素 if (!batch.isEmpty()) { processor.accept(batch); } } private String generateCacheKey(CustomerCriteria criteria, int pageSize) { return String.format(\u0026#34;customers_%s_%d\u0026#34;, criteria.hashCode(), pageSize); } } /** * 快取迭代器實現 */ class CachingIterator\u0026lt;T\u0026gt; implements ModernIterator\u0026lt;T\u0026gt; { private final Iterator\u0026lt;T\u0026gt; delegate; private final List\u0026lt;T\u0026gt; cache = new ArrayList\u0026lt;\u0026gt;(); private final Cache\u0026lt;String, List\u0026lt;T\u0026gt;\u0026gt; globalCache; private final String cacheKey; public CachingIterator(CustomerCriteria criteria, int pageSize, Cache\u0026lt;String, List\u0026lt;T\u0026gt;\u0026gt; globalCache, String cacheKey) { this.globalCache = globalCache; this.cacheKey = cacheKey; // 實際從數據庫加載數據的邏輯 List\u0026lt;T\u0026gt; data = loadDataFromDatabase(criteria, pageSize); this.delegate = data.iterator(); } @Override public boolean hasNext() { return delegate.hasNext(); } @Override public T next() { T element = delegate.next(); cache.add(element); // 當迭代完成時，將數據加入快取 if (!delegate.hasNext()) { globalCache.put(cacheKey, new ArrayList\u0026lt;\u0026gt;(cache)); } return element; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private List\u0026lt;T\u0026gt; loadDataFromDatabase(CustomerCriteria criteria, int pageSize) { // 簡化實現，實際應該調用數據庫服務 return (List\u0026lt;T\u0026gt;) new ArrayList\u0026lt;Customer\u0026gt;(); } } 2. 測試策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 /** * 迭代器模式測試 */ @ExtendWith(MockitoExtension.class) class IteratorPatternTest { @Mock private CustomerRepository customerRepository; @InjectMocks private CustomerIteratorService customerIteratorService; @Test void testPagedIteratorBasicFunctionality() { // Given CustomerCriteria criteria = CustomerCriteria.builder().withType(CustomerType.VIP); List\u0026lt;Customer\u0026gt; customers = createTestCustomers(); Page\u0026lt;Customer\u0026gt; page = new PageImpl\u0026lt;\u0026gt;(customers); when(customerRepository.findByCriteria(eq(criteria), any(Pageable.class))) .thenReturn(page); // When PagedCustomerIterator iterator = customerIteratorService.createPagedIterator(criteria, 2); // Then assertThat(iterator.hasNext()).isTrue(); Customer first = iterator.next(); assertThat(first).isNotNull(); assertThat(iterator.getTotalElements()).isEqualTo(customers.size()); } @Test void testModernIteratorFiltering() { // Given List\u0026lt;Customer\u0026gt; customers = createTestCustomers(); ModernIterator\u0026lt;Customer\u0026gt; iterator = new ListIteratorAdapter\u0026lt;\u0026gt;(customers); // When ModernIterator\u0026lt;Customer\u0026gt; filteredIterator = iterator.filter( customer -\u0026gt; customer.getType() == CustomerType.VIP); // Then List\u0026lt;Customer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); while (filteredIterator.hasNext()) { result.add(filteredIterator.next()); } assertThat(result).allMatch(customer -\u0026gt; customer.getType() == CustomerType.VIP); } @Test void testModernIteratorMapping() { // Given List\u0026lt;Customer\u0026gt; customers = createTestCustomers(); ModernIterator\u0026lt;Customer\u0026gt; iterator = new ListIteratorAdapter\u0026lt;\u0026gt;(customers); // When ModernIterator\u0026lt;String\u0026gt; emailIterator = iterator.map(Customer::getEmail); // Then List\u0026lt;String\u0026gt; emails = new ArrayList\u0026lt;\u0026gt;(); while (emailIterator.hasNext()) { emails.add(emailIterator.next()); } assertThat(emails).hasSize(customers.size()); assertThat(emails).allMatch(email -\u0026gt; email.contains(\u0026#34;@\u0026#34;)); } @Test void testCompositeIterator() { // Given List\u0026lt;Customer\u0026gt; batch1 = createTestCustomers().subList(0, 2); List\u0026lt;Customer\u0026gt; batch2 = createTestCustomers().subList(2, 4); CompositeIterator\u0026lt;Customer\u0026gt; compositeIterator = new CompositeIterator\u0026lt;\u0026gt;( new ListIteratorAdapter\u0026lt;\u0026gt;(batch1), new ListIteratorAdapter\u0026lt;\u0026gt;(batch2) ); // When List\u0026lt;Customer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); while (compositeIterator.hasNext()) { result.add(compositeIterator.next()); } // Then assertThat(result).hasSize(4); } @Test void testStreamIntegration() { // Given List\u0026lt;Customer\u0026gt; customers = createTestCustomers(); ModernIterator\u0026lt;Customer\u0026gt; iterator = new ListIteratorAdapter\u0026lt;\u0026gt;(customers); // When long vipCount = iterator.asStream() .filter(customer -\u0026gt; customer.getType() == CustomerType.VIP) .count(); // Then long expectedVipCount = customers.stream() .filter(customer -\u0026gt; customer.getType() == CustomerType.VIP) .count(); assertThat(vipCount).isEqualTo(expectedVipCount); } private List\u0026lt;Customer\u0026gt; createTestCustomers() { return Arrays.asList( new Customer(\u0026#34;C001\u0026#34;, \u0026#34;測試1\u0026#34;, \u0026#34;test1@example.com\u0026#34;, CustomerType.REGULAR), new Customer(\u0026#34;C002\u0026#34;, \u0026#34;測試2\u0026#34;, \u0026#34;test2@example.com\u0026#34;, CustomerType.VIP), new Customer(\u0026#34;C003\u0026#34;, \u0026#34;測試3\u0026#34;, \u0026#34;test3@example.com\u0026#34;, CustomerType.ENTERPRISE), new Customer(\u0026#34;C004\u0026#34;, \u0026#34;測試4\u0026#34;, \u0026#34;test4@example.com\u0026#34;, CustomerType.VIP) ); } } /** * Spring Boot 整合測試 */ @SpringBootTest @TestPropertySource(properties = { \u0026#34;app.iterator.default-page-size=10\u0026#34;, \u0026#34;app.iterator.max-page-size=100\u0026#34; }) class IteratorPatternIntegrationTest { @Autowired private CustomerIteratorService customerIteratorService; @Autowired private CustomerRepository customerRepository; @Test @Transactional void testPaginatedIteratorWithDatabase() { // Given saveTestCustomers(); CustomerCriteria criteria = CustomerCriteria.builder(); // When PagedCustomerIterator iterator = customerIteratorService.createPagedIterator(criteria, 2); // Then assertThat(iterator.hasNext()).isTrue(); assertThat(iterator.getTotalElements()).isGreaterThan(0); List\u0026lt;Customer\u0026gt; firstBatch = iterator.nextBatch(2); assertThat(firstBatch).hasSizeLessThanOrEqualTo(2); } @Test void testBatchProcessing() { // Given saveTestCustomers(); CustomerCriteria criteria = CustomerCriteria.builder().withActiveStatus(true); AtomicInteger processedCount = new AtomicInteger(0); // When customerIteratorService.processBatchCustomers(criteria, 5, batch -\u0026gt; { processedCount.addAndGet(batch.size()); }); // Then assertThat(processedCount.get()).isGreaterThan(0); } private void saveTestCustomers() { List\u0026lt;Customer\u0026gt; customers = createTestCustomers(); customerRepository.saveAll(customers); } private List\u0026lt;Customer\u0026gt; createTestCustomers() { return Arrays.asList( new Customer(\u0026#34;IT001\u0026#34;, \u0026#34;整合測試1\u0026#34;, \u0026#34;integration1@example.com\u0026#34;, CustomerType.REGULAR), new Customer(\u0026#34;IT002\u0026#34;, \u0026#34;整合測試2\u0026#34;, \u0026#34;integration2@example.com\u0026#34;, CustomerType.VIP), new Customer(\u0026#34;IT003\u0026#34;, \u0026#34;整合測試3\u0026#34;, \u0026#34;integration3@example.com\u0026#34;, CustomerType.ENTERPRISE) ); } } 最佳實踐與建議 1. 設計原則 責任分離：將迭代邏輯與業務邏輯分離 延遲加載：對大數據集採用分頁或流式處理 記憶體效率：避免一次加載所有數據到記憶體 異常安全：確保迭代過程中的異常得到適當處理 2. 常見陷阱 避免在迭代過程中修改集合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // ❌ 錯誤的設計 - 在迭代中修改集合 List\u0026lt;Customer\u0026gt; customers = getCustomers(); for (Customer customer : customers) { if (customer.isInactive()) { customers.remove(customer); // ConcurrentModificationException } } // ✅ 正確的設計 - 使用 Iterator.remove() 或收集後批量處理 Iterator\u0026lt;Customer\u0026gt; iterator = customers.iterator(); while (iterator.hasNext()) { Customer customer = iterator.next(); if (customer.isInactive()) { iterator.remove(); } } 正確處理資源釋放 1 2 3 4 5 6 // ✅ 使用 try-with-resources 確保資源釋放 try (Stream\u0026lt;Customer\u0026gt; customerStream = customerRepository.findAllActiveCustomersAsStream()) { customerStream .filter(customer -\u0026gt; customer.getType() == CustomerType.VIP) .forEach(this::processVipCustomer); } 3. 使用建議 適用場景：大數據集遍歷、分頁處理、流式數據處理 Spring Data 整合：善用 Page、Slice 和 Stream 查詢 效能優化：考慮使用快取、異步處理和並行流 總結 現代化的迭代器模式不僅包含傳統的遍歷功能，更整合了 Java 8+ 的 Stream API、Spring Data 的分頁機制，以及企業級的批量處理能力。通過合理運用這些現代特性，可以構建高效、可擴展的數據處理系統。\n主要優點 統一接口：提供一致的遍歷方式 記憶體效率：支持大數據集的分批處理 函數式整合：與現代 Java 函數式編程無縫整合 企業級特性：支持分頁、快取、異步處理 主要缺點 複雜性增加：現代化功能增加了實現複雜度 效能開銷：某些高級功能可能帶來額外開銷 依賴性：與特定框架（如 Spring Data）耦合 正確使用現代化迭代器模式可以大幅提升數據處理的效率和可維護性，是企業級應用開發中不可或缺的重要模式。\n","permalink":"https://xinqilin.github.io/post/architecture/iterator/","tags":["Design Pattern","Iterator Pattern","Behavioral Pattern","Java Iterator","Stream API","Spring Data","Pagination","Custom Iterator","Java 8+","Spring Boot","Enterprise Architecture","Collection Traversal","Lazy Loading","Performance Optimization","Functional Programming","Lambda Expressions","Best Practices"],"title":"迭代器模式 (Iterator Pattern) 現代化完整指南：Java 8+ Stream API、Spring Data 分頁與企業級迭代器實作最佳實踐"},{"content":"Visitor 當必須對一組相似類型的對象執行操作時，我們使用訪問者模式。借助 visitor pattern，我們可以將操作邏輯從對象轉移到另一個類。例如，考慮一個購物車，我們可以在其中添加不同類型的商品（元素），當我們點擊結帳按鈕時，它會計算出我們需要支付的總金額。現在，我們可以在項目類中包含計算邏輯，或者我們可以使用 visitor pattern 將此邏輯移到另一個類中。因此，使用 visitor pattern，我們可以將邏輯移到另一個類。\nvisitor pattern 允許在不更改集合中任何對象的類的情況下定義操作。為此，visitor pattern 建議在稱為 visitor類的單獨類中定義操作。這將操作與其操作的對象集合分開。對於要定義的每個新操作，都會創建一個新的訪問者類。由於操作將在一組對像上執行，因此訪問者需要一種訪問這些對象的公共成員的方法。\nVisitor：為對象結構中的每個 ConcreteElement 類聲明一個訪問操作。操作的名稱和簽名標識向訪問者發送訪問請求的類。這讓訪問者可以確定被訪問元素的具體類。然後訪問者可以通過其特定的界面直接訪問該元素。 ConcreteVisitor：實現訪問者聲明的每個操作。每個操作都實現了為結構中的相應對像類定義的算法片段。ConcreteVisitor 為算法提供上下文並存儲其本地狀態。這種狀態通常會在結構的遍歷過程中累積結果。 Element：定義一個接受訪問者作為參數的操作。 ConcreteElement：實現以訪問者為參數的 Accept 操作。 ObjectStructure:\n可以枚舉它的元素。 可以提供高級界面以允許訪問者訪問其元素。 可以是組合或集合，例如列表或集合。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public interface ShoppingCartElement { public int accept(ShoppingCartVisitor visitor); } public class Beef implements ShoppingCartElement { private int price; private double weight; // constructor , getter , setter @Override //Notice the implementation of accept() method in concrete classes, //its calling visit() method of Visitor and passing itself as argument. public int accept(ShoppingCartVisitor visitor) { return visitor.visit(this); } } public class Fruit implements ShoppingCartElement { private int pricePerKg; private int weight; private String name; // constructor , getter , setter @Override public int accept(ShoppingCartVisitor visitor) { return visitor.visit(this); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public interface ShoppingCartVisitor { int visit(Beef book); int visit(Fruit fruit); } public class ShoppingCartVisitorImpl implements ShoppingCartVisitor { @Override public int visit(Beef beef) { var cost = 0; //apply 5$ discount if book price is greater than 50 if(beef.getPrice() \u0026gt; 50){ cost = beef.getPrice() - 5; } else { cost = beef.getPrice(); } log.info(\u0026#34;beef: {}\u0026#34;, beef); return cost; } @Override public int visit(Fruit fruit) { var cost = fruit.getPricePerKg() * fruit.getWeight(); log.info(\u0026#34;cost: \u0026#34; + cost); return cost; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public static void main(String[] args) { var items = new ShoppingCartElement[]{ new Beef(20, 2.0), new Beef(100, 3.0), new Fruit(10, 2, \u0026#34;Apple\u0026#34;), new Fruit(5, 5, \u0026#34;Banana\u0026#34;) }; int total = calculatePrice(items); log.info(\u0026#34;total: \u0026#34; + total); } private static int calculatePrice(ShoppingCartElement[] items) { var visitor = new ShoppingCartVisitorImpl(); int sum = 0; for(ShoppingCartElement item : items){ sum += item.accept(visitor); } return sum; } 一個對象結構包含許多具有不同接口的對像類，並且您希望對這些對象執行依賴於它們的具體類的操作。 當我們需要對對象結構中的對象執行許多不同且不相關的操作時，我們希望避免這些操作 \u0026ldquo;污染\u0026rdquo; 它們的 class。訪問者允許您通過在一個類中定義相關操作來將它們保持在一起。當我們需要與許多應用程序共享對象結構時，使用訪問者將操作放在那些需要它們的應用程序中。 定義對象結構的類很少更改，但您經常希望在該結構上定義新操作。但是，更改對象結構類需要重新定義所有訪問者的接口，這可能是昂貴的。如果對象結構類經常更改，那麼最好在這些類中定義操作。 ","permalink":"https://xinqilin.github.io/post/architecture/visitor/","tags":[],"title":"DesignPattern - Behavioral - Visitor"},{"content":"狀態模式 (State Pattern) 完整實作指南 模式概述 狀態模式是一種行為設計模式，它允許物件在其內部狀態改變時改變其行為。這個模式將狀態相關的行為抽取到獨立的狀態類別中，讓原物件將工作委派給狀態物件的實例，而不是自行進行處理。\n核心概念 1. 狀態模式解決的問題 複雜的條件邏輯：避免大量的 if-else 和 switch-case 語句 狀態相關行為分散：將狀態相關的邏輯集中管理 狀態轉換複雜性：提供清晰的狀態轉換機制 行為變化管理：讓物件根據狀態動態改變行為 2. 模式結構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // 狀態介面 public interface State { void handle(Context context); String getStateName(); } // 上下文類別 public class Context { private State currentState; public Context(State initialState) { this.currentState = initialState; } public void setState(State state) { this.currentState = state; } public void request() { currentState.handle(this); } public State getCurrentState() { return currentState; } } // 具體狀態類別 public class ConcreteStateA implements State { @Override public void handle(Context context) { System.out.println(\u0026#34;處理狀態 A 的邏輯\u0026#34;); // 可能的狀態轉換 context.setState(new ConcreteStateB()); } @Override public String getStateName() { return \u0026#34;State A\u0026#34;; } } public class ConcreteStateB implements State { @Override public void handle(Context context) { System.out.println(\u0026#34;處理狀態 B 的邏輯\u0026#34;); // 可能的狀態轉換 context.setState(new ConcreteStateA()); } @Override public String getStateName() { return \u0026#34;State B\u0026#34;; } } 基礎實作範例 1. 文件審核流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 /** * 文件審核狀態介面 */ public interface DocumentState { void submit(DocumentContext document); void approve(DocumentContext document); void reject(DocumentContext document); void publish(DocumentContext document); String getStatusName(); boolean canTransitionTo(DocumentState newState); } /** * 文件上下文類別 */ public class DocumentContext { private DocumentState currentState; private String documentId; private String content; private String author; private LocalDateTime lastModified; private List\u0026lt;String\u0026gt; reviewComments; public DocumentContext(String documentId, String content, String author) { this.documentId = documentId; this.content = content; this.author = author; this.lastModified = LocalDateTime.now(); this.reviewComments = new ArrayList\u0026lt;\u0026gt;(); this.currentState = new DraftState(); } public void setState(DocumentState state) { if (currentState.canTransitionTo(state)) { System.out.println(\u0026#34;文件狀態從 \u0026#34; + currentState.getStatusName() + \u0026#34; 轉換為 \u0026#34; + state.getStatusName()); this.currentState = state; this.lastModified = LocalDateTime.now(); } else { throw new IllegalStateException(\u0026#34;無法從 \u0026#34; + currentState.getStatusName() + \u0026#34; 轉換為 \u0026#34; + state.getStatusName()); } } public void submit() { currentState.submit(this); } public void approve() { currentState.approve(this); } public void reject() { currentState.reject(this); } public void publish() { currentState.publish(this); } // Getters and Setters public DocumentState getCurrentState() { return currentState; } public String getDocumentId() { return documentId; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public String getAuthor() { return author; } public LocalDateTime getLastModified() { return lastModified; } public List\u0026lt;String\u0026gt; getReviewComments() { return reviewComments; } public void addReviewComment(String comment) { reviewComments.add(comment); } } /** * 草稿狀態 */ public class DraftState implements DocumentState { @Override public void submit(DocumentContext document) { System.out.println(\u0026#34;提交文件進行審核\u0026#34;); document.setState(new UnderReviewState()); } @Override public void approve(DocumentContext document) { throw new IllegalStateException(\u0026#34;草稿狀態無法直接批准\u0026#34;); } @Override public void reject(DocumentContext document) { throw new IllegalStateException(\u0026#34;草稿狀態無法拒絕\u0026#34;); } @Override public void publish(DocumentContext document) { throw new IllegalStateException(\u0026#34;草稿狀態無法直接發布\u0026#34;); } @Override public String getStatusName() { return \u0026#34;DRAFT\u0026#34;; } @Override public boolean canTransitionTo(DocumentState newState) { return newState instanceof UnderReviewState; } } /** * 審核中狀態 */ public class UnderReviewState implements DocumentState { @Override public void submit(DocumentContext document) { throw new IllegalStateException(\u0026#34;文件已在審核中\u0026#34;); } @Override public void approve(DocumentContext document) { System.out.println(\u0026#34;審核通過，文件已批准\u0026#34;); document.setState(new ApprovedState()); } @Override public void reject(DocumentContext document) { System.out.println(\u0026#34;審核未通過，文件被拒絕\u0026#34;); document.setState(new RejectedState()); } @Override public void publish(DocumentContext document) { throw new IllegalStateException(\u0026#34;審核中的文件無法直接發布\u0026#34;); } @Override public String getStatusName() { return \u0026#34;UNDER_REVIEW\u0026#34;; } @Override public boolean canTransitionTo(DocumentState newState) { return newState instanceof ApprovedState || newState instanceof RejectedState; } } /** * 已批准狀態 */ public class ApprovedState implements DocumentState { @Override public void submit(DocumentContext document) { throw new IllegalStateException(\u0026#34;已批准的文件無法重新提交\u0026#34;); } @Override public void approve(DocumentContext document) { System.out.println(\u0026#34;文件已經是批准狀態\u0026#34;); } @Override public void reject(DocumentContext document) { System.out.println(\u0026#34;撤銷批准，文件被拒絕\u0026#34;); document.setState(new RejectedState()); } @Override public void publish(DocumentContext document) { System.out.println(\u0026#34;發布文件\u0026#34;); document.setState(new PublishedState()); } @Override public String getStatusName() { return \u0026#34;APPROVED\u0026#34;; } @Override public boolean canTransitionTo(DocumentState newState) { return newState instanceof PublishedState || newState instanceof RejectedState; } } /** * 已拒絕狀態 */ public class RejectedState implements DocumentState { @Override public void submit(DocumentContext document) { System.out.println(\u0026#34;重新提交文件進行審核\u0026#34;); document.setState(new UnderReviewState()); } @Override public void approve(DocumentContext document) { throw new IllegalStateException(\u0026#34;被拒絕的文件無法直接批准\u0026#34;); } @Override public void reject(DocumentContext document) { System.out.println(\u0026#34;文件已經是拒絕狀態\u0026#34;); } @Override public void publish(DocumentContext document) { throw new IllegalStateException(\u0026#34;被拒絕的文件無法發布\u0026#34;); } @Override public String getStatusName() { return \u0026#34;REJECTED\u0026#34;; } @Override public boolean canTransitionTo(DocumentState newState) { return newState instanceof UnderReviewState; } } /** * 已發布狀態 */ public class PublishedState implements DocumentState { @Override public void submit(DocumentContext document) { throw new IllegalStateException(\u0026#34;已發布的文件無法重新提交\u0026#34;); } @Override public void approve(DocumentContext document) { System.out.println(\u0026#34;文件已經是發布狀態\u0026#34;); } @Override public void reject(DocumentContext document) { throw new IllegalStateException(\u0026#34;已發布的文件無法拒絕\u0026#34;); } @Override public void publish(DocumentContext document) { System.out.println(\u0026#34;文件已經是發布狀態\u0026#34;); } @Override public String getStatusName() { return \u0026#34;PUBLISHED\u0026#34;; } @Override public boolean canTransitionTo(DocumentState newState) { return false; // 發布狀態是終端狀態 } } 2. 文件審核流程測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /** * 文件審核流程測試類別 */ public class DocumentWorkflowExample { public static void main(String[] args) { // 創建文件 DocumentContext document = new DocumentContext( \u0026#34;DOC-001\u0026#34;, \u0026#34;這是一份重要的技術文件\u0026#34;, \u0026#34;張三\u0026#34; ); System.out.println(\u0026#34;=== 文件工作流程示範 ===\u0026#34;); System.out.println(\u0026#34;初始狀態: \u0026#34; + document.getCurrentState().getStatusName()); try { // 提交審核 document.submit(); System.out.println(\u0026#34;當前狀態: \u0026#34; + document.getCurrentState().getStatusName()); // 審核通過 document.approve(); System.out.println(\u0026#34;當前狀態: \u0026#34; + document.getCurrentState().getStatusName()); // 發布文件 document.publish(); System.out.println(\u0026#34;當前狀態: \u0026#34; + document.getCurrentState().getStatusName()); } catch (IllegalStateException e) { System.err.println(\u0026#34;狀態轉換錯誤: \u0026#34; + e.getMessage()); } // 測試錯誤的狀態轉換 System.out.println(\u0026#34;\\n=== 測試錯誤狀態轉換 ===\u0026#34;); try { document.submit(); // 已發布的文件無法重新提交 } catch (IllegalStateException e) { System.err.println(\u0026#34;預期錯誤: \u0026#34; + e.getMessage()); } } } 企業級應用案例 1. 訂單處理系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 /** * 訂單狀態介面 */ public interface OrderState { void confirmOrder(OrderContext order); void payOrder(OrderContext order); void shipOrder(OrderContext order); void deliverOrder(OrderContext order); void cancelOrder(OrderContext order); void returnOrder(OrderContext order); OrderStatus getStatus(); Set\u0026lt;OrderStatus\u0026gt; getAllowedTransitions(); } /** * 訂單狀態枚舉 */ public enum OrderStatus { PENDING(\u0026#34;待確認\u0026#34;), CONFIRMED(\u0026#34;已確認\u0026#34;), PAID(\u0026#34;已付款\u0026#34;), SHIPPED(\u0026#34;已發貨\u0026#34;), DELIVERED(\u0026#34;已送達\u0026#34;), CANCELLED(\u0026#34;已取消\u0026#34;), RETURNED(\u0026#34;已退貨\u0026#34;); private final String description; OrderStatus(String description) { this.description = description; } public String getDescription() { return description; } } /** * 訂單上下文類別 */ public class OrderContext { private OrderState currentState; private String orderId; private String customerId; private List\u0026lt;OrderItem\u0026gt; items; private BigDecimal totalAmount; private LocalDateTime orderDate; private LocalDateTime lastUpdated; private List\u0026lt;OrderEvent\u0026gt; eventHistory; public OrderContext(String orderId, String customerId, List\u0026lt;OrderItem\u0026gt; items) { this.orderId = orderId; this.customerId = customerId; this.items = new ArrayList\u0026lt;\u0026gt;(items); this.totalAmount = calculateTotal(); this.orderDate = LocalDateTime.now(); this.lastUpdated = LocalDateTime.now(); this.eventHistory = new ArrayList\u0026lt;\u0026gt;(); this.currentState = new PendingOrderState(); addEvent(\u0026#34;ORDER_CREATED\u0026#34;, \u0026#34;訂單已創建\u0026#34;); } public void setState(OrderState newState) { OrderState oldState = this.currentState; this.currentState = newState; this.lastUpdated = LocalDateTime.now(); addEvent(\u0026#34;STATE_CHANGED\u0026#34;, String.format(\u0026#34;狀態從 %s 變更為 %s\u0026#34;, oldState.getStatus().getDescription(), newState.getStatus().getDescription())); } private void addEvent(String eventType, String description) { eventHistory.add(new OrderEvent(LocalDateTime.now(), eventType, description)); } private BigDecimal calculateTotal() { return items.stream() .map(item -\u0026gt; item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity()))) .reduce(BigDecimal.ZERO, BigDecimal::add); } // 委派給當前狀態的方法 public void confirmOrder() { currentState.confirmOrder(this); } public void payOrder() { currentState.payOrder(this); } public void shipOrder() { currentState.shipOrder(this); } public void deliverOrder() { currentState.deliverOrder(this); } public void cancelOrder() { currentState.cancelOrder(this); } public void returnOrder() { currentState.returnOrder(this); } // Getters and Setters public OrderState getCurrentState() { return currentState; } public String getOrderId() { return orderId; } public String getCustomerId() { return customerId; } public List\u0026lt;OrderItem\u0026gt; getItems() { return items; } public BigDecimal getTotalAmount() { return totalAmount; } public LocalDateTime getOrderDate() { return orderDate; } public LocalDateTime getLastUpdated() { return lastUpdated; } public List\u0026lt;OrderEvent\u0026gt; getEventHistory() { return eventHistory; } } /** * 待確認訂單狀態 */ public class PendingOrderState implements OrderState { @Override public void confirmOrder(OrderContext order) { System.out.println(\u0026#34;確認訂單: \u0026#34; + order.getOrderId()); order.setState(new ConfirmedOrderState()); } @Override public void payOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;待確認的訂單無法直接付款\u0026#34;); } @Override public void shipOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;待確認的訂單無法發貨\u0026#34;); } @Override public void deliverOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;待確認的訂單無法送達\u0026#34;); } @Override public void cancelOrder(OrderContext order) { System.out.println(\u0026#34;取消訂單: \u0026#34; + order.getOrderId()); order.setState(new CancelledOrderState()); } @Override public void returnOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;待確認的訂單無法退貨\u0026#34;); } @Override public OrderStatus getStatus() { return OrderStatus.PENDING; } @Override public Set\u0026lt;OrderStatus\u0026gt; getAllowedTransitions() { return Set.of(OrderStatus.CONFIRMED, OrderStatus.CANCELLED); } } /** * 已確認訂單狀態 */ public class ConfirmedOrderState implements OrderState { @Override public void confirmOrder(OrderContext order) { System.out.println(\u0026#34;訂單已經是確認狀態\u0026#34;); } @Override public void payOrder(OrderContext order) { System.out.println(\u0026#34;付款成功: \u0026#34; + order.getOrderId()); // 這裡可以整合支付系統 order.setState(new PaidOrderState()); } @Override public void shipOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;未付款的訂單無法發貨\u0026#34;); } @Override public void deliverOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;未付款的訂單無法送達\u0026#34;); } @Override public void cancelOrder(OrderContext order) { System.out.println(\u0026#34;取消已確認的訂單: \u0026#34; + order.getOrderId()); order.setState(new CancelledOrderState()); } @Override public void returnOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;未付款的訂單無法退貨\u0026#34;); } @Override public OrderStatus getStatus() { return OrderStatus.CONFIRMED; } @Override public Set\u0026lt;OrderStatus\u0026gt; getAllowedTransitions() { return Set.of(OrderStatus.PAID, OrderStatus.CANCELLED); } } /** * 已付款訂單狀態 */ public class PaidOrderState implements OrderState { @Override public void confirmOrder(OrderContext order) { System.out.println(\u0026#34;訂單已經是確認狀態\u0026#34;); } @Override public void payOrder(OrderContext order) { System.out.println(\u0026#34;訂單已經付款\u0026#34;); } @Override public void shipOrder(OrderContext order) { System.out.println(\u0026#34;發貨: \u0026#34; + order.getOrderId()); // 整合物流系統 order.setState(new ShippedOrderState()); } @Override public void deliverOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;未發貨的訂單無法直接送達\u0026#34;); } @Override public void cancelOrder(OrderContext order) { System.out.println(\u0026#34;取消已付款的訂單，將進行退款: \u0026#34; + order.getOrderId()); // 這裡需要觸發退款流程 order.setState(new CancelledOrderState()); } @Override public void returnOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;未發貨的訂單無法退貨\u0026#34;); } @Override public OrderStatus getStatus() { return OrderStatus.PAID; } @Override public Set\u0026lt;OrderStatus\u0026gt; getAllowedTransitions() { return Set.of(OrderStatus.SHIPPED, OrderStatus.CANCELLED); } } /** * 已發貨訂單狀態 */ public class ShippedOrderState implements OrderState { @Override public void confirmOrder(OrderContext order) { System.out.println(\u0026#34;訂單已經確認並發貨\u0026#34;); } @Override public void payOrder(OrderContext order) { System.out.println(\u0026#34;訂單已經付款\u0026#34;); } @Override public void shipOrder(OrderContext order) { System.out.println(\u0026#34;訂單已經發貨\u0026#34;); } @Override public void deliverOrder(OrderContext order) { System.out.println(\u0026#34;訂單送達: \u0026#34; + order.getOrderId()); order.setState(new DeliveredOrderState()); } @Override public void cancelOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;已發貨的訂單無法取消，請聯繫客服\u0026#34;); } @Override public void returnOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;未送達的訂單無法退貨\u0026#34;); } @Override public OrderStatus getStatus() { return OrderStatus.SHIPPED; } @Override public Set\u0026lt;OrderStatus\u0026gt; getAllowedTransitions() { return Set.of(OrderStatus.DELIVERED); } } /** * 已送達訂單狀態 */ public class DeliveredOrderState implements OrderState { @Override public void confirmOrder(OrderContext order) { System.out.println(\u0026#34;訂單已完成\u0026#34;); } @Override public void payOrder(OrderContext order) { System.out.println(\u0026#34;訂單已付款並完成\u0026#34;); } @Override public void shipOrder(OrderContext order) { System.out.println(\u0026#34;訂單已發貨並送達\u0026#34;); } @Override public void deliverOrder(OrderContext order) { System.out.println(\u0026#34;訂單已經送達\u0026#34;); } @Override public void cancelOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;已送達的訂單無法取消\u0026#34;); } @Override public void returnOrder(OrderContext order) { System.out.println(\u0026#34;處理退貨請求: \u0026#34; + order.getOrderId()); order.setState(new ReturnedOrderState()); } @Override public OrderStatus getStatus() { return OrderStatus.DELIVERED; } @Override public Set\u0026lt;OrderStatus\u0026gt; getAllowedTransitions() { return Set.of(OrderStatus.RETURNED); } } /** * 已取消訂單狀態 */ public class CancelledOrderState implements OrderState { @Override public void confirmOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;已取消的訂單無法確認\u0026#34;); } @Override public void payOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;已取消的訂單無法付款\u0026#34;); } @Override public void shipOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;已取消的訂單無法發貨\u0026#34;); } @Override public void deliverOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;已取消的訂單無法送達\u0026#34;); } @Override public void cancelOrder(OrderContext order) { System.out.println(\u0026#34;訂單已經是取消狀態\u0026#34;); } @Override public void returnOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;已取消的訂單無法退貨\u0026#34;); } @Override public OrderStatus getStatus() { return OrderStatus.CANCELLED; } @Override public Set\u0026lt;OrderStatus\u0026gt; getAllowedTransitions() { return Set.of(); // 終端狀態 } } /** * 已退貨訂單狀態 */ public class ReturnedOrderState implements OrderState { @Override public void confirmOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;已退貨的訂單無法確認\u0026#34;); } @Override public void payOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;已退貨的訂單無法付款\u0026#34;); } @Override public void shipOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;已退貨的訂單無法發貨\u0026#34;); } @Override public void deliverOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;已退貨的訂單無法送達\u0026#34;); } @Override public void cancelOrder(OrderContext order) { throw new IllegalStateException(\u0026#34;已退貨的訂單無法取消\u0026#34;); } @Override public void returnOrder(OrderContext order) { System.out.println(\u0026#34;訂單已經是退貨狀態\u0026#34;); } @Override public OrderStatus getStatus() { return OrderStatus.RETURNED; } @Override public Set\u0026lt;OrderStatus\u0026gt; getAllowedTransitions() { return Set.of(); // 終端狀態 } } /** * 輔助類別 */ public class OrderItem { private String productId; private String productName; private BigDecimal price; private int quantity; public OrderItem(String productId, String productName, BigDecimal price, int quantity) { this.productId = productId; this.productName = productName; this.price = price; this.quantity = quantity; } // Getters public String getProductId() { return productId; } public String getProductName() { return productName; } public BigDecimal getPrice() { return price; } public int getQuantity() { return quantity; } } public class OrderEvent { private LocalDateTime timestamp; private String eventType; private String description; public OrderEvent(LocalDateTime timestamp, String eventType, String description) { this.timestamp = timestamp; this.eventType = eventType; this.description = description; } // Getters public LocalDateTime getTimestamp() { return timestamp; } public String getEventType() { return eventType; } public String getDescription() { return description; } @Override public String toString() { return String.format(\u0026#34;[%s] %s: %s\u0026#34;, timestamp, eventType, description); } } 2. 訂單處理系統測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /** * 訂單處理系統示範 */ public class OrderProcessingExample { public static void main(String[] args) { // 創建訂單項目 List\u0026lt;OrderItem\u0026gt; items = Arrays.asList( new OrderItem(\u0026#34;P001\u0026#34;, \u0026#34;筆記型電腦\u0026#34;, new BigDecimal(\u0026#34;50000\u0026#34;), 1), new OrderItem(\u0026#34;P002\u0026#34;, \u0026#34;滑鼠\u0026#34;, new BigDecimal(\u0026#34;1000\u0026#34;), 2) ); // 創建訂單 OrderContext order = new OrderContext(\u0026#34;ORDER-2023-001\u0026#34;, \u0026#34;CUST-001\u0026#34;, items); System.out.println(\u0026#34;=== 訂單處理流程示範 ===\u0026#34;); System.out.println(\u0026#34;訂單總額: \u0026#34; + order.getTotalAmount()); System.out.println(\u0026#34;初始狀態: \u0026#34; + order.getCurrentState().getStatus().getDescription()); try { // 正常流程 order.confirmOrder(); System.out.println(\u0026#34;當前狀態: \u0026#34; + order.getCurrentState().getStatus().getDescription()); order.payOrder(); System.out.println(\u0026#34;當前狀態: \u0026#34; + order.getCurrentState().getStatus().getDescription()); order.shipOrder(); System.out.println(\u0026#34;當前狀態: \u0026#34; + order.getCurrentState().getStatus().getDescription()); order.deliverOrder(); System.out.println(\u0026#34;當前狀態: \u0026#34; + order.getCurrentState().getStatus().getDescription()); // 查看事件歷史 System.out.println(\u0026#34;\\n=== 訂單事件歷史 ===\u0026#34;); order.getEventHistory().forEach(System.out::println); } catch (IllegalStateException e) { System.err.println(\u0026#34;狀態轉換錯誤: \u0026#34; + e.getMessage()); } } } Spring Boot 整合 1. 狀態管理服務 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 /** * 狀態工廠介面 */ public interface StateFactory\u0026lt;T extends Enum\u0026lt;T\u0026gt;\u0026gt; { State createState(T stateType); Set\u0026lt;T\u0026gt; getValidTransitions(T currentState); } /** * 文件狀態工廠 */ @Component public class DocumentStateFactory implements StateFactory\u0026lt;DocumentStatus\u0026gt; { private final Map\u0026lt;DocumentStatus, Supplier\u0026lt;DocumentState\u0026gt;\u0026gt; stateCreators; private final Map\u0026lt;DocumentStatus, Set\u0026lt;DocumentStatus\u0026gt;\u0026gt; transitionRules; public DocumentStateFactory() { // 初始化狀態創建器 stateCreators = Map.of( DocumentStatus.DRAFT, DraftState::new, DocumentStatus.UNDER_REVIEW, UnderReviewState::new, DocumentStatus.APPROVED, ApprovedState::new, DocumentStatus.REJECTED, RejectedState::new, DocumentStatus.PUBLISHED, PublishedState::new ); // 初始化狀態轉換規則 transitionRules = Map.of( DocumentStatus.DRAFT, Set.of(DocumentStatus.UNDER_REVIEW), DocumentStatus.UNDER_REVIEW, Set.of(DocumentStatus.APPROVED, DocumentStatus.REJECTED), DocumentStatus.APPROVED, Set.of(DocumentStatus.PUBLISHED, DocumentStatus.REJECTED), DocumentStatus.REJECTED, Set.of(DocumentStatus.UNDER_REVIEW), DocumentStatus.PUBLISHED, Set.of() // 終端狀態 ); } @Override public DocumentState createState(DocumentStatus stateType) { Supplier\u0026lt;DocumentState\u0026gt; creator = stateCreators.get(stateType); if (creator == null) { throw new IllegalArgumentException(\u0026#34;未知的文件狀態: \u0026#34; + stateType); } return creator.get(); } @Override public Set\u0026lt;DocumentStatus\u0026gt; getValidTransitions(DocumentStatus currentState) { return transitionRules.getOrDefault(currentState, Set.of()); } } /** * 文件狀態枚舉 */ public enum DocumentStatus { DRAFT, UNDER_REVIEW, APPROVED, REJECTED, PUBLISHED } /** * 文件實體 */ @Entity @Table(name = \u0026#34;documents\u0026#34;) public class DocumentEntity { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(unique = true, nullable = false) private String documentId; @Column(nullable = false) private String title; @Lob private String content; @Column(nullable = false) private String author; @Enumerated(EnumType.STRING) @Column(nullable = false) private DocumentStatus status; @CreationTimestamp private LocalDateTime createdAt; @UpdateTimestamp private LocalDateTime updatedAt; @OneToMany(mappedBy = \u0026#34;document\u0026#34;, cascade = CascadeType.ALL, fetch = FetchType.LAZY) private List\u0026lt;DocumentEventEntity\u0026gt; events = new ArrayList\u0026lt;\u0026gt;(); // Constructors, Getters, and Setters public DocumentEntity() {} public DocumentEntity(String documentId, String title, String content, String author) { this.documentId = documentId; this.title = title; this.content = content; this.author = author; this.status = DocumentStatus.DRAFT; } // Getters and Setters public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getDocumentId() { return documentId; } public void setDocumentId(String documentId) { this.documentId = documentId; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public DocumentStatus getStatus() { return status; } public void setStatus(DocumentStatus status) { this.status = status; } public LocalDateTime getCreatedAt() { return createdAt; } public LocalDateTime getUpdatedAt() { return updatedAt; } public List\u0026lt;DocumentEventEntity\u0026gt; getEvents() { return events; } } /** * 文件事件實體 */ @Entity @Table(name = \u0026#34;document_events\u0026#34;) public class DocumentEventEntity { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;document_id\u0026#34;) private DocumentEntity document; @Column(nullable = false) private String eventType; @Column(nullable = false) private String description; @CreationTimestamp private LocalDateTime timestamp; // Constructors, Getters, and Setters public DocumentEventEntity() {} public DocumentEventEntity(DocumentEntity document, String eventType, String description) { this.document = document; this.eventType = eventType; this.description = description; } // Getters and Setters public Long getId() { return id; } public DocumentEntity getDocument() { return document; } public String getEventType() { return eventType; } public String getDescription() { return description; } public LocalDateTime getTimestamp() { return timestamp; } } /** * 文件管理服務 */ @Service @Transactional public class DocumentManagementService { private final DocumentRepository documentRepository; private final DocumentEventRepository eventRepository; private final DocumentStateFactory stateFactory; private final ApplicationEventPublisher eventPublisher; public DocumentManagementService(DocumentRepository documentRepository, DocumentEventRepository eventRepository, DocumentStateFactory stateFactory, ApplicationEventPublisher eventPublisher) { this.documentRepository = documentRepository; this.eventRepository = eventRepository; this.stateFactory = stateFactory; this.eventPublisher = eventPublisher; } public DocumentEntity createDocument(String title, String content, String author) { String documentId = \u0026#34;DOC-\u0026#34; + System.currentTimeMillis(); DocumentEntity document = new DocumentEntity(documentId, title, content, author); DocumentEntity savedDocument = documentRepository.save(document); recordEvent(savedDocument, \u0026#34;DOCUMENT_CREATED\u0026#34;, \u0026#34;文件已創建\u0026#34;); return savedDocument; } public DocumentEntity transitionState(String documentId, DocumentStatus newStatus) { DocumentEntity document = documentRepository.findByDocumentId(documentId) .orElseThrow(() -\u0026gt; new EntityNotFoundException(\u0026#34;文件不存在: \u0026#34; + documentId)); DocumentStatus currentStatus = document.getStatus(); // 驗證狀態轉換是否有效 Set\u0026lt;DocumentStatus\u0026gt; validTransitions = stateFactory.getValidTransitions(currentStatus); if (!validTransitions.contains(newStatus)) { throw new IllegalStateException( String.format(\u0026#34;無法從狀態 %s 轉換到 %s\u0026#34;, currentStatus, newStatus)); } // 執行狀態轉換 document.setStatus(newStatus); DocumentEntity savedDocument = documentRepository.save(document); // 記錄事件 recordEvent(savedDocument, \u0026#34;STATE_CHANGED\u0026#34;, String.format(\u0026#34;狀態從 %s 變更為 %s\u0026#34;, currentStatus, newStatus)); // 發布領域事件 eventPublisher.publishEvent(new DocumentStateChangedEvent( documentId, currentStatus, newStatus, LocalDateTime.now())); return savedDocument; } public DocumentEntity submitForReview(String documentId) { return transitionState(documentId, DocumentStatus.UNDER_REVIEW); } public DocumentEntity approveDocument(String documentId, String reviewComment) { DocumentEntity document = transitionState(documentId, DocumentStatus.APPROVED); if (reviewComment != null \u0026amp;\u0026amp; !reviewComment.trim().isEmpty()) { recordEvent(document, \u0026#34;REVIEW_COMMENT\u0026#34;, reviewComment); } return document; } public DocumentEntity rejectDocument(String documentId, String rejectionReason) { DocumentEntity document = transitionState(documentId, DocumentStatus.REJECTED); if (rejectionReason != null \u0026amp;\u0026amp; !rejectionReason.trim().isEmpty()) { recordEvent(document, \u0026#34;REJECTION_REASON\u0026#34;, rejectionReason); } return document; } public DocumentEntity publishDocument(String documentId) { return transitionState(documentId, DocumentStatus.PUBLISHED); } @Transactional(readOnly = true) public DocumentEntity getDocument(String documentId) { return documentRepository.findByDocumentId(documentId) .orElseThrow(() -\u0026gt; new EntityNotFoundException(\u0026#34;文件不存在: \u0026#34; + documentId)); } @Transactional(readOnly = true) public List\u0026lt;DocumentEventEntity\u0026gt; getDocumentHistory(String documentId) { DocumentEntity document = getDocument(documentId); return eventRepository.findByDocumentOrderByTimestampAsc(document); } private void recordEvent(DocumentEntity document, String eventType, String description) { DocumentEventEntity event = new DocumentEventEntity(document, eventType, description); eventRepository.save(event); } } /** * 文件狀態變更事件 */ public class DocumentStateChangedEvent { private final String documentId; private final DocumentStatus fromStatus; private final DocumentStatus toStatus; private final LocalDateTime timestamp; public DocumentStateChangedEvent(String documentId, DocumentStatus fromStatus, DocumentStatus toStatus, LocalDateTime timestamp) { this.documentId = documentId; this.fromStatus = fromStatus; this.toStatus = toStatus; this.timestamp = timestamp; } // Getters public String getDocumentId() { return documentId; } public DocumentStatus getFromStatus() { return fromStatus; } public DocumentStatus getToStatus() { return toStatus; } public LocalDateTime getTimestamp() { return timestamp; } } /** * 事件監聽器 */ @Component public class DocumentEventListener { private static final Logger logger = LoggerFactory.getLogger(DocumentEventListener.class); @EventListener public void handleDocumentStateChanged(DocumentStateChangedEvent event) { logger.info(\u0026#34;文件狀態變更: {} 從 {} 變更為 {}\u0026#34;, event.getDocumentId(), event.getFromStatus(), event.getToStatus()); // 根據狀態變更執行相應的業務邏輯 switch (event.getToStatus()) { case UNDER_REVIEW: sendReviewNotification(event.getDocumentId()); break; case APPROVED: sendApprovalNotification(event.getDocumentId()); break; case PUBLISHED: sendPublicationNotification(event.getDocumentId()); break; default: // 其他狀態的處理 break; } } private void sendReviewNotification(String documentId) { logger.info(\u0026#34;發送審核通知: {}\u0026#34;, documentId); // 實作通知邏輯 } private void sendApprovalNotification(String documentId) { logger.info(\u0026#34;發送批准通知: {}\u0026#34;, documentId); // 實作通知邏輯 } private void sendPublicationNotification(String documentId) { logger.info(\u0026#34;發送發布通知: {}\u0026#34;, documentId); // 實作通知邏輯 } } 2. REST API 控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 /** * 文件管理 REST API */ @RestController @RequestMapping(\u0026#34;/api/documents\u0026#34;) @Validated public class DocumentController { private final DocumentManagementService documentService; public DocumentController(DocumentManagementService documentService) { this.documentService = documentService; } @PostMapping public ResponseEntity\u0026lt;DocumentResponse\u0026gt; createDocument( @Valid @RequestBody CreateDocumentRequest request) { DocumentEntity document = documentService.createDocument( request.getTitle(), request.getContent(), request.getAuthor() ); return ResponseEntity.status(HttpStatus.CREATED) .body(DocumentResponse.from(document)); } @GetMapping(\u0026#34;/{documentId}\u0026#34;) public ResponseEntity\u0026lt;DocumentResponse\u0026gt; getDocument( @PathVariable @NotBlank String documentId) { DocumentEntity document = documentService.getDocument(documentId); return ResponseEntity.ok(DocumentResponse.from(document)); } @PostMapping(\u0026#34;/{documentId}/submit\u0026#34;) public ResponseEntity\u0026lt;DocumentResponse\u0026gt; submitDocument( @PathVariable @NotBlank String documentId) { DocumentEntity document = documentService.submitForReview(documentId); return ResponseEntity.ok(DocumentResponse.from(document)); } @PostMapping(\u0026#34;/{documentId}/approve\u0026#34;) public ResponseEntity\u0026lt;DocumentResponse\u0026gt; approveDocument( @PathVariable @NotBlank String documentId, @RequestBody(required = false) ApprovalRequest request) { String comment = request != null ? request.getComment() : null; DocumentEntity document = documentService.approveDocument(documentId, comment); return ResponseEntity.ok(DocumentResponse.from(document)); } @PostMapping(\u0026#34;/{documentId}/reject\u0026#34;) public ResponseEntity\u0026lt;DocumentResponse\u0026gt; rejectDocument( @PathVariable @NotBlank String documentId, @Valid @RequestBody RejectionRequest request) { DocumentEntity document = documentService.rejectDocument( documentId, request.getReason()); return ResponseEntity.ok(DocumentResponse.from(document)); } @PostMapping(\u0026#34;/{documentId}/publish\u0026#34;) public ResponseEntity\u0026lt;DocumentResponse\u0026gt; publishDocument( @PathVariable @NotBlank String documentId) { DocumentEntity document = documentService.publishDocument(documentId); return ResponseEntity.ok(DocumentResponse.from(document)); } @GetMapping(\u0026#34;/{documentId}/history\u0026#34;) public ResponseEntity\u0026lt;List\u0026lt;DocumentEventResponse\u0026gt;\u0026gt; getDocumentHistory( @PathVariable @NotBlank String documentId) { List\u0026lt;DocumentEventEntity\u0026gt; events = documentService.getDocumentHistory(documentId); List\u0026lt;DocumentEventResponse\u0026gt; responses = events.stream() .map(DocumentEventResponse::from) .collect(Collectors.toList()); return ResponseEntity.ok(responses); } @ExceptionHandler(IllegalStateException.class) public ResponseEntity\u0026lt;ErrorResponse\u0026gt; handleIllegalStateException( IllegalStateException ex) { ErrorResponse error = new ErrorResponse(\u0026#34;STATE_TRANSITION_ERROR\u0026#34;, ex.getMessage()); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error); } @ExceptionHandler(EntityNotFoundException.class) public ResponseEntity\u0026lt;ErrorResponse\u0026gt; handleEntityNotFoundException( EntityNotFoundException ex) { ErrorResponse error = new ErrorResponse(\u0026#34;ENTITY_NOT_FOUND\u0026#34;, ex.getMessage()); return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error); } } /** * 請求/回應 DTO 類別 */ public class CreateDocumentRequest { @NotBlank(message = \u0026#34;標題不能為空\u0026#34;) private String title; @NotBlank(message = \u0026#34;內容不能為空\u0026#34;) private String content; @NotBlank(message = \u0026#34;作者不能為空\u0026#34;) private String author; // Getters and Setters public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } } public class ApprovalRequest { private String comment; public String getComment() { return comment; } public void setComment(String comment) { this.comment = comment; } } public class RejectionRequest { @NotBlank(message = \u0026#34;拒絕原因不能為空\u0026#34;) private String reason; public String getReason() { return reason; } public void setReason(String reason) { this.reason = reason; } } public class DocumentResponse { private String documentId; private String title; private String content; private String author; private DocumentStatus status; private LocalDateTime createdAt; private LocalDateTime updatedAt; public static DocumentResponse from(DocumentEntity entity) { DocumentResponse response = new DocumentResponse(); response.documentId = entity.getDocumentId(); response.title = entity.getTitle(); response.content = entity.getContent(); response.author = entity.getAuthor(); response.status = entity.getStatus(); response.createdAt = entity.getCreatedAt(); response.updatedAt = entity.getUpdatedAt(); return response; } // Getters public String getDocumentId() { return documentId; } public String getTitle() { return title; } public String getContent() { return content; } public String getAuthor() { return author; } public DocumentStatus getStatus() { return status; } public LocalDateTime getCreatedAt() { return createdAt; } public LocalDateTime getUpdatedAt() { return updatedAt; } } public class DocumentEventResponse { private String eventType; private String description; private LocalDateTime timestamp; public static DocumentEventResponse from(DocumentEventEntity entity) { DocumentEventResponse response = new DocumentEventResponse(); response.eventType = entity.getEventType(); response.description = entity.getDescription(); response.timestamp = entity.getTimestamp(); return response; } // Getters public String getEventType() { return eventType; } public String getDescription() { return description; } public LocalDateTime getTimestamp() { return timestamp; } } public class ErrorResponse { private String errorCode; private String message; private LocalDateTime timestamp; public ErrorResponse(String errorCode, String message) { this.errorCode = errorCode; this.message = message; this.timestamp = LocalDateTime.now(); } // Getters public String getErrorCode() { return errorCode; } public String getMessage() { return message; } public LocalDateTime getTimestamp() { return timestamp; } } 狀態機引擎實作 1. 通用狀態機引擎 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 /** * 通用狀態機介面 */ public interface StateMachine\u0026lt;S extends Enum\u0026lt;S\u0026gt;, E extends Enum\u0026lt;E\u0026gt;, C\u0026gt; { S getCurrentState(); void sendEvent(E event, C context); Set\u0026lt;E\u0026gt; getAvailableEvents(); boolean canTransition(E event); void addTransitionListener(TransitionListener\u0026lt;S, E, C\u0026gt; listener); void removeTransitionListener(TransitionListener\u0026lt;S, E, C\u0026gt; listener); } /** * 狀態轉換監聽器 */ public interface TransitionListener\u0026lt;S extends Enum\u0026lt;S\u0026gt;, E extends Enum\u0026lt;E\u0026gt;, C\u0026gt; { void onTransition(S fromState, S toState, E event, C context); void onTransitionFailed(S currentState, E event, C context, Exception exception); } /** * 狀態轉換定義 */ public class StateTransition\u0026lt;S extends Enum\u0026lt;S\u0026gt;, E extends Enum\u0026lt;E\u0026gt;, C\u0026gt; { private final S fromState; private final S toState; private final E event; private final Predicate\u0026lt;C\u0026gt; guard; private final Consumer\u0026lt;C\u0026gt; action; public StateTransition(S fromState, S toState, E event) { this(fromState, toState, event, null, null); } public StateTransition(S fromState, S toState, E event, Predicate\u0026lt;C\u0026gt; guard) { this(fromState, toState, event, guard, null); } public StateTransition(S fromState, S toState, E event, Predicate\u0026lt;C\u0026gt; guard, Consumer\u0026lt;C\u0026gt; action) { this.fromState = fromState; this.toState = toState; this.event = event; this.guard = guard != null ? guard : context -\u0026gt; true; this.action = action; } public boolean canExecute(S currentState, E triggerEvent, C context) { return fromState.equals(currentState) \u0026amp;\u0026amp; event.equals(triggerEvent) \u0026amp;\u0026amp; guard.test(context); } public void execute(C context) { if (action != null) { action.accept(context); } } // Getters public S getFromState() { return fromState; } public S getToState() { return toState; } public E getEvent() { return event; } } /** * 狀態機實作 */ public class DefaultStateMachine\u0026lt;S extends Enum\u0026lt;S\u0026gt;, E extends Enum\u0026lt;E\u0026gt;, C\u0026gt; implements StateMachine\u0026lt;S, E, C\u0026gt; { private S currentState; private final Map\u0026lt;String, StateTransition\u0026lt;S, E, C\u0026gt;\u0026gt; transitions; private final List\u0026lt;TransitionListener\u0026lt;S, E, C\u0026gt;\u0026gt; listeners; public DefaultStateMachine(S initialState) { this.currentState = initialState; this.transitions = new ConcurrentHashMap\u0026lt;\u0026gt;(); this.listeners = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); } public void addTransition(StateTransition\u0026lt;S, E, C\u0026gt; transition) { String key = createTransitionKey(transition.getFromState(), transition.getEvent()); transitions.put(key, transition); } @Override public synchronized void sendEvent(E event, C context) { String key = createTransitionKey(currentState, event); StateTransition\u0026lt;S, E, C\u0026gt; transition = transitions.get(key); if (transition == null) { String error = String.format(\u0026#34;沒有從狀態 %s 透過事件 %s 的轉換\u0026#34;, currentState, event); notifyTransitionFailed(currentState, event, context, new IllegalStateException(error)); throw new IllegalStateException(error); } if (!transition.canExecute(currentState, event, context)) { String error = String.format(\u0026#34;轉換條件不滿足: %s -\u0026gt; %s (%s)\u0026#34;, currentState, transition.getToState(), event); notifyTransitionFailed(currentState, event, context, new IllegalStateException(error)); throw new IllegalStateException(error); } try { S fromState = currentState; transition.execute(context); currentState = transition.getToState(); notifyTransition(fromState, currentState, event, context); } catch (Exception e) { notifyTransitionFailed(currentState, event, context, e); throw new RuntimeException(\u0026#34;狀態轉換執行失敗\u0026#34;, e); } } @Override public S getCurrentState() { return currentState; } @Override public Set\u0026lt;E\u0026gt; getAvailableEvents() { return transitions.keySet().stream() .filter(key -\u0026gt; key.startsWith(currentState.name() + \u0026#34;:\u0026#34;)) .map(key -\u0026gt; key.substring(key.indexOf(\u0026#34;:\u0026#34;) + 1)) .map(eventName -\u0026gt; Enum.valueOf(getEventClass(), eventName)) .collect(Collectors.toSet()); } @Override public boolean canTransition(E event) { String key = createTransitionKey(currentState, event); return transitions.containsKey(key); } @Override public void addTransitionListener(TransitionListener\u0026lt;S, E, C\u0026gt; listener) { listeners.add(listener); } @Override public void removeTransitionListener(TransitionListener\u0026lt;S, E, C\u0026gt; listener) { listeners.remove(listener); } private String createTransitionKey(S state, E event) { return state.name() + \u0026#34;:\u0026#34; + event.name(); } private void notifyTransition(S fromState, S toState, E event, C context) { for (TransitionListener\u0026lt;S, E, C\u0026gt; listener : listeners) { try { listener.onTransition(fromState, toState, event, context); } catch (Exception e) { System.err.println(\u0026#34;轉換監聽器執行錯誤: \u0026#34; + e.getMessage()); } } } private void notifyTransitionFailed(S currentState, E event, C context, Exception exception) { for (TransitionListener\u0026lt;S, E, C\u0026gt; listener : listeners) { try { listener.onTransitionFailed(currentState, event, context, exception); } catch (Exception e) { System.err.println(\u0026#34;轉換失敗監聽器執行錯誤: \u0026#34; + e.getMessage()); } } } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private Class\u0026lt;E\u0026gt; getEventClass() { // 這是一個簡化的實作，實際應用中可能需要更複雜的類型推斷 return (Class\u0026lt;E\u0026gt;) transitions.values().iterator().next().getEvent().getClass(); } } /** * 狀態機建構器 */ public class StateMachineBuilder\u0026lt;S extends Enum\u0026lt;S\u0026gt;, E extends Enum\u0026lt;E\u0026gt;, C\u0026gt; { private final S initialState; private final List\u0026lt;StateTransition\u0026lt;S, E, C\u0026gt;\u0026gt; transitions; public StateMachineBuilder(S initialState) { this.initialState = initialState; this.transitions = new ArrayList\u0026lt;\u0026gt;(); } public static \u0026lt;S extends Enum\u0026lt;S\u0026gt;, E extends Enum\u0026lt;E\u0026gt;, C\u0026gt; StateMachineBuilder\u0026lt;S, E, C\u0026gt; create(S initialState) { return new StateMachineBuilder\u0026lt;\u0026gt;(initialState); } public StateMachineBuilder\u0026lt;S, E, C\u0026gt; transition(S from, S to, E event) { transitions.add(new StateTransition\u0026lt;\u0026gt;(from, to, event)); return this; } public StateMachineBuilder\u0026lt;S, E, C\u0026gt; transition(S from, S to, E event, Predicate\u0026lt;C\u0026gt; guard) { transitions.add(new StateTransition\u0026lt;\u0026gt;(from, to, event, guard)); return this; } public StateMachineBuilder\u0026lt;S, E, C\u0026gt; transition(S from, S to, E event, Predicate\u0026lt;C\u0026gt; guard, Consumer\u0026lt;C\u0026gt; action) { transitions.add(new StateTransition\u0026lt;\u0026gt;(from, to, event, guard, action)); return this; } public StateMachine\u0026lt;S, E, C\u0026gt; build() { DefaultStateMachine\u0026lt;S, E, C\u0026gt; stateMachine = new DefaultStateMachine\u0026lt;\u0026gt;(initialState); transitions.forEach(stateMachine::addTransition); return stateMachine; } } 2. 狀態機使用範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 /** * 訂單狀態和事件定義 */ public enum OrderState { PENDING, CONFIRMED, PAID, SHIPPED, DELIVERED, CANCELLED, RETURNED } public enum OrderEvent { CONFIRM, PAY, SHIP, DELIVER, CANCEL, RETURN } /** * 訂單上下文 */ public class OrderContext { private String orderId; private BigDecimal amount; private String customerId; private boolean paymentVerified; private boolean inventoryAvailable; public OrderContext(String orderId, BigDecimal amount, String customerId) { this.orderId = orderId; this.amount = amount; this.customerId = customerId; this.paymentVerified = false; this.inventoryAvailable = true; } // Getters and Setters public String getOrderId() { return orderId; } public BigDecimal getAmount() { return amount; } public String getCustomerId() { return customerId; } public boolean isPaymentVerified() { return paymentVerified; } public void setPaymentVerified(boolean paymentVerified) { this.paymentVerified = paymentVerified; } public boolean isInventoryAvailable() { return inventoryAvailable; } public void setInventoryAvailable(boolean inventoryAvailable) { this.inventoryAvailable = inventoryAvailable; } } /** * 訂單狀態機範例 */ public class OrderStateMachineExample { public static void main(String[] args) { // 建立訂單狀態機 StateMachine\u0026lt;OrderState, OrderEvent, OrderContext\u0026gt; orderStateMachine = StateMachineBuilder.\u0026lt;OrderState, OrderEvent, OrderContext\u0026gt;create(OrderState.PENDING) // 基本轉換 .transition(OrderState.PENDING, OrderState.CONFIRMED, OrderEvent.CONFIRM) .transition(OrderState.CONFIRMED, OrderState.PAID, OrderEvent.PAY, context -\u0026gt; context.isInventoryAvailable()) // 有庫存才能付款 .transition(OrderState.PAID, OrderState.SHIPPED, OrderEvent.SHIP, context -\u0026gt; context.isPaymentVerified()) // 付款確認後才能發貨 .transition(OrderState.SHIPPED, OrderState.DELIVERED, OrderEvent.DELIVER) // 取消轉換 .transition(OrderState.PENDING, OrderState.CANCELLED, OrderEvent.CANCEL) .transition(OrderState.CONFIRMED, OrderState.CANCELLED, OrderEvent.CANCEL) .transition(OrderState.PAID, OrderState.CANCELLED, OrderEvent.CANCEL, null, context -\u0026gt; System.out.println(\u0026#34;執行退款: \u0026#34; + context.getOrderId())) // 退貨轉換 .transition(OrderState.DELIVERED, OrderState.RETURNED, OrderEvent.RETURN, null, context -\u0026gt; System.out.println(\u0026#34;處理退貨: \u0026#34; + context.getOrderId())) .build(); // 添加轉換監聽器 orderStateMachine.addTransitionListener(new TransitionListener\u0026lt;OrderState, OrderEvent, OrderContext\u0026gt;() { @Override public void onTransition(OrderState fromState, OrderState toState, OrderEvent event, OrderContext context) { System.out.printf(\u0026#34;訂單 %s: %s -\u0026gt; %s (事件: %s)\\n\u0026#34;, context.getOrderId(), fromState, toState, event); } @Override public void onTransitionFailed(OrderState currentState, OrderEvent event, OrderContext context, Exception exception) { System.err.printf(\u0026#34;轉換失敗 - 訂單 %s 在狀態 %s 執行事件 %s: %s\\n\u0026#34;, context.getOrderId(), currentState, event, exception.getMessage()); } }); // 模擬訂單處理流程 OrderContext orderContext = new OrderContext(\u0026#34;ORDER-001\u0026#34;, new BigDecimal(\u0026#34;1000\u0026#34;), \u0026#34;CUST-001\u0026#34;); try { System.out.println(\u0026#34;=== 訂單處理流程 ===\u0026#34;); System.out.println(\u0026#34;初始狀態: \u0026#34; + orderStateMachine.getCurrentState()); System.out.println(\u0026#34;可用事件: \u0026#34; + orderStateMachine.getAvailableEvents()); // 確認訂單 orderStateMachine.sendEvent(OrderEvent.CONFIRM, orderContext); System.out.println(\u0026#34;可用事件: \u0026#34; + orderStateMachine.getAvailableEvents()); // 付款 orderStateMachine.sendEvent(OrderEvent.PAY, orderContext); System.out.println(\u0026#34;可用事件: \u0026#34; + orderStateMachine.getAvailableEvents()); // 驗證付款 orderContext.setPaymentVerified(true); // 發貨 orderStateMachine.sendEvent(OrderEvent.SHIP, orderContext); System.out.println(\u0026#34;可用事件: \u0026#34; + orderStateMachine.getAvailableEvents()); // 送達 orderStateMachine.sendEvent(OrderEvent.DELIVER, orderContext); System.out.println(\u0026#34;最終狀態: \u0026#34; + orderStateMachine.getCurrentState()); System.out.println(\u0026#34;可用事件: \u0026#34; + orderStateMachine.getAvailableEvents()); } catch (Exception e) { System.err.println(\u0026#34;處理錯誤: \u0026#34; + e.getMessage()); } } } 最佳實踐與設計原則 1. 狀態模式 vs 策略模式 特徵 狀態模式 策略模式 目的 根據內部狀態改變行為 封裝可互換的算法 狀態/策略數量 通常固定且有限 可動態擴展 轉換控制 狀態自己控制轉換 客戶端選擇策略 上下文依賴 狀態知道上下文 策略相對獨立 生命週期 狀態可能有生命週期 策略通常無狀態 2. 設計原則 單一職責原則 (SRP) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // ✅ 好的設計：每個狀態類別只負責一個狀態的行為 public class DraftDocumentState implements DocumentState { @Override public void submit(DocumentContext context) { // 只處理草稿狀態的提交邏輯 validateDocument(context); context.setState(new UnderReviewState()); } private void validateDocument(DocumentContext context) { // 文件驗證邏輯 } } // ❌ 壞的設計：一個類別處理多個狀態 public class DocumentProcessor { public void processDocument(DocumentContext context, String action) { switch (context.getStatus()) { case DRAFT: if (\u0026#34;submit\u0026#34;.equals(action)) { // 處理提交 } break; case UNDER_REVIEW: if (\u0026#34;approve\u0026#34;.equals(action)) { // 處理批准 } break; // 更多狀態... } } } 開閉原則 (OCP) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ✅ 容易擴展：添加新狀態不需要修改現有代碼 public class ArchiveState implements DocumentState { @Override public void submit(DocumentContext document) { throw new IllegalStateException(\u0026#34;已歸檔的文件無法重新提交\u0026#34;); } @Override public void approve(DocumentContext document) { throw new IllegalStateException(\u0026#34;已歸檔的文件無法批准\u0026#34;); } // 實現其他方法... } 3. 效能優化策略 狀態實例管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * 狀態實例池 - 避免重複創建狀態對象 */ public class StateInstancePool { private static final Map\u0026lt;Class\u0026lt;? extends DocumentState\u0026gt;, DocumentState\u0026gt; INSTANCE_POOL = new ConcurrentHashMap\u0026lt;\u0026gt;(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static \u0026lt;T extends DocumentState\u0026gt; T getInstance(Class\u0026lt;T\u0026gt; stateClass) { return (T) INSTANCE_POOL.computeIfAbsent(stateClass, key -\u0026gt; { try { return key.getDeclaredConstructor().newInstance(); } catch (Exception e) { throw new RuntimeException(\u0026#34;無法創建狀態實例: \u0026#34; + key.getName(), e); } }); } } // 使用狀態池 public class OptimizedDraftState implements DocumentState { @Override public void submit(DocumentContext document) { document.setState(StateInstancePool.getInstance(UnderReviewState.class)); } } 狀態轉換快取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * 狀態轉換快取 */ @Component public class StateTransitionCache { private final Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; transitionCache = new ConcurrentHashMap\u0026lt;\u0026gt;(); public boolean isValidTransition(String fromState, String toState) { String key = fromState + \u0026#34;-\u0026gt;\u0026#34; + toState; return transitionCache.computeIfAbsent(fromState, this::loadValidTransitions) .contains(toState); } private Set\u0026lt;String\u0026gt; loadValidTransitions(String fromState) { // 從配置或資料庫載入有效轉換 // 這裡簡化為硬編碼 switch (fromState) { case \u0026#34;DRAFT\u0026#34;: return Set.of(\u0026#34;UNDER_REVIEW\u0026#34;); case \u0026#34;UNDER_REVIEW\u0026#34;: return Set.of(\u0026#34;APPROVED\u0026#34;, \u0026#34;REJECTED\u0026#34;); case \u0026#34;APPROVED\u0026#34;: return Set.of(\u0026#34;PUBLISHED\u0026#34;, \u0026#34;REJECTED\u0026#34;); case \u0026#34;REJECTED\u0026#34;: return Set.of(\u0026#34;UNDER_REVIEW\u0026#34;); default: return Set.of(); } } } 4. 測試策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 /** * 狀態模式單元測試 */ @ExtendWith(MockitoExtension.class) class DocumentStateTest { @Mock private DocumentContext mockContext; @Test void testDraftStateSubmit() { // Given DraftState draftState = new DraftState(); // When draftState.submit(mockContext); // Then verify(mockContext).setState(any(UnderReviewState.class)); } @Test void testDraftStateCannotApprove() { // Given DraftState draftState = new DraftState(); // When \u0026amp; Then assertThrows(IllegalStateException.class, () -\u0026gt; { draftState.approve(mockContext); }); } @Test void testStateTransitionValidation() { // Given DocumentContext document = new DocumentContext(\u0026#34;DOC-001\u0026#34;, \u0026#34;Content\u0026#34;, \u0026#34;Author\u0026#34;); // When \u0026amp; Then assertDoesNotThrow(() -\u0026gt; document.submit()); assertEquals(\u0026#34;UNDER_REVIEW\u0026#34;, document.getCurrentState().getStatusName()); assertDoesNotThrow(() -\u0026gt; document.approve()); assertEquals(\u0026#34;APPROVED\u0026#34;, document.getCurrentState().getStatusName()); assertThrows(IllegalStateException.class, () -\u0026gt; document.submit()); } } /** * 狀態機整合測試 */ @SpringBootTest @Transactional class DocumentWorkflowIntegrationTest { @Autowired private DocumentManagementService documentService; @Test void testCompleteDocumentWorkflow() { // Given DocumentEntity document = documentService.createDocument( \u0026#34;測試文件\u0026#34;, \u0026#34;測試內容\u0026#34;, \u0026#34;測試作者\u0026#34;); String documentId = document.getDocumentId(); // When \u0026amp; Then // 提交審核 document = documentService.submitForReview(documentId); assertEquals(DocumentStatus.UNDER_REVIEW, document.getStatus()); // 批准文件 document = documentService.approveDocument(documentId, \u0026#34;審核通過\u0026#34;); assertEquals(DocumentStatus.APPROVED, document.getStatus()); // 發布文件 document = documentService.publishDocument(documentId); assertEquals(DocumentStatus.PUBLISHED, document.getStatus()); // 驗證事件歷史 List\u0026lt;DocumentEventEntity\u0026gt; events = documentService.getDocumentHistory(documentId); assertTrue(events.size() \u0026gt;= 4); // 創建、提交、批准、發布 } @Test void testInvalidStateTransition() { // Given DocumentEntity document = documentService.createDocument( \u0026#34;測試文件\u0026#34;, \u0026#34;測試內容\u0026#34;, \u0026#34;測試作者\u0026#34;); // When \u0026amp; Then assertThrows(IllegalStateException.class, () -\u0026gt; { documentService.publishDocument(document.getDocumentId()); // 草稿無法直接發布 }); } } 總結與最佳實踐 狀態模式的優點 清晰的狀態管理：將狀態相關的行為封裝在獨立的類別中 易於擴展：新增狀態不需要修改現有代碼 避免複雜的條件判斷：消除大量的 if-else 和 switch-case 語句 符合開閉原則：對擴展開放，對修改封閉 狀態轉換明確：狀態之間的轉換關係清晰可見 狀態模式的缺點 類別數量增加：每個狀態都需要一個類別 複雜度增加：對於簡單的狀態邏輯可能過度設計 狀態共享困難：狀態之間難以共享數據 使用建議 適用場景：\n對象行為依賴於其狀態 存在大量狀態相關的條件判斷 狀態轉換邏輯複雜 需要明確的狀態管理 設計原則：\n保持狀態類別的單一職責 使用工廠模式管理狀態實例 考慮狀態轉換的原子性 實作完整的異常處理 實作技巧：\n使用枚舉定義狀態和事件 實作狀態轉換驗證 添加事件監聽機制 考慮持久化狀態信息 狀態模式是管理復雜狀態邏輯的強大工具，特別適合工作流程、訂單處理、用戶認證等需要明確狀態管理的場景。正確使用狀態模式可以大幅提升代碼的可維護性和可擴展性。\n","permalink":"https://xinqilin.github.io/post/architecture/state/","tags":["Design Pattern","State Pattern","Behavioral Pattern","State Machine","Finite State Machine","Dynamic Behavior","Context","State Transition","Java","Spring Boot","Enterprise Architecture","Workflow Engine","Business Process","Event-Driven Architecture","Order Processing","User Authentication","Document Lifecycle","Best Practices"],"title":"狀態模式 (State Pattern) 完整實作指南：動態行為切換與狀態機設計最佳實踐"},{"content":"Command Pattern 命令模式 Command Pattern 是行為型設計模式之一，它將一個請求封裝為一個對象，從而讓你可以用不同的請求對客戶端進行參數化、對請求排隊或記錄請求日誌，以及支持可撤銷的操作。\n核心概念 命令模式將發出請求的對象與處理請求的對象分離開來。這個模式的關鍵在於引入了命令對象，它封裝了一個行為或一組行為，使得可以在不同的時間、不同的上下文中執行這些行為。\n主要組成部分 Command (命令接口): 定義執行操作的接口 ConcreteCommand (具體命令): 實現命令接口，綁定接收者和動作 Receiver (接收者): 執行實際操作的對象 Invoker (調用者): 調用命令對象執行請求 Client (客戶端): 創建具體命令對象並設置接收者 主要優勢 解耦: 調用者和接收者之間完全解耦 可撤銷: 支持撤銷和重做操作 宏命令: 支持命令的組合和批處理 日誌記錄: 便於記錄和審計操作 隊列處理: 支持請求的排隊和延遲執行 1. 基礎命令模式實現 基本命令接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // 命令接口 public interface Command { void execute(); void undo(); String getDescription(); } // 空命令實現 - 空對象模式 public class NoCommand implements Command { @Override public void execute() { // 什麼都不做 } @Override public void undo() { // 什麼都不做 } @Override public String getDescription() { return \u0026#34;No Command\u0026#34;; } } // 抽象命令基類 public abstract class AbstractCommand implements Command { protected final String description; protected final LocalDateTime timestamp; public AbstractCommand(String description) { this.description = description; this.timestamp = LocalDateTime.now(); } @Override public String getDescription() { return description; } public LocalDateTime getTimestamp() { return timestamp; } @Override public String toString() { return String.format(\u0026#34;%s [%s]\u0026#34;, description, timestamp); } } 文本編輯器命令範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 // 接收者 - 文本編輯器 public class TextEditor { private StringBuilder content; private int cursor; public TextEditor() { this.content = new StringBuilder(); this.cursor = 0; } public void insertText(String text) { content.insert(cursor, text); cursor += text.length(); } public void deleteText(int length) { int startPos = Math.max(0, cursor - length); content.delete(startPos, cursor); cursor = startPos; } public void setCursor(int position) { this.cursor = Math.max(0, Math.min(position, content.length())); } public String getContent() { return content.toString(); } public int getCursor() { return cursor; } public void clear() { content.setLength(0); cursor = 0; } } // 具體命令實現 public class InsertTextCommand extends AbstractCommand { private final TextEditor editor; private final String text; private final int savedCursor; public InsertTextCommand(TextEditor editor, String text) { super(\u0026#34;Insert: \u0026#34; + text); this.editor = editor; this.text = text; this.savedCursor = editor.getCursor(); } @Override public void execute() { editor.insertText(text); } @Override public void undo() { editor.setCursor(savedCursor + text.length()); editor.deleteText(text.length()); } } public class DeleteTextCommand extends AbstractCommand { private final TextEditor editor; private final int length; private final int savedCursor; private String deletedText; public DeleteTextCommand(TextEditor editor, int length) { super(\u0026#34;Delete: \u0026#34; + length + \u0026#34; chars\u0026#34;); this.editor = editor; this.length = length; this.savedCursor = editor.getCursor(); } @Override public void execute() { int startPos = Math.max(0, savedCursor - length); deletedText = editor.getContent().substring(startPos, savedCursor); editor.deleteText(length); } @Override public void undo() { editor.setCursor(savedCursor - length); editor.insertText(deletedText); } } public class ClearCommand extends AbstractCommand { private final TextEditor editor; private String savedContent; private int savedCursor; public ClearCommand(TextEditor editor) { super(\u0026#34;Clear all\u0026#34;); this.editor = editor; } @Override public void execute() { savedContent = editor.getContent(); savedCursor = editor.getCursor(); editor.clear(); } @Override public void undo() { editor.clear(); editor.insertText(savedContent); editor.setCursor(savedCursor); } } 命令調用者和歷史管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // 命令調用者 public class CommandInvoker { private final Stack\u0026lt;Command\u0026gt; undoStack = new Stack\u0026lt;\u0026gt;(); private final Stack\u0026lt;Command\u0026gt; redoStack = new Stack\u0026lt;\u0026gt;(); private final int maxHistorySize; public CommandInvoker(int maxHistorySize) { this.maxHistorySize = maxHistorySize; } public void executeCommand(Command command) { command.execute(); // 添加到撤銷堆棧 undoStack.push(command); // 清空重做堆棧 redoStack.clear(); // 限制歷史大小 if (undoStack.size() \u0026gt; maxHistorySize) { undoStack.removeElementAt(0); } } public boolean canUndo() { return !undoStack.isEmpty(); } public boolean canRedo() { return !redoStack.isEmpty(); } public void undo() { if (canUndo()) { Command command = undoStack.pop(); command.undo(); redoStack.push(command); } } public void redo() { if (canRedo()) { Command command = redoStack.pop(); command.execute(); undoStack.push(command); } } public List\u0026lt;Command\u0026gt; getUndoHistory() { return new ArrayList\u0026lt;\u0026gt;(undoStack); } public List\u0026lt;Command\u0026gt; getRedoHistory() { return new ArrayList\u0026lt;\u0026gt;(redoStack); } public void clearHistory() { undoStack.clear(); redoStack.clear(); } } 基礎使用範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class BasicCommandDemo { public static void main(String[] args) { // 創建文本編輯器和命令調用者 TextEditor editor = new TextEditor(); CommandInvoker invoker = new CommandInvoker(10); // 執行一系列命令 invoker.executeCommand(new InsertTextCommand(editor, \u0026#34;Hello\u0026#34;)); System.out.println(\u0026#34;After insert \u0026#39;Hello\u0026#39;: \u0026#34; + editor.getContent()); invoker.executeCommand(new InsertTextCommand(editor, \u0026#34; World\u0026#34;)); System.out.println(\u0026#34;After insert \u0026#39; World\u0026#39;: \u0026#34; + editor.getContent()); invoker.executeCommand(new DeleteTextCommand(editor, 5)); System.out.println(\u0026#34;After delete 5 chars: \u0026#34; + editor.getContent()); // 撤銷操作 System.out.println(\u0026#34;\\n=== Undo Operations ===\u0026#34;); while (invoker.canUndo()) { System.out.println(\u0026#34;Undoing...\u0026#34;); invoker.undo(); System.out.println(\u0026#34;Content: \u0026#34; + editor.getContent()); } // 重做操作 System.out.println(\u0026#34;\\n=== Redo Operations ===\u0026#34;); while (invoker.canRedo()) { System.out.println(\u0026#34;Redoing...\u0026#34;); invoker.redo(); System.out.println(\u0026#34;Content: \u0026#34; + editor.getContent()); } // 顯示歷史記錄 System.out.println(\u0026#34;\\n=== Command History ===\u0026#34;); invoker.getUndoHistory().forEach(System.out::println); } } 2. 宏命令和複合命令 宏命令實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 宏命令 - 組合多個命令 public class MacroCommand extends AbstractCommand { private final List\u0026lt;Command\u0026gt; commands = new ArrayList\u0026lt;\u0026gt;(); public MacroCommand(String description) { super(description); } public void addCommand(Command command) { commands.add(command); } public void removeCommand(Command command) { commands.remove(command); } @Override public void execute() { for (Command command : commands) { command.execute(); } } @Override public void undo() { // 反向執行撤銷操作 for (int i = commands.size() - 1; i \u0026gt;= 0; i--) { commands.get(i).undo(); } } public List\u0026lt;Command\u0026gt; getCommands() { return new ArrayList\u0026lt;\u0026gt;(commands); } } // 條件命令 - 根據條件執行 public class ConditionalCommand extends AbstractCommand { private final Command command; private final Supplier\u0026lt;Boolean\u0026gt; condition; public ConditionalCommand(String description, Command command, Supplier\u0026lt;Boolean\u0026gt; condition) { super(description); this.command = command; this.condition = condition; } @Override public void execute() { if (condition.get()) { command.execute(); } } @Override public void undo() { if (condition.get()) { command.undo(); } } } 使用範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class MacroCommandDemo { public static void main(String[] args) { TextEditor editor = new TextEditor(); CommandInvoker invoker = new CommandInvoker(10); // 創建宏命令 MacroCommand formatTextMacro = new MacroCommand(\u0026#34;Format Text\u0026#34;); formatTextMacro.addCommand(new InsertTextCommand(editor, \u0026#34;public class HelloWorld {\u0026#34;)); formatTextMacro.addCommand(new InsertTextCommand(editor, \u0026#34;\\n\u0026#34;)); formatTextMacro.addCommand(new InsertTextCommand(editor, \u0026#34; public static void main(String[] args) {\u0026#34;)); formatTextMacro.addCommand(new InsertTextCommand(editor, \u0026#34;\\n\u0026#34;)); formatTextMacro.addCommand(new InsertTextCommand(editor, \u0026#34; System.out.println(\\\u0026#34;Hello, World!\\\u0026#34;);\u0026#34;)); formatTextMacro.addCommand(new InsertTextCommand(editor, \u0026#34;\\n\u0026#34;)); formatTextMacro.addCommand(new InsertTextCommand(editor, \u0026#34; }\u0026#34;)); formatTextMacro.addCommand(new InsertTextCommand(editor, \u0026#34;\\n\u0026#34;)); formatTextMacro.addCommand(new InsertTextCommand(editor, \u0026#34;}\u0026#34;)); // 執行宏命令 invoker.executeCommand(formatTextMacro); System.out.println(\u0026#34;After macro execution:\u0026#34;); System.out.println(editor.getContent()); // 撤銷宏命令 invoker.undo(); System.out.println(\u0026#34;\\nAfter undo macro:\u0026#34;); System.out.println(editor.getContent()); } } 3. CQRS (Command Query Responsibility Segregation) CQRS 基礎結構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 命令基類 public abstract class CommandBase { private final String commandId; private final LocalDateTime timestamp; public CommandBase() { this.commandId = UUID.randomUUID().toString(); this.timestamp = LocalDateTime.now(); } public String getCommandId() { return commandId; } public LocalDateTime getTimestamp() { return timestamp; } } // 查詢基類 public abstract class QueryBase\u0026lt;T\u0026gt; { private final String queryId; private final LocalDateTime timestamp; public QueryBase() { this.queryId = UUID.randomUUID().toString(); this.timestamp = LocalDateTime.now(); } public String getQueryId() { return queryId; } public LocalDateTime getTimestamp() { return timestamp; } } // 用戶領域模型 public class User { private String id; private String email; private String name; private LocalDateTime createdAt; private LocalDateTime updatedAt; public User(String id, String email, String name) { this.id = id; this.email = email; this.name = name; this.createdAt = LocalDateTime.now(); this.updatedAt = LocalDateTime.now(); } public void updateName(String newName) { this.name = newName; this.updatedAt = LocalDateTime.now(); } public void updateEmail(String newEmail) { this.email = newEmail; this.updatedAt = LocalDateTime.now(); } // getters public String getId() { return id; } public String getEmail() { return email; } public String getName() { return name; } public LocalDateTime getCreatedAt() { return createdAt; } public LocalDateTime getUpdatedAt() { return updatedAt; } } CQRS 命令定義 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // 用戶命令 public class CreateUserCommand extends CommandBase { private final String email; private final String name; public CreateUserCommand(String email, String name) { super(); this.email = email; this.name = name; } public String getEmail() { return email; } public String getName() { return name; } } public class UpdateUserNameCommand extends CommandBase { private final String userId; private final String newName; public UpdateUserNameCommand(String userId, String newName) { super(); this.userId = userId; this.newName = newName; } public String getUserId() { return userId; } public String getNewName() { return newName; } } public class UpdateUserEmailCommand extends CommandBase { private final String userId; private final String newEmail; public UpdateUserEmailCommand(String userId, String newEmail) { super(); this.userId = userId; this.newEmail = newEmail; } public String getUserId() { return userId; } public String getNewEmail() { return newEmail; } } public class DeleteUserCommand extends CommandBase { private final String userId; public DeleteUserCommand(String userId) { super(); this.userId = userId; } public String getUserId() { return userId; } } CQRS 查詢定義 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 用戶查詢 public class GetUserByIdQuery extends QueryBase\u0026lt;User\u0026gt; { private final String userId; public GetUserByIdQuery(String userId) { super(); this.userId = userId; } public String getUserId() { return userId; } } public class GetUserByEmailQuery extends QueryBase\u0026lt;User\u0026gt; { private final String email; public GetUserByEmailQuery(String email) { super(); this.email = email; } public String getEmail() { return email; } } public class GetAllUsersQuery extends QueryBase\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; { private final int page; private final int size; public GetAllUsersQuery(int page, int size) { super(); this.page = page; this.size = size; } public int getPage() { return page; } public int getSize() { return size; } } CQRS 命令和查詢處理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 // 命令處理器接口 public interface CommandHandler\u0026lt;T extends CommandBase\u0026gt; { void handle(T command); } // 查詢處理器接口 public interface QueryHandler\u0026lt;Q extends QueryBase\u0026lt;R\u0026gt;, R\u0026gt; { R handle(Q query); } // 用戶命令處理器 @Component public class UserCommandHandler implements CommandHandler\u0026lt;CreateUserCommand\u0026gt;, CommandHandler\u0026lt;UpdateUserNameCommand\u0026gt;, CommandHandler\u0026lt;UpdateUserEmailCommand\u0026gt;, CommandHandler\u0026lt;DeleteUserCommand\u0026gt; { private final Map\u0026lt;String, User\u0026gt; userStore = new ConcurrentHashMap\u0026lt;\u0026gt;(); @Override public void handle(CreateUserCommand command) { String userId = UUID.randomUUID().toString(); User user = new User(userId, command.getEmail(), command.getName()); userStore.put(userId, user); System.out.println(\u0026#34;User created: \u0026#34; + userId); } @Override public void handle(UpdateUserNameCommand command) { User user = userStore.get(command.getUserId()); if (user != null) { user.updateName(command.getNewName()); System.out.println(\u0026#34;User name updated: \u0026#34; + command.getUserId()); } else { throw new IllegalArgumentException(\u0026#34;User not found: \u0026#34; + command.getUserId()); } } @Override public void handle(UpdateUserEmailCommand command) { User user = userStore.get(command.getUserId()); if (user != null) { user.updateEmail(command.getNewEmail()); System.out.println(\u0026#34;User email updated: \u0026#34; + command.getUserId()); } else { throw new IllegalArgumentException(\u0026#34;User not found: \u0026#34; + command.getUserId()); } } @Override public void handle(DeleteUserCommand command) { User user = userStore.remove(command.getUserId()); if (user != null) { System.out.println(\u0026#34;User deleted: \u0026#34; + command.getUserId()); } else { throw new IllegalArgumentException(\u0026#34;User not found: \u0026#34; + command.getUserId()); } } public Map\u0026lt;String, User\u0026gt; getUserStore() { return new HashMap\u0026lt;\u0026gt;(userStore); } } // 用戶查詢處理器 @Component public class UserQueryHandler implements QueryHandler\u0026lt;GetUserByIdQuery, User\u0026gt;, QueryHandler\u0026lt;GetUserByEmailQuery, User\u0026gt;, QueryHandler\u0026lt;GetAllUsersQuery, List\u0026lt;User\u0026gt;\u0026gt; { private final UserCommandHandler userCommandHandler; public UserQueryHandler(UserCommandHandler userCommandHandler) { this.userCommandHandler = userCommandHandler; } @Override public User handle(GetUserByIdQuery query) { return userCommandHandler.getUserStore().get(query.getUserId()); } @Override public User handle(GetUserByEmailQuery query) { return userCommandHandler.getUserStore().values().stream() .filter(user -\u0026gt; user.getEmail().equals(query.getEmail())) .findFirst() .orElse(null); } @Override public List\u0026lt;User\u0026gt; handle(GetAllUsersQuery query) { List\u0026lt;User\u0026gt; allUsers = new ArrayList\u0026lt;\u0026gt;(userCommandHandler.getUserStore().values()); int start = query.getPage() * query.getSize(); int end = Math.min(start + query.getSize(), allUsers.size()); if (start \u0026gt;= allUsers.size()) { return Collections.emptyList(); } return allUsers.subList(start, end); } } 4. 命令總線 (Command Bus) 命令總線接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 // 命令總線接口 public interface CommandBus { \u0026lt;T extends CommandBase\u0026gt; void send(T command); \u0026lt;T extends CommandBase\u0026gt; CompletableFuture\u0026lt;Void\u0026gt; sendAsync(T command); } // 查詢總線接口 public interface QueryBus { \u0026lt;Q extends QueryBase\u0026lt;R\u0026gt;, R\u0026gt; R send(Q query); \u0026lt;Q extends QueryBase\u0026lt;R\u0026gt;, R\u0026gt; CompletableFuture\u0026lt;R\u0026gt; sendAsync(Q query); } // 命令總線實現 @Component public class SimpleCommandBus implements CommandBus { private final Map\u0026lt;Class\u0026lt;?\u0026gt;, CommandHandler\u0026lt;?\u0026gt;\u0026gt; handlers = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final ExecutorService executorService = Executors.newFixedThreadPool(10); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T extends CommandBase\u0026gt; void registerHandler(Class\u0026lt;T\u0026gt; commandType, CommandHandler\u0026lt;T\u0026gt; handler) { handlers.put(commandType, handler); } @Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T extends CommandBase\u0026gt; void send(T command) { CommandHandler\u0026lt;T\u0026gt; handler = (CommandHandler\u0026lt;T\u0026gt;) handlers.get(command.getClass()); if (handler == null) { throw new IllegalArgumentException(\u0026#34;No handler found for command: \u0026#34; + command.getClass()); } try { handler.handle(command); } catch (Exception e) { throw new RuntimeException(\u0026#34;Command handling failed: \u0026#34; + e.getMessage(), e); } } @Override public \u0026lt;T extends CommandBase\u0026gt; CompletableFuture\u0026lt;Void\u0026gt; sendAsync(T command) { return CompletableFuture.runAsync(() -\u0026gt; send(command), executorService); } public void shutdown() { executorService.shutdown(); } } // 查詢總線實現 @Component public class SimpleQueryBus implements QueryBus { private final Map\u0026lt;Class\u0026lt;?\u0026gt;, QueryHandler\u0026lt;?, ?\u0026gt;\u0026gt; handlers = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final ExecutorService executorService = Executors.newFixedThreadPool(10); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;Q extends QueryBase\u0026lt;R\u0026gt;, R\u0026gt; void registerHandler(Class\u0026lt;Q\u0026gt; queryType, QueryHandler\u0026lt;Q, R\u0026gt; handler) { handlers.put(queryType, handler); } @Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;Q extends QueryBase\u0026lt;R\u0026gt;, R\u0026gt; R send(Q query) { QueryHandler\u0026lt;Q, R\u0026gt; handler = (QueryHandler\u0026lt;Q, R\u0026gt;) handlers.get(query.getClass()); if (handler == null) { throw new IllegalArgumentException(\u0026#34;No handler found for query: \u0026#34; + query.getClass()); } try { return handler.handle(query); } catch (Exception e) { throw new RuntimeException(\u0026#34;Query handling failed: \u0026#34; + e.getMessage(), e); } } @Override public \u0026lt;Q extends QueryBase\u0026lt;R\u0026gt;, R\u0026gt; CompletableFuture\u0026lt;R\u0026gt; sendAsync(Q query) { return CompletableFuture.supplyAsync(() -\u0026gt; send(query), executorService); } public void shutdown() { executorService.shutdown(); } } 命令總線配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 命令總線配置 @Configuration public class CommandBusConfiguration { @Bean public SimpleCommandBus commandBus(UserCommandHandler userCommandHandler) { SimpleCommandBus commandBus = new SimpleCommandBus(); // 註冊命令處理器 commandBus.registerHandler(CreateUserCommand.class, userCommandHandler); commandBus.registerHandler(UpdateUserNameCommand.class, userCommandHandler); commandBus.registerHandler(UpdateUserEmailCommand.class, userCommandHandler); commandBus.registerHandler(DeleteUserCommand.class, userCommandHandler); return commandBus; } @Bean public SimpleQueryBus queryBus(UserQueryHandler userQueryHandler) { SimpleQueryBus queryBus = new SimpleQueryBus(); // 註冊查詢處理器 queryBus.registerHandler(GetUserByIdQuery.class, userQueryHandler); queryBus.registerHandler(GetUserByEmailQuery.class, userQueryHandler); queryBus.registerHandler(GetAllUsersQuery.class, userQueryHandler); return queryBus; } } 5. 審計和日誌記錄 審計命令裝飾器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 // 審計信息 public class AuditInfo { private final String userId; private final String sessionId; private final String ipAddress; private final LocalDateTime timestamp; public AuditInfo(String userId, String sessionId, String ipAddress) { this.userId = userId; this.sessionId = sessionId; this.ipAddress = ipAddress; this.timestamp = LocalDateTime.now(); } // getters public String getUserId() { return userId; } public String getSessionId() { return sessionId; } public String getIpAddress() { return ipAddress; } public LocalDateTime getTimestamp() { return timestamp; } } // 可審計的命令 public interface AuditableCommand { void setAuditInfo(AuditInfo auditInfo); AuditInfo getAuditInfo(); } // 增強的命令基類 public abstract class AuditableCommandBase extends CommandBase implements AuditableCommand { private AuditInfo auditInfo; @Override public void setAuditInfo(AuditInfo auditInfo) { this.auditInfo = auditInfo; } @Override public AuditInfo getAuditInfo() { return auditInfo; } } // 審計記錄 public class AuditRecord { private final String recordId; private final String commandId; private final String commandType; private final String userId; private final String sessionId; private final String ipAddress; private final LocalDateTime timestamp; private final String details; private final boolean success; private final String errorMessage; public AuditRecord(String commandId, String commandType, String userId, String sessionId, String ipAddress, LocalDateTime timestamp, String details, boolean success, String errorMessage) { this.recordId = UUID.randomUUID().toString(); this.commandId = commandId; this.commandType = commandType; this.userId = userId; this.sessionId = sessionId; this.ipAddress = ipAddress; this.timestamp = timestamp; this.details = details; this.success = success; this.errorMessage = errorMessage; } // getters public String getRecordId() { return recordId; } public String getCommandId() { return commandId; } public String getCommandType() { return commandType; } public String getUserId() { return userId; } public String getSessionId() { return sessionId; } public String getIpAddress() { return ipAddress; } public LocalDateTime getTimestamp() { return timestamp; } public String getDetails() { return details; } public boolean isSuccess() { return success; } public String getErrorMessage() { return errorMessage; } @Override public String toString() { return String.format(\u0026#34;[%s] %s by %s at %s - %s\u0026#34;, success ? \u0026#34;SUCCESS\u0026#34; : \u0026#34;FAILED\u0026#34;, commandType, userId, timestamp, details); } } 審計命令總線 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // 帶審計功能的命令總線 @Component public class AuditableCommandBus implements CommandBus { private final SimpleCommandBus commandBus; private final List\u0026lt;AuditRecord\u0026gt; auditRecords = new ArrayList\u0026lt;\u0026gt;(); public AuditableCommandBus(SimpleCommandBus commandBus) { this.commandBus = commandBus; } @Override public \u0026lt;T extends CommandBase\u0026gt; void send(T command) { String commandId = command.getCommandId(); String commandType = command.getClass().getSimpleName(); AuditInfo auditInfo = null; if (command instanceof AuditableCommand) { auditInfo = ((AuditableCommand) command).getAuditInfo(); } boolean success = false; String errorMessage = null; try { commandBus.send(command); success = true; } catch (Exception e) { errorMessage = e.getMessage(); throw e; } finally { // 記錄審計信息 AuditRecord record = new AuditRecord( commandId, commandType, auditInfo != null ? auditInfo.getUserId() : \u0026#34;unknown\u0026#34;, auditInfo != null ? auditInfo.getSessionId() : \u0026#34;unknown\u0026#34;, auditInfo != null ? auditInfo.getIpAddress() : \u0026#34;unknown\u0026#34;, LocalDateTime.now(), generateCommandDetails(command), success, errorMessage ); auditRecords.add(record); System.out.println(\u0026#34;Audit: \u0026#34; + record); } } @Override public \u0026lt;T extends CommandBase\u0026gt; CompletableFuture\u0026lt;Void\u0026gt; sendAsync(T command) { return CompletableFuture.runAsync(() -\u0026gt; send(command)); } private String generateCommandDetails(CommandBase command) { // 使用反射生成命令詳情 StringBuilder details = new StringBuilder(); details.append(command.getClass().getSimpleName()).append(\u0026#34; {\u0026#34;); try { Field[] fields = command.getClass().getDeclaredFields(); for (Field field : fields) { field.setAccessible(true); Object value = field.get(command); if (value != null \u0026amp;\u0026amp; !field.getName().equals(\u0026#34;commandId\u0026#34;) \u0026amp;\u0026amp; !field.getName().equals(\u0026#34;timestamp\u0026#34;)) { details.append(field.getName()).append(\u0026#34;=\u0026#34;).append(value).append(\u0026#34;, \u0026#34;); } } } catch (Exception e) { details.append(\u0026#34;details unavailable\u0026#34;); } details.append(\u0026#34;}\u0026#34;); return details.toString(); } public List\u0026lt;AuditRecord\u0026gt; getAuditRecords() { return new ArrayList\u0026lt;\u0026gt;(auditRecords); } public List\u0026lt;AuditRecord\u0026gt; getAuditRecords(String userId) { return auditRecords.stream() .filter(record -\u0026gt; record.getUserId().equals(userId)) .collect(Collectors.toList()); } } 6. Spring Boot 集成 Spring Boot 命令控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 // 用戶 REST 控制器 @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { private final CommandBus commandBus; private final QueryBus queryBus; public UserController(CommandBus commandBus, QueryBus queryBus) { this.commandBus = commandBus; this.queryBus = queryBus; } @PostMapping public ResponseEntity\u0026lt;String\u0026gt; createUser(@RequestBody CreateUserRequest request, HttpServletRequest httpRequest) { try { CreateUserCommand command = new CreateUserCommand(request.getEmail(), request.getName()); // 設置審計信息 if (command instanceof AuditableCommand) { AuditInfo auditInfo = new AuditInfo( \u0026#34;current-user-id\u0026#34;, // 從安全上下文獲取 httpRequest.getSession().getId(), httpRequest.getRemoteAddr() ); ((AuditableCommand) command).setAuditInfo(auditInfo); } commandBus.send(command); return ResponseEntity.ok(\u0026#34;User created successfully\u0026#34;); } catch (Exception e) { return ResponseEntity.badRequest().body(\u0026#34;Failed to create user: \u0026#34; + e.getMessage()); } } @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;User\u0026gt; getUser(@PathVariable String id) { try { GetUserByIdQuery query = new GetUserByIdQuery(id); User user = queryBus.send(query); if (user != null) { return ResponseEntity.ok(user); } else { return ResponseEntity.notFound().build(); } } catch (Exception e) { return ResponseEntity.badRequest().build(); } } @GetMapping public ResponseEntity\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; getAllUsers(@RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @RequestParam(defaultValue = \u0026#34;10\u0026#34;) int size) { try { GetAllUsersQuery query = new GetAllUsersQuery(page, size); List\u0026lt;User\u0026gt; users = queryBus.send(query); return ResponseEntity.ok(users); } catch (Exception e) { return ResponseEntity.badRequest().build(); } } @PutMapping(\u0026#34;/{id}/name\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; updateUserName(@PathVariable String id, @RequestBody UpdateUserNameRequest request, HttpServletRequest httpRequest) { try { UpdateUserNameCommand command = new UpdateUserNameCommand(id, request.getName()); // 設置審計信息 if (command instanceof AuditableCommand) { AuditInfo auditInfo = new AuditInfo( \u0026#34;current-user-id\u0026#34;, httpRequest.getSession().getId(), httpRequest.getRemoteAddr() ); ((AuditableCommand) command).setAuditInfo(auditInfo); } commandBus.send(command); return ResponseEntity.ok(\u0026#34;User name updated successfully\u0026#34;); } catch (Exception e) { return ResponseEntity.badRequest().body(\u0026#34;Failed to update user name: \u0026#34; + e.getMessage()); } } @DeleteMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; deleteUser(@PathVariable String id, HttpServletRequest httpRequest) { try { DeleteUserCommand command = new DeleteUserCommand(id); // 設置審計信息 if (command instanceof AuditableCommand) { AuditInfo auditInfo = new AuditInfo( \u0026#34;current-user-id\u0026#34;, httpRequest.getSession().getId(), httpRequest.getRemoteAddr() ); ((AuditableCommand) command).setAuditInfo(auditInfo); } commandBus.send(command); return ResponseEntity.ok(\u0026#34;User deleted successfully\u0026#34;); } catch (Exception e) { return ResponseEntity.badRequest().body(\u0026#34;Failed to delete user: \u0026#34; + e.getMessage()); } } } // 請求 DTO public class CreateUserRequest { private String email; private String name; // getters and setters public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getName() { return name; } public void setName(String name) { this.name = name; } } public class UpdateUserNameRequest { private String name; // getter and setter public String getName() { return name; } public void setName(String name) { this.name = name; } } 7. 命令模式的高級特性 異步命令處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 異步命令處理器 @Component public class AsyncCommandProcessor { private final CommandBus commandBus; private final ExecutorService executorService = Executors.newFixedThreadPool(5); public AsyncCommandProcessor(CommandBus commandBus) { this.commandBus = commandBus; } public \u0026lt;T extends CommandBase\u0026gt; CompletableFuture\u0026lt;Void\u0026gt; processAsync(T command) { return CompletableFuture.runAsync(() -\u0026gt; { try { commandBus.send(command); } catch (Exception e) { throw new RuntimeException(\u0026#34;Async command processing failed\u0026#34;, e); } }, executorService); } public \u0026lt;T extends CommandBase\u0026gt; CompletableFuture\u0026lt;Void\u0026gt; processWithDelay(T command, long delayMs) { return CompletableFuture.runAsync(() -\u0026gt; { try { Thread.sleep(delayMs); commandBus.send(command); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException(\u0026#34;Command processing interrupted\u0026#34;, e); } catch (Exception e) { throw new RuntimeException(\u0026#34;Delayed command processing failed\u0026#34;, e); } }, executorService); } public void shutdown() { executorService.shutdown(); } } 命令驗證和中間件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 // 命令驗證器 public interface CommandValidator\u0026lt;T extends CommandBase\u0026gt; { ValidationResult validate(T command); } // 驗證結果 public class ValidationResult { private final boolean valid; private final List\u0026lt;String\u0026gt; errors; public ValidationResult(boolean valid, List\u0026lt;String\u0026gt; errors) { this.valid = valid; this.errors = errors != null ? errors : Collections.emptyList(); } public static ValidationResult success() { return new ValidationResult(true, null); } public static ValidationResult failure(List\u0026lt;String\u0026gt; errors) { return new ValidationResult(false, errors); } public boolean isValid() { return valid; } public List\u0026lt;String\u0026gt; getErrors() { return errors; } } // 用戶命令驗證器 @Component public class UserCommandValidator implements CommandValidator\u0026lt;CreateUserCommand\u0026gt; { @Override public ValidationResult validate(CreateUserCommand command) { List\u0026lt;String\u0026gt; errors = new ArrayList\u0026lt;\u0026gt;(); if (command.getEmail() == null || command.getEmail().trim().isEmpty()) { errors.add(\u0026#34;Email is required\u0026#34;); } else if (!isValidEmail(command.getEmail())) { errors.add(\u0026#34;Invalid email format\u0026#34;); } if (command.getName() == null || command.getName().trim().isEmpty()) { errors.add(\u0026#34;Name is required\u0026#34;); } else if (command.getName().length() \u0026lt; 2) { errors.add(\u0026#34;Name must be at least 2 characters\u0026#34;); } return errors.isEmpty() ? ValidationResult.success() : ValidationResult.failure(errors); } private boolean isValidEmail(String email) { return email.contains(\u0026#34;@\u0026#34;) \u0026amp;\u0026amp; email.contains(\u0026#34;.\u0026#34;); } } // 帶驗證的命令總線 @Component public class ValidatingCommandBus implements CommandBus { private final CommandBus commandBus; private final Map\u0026lt;Class\u0026lt;?\u0026gt;, CommandValidator\u0026lt;?\u0026gt;\u0026gt; validators = new ConcurrentHashMap\u0026lt;\u0026gt;(); public ValidatingCommandBus(CommandBus commandBus) { this.commandBus = commandBus; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T extends CommandBase\u0026gt; void registerValidator(Class\u0026lt;T\u0026gt; commandType, CommandValidator\u0026lt;T\u0026gt; validator) { validators.put(commandType, validator); } @Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T extends CommandBase\u0026gt; void send(T command) { // 執行驗證 CommandValidator\u0026lt;T\u0026gt; validator = (CommandValidator\u0026lt;T\u0026gt;) validators.get(command.getClass()); if (validator != null) { ValidationResult result = validator.validate(command); if (!result.isValid()) { throw new IllegalArgumentException(\u0026#34;Command validation failed: \u0026#34; + result.getErrors()); } } // 執行命令 commandBus.send(command); } @Override public \u0026lt;T extends CommandBase\u0026gt; CompletableFuture\u0026lt;Void\u0026gt; sendAsync(T command) { return CompletableFuture.runAsync(() -\u0026gt; send(command)); } } 8. 命令模式的最佳實踐 錯誤處理和重試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 // 命令執行結果 public class CommandResult { private final boolean success; private final String message; private final Exception exception; public CommandResult(boolean success, String message, Exception exception) { this.success = success; this.message = message; this.exception = exception; } public static CommandResult success(String message) { return new CommandResult(true, message, null); } public static CommandResult failure(String message, Exception exception) { return new CommandResult(false, message, exception); } public boolean isSuccess() { return success; } public String getMessage() { return message; } public Exception getException() { return exception; } } // 帶重試的命令總線 @Component public class RetryableCommandBus implements CommandBus { private final CommandBus commandBus; private final int maxRetries; private final long retryDelayMs; public RetryableCommandBus(CommandBus commandBus, int maxRetries, long retryDelayMs) { this.commandBus = commandBus; this.maxRetries = maxRetries; this.retryDelayMs = retryDelayMs; } @Override public \u0026lt;T extends CommandBase\u0026gt; void send(T command) { int attempts = 0; Exception lastException = null; while (attempts \u0026lt;= maxRetries) { try { commandBus.send(command); return; // 成功執行 } catch (Exception e) { lastException = e; attempts++; if (attempts \u0026lt;= maxRetries) { System.out.println(\u0026#34;Command failed, retrying... (attempt \u0026#34; + attempts + \u0026#34;/\u0026#34; + maxRetries + \u0026#34;)\u0026#34;); try { Thread.sleep(retryDelayMs); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); throw new RuntimeException(\u0026#34;Command retry interrupted\u0026#34;, ie); } } } } throw new RuntimeException(\u0026#34;Command failed after \u0026#34; + maxRetries + \u0026#34; retries\u0026#34;, lastException); } @Override public \u0026lt;T extends CommandBase\u0026gt; CompletableFuture\u0026lt;Void\u0026gt; sendAsync(T command) { return CompletableFuture.runAsync(() -\u0026gt; send(command)); } } 命令模式測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 @ExtendWith(MockitoExtension.class) class CommandPatternTest { @Test void shouldExecuteCommandSuccessfully() { // Given TextEditor editor = new TextEditor(); Command command = new InsertTextCommand(editor, \u0026#34;Hello World\u0026#34;); // When command.execute(); // Then assertEquals(\u0026#34;Hello World\u0026#34;, editor.getContent()); } @Test void shouldUndoCommandSuccessfully() { // Given TextEditor editor = new TextEditor(); Command command = new InsertTextCommand(editor, \u0026#34;Hello World\u0026#34;); // When command.execute(); command.undo(); // Then assertEquals(\u0026#34;\u0026#34;, editor.getContent()); } @Test void shouldHandleCommandHistory() { // Given TextEditor editor = new TextEditor(); CommandInvoker invoker = new CommandInvoker(10); // When invoker.executeCommand(new InsertTextCommand(editor, \u0026#34;Hello\u0026#34;)); invoker.executeCommand(new InsertTextCommand(editor, \u0026#34; World\u0026#34;)); // Then assertEquals(\u0026#34;Hello World\u0026#34;, editor.getContent()); assertTrue(invoker.canUndo()); invoker.undo(); assertEquals(\u0026#34;Hello\u0026#34;, editor.getContent()); assertTrue(invoker.canRedo()); invoker.redo(); assertEquals(\u0026#34;Hello World\u0026#34;, editor.getContent()); } } // CQRS 測試 @SpringBootTest class CQRSTest { @Autowired private CommandBus commandBus; @Autowired private QueryBus queryBus; @Test void shouldHandleCreateUserCommand() { // Given CreateUserCommand command = new CreateUserCommand(\u0026#34;test@example.com\u0026#34;, \u0026#34;Test User\u0026#34;); // When commandBus.send(command); // Then GetUserByEmailQuery query = new GetUserByEmailQuery(\u0026#34;test@example.com\u0026#34;); User user = queryBus.send(query); assertNotNull(user); assertEquals(\u0026#34;test@example.com\u0026#34;, user.getEmail()); assertEquals(\u0026#34;Test User\u0026#34;, user.getName()); } @Test void shouldHandleUpdateUserNameCommand() { // Given CreateUserCommand createCommand = new CreateUserCommand(\u0026#34;test@example.com\u0026#34;, \u0026#34;Test User\u0026#34;); commandBus.send(createCommand); GetUserByEmailQuery query = new GetUserByEmailQuery(\u0026#34;test@example.com\u0026#34;); User user = queryBus.send(query); // When UpdateUserNameCommand updateCommand = new UpdateUserNameCommand(user.getId(), \u0026#34;Updated Name\u0026#34;); commandBus.send(updateCommand); // Then User updatedUser = queryBus.send(new GetUserByIdQuery(user.getId())); assertEquals(\u0026#34;Updated Name\u0026#34;, updatedUser.getName()); } } 9. 總結 適用場景 GUI 應用: 實現菜單操作、工具欄按鈕等 撤銷重做: 需要支持撤銷重做功能的系統 宏操作: 需要錄製和回放一系列操作 事務處理: 需要將操作封裝為事務的系統 異步處理: 需要將請求排隊處理的系統 關鍵要點 封裝請求: 將請求封裝為對象 解耦調用者和接收者: 調用者無需知道接收者的具體實現 支持撤銷重做: 通過 undo 方法實現撤銷功能 支持日誌和審計: 便於記錄操作歷史 支持宏命令: 可以組合多個命令 企業級應用 CQRS: 分離命令和查詢的職責 命令總線: 統一管理命令的分發和處理 審計日誌: 記錄所有命令的執行情況 異步處理: 支持命令的異步執行 驗證和重試: 確保命令執行的可靠性 與其他模式的關係 策略模式: 命令模式封裝動作，策略模式封裝算法 觀察者模式: 命令執行後可以通知觀察者 職責鏈模式: 可以將命令沿著職責鏈傳遞 備忘錄模式: 結合使用實現複雜的撤銷重做功能 命令模式在現代企業級應用中扮演著重要角色，特別是在 CQRS 架構和事件驅動系統中。結合 Spring Boot 和現代 Java 特性，可以構建出高度可維護和可擴展的系統架構。\n","permalink":"https://xinqilin.github.io/post/architecture/command/","tags":[],"title":"DesignPattern - Behavioral - Command Pattern"},{"content":"Strategy Pattern 策略模式 Strategy Pattern 是行為型設計模式之一，它定義了一系列算法，把它們封裝起來，並使它們可以相互替換。策略模式讓算法的變化獨立於使用算法的客戶端。\n核心概念 策略模式的核心思想是將算法的定義與使用分離，通過定義一族算法，將每個算法封裝起來，並使它們可以互相替換。這樣可以讓算法的變化不會影響到使用算法的客戶端。\n主要組成部分 Strategy (策略接口): 定義所有具體策略的公共接口 ConcreteStrategy (具體策略): 實現具體的算法 Context (上下文): 持有策略的引用，並將客戶端的請求委派給策略 主要優勢 算法切換靈活: 可以在運行時切換算法 算法獨立: 算法的變化不影響客戶端 開閉原則: 新增算法無需修改現有代碼 可測試性: 每個策略都可以獨立測試 代碼重用: 算法可以在不同上下文中重用 1. 基礎策略模式實現 經典支付策略範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // 策略接口 public interface PaymentStrategy { PaymentResult processPayment(PaymentRequest request); boolean validatePayment(PaymentRequest request); String getPaymentMethodName(); } // 支付請求模型 public class PaymentRequest { private final BigDecimal amount; private final String currency; private final String merchantId; private final Map\u0026lt;String, String\u0026gt; additionalData; public PaymentRequest(BigDecimal amount, String currency, String merchantId) { this.amount = amount; this.currency = currency; this.merchantId = merchantId; this.additionalData = new HashMap\u0026lt;\u0026gt;(); } // getters and setters public BigDecimal getAmount() { return amount; } public String getCurrency() { return currency; } public String getMerchantId() { return merchantId; } public Map\u0026lt;String, String\u0026gt; getAdditionalData() { return additionalData; } } // 支付結果模型 public class PaymentResult { private final boolean success; private final String transactionId; private final String message; private final LocalDateTime timestamp; public PaymentResult(boolean success, String transactionId, String message) { this.success = success; this.transactionId = transactionId; this.message = message; this.timestamp = LocalDateTime.now(); } // getters public boolean isSuccess() { return success; } public String getTransactionId() { return transactionId; } public String getMessage() { return message; } public LocalDateTime getTimestamp() { return timestamp; } } 具體策略實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 // 信用卡支付策略 public class CreditCardPaymentStrategy implements PaymentStrategy { private final String cardNumber; private final String cardHolderName; private final String expiryDate; private final String cvv; public CreditCardPaymentStrategy(String cardNumber, String cardHolderName, String expiryDate, String cvv) { this.cardNumber = cardNumber; this.cardHolderName = cardHolderName; this.expiryDate = expiryDate; this.cvv = cvv; } @Override public PaymentResult processPayment(PaymentRequest request) { if (!validatePayment(request)) { return new PaymentResult(false, null, \u0026#34;信用卡驗證失敗\u0026#34;); } try { // 模擬信用卡支付處理 String transactionId = \u0026#34;CC_\u0026#34; + System.currentTimeMillis(); System.out.println(\u0026#34;正在處理信用卡支付...\u0026#34;); System.out.println(\u0026#34;金額: \u0026#34; + request.getAmount() + \u0026#34; \u0026#34; + request.getCurrency()); System.out.println(\u0026#34;卡號: \u0026#34; + maskCardNumber(cardNumber)); // 模擬網絡延遲 Thread.sleep(1000); return new PaymentResult(true, transactionId, \u0026#34;信用卡支付成功\u0026#34;); } catch (InterruptedException e) { return new PaymentResult(false, null, \u0026#34;支付過程中發生錯誤\u0026#34;); } } @Override public boolean validatePayment(PaymentRequest request) { // 驗證邏輯 if (request.getAmount().compareTo(BigDecimal.ZERO) \u0026lt;= 0) { return false; } if (cardNumber == null || cardNumber.length() \u0026lt; 16) { return false; } if (cvv == null || cvv.length() != 3) { return false; } return true; } @Override public String getPaymentMethodName() { return \u0026#34;信用卡支付\u0026#34;; } private String maskCardNumber(String cardNumber) { return \u0026#34;**** **** **** \u0026#34; + cardNumber.substring(cardNumber.length() - 4); } } // PayPal 支付策略 public class PayPalPaymentStrategy implements PaymentStrategy { private final String email; private final String password; public PayPalPaymentStrategy(String email, String password) { this.email = email; this.password = password; } @Override public PaymentResult processPayment(PaymentRequest request) { if (!validatePayment(request)) { return new PaymentResult(false, null, \u0026#34;PayPal 驗證失敗\u0026#34;); } try { String transactionId = \u0026#34;PP_\u0026#34; + System.currentTimeMillis(); System.out.println(\u0026#34;正在處理 PayPal 支付...\u0026#34;); System.out.println(\u0026#34;金額: \u0026#34; + request.getAmount() + \u0026#34; \u0026#34; + request.getCurrency()); System.out.println(\u0026#34;PayPal 帳戶: \u0026#34; + email); // 模擬 PayPal API 調用 Thread.sleep(800); return new PaymentResult(true, transactionId, \u0026#34;PayPal 支付成功\u0026#34;); } catch (InterruptedException e) { return new PaymentResult(false, null, \u0026#34;PayPal 支付過程中發生錯誤\u0026#34;); } } @Override public boolean validatePayment(PaymentRequest request) { if (request.getAmount().compareTo(BigDecimal.ZERO) \u0026lt;= 0) { return false; } if (email == null || !email.contains(\u0026#34;@\u0026#34;)) { return false; } if (password == null || password.length() \u0026lt; 6) { return false; } return true; } @Override public String getPaymentMethodName() { return \u0026#34;PayPal 支付\u0026#34;; } } // 銀行轉帳策略 public class BankTransferPaymentStrategy implements PaymentStrategy { private final String accountNumber; private final String routingNumber; private final String accountHolderName; public BankTransferPaymentStrategy(String accountNumber, String routingNumber, String accountHolderName) { this.accountNumber = accountNumber; this.routingNumber = routingNumber; this.accountHolderName = accountHolderName; } @Override public PaymentResult processPayment(PaymentRequest request) { if (!validatePayment(request)) { return new PaymentResult(false, null, \u0026#34;銀行轉帳驗證失敗\u0026#34;); } try { String transactionId = \u0026#34;BT_\u0026#34; + System.currentTimeMillis(); System.out.println(\u0026#34;正在處理銀行轉帳...\u0026#34;); System.out.println(\u0026#34;金額: \u0026#34; + request.getAmount() + \u0026#34; \u0026#34; + request.getCurrency()); System.out.println(\u0026#34;收款帳戶: \u0026#34; + maskAccountNumber(accountNumber)); // 模擬銀行處理時間 Thread.sleep(2000); return new PaymentResult(true, transactionId, \u0026#34;銀行轉帳成功\u0026#34;); } catch (InterruptedException e) { return new PaymentResult(false, null, \u0026#34;銀行轉帳過程中發生錯誤\u0026#34;); } } @Override public boolean validatePayment(PaymentRequest request) { if (request.getAmount().compareTo(BigDecimal.ZERO) \u0026lt;= 0) { return false; } if (accountNumber == null || accountNumber.length() \u0026lt; 10) { return false; } if (routingNumber == null || routingNumber.length() != 9) { return false; } return true; } @Override public String getPaymentMethodName() { return \u0026#34;銀行轉帳\u0026#34;; } private String maskAccountNumber(String accountNumber) { return \u0026#34;*\u0026#34;.repeat(accountNumber.length() - 4) + accountNumber.substring(accountNumber.length() - 4); } } 上下文類實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 支付處理器上下文 public class PaymentProcessor { private PaymentStrategy paymentStrategy; public PaymentProcessor(PaymentStrategy paymentStrategy) { this.paymentStrategy = paymentStrategy; } public void setPaymentStrategy(PaymentStrategy paymentStrategy) { this.paymentStrategy = paymentStrategy; } public PaymentResult processPayment(PaymentRequest request) { if (paymentStrategy == null) { return new PaymentResult(false, null, \u0026#34;未設置支付策略\u0026#34;); } System.out.println(\u0026#34;使用支付方式: \u0026#34; + paymentStrategy.getPaymentMethodName()); PaymentResult result = paymentStrategy.processPayment(request); // 記錄支付結果 logPaymentResult(request, result); return result; } private void logPaymentResult(PaymentRequest request, PaymentResult result) { System.out.println(\u0026#34;=== 支付日誌 ===\u0026#34;); System.out.println(\u0026#34;時間: \u0026#34; + result.getTimestamp()); System.out.println(\u0026#34;金額: \u0026#34; + request.getAmount() + \u0026#34; \u0026#34; + request.getCurrency()); System.out.println(\u0026#34;狀態: \u0026#34; + (result.isSuccess() ? \u0026#34;成功\u0026#34; : \u0026#34;失敗\u0026#34;)); System.out.println(\u0026#34;訊息: \u0026#34; + result.getMessage()); if (result.getTransactionId() != null) { System.out.println(\u0026#34;交易ID: \u0026#34; + result.getTransactionId()); } System.out.println(\u0026#34;==================\u0026#34;); } } 基礎使用範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class BasicStrategyDemo { public static void main(String[] args) { // 創建支付請求 PaymentRequest request = new PaymentRequest( new BigDecimal(\u0026#34;299.99\u0026#34;), \u0026#34;TWD\u0026#34;, \u0026#34;MERCHANT_001\u0026#34; ); // 信用卡支付 PaymentStrategy creditCardStrategy = new CreditCardPaymentStrategy( \u0026#34;4111111111111111\u0026#34;, \u0026#34;John Doe\u0026#34;, \u0026#34;12/25\u0026#34;, \u0026#34;123\u0026#34; ); PaymentProcessor processor = new PaymentProcessor(creditCardStrategy); PaymentResult result1 = processor.processPayment(request); // 切換到 PayPal 支付 PaymentStrategy paypalStrategy = new PayPalPaymentStrategy( \u0026#34;user@example.com\u0026#34;, \u0026#34;password123\u0026#34; ); processor.setPaymentStrategy(paypalStrategy); PaymentResult result2 = processor.processPayment(request); // 切換到銀行轉帳 PaymentStrategy bankTransferStrategy = new BankTransferPaymentStrategy( \u0026#34;1234567890\u0026#34;, \u0026#34;123456789\u0026#34;, \u0026#34;John Doe\u0026#34; ); processor.setPaymentStrategy(bankTransferStrategy); PaymentResult result3 = processor.processPayment(request); } } 2. 現代 Java 函數式策略模式 使用 Lambda 表達式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 // 函數式策略接口 @FunctionalInterface public interface DiscountStrategy { BigDecimal calculateDiscount(BigDecimal originalPrice, Customer customer); } // 客戶模型 public class Customer { private final String id; private final String name; private final CustomerType type; private final LocalDate memberSince; private final BigDecimal totalSpent; public Customer(String id, String name, CustomerType type, LocalDate memberSince, BigDecimal totalSpent) { this.id = id; this.name = name; this.type = type; this.memberSince = memberSince; this.totalSpent = totalSpent; } // getters public String getId() { return id; } public String getName() { return name; } public CustomerType getType() { return type; } public LocalDate getMemberSince() { return memberSince; } public BigDecimal getTotalSpent() { return totalSpent; } } public enum CustomerType { REGULAR, PREMIUM, VIP } // 函數式折扣策略 public class FunctionalDiscountStrategies { // 常規折扣策略 public static final DiscountStrategy REGULAR_DISCOUNT = (price, customer) -\u0026gt; price.multiply(BigDecimal.valueOf(0.05)); // 會員折扣策略 public static final DiscountStrategy MEMBER_DISCOUNT = (price, customer) -\u0026gt; { long membershipYears = ChronoUnit.YEARS.between( customer.getMemberSince(), LocalDate.now()); double discountRate = Math.min(0.20, 0.05 + (membershipYears * 0.01)); return price.multiply(BigDecimal.valueOf(discountRate)); }; // VIP 折扣策略 public static final DiscountStrategy VIP_DISCOUNT = (price, customer) -\u0026gt; { if (customer.getType() == CustomerType.VIP) { return price.multiply(BigDecimal.valueOf(0.25)); } return BigDecimal.ZERO; }; // 大額消費折扣策略 public static final DiscountStrategy HIGH_SPENDER_DISCOUNT = (price, customer) -\u0026gt; { if (customer.getTotalSpent().compareTo(BigDecimal.valueOf(10000)) \u0026gt;= 0) { return price.multiply(BigDecimal.valueOf(0.15)); } return BigDecimal.ZERO; }; // 組合策略 - 取最大折扣 public static DiscountStrategy maxDiscount(DiscountStrategy... strategies) { return (price, customer) -\u0026gt; { return Arrays.stream(strategies) .map(strategy -\u0026gt; strategy.calculateDiscount(price, customer)) .max(BigDecimal::compareTo) .orElse(BigDecimal.ZERO); }; } // 組合策略 - 累加折扣 public static DiscountStrategy additiveDiscount(DiscountStrategy... strategies) { return (price, customer) -\u0026gt; { return Arrays.stream(strategies) .map(strategy -\u0026gt; strategy.calculateDiscount(price, customer)) .reduce(BigDecimal.ZERO, BigDecimal::add); }; } } 函數式策略使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 // 價格計算器 public class PriceCalculator { private DiscountStrategy discountStrategy; public PriceCalculator(DiscountStrategy discountStrategy) { this.discountStrategy = discountStrategy; } public BigDecimal calculateFinalPrice(BigDecimal originalPrice, Customer customer) { BigDecimal discount = discountStrategy.calculateDiscount(originalPrice, customer); BigDecimal finalPrice = originalPrice.subtract(discount); System.out.printf(\u0026#34;原價: %s, 折扣: %s, 最終價格: %s%n\u0026#34;, originalPrice, discount, finalPrice); return finalPrice; } public void setDiscountStrategy(DiscountStrategy discountStrategy) { this.discountStrategy = discountStrategy; } } // 函數式策略範例 public class FunctionalStrategyDemo { public static void main(String[] args) { // 創建客戶 Customer regularCustomer = new Customer(\u0026#34;001\u0026#34;, \u0026#34;Alice\u0026#34;, CustomerType.REGULAR, LocalDate.now().minusYears(1), BigDecimal.valueOf(5000)); Customer vipCustomer = new Customer(\u0026#34;002\u0026#34;, \u0026#34;Bob\u0026#34;, CustomerType.VIP, LocalDate.now().minusYears(3), BigDecimal.valueOf(15000)); BigDecimal originalPrice = BigDecimal.valueOf(1000); // 使用預定義策略 PriceCalculator calculator = new PriceCalculator( FunctionalDiscountStrategies.REGULAR_DISCOUNT); calculator.calculateFinalPrice(originalPrice, regularCustomer); // 使用 Lambda 表達式創建策略 DiscountStrategy seasonalDiscount = (price, customer) -\u0026gt; price.multiply(BigDecimal.valueOf(0.10)); // 10% 季節性折扣 calculator.setDiscountStrategy(seasonalDiscount); calculator.calculateFinalPrice(originalPrice, regularCustomer); // 使用組合策略 DiscountStrategy combinedStrategy = FunctionalDiscountStrategies.maxDiscount( FunctionalDiscountStrategies.MEMBER_DISCOUNT, FunctionalDiscountStrategies.VIP_DISCOUNT, FunctionalDiscountStrategies.HIGH_SPENDER_DISCOUNT ); calculator.setDiscountStrategy(combinedStrategy); calculator.calculateFinalPrice(originalPrice, vipCustomer); // 使用方法引用 calculator.setDiscountStrategy(FunctionalStrategyDemo::loyaltyDiscount); calculator.calculateFinalPrice(originalPrice, vipCustomer); } // 靜態方法作為策略 private static BigDecimal loyaltyDiscount(BigDecimal price, Customer customer) { long membershipDays = ChronoUnit.DAYS.between( customer.getMemberSince(), LocalDate.now()); double discountRate = Math.min(0.30, membershipDays * 0.0001); return price.multiply(BigDecimal.valueOf(discountRate)); } } 3. Spring Boot 中的策略模式 Spring 配置和依賴注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 // 通知策略接口 public interface NotificationStrategy { void sendNotification(String recipient, String message); boolean isAvailable(); String getChannelName(); } // 具體通知策略實現 @Component public class EmailNotificationStrategy implements NotificationStrategy { @Value(\u0026#34;${notification.email.enabled:true}\u0026#34;) private boolean enabled; @Autowired private JavaMailSender mailSender; @Override public void sendNotification(String recipient, String message) { if (!isAvailable()) { throw new IllegalStateException(\u0026#34;Email 通知服務不可用\u0026#34;); } try { SimpleMailMessage mailMessage = new SimpleMailMessage(); mailMessage.setTo(recipient); mailMessage.setSubject(\u0026#34;系統通知\u0026#34;); mailMessage.setText(message); mailSender.send(mailMessage); System.out.println(\u0026#34;Email 通知已發送到: \u0026#34; + recipient); } catch (Exception e) { System.err.println(\u0026#34;Email 發送失敗: \u0026#34; + e.getMessage()); } } @Override public boolean isAvailable() { return enabled \u0026amp;\u0026amp; mailSender != null; } @Override public String getChannelName() { return \u0026#34;email\u0026#34;; } } @Component public class SmsNotificationStrategy implements NotificationStrategy { @Value(\u0026#34;${notification.sms.enabled:true}\u0026#34;) private boolean enabled; @Value(\u0026#34;${notification.sms.api-key:}\u0026#34;) private String apiKey; @Override public void sendNotification(String recipient, String message) { if (!isAvailable()) { throw new IllegalStateException(\u0026#34;SMS 通知服務不可用\u0026#34;); } // 模擬 SMS API 調用 System.out.println(\u0026#34;SMS 通知已發送到: \u0026#34; + recipient); System.out.println(\u0026#34;內容: \u0026#34; + message); } @Override public boolean isAvailable() { return enabled \u0026amp;\u0026amp; apiKey != null \u0026amp;\u0026amp; !apiKey.isEmpty(); } @Override public String getChannelName() { return \u0026#34;sms\u0026#34;; } } 策略工廠和管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // 通知策略工廠 @Component public class NotificationStrategyFactory { private final Map\u0026lt;String, NotificationStrategy\u0026gt; strategies; public NotificationStrategyFactory(List\u0026lt;NotificationStrategy\u0026gt; strategyList) { this.strategies = strategyList.stream() .collect(Collectors.toMap( NotificationStrategy::getChannelName, Function.identity() )); } public NotificationStrategy getStrategy(String channelName) { NotificationStrategy strategy = strategies.get(channelName); if (strategy == null) { throw new IllegalArgumentException(\u0026#34;不支援的通知方式: \u0026#34; + channelName); } return strategy; } public List\u0026lt;NotificationStrategy\u0026gt; getAvailableStrategies() { return strategies.values().stream() .filter(NotificationStrategy::isAvailable) .collect(Collectors.toList()); } public Set\u0026lt;String\u0026gt; getSupportedChannels() { return strategies.keySet(); } } // 通知服務 @Service public class NotificationService { private final NotificationStrategyFactory strategyFactory; public NotificationService(NotificationStrategyFactory strategyFactory) { this.strategyFactory = strategyFactory; } public void sendNotification(String channel, String recipient, String message) { NotificationStrategy strategy = strategyFactory.getStrategy(channel); if (!strategy.isAvailable()) { // 降級策略 - 嘗試其他可用的通知方式 List\u0026lt;NotificationStrategy\u0026gt; availableStrategies = strategyFactory.getAvailableStrategies(); if (!availableStrategies.isEmpty()) { NotificationStrategy fallbackStrategy = availableStrategies.get(0); System.out.println(\u0026#34;原通知方式不可用，使用備選方式: \u0026#34; + fallbackStrategy.getChannelName()); fallbackStrategy.sendNotification(recipient, message); return; } throw new IllegalStateException(\u0026#34;所有通知方式都不可用\u0026#34;); } strategy.sendNotification(recipient, message); } public void broadcastNotification(String message) { List\u0026lt;NotificationStrategy\u0026gt; availableStrategies = strategyFactory.getAvailableStrategies(); availableStrategies.parallelStream() .forEach(strategy -\u0026gt; { try { strategy.sendNotification(\u0026#34;broadcast\u0026#34;, message); } catch (Exception e) { System.err.println(\u0026#34;廣播通知失敗 [\u0026#34; + strategy.getChannelName() + \u0026#34;]: \u0026#34; + e.getMessage()); } }); } } 4. 策略模式的最佳實踐 避免常見陷阱 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // ❌ 錯誤：策略類過於複雜 public class BadComplexStrategy implements PaymentStrategy { @Override public PaymentResult processPayment(PaymentRequest request) { // 100+ 行複雜邏輯 // 包含多個職責 // 難以測試和維護 return null; } } // ✅ 正確：單一職責的策略 public class GoodSimpleStrategy implements PaymentStrategy { private final PaymentValidator validator; private final PaymentProcessor processor; public GoodSimpleStrategy(PaymentValidator validator, PaymentProcessor processor) { this.validator = validator; this.processor = processor; } @Override public PaymentResult processPayment(PaymentRequest request) { if (!validator.validate(request)) { return new PaymentResult(false, null, \u0026#34;驗證失敗\u0026#34;); } return processor.process(request); } } 策略模式測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @ExtendWith(MockitoExtension.class) class PaymentStrategyTest { @Test void creditCardPayment_shouldProcessSuccessfully() { // Given PaymentStrategy strategy = new CreditCardPaymentStrategy( \u0026#34;4111111111111111\u0026#34;, \u0026#34;John Doe\u0026#34;, \u0026#34;12/25\u0026#34;, \u0026#34;123\u0026#34;); PaymentRequest request = new PaymentRequest( BigDecimal.valueOf(100), \u0026#34;USD\u0026#34;, \u0026#34;MERCHANT_001\u0026#34;); // When PaymentResult result = strategy.processPayment(request); // Then assertThat(result.isSuccess()).isTrue(); assertThat(result.getTransactionId()).isNotNull(); assertThat(result.getTransactionId()).startsWith(\u0026#34;CC_\u0026#34;); } @Test void paymentProcessor_shouldSwitchStrategies() { // Given PaymentStrategy creditCardStrategy = new CreditCardPaymentStrategy( \u0026#34;4111111111111111\u0026#34;, \u0026#34;John Doe\u0026#34;, \u0026#34;12/25\u0026#34;, \u0026#34;123\u0026#34;); PaymentStrategy paypalStrategy = new PayPalPaymentStrategy( \u0026#34;user@example.com\u0026#34;, \u0026#34;password123\u0026#34;); PaymentProcessor processor = new PaymentProcessor(creditCardStrategy); PaymentRequest request = new PaymentRequest( BigDecimal.valueOf(100), \u0026#34;USD\u0026#34;, \u0026#34;MERCHANT_001\u0026#34;); // When \u0026amp; Then PaymentResult result1 = processor.processPayment(request); assertThat(result1.isSuccess()).isTrue(); processor.setPaymentStrategy(paypalStrategy); PaymentResult result2 = processor.processPayment(request); assertThat(result2.isSuccess()).isTrue(); assertThat(result2.getTransactionId()).startsWith(\u0026#34;PP_\u0026#34;); } } 5. 總結 適用場景 算法選擇: 需要在多個算法間動態選擇 行為變化: 對象行為需要在運行時改變 條件邏輯: 替代複雜的條件分支結構 擴展性: 需要頻繁添加新的行為實現 關鍵要點 單一職責: 每個策略專注於一個特定算法 開閉原則: 容易添加新策略，無需修改現有代碼 運行時切換: 支持動態切換策略 測試友好: 每個策略可以獨立測試 Spring Boot 最佳實踐 依賴注入: 使用 Spring 管理策略實例 配置驅動: 通過配置文件控制策略選擇 條件創建: 使用 @ConditionalOnProperty 控制策略載入 監控集成: 整合 Spring Actuator 監控策略使用情況 與其他模式的關係 工廠模式: 用於創建策略實例 裝飾器模式: 為策略添加額外功能 責任鏈模式: 組合多個策略處理複雜業務 模板方法模式: 在策略內部定義算法骨架 策略模式是企業級應用中最常用的設計模式之一，特別適合處理業務規則頻繁變化的場景。在 Spring Boot 環境中，結合依賴注入和配置管理，可以構建出高度靈活和可維護的應用系統。\n","permalink":"https://xinqilin.github.io/post/architecture/strategy/","tags":[],"title":"DesignPattern - Behavioral - Strategy Pattern"},{"content":"Observer Pattern 觀察者模式 Observer Pattern 是行為型設計模式之一，它定義了一種一對多的依賴關係，當一個對象的狀態發生改變時，所有依賴於它的對象都會得到通知並被自動更新。\n核心概念 觀察者模式建立了一種「發布-訂閱」(Publisher-Subscriber) 的關係，讓觀察者(Observer)能夠監聽主題(Subject)的狀態變化。當主題狀態發生改變時，它會自動通知所有註冊的觀察者。\n主要組成部分 Subject (主題): 維護觀察者列表，提供註冊/取消註冊介面 Observer (觀察者): 定義接收通知的介面 ConcreteSubject (具體主題): 實現主題介面，儲存狀態並通知觀察者 ConcreteObserver (具體觀察者): 實現觀察者介面，處理通知 主要優勢 鬆耦合: 主題和觀察者之間保持鬆耦合關係 動態關係: 可以在運行時動態添加或移除觀察者 廣播通信: 一個主題可以同時通知多個觀察者 開閉原則: 新增觀察者類型無需修改現有代碼 1. 傳統 Observer 模式實現 基礎觀察者模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // 主題接口 public interface Subject\u0026lt;T\u0026gt; { void registerObserver(Observer\u0026lt;T\u0026gt; observer); void unregisterObserver(Observer\u0026lt;T\u0026gt; observer); void notifyObservers(); void notifyObservers(T data); } // 觀察者接口 public interface Observer\u0026lt;T\u0026gt; { void update(T data); void update(Subject\u0026lt;T\u0026gt; subject); } // 抽象主題實現 public abstract class AbstractSubject\u0026lt;T\u0026gt; implements Subject\u0026lt;T\u0026gt; { private final List\u0026lt;Observer\u0026lt;T\u0026gt;\u0026gt; observers = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); private final Object lock = new Object(); @Override public void registerObserver(Observer\u0026lt;T\u0026gt; observer) { if (observer == null) { throw new IllegalArgumentException(\u0026#34;Observer cannot be null\u0026#34;); } synchronized (lock) { if (!observers.contains(observer)) { observers.add(observer); } } } @Override public void unregisterObserver(Observer\u0026lt;T\u0026gt; observer) { synchronized (lock) { observers.remove(observer); } } @Override public void notifyObservers() { List\u0026lt;Observer\u0026lt;T\u0026gt;\u0026gt; currentObservers; synchronized (lock) { currentObservers = new ArrayList\u0026lt;\u0026gt;(observers); } for (Observer\u0026lt;T\u0026gt; observer : currentObservers) { try { observer.update(this); } catch (Exception e) { System.err.println(\u0026#34;Observer notification failed: \u0026#34; + e.getMessage()); } } } @Override public void notifyObservers(T data) { List\u0026lt;Observer\u0026lt;T\u0026gt;\u0026gt; currentObservers; synchronized (lock) { currentObservers = new ArrayList\u0026lt;\u0026gt;(observers); } for (Observer\u0026lt;T\u0026gt; observer : currentObservers) { try { observer.update(data); } catch (Exception e) { System.err.println(\u0026#34;Observer notification failed: \u0026#34; + e.getMessage()); } } } public int getObserverCount() { synchronized (lock) { return observers.size(); } } } 具體實現範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 // 股票模型 public class Stock { private final String symbol; private BigDecimal price; private BigDecimal change; private LocalDateTime timestamp; public Stock(String symbol, BigDecimal price) { this.symbol = symbol; this.price = price; this.change = BigDecimal.ZERO; this.timestamp = LocalDateTime.now(); } // getters and setters public String getSymbol() { return symbol; } public BigDecimal getPrice() { return price; } public BigDecimal getChange() { return change; } public LocalDateTime getTimestamp() { return timestamp; } public void updatePrice(BigDecimal newPrice) { this.change = newPrice.subtract(this.price); this.price = newPrice; this.timestamp = LocalDateTime.now(); } @Override public String toString() { return String.format(\u0026#34;Stock{symbol=\u0026#39;%s\u0026#39;, price=%s, change=%s, timestamp=%s}\u0026#34;, symbol, price, change, timestamp); } } // 股票價格主題 public class StockPrice extends AbstractSubject\u0026lt;Stock\u0026gt; { private Stock stock; public StockPrice(String symbol, BigDecimal initialPrice) { this.stock = new Stock(symbol, initialPrice); } public void updatePrice(BigDecimal newPrice) { stock.updatePrice(newPrice); notifyObservers(stock); } public Stock getStock() { return stock; } } // 股票顯示觀察者 public class StockDisplay implements Observer\u0026lt;Stock\u0026gt; { private final String displayName; public StockDisplay(String displayName) { this.displayName = displayName; } @Override public void update(Stock stock) { System.out.printf(\u0026#34;[%s] 股票更新: %s%n\u0026#34;, displayName, stock); } @Override public void update(Subject\u0026lt;Stock\u0026gt; subject) { if (subject instanceof StockPrice) { StockPrice stockPrice = (StockPrice) subject; update(stockPrice.getStock()); } } } // 股票警報觀察者 public class StockAlert implements Observer\u0026lt;Stock\u0026gt; { private final BigDecimal threshold; private final String alertType; public StockAlert(BigDecimal threshold, String alertType) { this.threshold = threshold; this.alertType = alertType; } @Override public void update(Stock stock) { if (\u0026#34;HIGH\u0026#34;.equals(alertType) \u0026amp;\u0026amp; stock.getPrice().compareTo(threshold) \u0026gt; 0) { System.out.printf(\u0026#34;🚨 高價警報: %s 超過 %s%n\u0026#34;, stock.getSymbol(), threshold); } else if (\u0026#34;LOW\u0026#34;.equals(alertType) \u0026amp;\u0026amp; stock.getPrice().compareTo(threshold) \u0026lt; 0) { System.out.printf(\u0026#34;🚨 低價警報: %s 低於 %s%n\u0026#34;, stock.getSymbol(), threshold); } } @Override public void update(Subject\u0026lt;Stock\u0026gt; subject) { if (subject instanceof StockPrice) { StockPrice stockPrice = (StockPrice) subject; update(stockPrice.getStock()); } } } 基礎使用範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class BasicObserverDemo { public static void main(String[] args) { // 創建股票價格主題 StockPrice appleStock = new StockPrice(\u0026#34;AAPL\u0026#34;, BigDecimal.valueOf(150.00)); // 創建觀察者 StockDisplay mobileDisplay = new StockDisplay(\u0026#34;手機應用\u0026#34;); StockDisplay webDisplay = new StockDisplay(\u0026#34;網頁版\u0026#34;); StockAlert highAlert = new StockAlert(BigDecimal.valueOf(160.00), \u0026#34;HIGH\u0026#34;); StockAlert lowAlert = new StockAlert(BigDecimal.valueOf(140.00), \u0026#34;LOW\u0026#34;); // 註冊觀察者 appleStock.registerObserver(mobileDisplay); appleStock.registerObserver(webDisplay); appleStock.registerObserver(highAlert); appleStock.registerObserver(lowAlert); System.out.println(\u0026#34;=== 初始狀態 ===\u0026#34;); System.out.println(\u0026#34;觀察者數量: \u0026#34; + appleStock.getObserverCount()); // 更新股票價格 System.out.println(\u0026#34;\\n=== 價格上漲 ===\u0026#34;); appleStock.updatePrice(BigDecimal.valueOf(155.50)); System.out.println(\u0026#34;\\n=== 價格下跌 ===\u0026#34;); appleStock.updatePrice(BigDecimal.valueOf(135.00)); System.out.println(\u0026#34;\\n=== 價格大幅上漲 ===\u0026#34;); appleStock.updatePrice(BigDecimal.valueOf(165.00)); // 移除觀察者 appleStock.unregisterObserver(webDisplay); System.out.println(\u0026#34;\\n=== 移除網頁顯示觀察者後 ===\u0026#34;); appleStock.updatePrice(BigDecimal.valueOf(170.00)); } } 2. 現代 Java 觀察者模式 使用 Java 內建 Observable 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import java.util.Observable; import java.util.Observer; // 使用 Java 內建 Observable (已棄用，但仍可學習) public class NewsAgency extends Observable { private String news; public void setNews(String news) { this.news = news; setChanged(); notifyObservers(news); } public String getNews() { return news; } } // 使用 PropertyChangeSupport 的現代實現 public class ModernNewsAgency { private String news; private final PropertyChangeSupport support; public ModernNewsAgency() { this.support = new PropertyChangeSupport(this); } public void addPropertyChangeListener(PropertyChangeListener listener) { support.addPropertyChangeListener(listener); } public void removePropertyChangeListener(PropertyChangeListener listener) { support.removePropertyChangeListener(listener); } public void setNews(String news) { String oldNews = this.news; this.news = news; support.firePropertyChange(\u0026#34;news\u0026#34;, oldNews, news); } public String getNews() { return news; } } 函數式觀察者模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // 函數式觀察者接口 @FunctionalInterface public interface EventListener\u0026lt;T\u0026gt; { void onEvent(T event); } // 事件發布器 public class EventPublisher\u0026lt;T\u0026gt; { private final List\u0026lt;EventListener\u0026lt;T\u0026gt;\u0026gt; listeners = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); public void subscribe(EventListener\u0026lt;T\u0026gt; listener) { listeners.add(listener); } public void unsubscribe(EventListener\u0026lt;T\u0026gt; listener) { listeners.remove(listener); } public void publish(T event) { listeners.parallelStream().forEach(listener -\u0026gt; { try { listener.onEvent(event); } catch (Exception e) { System.err.println(\u0026#34;Event listener failed: \u0026#34; + e.getMessage()); } }); } } // 使用範例 public class FunctionalObserverDemo { public static void main(String[] args) { EventPublisher\u0026lt;String\u0026gt; publisher = new EventPublisher\u0026lt;\u0026gt;(); // 使用 Lambda 表達式 publisher.subscribe(message -\u0026gt; System.out.println(\u0026#34;電子郵件: \u0026#34; + message)); publisher.subscribe(message -\u0026gt; System.out.println(\u0026#34;簡訊: \u0026#34; + message)); // 使用方法引用 publisher.subscribe(System.out::println); // 發布事件 publisher.publish(\u0026#34;新文章發布!\u0026#34;); } } 3. Spring Boot 事件驅動架構 Spring Events 基礎 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 自定義事件 public class UserRegisteredEvent extends ApplicationEvent { private final User user; public UserRegisteredEvent(Object source, User user) { super(source); this.user = user; } public User getUser() { return user; } } // 用戶模型 public class User { private final String id; private final String email; private final String name; private final LocalDateTime registeredAt; public User(String id, String email, String name) { this.id = id; this.email = email; this.name = name; this.registeredAt = LocalDateTime.now(); } // getters public String getId() { return id; } public String getEmail() { return email; } public String getName() { return name; } public LocalDateTime getRegisteredAt() { return registeredAt; } } // 事件發布服務 @Service public class UserService { private final ApplicationEventPublisher eventPublisher; public UserService(ApplicationEventPublisher eventPublisher) { this.eventPublisher = eventPublisher; } public void registerUser(String email, String name) { // 用戶註冊邏輯 String userId = UUID.randomUUID().toString(); User user = new User(userId, email, name); // 保存用戶到數據庫 saveUser(user); // 發布事件 eventPublisher.publishEvent(new UserRegisteredEvent(this, user)); } private void saveUser(User user) { // 模擬數據庫保存 System.out.println(\u0026#34;用戶已保存: \u0026#34; + user.getName()); } } Spring Event Listeners 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // 郵件服務事件監聽器 @Component public class EmailNotificationListener { @EventListener public void handleUserRegistered(UserRegisteredEvent event) { User user = event.getUser(); sendWelcomeEmail(user); } @Async @EventListener public void handleUserRegisteredAsync(UserRegisteredEvent event) { User user = event.getUser(); sendPromotionalEmail(user); } private void sendWelcomeEmail(User user) { System.out.println(\u0026#34;發送歡迎郵件給: \u0026#34; + user.getEmail()); // 實際郵件發送邏輯 } private void sendPromotionalEmail(User user) { System.out.println(\u0026#34;發送促銷郵件給: \u0026#34; + user.getEmail()); // 實際郵件發送邏輯 } } // 審計服務事件監聽器 @Component public class AuditListener { @EventListener @Order(1) // 確保審計優先執行 public void handleUserRegistered(UserRegisteredEvent event) { User user = event.getUser(); logUserRegistration(user); } private void logUserRegistration(User user) { System.out.println(\u0026#34;審計日誌 - 用戶註冊: \u0026#34; + user.getId() + \u0026#34; at \u0026#34; + user.getRegisteredAt()); } } // 統計服務事件監聽器 @Component public class StatisticsListener { private final AtomicLong registrationCount = new AtomicLong(0); @EventListener public void handleUserRegistered(UserRegisteredEvent event) { long count = registrationCount.incrementAndGet(); System.out.println(\u0026#34;註冊用戶總數: \u0026#34; + count); // 更新統計數據 updateRegistrationStats(event.getUser()); } private void updateRegistrationStats(User user) { // 更新統計數據庫 System.out.println(\u0026#34;更新統計數據\u0026#34;); } } 條件事件監聽 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 條件事件監聽器 @Component public class ConditionalEventListener { @EventListener(condition = \u0026#34;#event.user.email.contains(\u0026#39;admin\u0026#39;)\u0026#34;) public void handleAdminUserRegistered(UserRegisteredEvent event) { User user = event.getUser(); System.out.println(\u0026#34;管理員用戶註冊: \u0026#34; + user.getEmail()); notifyAdminTeam(user); } @EventListener(condition = \u0026#34;#event.user.email.endsWith(\u0026#39;.com\u0026#39;)\u0026#34;) public void handleComEmailRegistered(UserRegisteredEvent event) { User user = event.getUser(); System.out.println(\u0026#34;商業用戶註冊: \u0026#34; + user.getEmail()); } private void notifyAdminTeam(User user) { System.out.println(\u0026#34;通知管理員團隊: 新管理員用戶 \u0026#34; + user.getName()); } } 4. 響應式編程觀察者模式 RxJava 響應式觀察者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // 使用 RxJava 的響應式觀察者 public class RxObserverDemo { public static void main(String[] args) { // 創建 Observable Observable\u0026lt;String\u0026gt; newsObservable = Observable.create(emitter -\u0026gt; { // 模擬新聞發布 emitter.onNext(\u0026#34;突發新聞: 股市大漲\u0026#34;); emitter.onNext(\u0026#34;體育新聞: 世界杯開幕\u0026#34;); emitter.onNext(\u0026#34;科技新聞: 新 AI 技術發布\u0026#34;); emitter.onComplete(); }); // 創建觀察者 Observer\u0026lt;String\u0026gt; newsObserver = new Observer\u0026lt;String\u0026gt;() { @Override public void onSubscribe(Disposable d) { System.out.println(\u0026#34;訂閱新聞服務\u0026#34;); } @Override public void onNext(String news) { System.out.println(\u0026#34;接收新聞: \u0026#34; + news); } @Override public void onError(Throwable e) { System.err.println(\u0026#34;新聞接收錯誤: \u0026#34; + e.getMessage()); } @Override public void onComplete() { System.out.println(\u0026#34;新聞接收完成\u0026#34;); } }; // 訂閱 newsObservable.subscribe(newsObserver); // 使用操作符進行轉換和過濾 newsObservable .filter(news -\u0026gt; news.contains(\u0026#34;股市\u0026#34;)) .map(news -\u0026gt; news.toUpperCase()) .subscribe(news -\u0026gt; System.out.println(\u0026#34;股市新聞: \u0026#34; + news)); } } Project Reactor 響應式流 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // 使用 Project Reactor 的響應式流 @Service public class ReactiveStockService { private final Flux\u0026lt;Stock\u0026gt; stockStream; public ReactiveStockService() { this.stockStream = Flux.interval(Duration.ofSeconds(1)) .map(i -\u0026gt; generateRandomStock()) .share(); // 共享流 } private Stock generateRandomStock() { String[] symbols = {\u0026#34;AAPL\u0026#34;, \u0026#34;GOOGL\u0026#34;, \u0026#34;MSFT\u0026#34;, \u0026#34;AMZN\u0026#34;, \u0026#34;TSLA\u0026#34;}; String symbol = symbols[new Random().nextInt(symbols.length)]; BigDecimal price = BigDecimal.valueOf(100 + new Random().nextDouble() * 100); return new Stock(symbol, price); } public Flux\u0026lt;Stock\u0026gt; getStockStream() { return stockStream; } public Flux\u0026lt;Stock\u0026gt; getStockStream(String symbol) { return stockStream.filter(stock -\u0026gt; stock.getSymbol().equals(symbol)); } } // 響應式控制器 @RestController public class ReactiveStockController { private final ReactiveStockService stockService; public ReactiveStockController(ReactiveStockService stockService) { this.stockService = stockService; } @GetMapping(value = \u0026#34;/stocks/stream\u0026#34;, produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux\u0026lt;Stock\u0026gt; streamStocks() { return stockService.getStockStream(); } @GetMapping(value = \u0026#34;/stocks/{symbol}/stream\u0026#34;, produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux\u0026lt;Stock\u0026gt; streamStock(@PathVariable String symbol) { return stockService.getStockStream(symbol); } } 5. 異步觀察者模式 CompletableFuture 異步通知 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // 異步觀察者模式實現 public class AsyncObserverPattern { public static class AsyncSubject\u0026lt;T\u0026gt; { private final List\u0026lt;Function\u0026lt;T, CompletableFuture\u0026lt;Void\u0026gt;\u0026gt;\u0026gt; observers = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); private final Executor executor; public AsyncSubject(Executor executor) { this.executor = executor; } public void subscribe(Function\u0026lt;T, CompletableFuture\u0026lt;Void\u0026gt;\u0026gt; observer) { observers.add(observer); } public void unsubscribe(Function\u0026lt;T, CompletableFuture\u0026lt;Void\u0026gt;\u0026gt; observer) { observers.remove(observer); } public CompletableFuture\u0026lt;Void\u0026gt; notifyObservers(T data) { List\u0026lt;CompletableFuture\u0026lt;Void\u0026gt;\u0026gt; futures = observers.stream() .map(observer -\u0026gt; observer.apply(data)) .collect(Collectors.toList()); return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])); } } public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(4); AsyncSubject\u0026lt;String\u0026gt; subject = new AsyncSubject\u0026lt;\u0026gt;(executor); // 註冊異步觀察者 subject.subscribe(message -\u0026gt; CompletableFuture.runAsync(() -\u0026gt; { System.out.println(\u0026#34;觀察者 1 處理: \u0026#34; + message); try { Thread.sleep(1000); } catch (InterruptedException e) {} System.out.println(\u0026#34;觀察者 1 完成\u0026#34;); }, executor) ); subject.subscribe(message -\u0026gt; CompletableFuture.runAsync(() -\u0026gt; { System.out.println(\u0026#34;觀察者 2 處理: \u0026#34; + message); try { Thread.sleep(500); } catch (InterruptedException e) {} System.out.println(\u0026#34;觀察者 2 完成\u0026#34;); }, executor) ); // 發送通知 subject.notifyObservers(\u0026#34;異步消息\u0026#34;) .thenRun(() -\u0026gt; System.out.println(\u0026#34;所有觀察者處理完成\u0026#34;)) .join(); executor.shutdown(); } } 消息隊列觀察者模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // 使用消息隊列的觀察者模式 @Component public class MessageQueueObserver { @RabbitListener(queues = \u0026#34;user.registered\u0026#34;) public void handleUserRegistered(UserRegisteredEvent event) { System.out.println(\u0026#34;從消息隊列接收用戶註冊事件: \u0026#34; + event.getUser().getName()); // 處理業務邏輯 processUserRegistration(event.getUser()); } @RabbitListener(queues = \u0026#34;order.created\u0026#34;) public void handleOrderCreated(OrderCreatedEvent event) { System.out.println(\u0026#34;從消息隊列接收訂單創建事件: \u0026#34; + event.getOrderId()); // 處理訂單邏輯 processOrderCreation(event); } private void processUserRegistration(User user) { // 發送歡迎郵件 // 更新統計數據 // 觸發其他業務流程 } private void processOrderCreation(OrderCreatedEvent event) { // 更新庫存 // 發送確認郵件 // 觸發配送流程 } } // 訂單創建事件 public class OrderCreatedEvent { private final String orderId; private final String userId; private final BigDecimal amount; private final LocalDateTime createdAt; public OrderCreatedEvent(String orderId, String userId, BigDecimal amount) { this.orderId = orderId; this.userId = userId; this.amount = amount; this.createdAt = LocalDateTime.now(); } // getters public String getOrderId() { return orderId; } public String getUserId() { return userId; } public BigDecimal getAmount() { return amount; } public LocalDateTime getCreatedAt() { return createdAt; } } 6. 事件溯源 (Event Sourcing) 事件溯源模式實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 // 領域事件基類 public abstract class DomainEvent { private final String eventId; private final LocalDateTime occurredAt; private final String aggregateId; private final int version; public DomainEvent(String aggregateId, int version) { this.eventId = UUID.randomUUID().toString(); this.occurredAt = LocalDateTime.now(); this.aggregateId = aggregateId; this.version = version; } // getters public String getEventId() { return eventId; } public LocalDateTime getOccurredAt() { return occurredAt; } public String getAggregateId() { return aggregateId; } public int getVersion() { return version; } } // 賬戶相關事件 public class AccountCreatedEvent extends DomainEvent { private final String accountHolderName; private final BigDecimal initialBalance; public AccountCreatedEvent(String aggregateId, int version, String accountHolderName, BigDecimal initialBalance) { super(aggregateId, version); this.accountHolderName = accountHolderName; this.initialBalance = initialBalance; } // getters public String getAccountHolderName() { return accountHolderName; } public BigDecimal getInitialBalance() { return initialBalance; } } public class MoneyDepositedEvent extends DomainEvent { private final BigDecimal amount; private final String description; public MoneyDepositedEvent(String aggregateId, int version, BigDecimal amount, String description) { super(aggregateId, version); this.amount = amount; this.description = description; } // getters public BigDecimal getAmount() { return amount; } public String getDescription() { return description; } } public class MoneyWithdrawnEvent extends DomainEvent { private final BigDecimal amount; private final String description; public MoneyWithdrawnEvent(String aggregateId, int version, BigDecimal amount, String description) { super(aggregateId, version); this.amount = amount; this.description = description; } // getters public BigDecimal getAmount() { return amount; } public String getDescription() { return description; } } 事件存儲和重放 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 // 事件存儲接口 public interface EventStore { void saveEvents(String aggregateId, List\u0026lt;DomainEvent\u0026gt; events, int expectedVersion); List\u0026lt;DomainEvent\u0026gt; getEventsForAggregate(String aggregateId); } // 內存事件存儲實現 @Component public class InMemoryEventStore implements EventStore { private final Map\u0026lt;String, List\u0026lt;DomainEvent\u0026gt;\u0026gt; eventStore = new ConcurrentHashMap\u0026lt;\u0026gt;(); @Override public void saveEvents(String aggregateId, List\u0026lt;DomainEvent\u0026gt; events, int expectedVersion) { List\u0026lt;DomainEvent\u0026gt; existingEvents = eventStore.computeIfAbsent(aggregateId, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()); // 檢查版本衝突 if (existingEvents.size() != expectedVersion) { throw new ConcurrencyException(\u0026#34;Expected version \u0026#34; + expectedVersion + \u0026#34; but was \u0026#34; + existingEvents.size()); } existingEvents.addAll(events); } @Override public List\u0026lt;DomainEvent\u0026gt; getEventsForAggregate(String aggregateId) { return eventStore.getOrDefault(aggregateId, Collections.emptyList()); } } // 賬戶聚合根 public class Account { private String accountId; private String accountHolderName; private BigDecimal balance; private int version; private List\u0026lt;DomainEvent\u0026gt; changes = new ArrayList\u0026lt;\u0026gt;(); public Account() {} public Account(String accountId, String accountHolderName, BigDecimal initialBalance) { this.accountId = accountId; applyChange(new AccountCreatedEvent(accountId, 0, accountHolderName, initialBalance)); } public void deposit(BigDecimal amount, String description) { if (amount.compareTo(BigDecimal.ZERO) \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;存款金額必須大於零\u0026#34;); } applyChange(new MoneyDepositedEvent(accountId, version, amount, description)); } public void withdraw(BigDecimal amount, String description) { if (amount.compareTo(BigDecimal.ZERO) \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;提款金額必須大於零\u0026#34;); } if (balance.compareTo(amount) \u0026lt; 0) { throw new IllegalStateException(\u0026#34;餘額不足\u0026#34;); } applyChange(new MoneyWithdrawnEvent(accountId, version, amount, description)); } private void applyChange(DomainEvent event) { applyChange(event, true); } private void applyChange(DomainEvent event, boolean isNew) { // 應用事件到聚合狀態 if (event instanceof AccountCreatedEvent) { AccountCreatedEvent e = (AccountCreatedEvent) event; this.accountHolderName = e.getAccountHolderName(); this.balance = e.getInitialBalance(); } else if (event instanceof MoneyDepositedEvent) { MoneyDepositedEvent e = (MoneyDepositedEvent) event; this.balance = this.balance.add(e.getAmount()); } else if (event instanceof MoneyWithdrawnEvent) { MoneyWithdrawnEvent e = (MoneyWithdrawnEvent) event; this.balance = this.balance.subtract(e.getAmount()); } this.version = event.getVersion(); if (isNew) { changes.add(event); } } public void loadFromHistory(List\u0026lt;DomainEvent\u0026gt; events) { for (DomainEvent event : events) { applyChange(event, false); } } public List\u0026lt;DomainEvent\u0026gt; getUncommittedChanges() { return new ArrayList\u0026lt;\u0026gt;(changes); } public void markChangesAsCommitted() { changes.clear(); } // getters public String getAccountId() { return accountId; } public String getAccountHolderName() { return accountHolderName; } public BigDecimal getBalance() { return balance; } public int getVersion() { return version; } } 事件處理器和投影 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // 事件處理器 @Component public class AccountEventHandler { @EventListener public void handle(AccountCreatedEvent event) { System.out.println(\u0026#34;帳戶已創建: \u0026#34; + event.getAccountHolderName() + \u0026#34;, 初始餘額: \u0026#34; + event.getInitialBalance()); // 更新讀取模型 updateAccountProjection(event); } @EventListener public void handle(MoneyDepositedEvent event) { System.out.println(\u0026#34;存款: \u0026#34; + event.getAmount() + \u0026#34;, 描述: \u0026#34; + event.getDescription()); // 更新讀取模型 updateBalanceProjection(event); } @EventListener public void handle(MoneyWithdrawnEvent event) { System.out.println(\u0026#34;提款: \u0026#34; + event.getAmount() + \u0026#34;, 描述: \u0026#34; + event.getDescription()); // 更新讀取模型 updateBalanceProjection(event); } private void updateAccountProjection(AccountCreatedEvent event) { // 更新帳戶投影表 System.out.println(\u0026#34;更新帳戶投影: \u0026#34; + event.getAggregateId()); } private void updateBalanceProjection(DomainEvent event) { // 更新餘額投影表 System.out.println(\u0026#34;更新餘額投影: \u0026#34; + event.getAggregateId()); } } // 自定義併發異常 public class ConcurrencyException extends RuntimeException { public ConcurrencyException(String message) { super(message); } } 7. 企業級觀察者模式 分散式事件系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // 分散式事件發布器 @Component public class DistributedEventPublisher { private final RabbitTemplate rabbitTemplate; private final ApplicationEventPublisher localEventPublisher; public DistributedEventPublisher(RabbitTemplate rabbitTemplate, ApplicationEventPublisher localEventPublisher) { this.rabbitTemplate = rabbitTemplate; this.localEventPublisher = localEventPublisher; } public void publishEvent(DomainEvent event) { // 本地事件發布 localEventPublisher.publishEvent(event); // 分散式事件發布 publishToMessageQueue(event); } private void publishToMessageQueue(DomainEvent event) { try { String routingKey = event.getClass().getSimpleName(); rabbitTemplate.convertAndSend(\u0026#34;domain.events\u0026#34;, routingKey, event); } catch (Exception e) { System.err.println(\u0026#34;分散式事件發布失敗: \u0026#34; + e.getMessage()); } } } // 事件總線配置 @Configuration @EnableRabbit public class EventBusConfiguration { @Bean public TopicExchange domainEventsExchange() { return new TopicExchange(\u0026#34;domain.events\u0026#34;); } @Bean public Queue userEventsQueue() { return QueueBuilder.durable(\u0026#34;user.events\u0026#34;).build(); } @Bean public Queue orderEventsQueue() { return QueueBuilder.durable(\u0026#34;order.events\u0026#34;).build(); } @Bean public Binding userEventsBinding() { return BindingBuilder.bind(userEventsQueue()) .to(domainEventsExchange()) .with(\u0026#34;User*\u0026#34;); } @Bean public Binding orderEventsBinding() { return BindingBuilder.bind(orderEventsQueue()) .to(domainEventsExchange()) .with(\u0026#34;Order*\u0026#34;); } } 事件重試和錯誤處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 可靠事件處理器 @Component public class ReliableEventHandler { private final RetryTemplate retryTemplate; public ReliableEventHandler() { this.retryTemplate = RetryTemplate.builder() .maxAttempts(3) .fixedBackoff(1000) .retryOn(Exception.class) .build(); } @RabbitListener(queues = \u0026#34;user.events\u0026#34;) public void handleUserEvent(UserRegisteredEvent event) { retryTemplate.execute(context -\u0026gt; { processUserEvent(event); return null; }); } @Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 1000)) public void processUserEvent(UserRegisteredEvent event) { // 模擬可能失敗的操作 if (Math.random() \u0026lt; 0.3) { throw new RuntimeException(\u0026#34;處理失敗\u0026#34;); } System.out.println(\u0026#34;成功處理用戶事件: \u0026#34; + event.getUser().getName()); } @Recover public void recover(Exception e, UserRegisteredEvent event) { System.err.println(\u0026#34;用戶事件處理最終失敗: \u0026#34; + e.getMessage()); // 將失敗事件送到死信隊列或記錄到錯誤日誌 handleFailedEvent(event, e); } private void handleFailedEvent(UserRegisteredEvent event, Exception e) { // 記錄失敗事件 System.err.println(\u0026#34;記錄失敗事件: \u0026#34; + event.getUser().getName()); } } 8. 觀察者模式的最佳實踐 性能優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 高性能觀察者模式實現 public class HighPerformanceObserver { // 使用 Disruptor 的高性能事件處理 public static class DisruptorEventPublisher { private final RingBuffer\u0026lt;EventWrapper\u0026gt; ringBuffer; private final Disruptor\u0026lt;EventWrapper\u0026gt; disruptor; public DisruptorEventPublisher() { this.disruptor = new Disruptor\u0026lt;\u0026gt;(EventWrapper::new, 1024, Executors.defaultThreadFactory()); this.ringBuffer = disruptor.getRingBuffer(); // 註冊事件處理器 disruptor.handleEventsWith(new EventHandler\u0026lt;EventWrapper\u0026gt;() { @Override public void onEvent(EventWrapper event, long sequence, boolean endOfBatch) { // 處理事件 System.out.println(\u0026#34;處理事件: \u0026#34; + event.getData()); } }); disruptor.start(); } public void publishEvent(String data) { long sequence = ringBuffer.next(); try { EventWrapper event = ringBuffer.get(sequence); event.setData(data); } finally { ringBuffer.publish(sequence); } } public void shutdown() { disruptor.shutdown(); } } public static class EventWrapper { private String data; public String getData() { return data; } public void setData(String data) { this.data = data; } } } 測試策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @ExtendWith(MockitoExtension.class) class ObserverPatternTest { @Test void shouldNotifyAllObservers() { // Given StockPrice stockPrice = new StockPrice(\u0026#34;AAPL\u0026#34;, BigDecimal.valueOf(150.00)); StockDisplay display1 = mock(StockDisplay.class); StockDisplay display2 = mock(StockDisplay.class); stockPrice.registerObserver(display1); stockPrice.registerObserver(display2); // When stockPrice.updatePrice(BigDecimal.valueOf(155.00)); // Then verify(display1).update(any(Stock.class)); verify(display2).update(any(Stock.class)); } @Test void shouldHandleObserverExceptions() { // Given StockPrice stockPrice = new StockPrice(\u0026#34;AAPL\u0026#34;, BigDecimal.valueOf(150.00)); Observer\u0026lt;Stock\u0026gt; faultyObserver = mock(Observer.class); Observer\u0026lt;Stock\u0026gt; normalObserver = mock(Observer.class); doThrow(new RuntimeException(\u0026#34;Observer failed\u0026#34;)).when(faultyObserver).update(any(Stock.class)); stockPrice.registerObserver(faultyObserver); stockPrice.registerObserver(normalObserver); // When stockPrice.updatePrice(BigDecimal.valueOf(155.00)); // Then verify(faultyObserver).update(any(Stock.class)); verify(normalObserver).update(any(Stock.class)); // 應該仍然被調用 } } // Spring Boot 集成測試 @SpringBootTest @TestPropertySource(properties = { \u0026#34;spring.rabbitmq.host=localhost\u0026#34;, \u0026#34;spring.rabbitmq.port=5672\u0026#34; }) class SpringEventIntegrationTest { @Autowired private UserService userService; @MockBean private EmailNotificationListener emailListener; @Test void shouldPublishUserRegisteredEvent() { // When userService.registerUser(\u0026#34;test@example.com\u0026#34;, \u0026#34;Test User\u0026#34;); // Then verify(emailListener, timeout(1000)).handleUserRegistered(any(UserRegisteredEvent.class)); } } 9. 總結 適用場景 狀態變化通知: 當對象狀態改變需要通知多個依賴對象 事件驅動架構: 構建鬆耦合的事件驅動系統 發布-訂閱模式: 實現消息的發布和訂閱機制 模型-視圖分離: 在 MVC 架構中分離模型和視圖 關鍵要點 鬆耦合: 主題和觀察者之間保持鬆耦合 動態訂閱: 支持運行時動態添加和移除觀察者 廣播通信: 一對多的通信機制 異常處理: 確保單個觀察者異常不影響其他觀察者 現代實踐 Spring Events: 利用 Spring 框架的事件機制 響應式編程: 使用 RxJava 或 Project Reactor 消息隊列: 通過 RabbitMQ、Kafka 等實現分散式觀察者 事件溯源: 構建基於事件的系統架構 性能考慮 並發安全: 使用線程安全的觀察者列表 異步處理: 避免阻塞主線程 批量處理: 對大量事件進行批量處理 錯誤隔離: 確保單個觀察者異常不影響系統 觀察者模式是構建現代企業級應用的重要設計模式，特別是在微服務架構和事件驅動系統中。結合 Spring Boot 和響應式編程，可以構建出高度可擴展和maintainable的系統。\n","permalink":"https://xinqilin.github.io/post/architecture/observer/","tags":[],"title":"DesignPattern - Behavioral - Observer Pattern"},{"content":"責任鏈模式 (Chain of Responsibility Pattern) 完整實作指南 模式概述 責任鏈模式是一種行為設計模式，它允許你將請求沿著處理者鏈傳遞，直到其中一個處理者處理該請求。該模式讓多個對象都有機會處理請求，從而避免了請求的發送者和接收者之間的耦合關係。\n核心概念 責任鏈模式解決的核心問題：\n請求與處理者解耦：發送者不需要知道具體的處理者 動態處理流程：可以動態地組合和重排處理者 請求路由：請求會自動流向合適的處理者 擴展性：易於添加新的處理者，不影響現有代碼 基本架構 1. 傳統責任鏈實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // 請求基類 public abstract class Request { private String requestId; private RequestType type; private Object data; private LocalDateTime timestamp; public Request(RequestType type, Object data) { this.requestId = UUID.randomUUID().toString(); this.type = type; this.data = data; this.timestamp = LocalDateTime.now(); } // Getter 和 Setter 方法 public String getRequestId() { return requestId; } public RequestType getType() { return type; } public Object getData() { return data; } public LocalDateTime getTimestamp() { return timestamp; } } // 請求類型枚舉 public enum RequestType { AUTHENTICATION, AUTHORIZATION, VALIDATION, PROCESSING, LOGGING } // 處理者抽象類 public abstract class Handler { protected Handler nextHandler; public void setNext(Handler handler) { this.nextHandler = handler; } public Handler getNext() { return nextHandler; } public abstract boolean canHandle(Request request); public abstract void handle(Request request); // 處理請求的公共方法 public void processRequest(Request request) { if (canHandle(request)) { handle(request); } else if (nextHandler != null) { nextHandler.processRequest(request); } else { handleUnprocessedRequest(request); } } protected void handleUnprocessedRequest(Request request) { System.out.println(\u0026#34;請求無法處理: \u0026#34; + request.getRequestId()); } } 2. 具體處理者實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 // 認證處理者 public class AuthenticationHandler extends Handler { private AuthenticationService authService; public AuthenticationHandler(AuthenticationService authService) { this.authService = authService; } @Override public boolean canHandle(Request request) { return request.getType() == RequestType.AUTHENTICATION; } @Override public void handle(Request request) { System.out.println(\u0026#34;處理認證請求: \u0026#34; + request.getRequestId()); if (request.getData() instanceof AuthenticationRequest) { AuthenticationRequest authRequest = (AuthenticationRequest) request.getData(); try { boolean isValid = authService.authenticate(authRequest.getUsername(), authRequest.getPassword()); if (isValid) { System.out.println(\u0026#34;認證成功: \u0026#34; + authRequest.getUsername()); // 創建下一個處理階段的請求 AuthorizationRequest authzRequest = new AuthorizationRequest( authRequest.getUsername(), authRequest.getResource() ); Request nextRequest = new Request(RequestType.AUTHORIZATION, authzRequest); if (nextHandler != null) { nextHandler.processRequest(nextRequest); } } else { System.out.println(\u0026#34;認證失敗: \u0026#34; + authRequest.getUsername()); } } catch (Exception e) { System.err.println(\u0026#34;認證處理出錯: \u0026#34; + e.getMessage()); } } } } // 授權處理者 public class AuthorizationHandler extends Handler { private AuthorizationService authzService; public AuthorizationHandler(AuthorizationService authzService) { this.authzService = authzService; } @Override public boolean canHandle(Request request) { return request.getType() == RequestType.AUTHORIZATION; } @Override public void handle(Request request) { System.out.println(\u0026#34;處理授權請求: \u0026#34; + request.getRequestId()); if (request.getData() instanceof AuthorizationRequest) { AuthorizationRequest authzRequest = (AuthorizationRequest) request.getData(); try { boolean hasPermission = authzService.authorize( authzRequest.getUsername(), authzRequest.getResource() ); if (hasPermission) { System.out.println(\u0026#34;授權成功: \u0026#34; + authzRequest.getUsername() + \u0026#34; 訪問 \u0026#34; + authzRequest.getResource()); // 創建驗證請求 ValidationRequest validationRequest = new ValidationRequest( authzRequest.getUsername(), authzRequest.getResource() ); Request nextRequest = new Request(RequestType.VALIDATION, validationRequest); if (nextHandler != null) { nextHandler.processRequest(nextRequest); } } else { System.out.println(\u0026#34;授權失敗: \u0026#34; + authzRequest.getUsername() + \u0026#34; 無權訪問 \u0026#34; + authzRequest.getResource()); } } catch (Exception e) { System.err.println(\u0026#34;授權處理出錯: \u0026#34; + e.getMessage()); } } } } // 驗證處理者 public class ValidationHandler extends Handler { private ValidationService validationService; public ValidationHandler(ValidationService validationService) { this.validationService = validationService; } @Override public boolean canHandle(Request request) { return request.getType() == RequestType.VALIDATION; } @Override public void handle(Request request) { System.out.println(\u0026#34;處理驗證請求: \u0026#34; + request.getRequestId()); if (request.getData() instanceof ValidationRequest) { ValidationRequest validationRequest = (ValidationRequest) request.getData(); try { ValidationResult result = validationService.validate(validationRequest); if (result.isValid()) { System.out.println(\u0026#34;驗證成功: \u0026#34; + validationRequest.getUsername()); // 創建處理請求 ProcessingRequest processingRequest = new ProcessingRequest( validationRequest.getUsername(), validationRequest.getResource(), result.getValidatedData() ); Request nextRequest = new Request(RequestType.PROCESSING, processingRequest); if (nextHandler != null) { nextHandler.processRequest(nextRequest); } } else { System.out.println(\u0026#34;驗證失敗: \u0026#34; + result.getErrorMessage()); } } catch (Exception e) { System.err.println(\u0026#34;驗證處理出錯: \u0026#34; + e.getMessage()); } } } } // 業務處理者 public class ProcessingHandler extends Handler { private BusinessService businessService; public ProcessingHandler(BusinessService businessService) { this.businessService = businessService; } @Override public boolean canHandle(Request request) { return request.getType() == RequestType.PROCESSING; } @Override public void handle(Request request) { System.out.println(\u0026#34;處理業務請求: \u0026#34; + request.getRequestId()); if (request.getData() instanceof ProcessingRequest) { ProcessingRequest processingRequest = (ProcessingRequest) request.getData(); try { BusinessResult result = businessService.process(processingRequest); if (result.isSuccess()) { System.out.println(\u0026#34;業務處理成功: \u0026#34; + result.getMessage()); // 創建日誌請求 LoggingRequest loggingRequest = new LoggingRequest( processingRequest.getUsername(), \u0026#34;業務處理成功\u0026#34;, result ); Request nextRequest = new Request(RequestType.LOGGING, loggingRequest); if (nextHandler != null) { nextHandler.processRequest(nextRequest); } } else { System.out.println(\u0026#34;業務處理失敗: \u0026#34; + result.getErrorMessage()); } } catch (Exception e) { System.err.println(\u0026#34;業務處理出錯: \u0026#34; + e.getMessage()); } } } } // 日誌處理者 public class LoggingHandler extends Handler { private LoggingService loggingService; public LoggingHandler(LoggingService loggingService) { this.loggingService = loggingService; } @Override public boolean canHandle(Request request) { return request.getType() == RequestType.LOGGING; } @Override public void handle(Request request) { System.out.println(\u0026#34;處理日誌請求: \u0026#34; + request.getRequestId()); if (request.getData() instanceof LoggingRequest) { LoggingRequest loggingRequest = (LoggingRequest) request.getData(); try { loggingService.log( loggingRequest.getUsername(), loggingRequest.getMessage(), loggingRequest.getData() ); System.out.println(\u0026#34;日誌記錄完成: \u0026#34; + loggingRequest.getMessage()); } catch (Exception e) { System.err.println(\u0026#34;日誌處理出錯: \u0026#34; + e.getMessage()); } } } } 3. 請求數據類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 // 認證請求 public class AuthenticationRequest { private String username; private String password; private String resource; public AuthenticationRequest(String username, String password, String resource) { this.username = username; this.password = password; this.resource = resource; } // Getter 和 Setter 方法 public String getUsername() { return username; } public String getPassword() { return password; } public String getResource() { return resource; } } // 授權請求 public class AuthorizationRequest { private String username; private String resource; public AuthorizationRequest(String username, String resource) { this.username = username; this.resource = resource; } // Getter 和 Setter 方法 public String getUsername() { return username; } public String getResource() { return resource; } } // 驗證請求 public class ValidationRequest { private String username; private String resource; private Map\u0026lt;String, Object\u0026gt; parameters; public ValidationRequest(String username, String resource) { this.username = username; this.resource = resource; this.parameters = new HashMap\u0026lt;\u0026gt;(); } // Getter 和 Setter 方法 public String getUsername() { return username; } public String getResource() { return resource; } public Map\u0026lt;String, Object\u0026gt; getParameters() { return parameters; } public void addParameter(String key, Object value) { parameters.put(key, value); } } // 處理請求 public class ProcessingRequest { private String username; private String resource; private Object validatedData; public ProcessingRequest(String username, String resource, Object validatedData) { this.username = username; this.resource = resource; this.validatedData = validatedData; } // Getter 和 Setter 方法 public String getUsername() { return username; } public String getResource() { return resource; } public Object getValidatedData() { return validatedData; } } // 日誌請求 public class LoggingRequest { private String username; private String message; private Object data; public LoggingRequest(String username, String message, Object data) { this.username = username; this.message = message; this.data = data; } // Getter 和 Setter 方法 public String getUsername() { return username; } public String getMessage() { return message; } public Object getData() { return data; } } 現代責任鏈實現 1. 流式處理器鏈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // 處理器函數接口 @FunctionalInterface public interface RequestProcessor\u0026lt;T\u0026gt; { ProcessingResult\u0026lt;T\u0026gt; process(T request); } // 處理結果 public class ProcessingResult\u0026lt;T\u0026gt; { private boolean processed; private T result; private String message; private Exception error; private ProcessingResult(boolean processed, T result, String message, Exception error) { this.processed = processed; this.result = result; this.message = message; this.error = error; } public static \u0026lt;T\u0026gt; ProcessingResult\u0026lt;T\u0026gt; processed(T result) { return new ProcessingResult\u0026lt;\u0026gt;(true, result, null, null); } public static \u0026lt;T\u0026gt; ProcessingResult\u0026lt;T\u0026gt; processed(T result, String message) { return new ProcessingResult\u0026lt;\u0026gt;(true, result, message, null); } public static \u0026lt;T\u0026gt; ProcessingResult\u0026lt;T\u0026gt; notProcessed() { return new ProcessingResult\u0026lt;\u0026gt;(false, null, null, null); } public static \u0026lt;T\u0026gt; ProcessingResult\u0026lt;T\u0026gt; error(Exception error) { return new ProcessingResult\u0026lt;\u0026gt;(false, null, null, error); } // Getter 方法 public boolean isProcessed() { return processed; } public T getResult() { return result; } public String getMessage() { return message; } public Exception getError() { return error; } public boolean hasError() { return error != null; } } // 現代責任鏈實現 public class ProcessorChain\u0026lt;T\u0026gt; { private final List\u0026lt;RequestProcessor\u0026lt;T\u0026gt;\u0026gt; processors; public ProcessorChain() { this.processors = new ArrayList\u0026lt;\u0026gt;(); } public ProcessorChain\u0026lt;T\u0026gt; addProcessor(RequestProcessor\u0026lt;T\u0026gt; processor) { processors.add(processor); return this; } public ProcessorChain\u0026lt;T\u0026gt; addProcessor(Predicate\u0026lt;T\u0026gt; condition, RequestProcessor\u0026lt;T\u0026gt; processor) { processors.add(request -\u0026gt; { if (condition.test(request)) { return processor.process(request); } return ProcessingResult.notProcessed(); }); return this; } public ProcessingResult\u0026lt;T\u0026gt; process(T request) { for (RequestProcessor\u0026lt;T\u0026gt; processor : processors) { try { ProcessingResult\u0026lt;T\u0026gt; result = processor.process(request); if (result.isProcessed()) { return result; } if (result.hasError()) { return result; } } catch (Exception e) { return ProcessingResult.error(e); } } return ProcessingResult.notProcessed(); } } 2. 中介軟體模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // 中介軟體接口 @FunctionalInterface public interface Middleware\u0026lt;T\u0026gt; { void process(T request, MiddlewareChain\u0026lt;T\u0026gt; chain); } // 中介軟體鏈 public class MiddlewareChain\u0026lt;T\u0026gt; { private final List\u0026lt;Middleware\u0026lt;T\u0026gt;\u0026gt; middlewares; private int currentIndex = 0; public MiddlewareChain(List\u0026lt;Middleware\u0026lt;T\u0026gt;\u0026gt; middlewares) { this.middlewares = new ArrayList\u0026lt;\u0026gt;(middlewares); } public void next(T request) { if (currentIndex \u0026lt; middlewares.size()) { Middleware\u0026lt;T\u0026gt; middleware = middlewares.get(currentIndex++); middleware.process(request, this); } } public void reset() { currentIndex = 0; } } // 中介軟體管理器 public class MiddlewareManager\u0026lt;T\u0026gt; { private final List\u0026lt;Middleware\u0026lt;T\u0026gt;\u0026gt; middlewares; public MiddlewareManager() { this.middlewares = new ArrayList\u0026lt;\u0026gt;(); } public MiddlewareManager\u0026lt;T\u0026gt; use(Middleware\u0026lt;T\u0026gt; middleware) { middlewares.add(middleware); return this; } public void process(T request) { MiddlewareChain\u0026lt;T\u0026gt; chain = new MiddlewareChain\u0026lt;\u0026gt;(middlewares); chain.next(request); } } 企業級應用場景 1. HTTP 請求處理管道 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 // HTTP 請求對象 public class HttpRequestContext { private String method; private String path; private Map\u0026lt;String, String\u0026gt; headers; private Map\u0026lt;String, String\u0026gt; parameters; private Object body; private String userAgent; private String clientIp; private LocalDateTime timestamp; public HttpRequestContext(String method, String path) { this.method = method; this.path = path; this.headers = new HashMap\u0026lt;\u0026gt;(); this.parameters = new HashMap\u0026lt;\u0026gt;(); this.timestamp = LocalDateTime.now(); } // Getter 和 Setter 方法 public String getMethod() { return method; } public String getPath() { return path; } public Map\u0026lt;String, String\u0026gt; getHeaders() { return headers; } public Map\u0026lt;String, String\u0026gt; getParameters() { return parameters; } public Object getBody() { return body; } public void setBody(Object body) { this.body = body; } public String getUserAgent() { return userAgent; } public void setUserAgent(String userAgent) { this.userAgent = userAgent; } public String getClientIp() { return clientIp; } public void setClientIp(String clientIp) { this.clientIp = clientIp; } public LocalDateTime getTimestamp() { return timestamp; } public void addHeader(String key, String value) { headers.put(key, value); } public void addParameter(String key, String value) { parameters.put(key, value); } } // 安全檢查中介軟體 public class SecurityMiddleware implements Middleware\u0026lt;HttpRequestContext\u0026gt; { private final SecurityService securityService; public SecurityMiddleware(SecurityService securityService) { this.securityService = securityService; } @Override public void process(HttpRequestContext request, MiddlewareChain\u0026lt;HttpRequestContext\u0026gt; chain) { System.out.println(\u0026#34;執行安全檢查中介軟體\u0026#34;); // 檢查 IP 白名單 if (!securityService.isAllowedIp(request.getClientIp())) { System.out.println(\u0026#34;IP 地址被拒絕: \u0026#34; + request.getClientIp()); return; } // 檢查 User-Agent if (!securityService.isValidUserAgent(request.getUserAgent())) { System.out.println(\u0026#34;無效的 User-Agent: \u0026#34; + request.getUserAgent()); return; } // 檢查請求頻率 if (!securityService.checkRateLimit(request.getClientIp())) { System.out.println(\u0026#34;請求頻率過高: \u0026#34; + request.getClientIp()); return; } System.out.println(\u0026#34;安全檢查通過\u0026#34;); chain.next(request); } } // 認證中介軟體 public class AuthenticationMiddleware implements Middleware\u0026lt;HttpRequestContext\u0026gt; { private final AuthenticationService authService; public AuthenticationMiddleware(AuthenticationService authService) { this.authService = authService; } @Override public void process(HttpRequestContext request, MiddlewareChain\u0026lt;HttpRequestContext\u0026gt; chain) { System.out.println(\u0026#34;執行認證中介軟體\u0026#34;); String authHeader = request.getHeaders().get(\u0026#34;Authorization\u0026#34;); if (authHeader == null || !authHeader.startsWith(\u0026#34;Bearer \u0026#34;)) { System.out.println(\u0026#34;缺少認證令牌\u0026#34;); return; } String token = authHeader.substring(7); try { UserInfo userInfo = authService.validateToken(token); if (userInfo != null) { request.addParameter(\u0026#34;userId\u0026#34;, userInfo.getUserId()); request.addParameter(\u0026#34;username\u0026#34;, userInfo.getUsername()); System.out.println(\u0026#34;認證成功: \u0026#34; + userInfo.getUsername()); chain.next(request); } else { System.out.println(\u0026#34;無效的認證令牌\u0026#34;); } } catch (Exception e) { System.out.println(\u0026#34;認證失敗: \u0026#34; + e.getMessage()); } } } // 授權中介軟體 public class AuthorizationMiddleware implements Middleware\u0026lt;HttpRequestContext\u0026gt; { private final AuthorizationService authzService; public AuthorizationMiddleware(AuthorizationService authzService) { this.authzService = authzService; } @Override public void process(HttpRequestContext request, MiddlewareChain\u0026lt;HttpRequestContext\u0026gt; chain) { System.out.println(\u0026#34;執行授權中介軟體\u0026#34;); String userId = request.getParameters().get(\u0026#34;userId\u0026#34;); if (userId == null) { System.out.println(\u0026#34;用戶未認證\u0026#34;); return; } try { boolean hasPermission = authzService.hasPermission(userId, request.getPath(), request.getMethod()); if (hasPermission) { System.out.println(\u0026#34;授權成功: \u0026#34; + userId + \u0026#34; 訪問 \u0026#34; + request.getPath()); chain.next(request); } else { System.out.println(\u0026#34;授權失敗: 用戶 \u0026#34; + userId + \u0026#34; 無權訪問 \u0026#34; + request.getPath()); } } catch (Exception e) { System.out.println(\u0026#34;授權檢查失敗: \u0026#34; + e.getMessage()); } } } // 日誌中介軟體 public class LoggingMiddleware implements Middleware\u0026lt;HttpRequestContext\u0026gt; { private final LoggingService loggingService; public LoggingMiddleware(LoggingService loggingService) { this.loggingService = loggingService; } @Override public void process(HttpRequestContext request, MiddlewareChain\u0026lt;HttpRequestContext\u0026gt; chain) { long startTime = System.currentTimeMillis(); System.out.println(\u0026#34;請求開始: \u0026#34; + request.getMethod() + \u0026#34; \u0026#34; + request.getPath()); try { chain.next(request); } finally { long endTime = System.currentTimeMillis(); long duration = endTime - startTime; LogEntry logEntry = new LogEntry( request.getMethod(), request.getPath(), request.getClientIp(), request.getParameters().get(\u0026#34;userId\u0026#34;), duration, request.getTimestamp() ); loggingService.log(logEntry); System.out.println(\u0026#34;請求完成: \u0026#34; + request.getMethod() + \u0026#34; \u0026#34; + request.getPath() + \u0026#34; 耗時: \u0026#34; + duration + \u0026#34;ms\u0026#34;); } } } // 業務處理中介軟體 public class BusinessProcessingMiddleware implements Middleware\u0026lt;HttpRequestContext\u0026gt; { private final BusinessService businessService; public BusinessProcessingMiddleware(BusinessService businessService) { this.businessService = businessService; } @Override public void process(HttpRequestContext request, MiddlewareChain\u0026lt;HttpRequestContext\u0026gt; chain) { System.out.println(\u0026#34;執行業務處理中介軟體\u0026#34;); try { BusinessResult result = businessService.processRequest(request); if (result.isSuccess()) { System.out.println(\u0026#34;業務處理成功: \u0026#34; + result.getMessage()); request.addParameter(\u0026#34;result\u0026#34;, result.getData()); } else { System.out.println(\u0026#34;業務處理失敗: \u0026#34; + result.getErrorMessage()); } } catch (Exception e) { System.out.println(\u0026#34;業務處理異常: \u0026#34; + e.getMessage()); } } } 2. 工作流程處理系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 // 工作流程請求 public class WorkflowRequest { private String workflowId; private String requestId; private String initiator; private WorkflowType type; private Map\u0026lt;String, Object\u0026gt; data; private WorkflowStatus status; private LocalDateTime createdAt; private LocalDateTime updatedAt; public WorkflowRequest(String workflowId, String initiator, WorkflowType type) { this.workflowId = workflowId; this.requestId = UUID.randomUUID().toString(); this.initiator = initiator; this.type = type; this.data = new HashMap\u0026lt;\u0026gt;(); this.status = WorkflowStatus.PENDING; this.createdAt = LocalDateTime.now(); this.updatedAt = LocalDateTime.now(); } // Getter 和 Setter 方法 public String getWorkflowId() { return workflowId; } public String getRequestId() { return requestId; } public String getInitiator() { return initiator; } public WorkflowType getType() { return type; } public Map\u0026lt;String, Object\u0026gt; getData() { return data; } public WorkflowStatus getStatus() { return status; } public void setStatus(WorkflowStatus status) { this.status = status; this.updatedAt = LocalDateTime.now(); } public LocalDateTime getCreatedAt() { return createdAt; } public LocalDateTime getUpdatedAt() { return updatedAt; } public void addData(String key, Object value) { data.put(key, value); } public Object getData(String key) { return data.get(key); } } // 工作流程類型 public enum WorkflowType { LEAVE_REQUEST, EXPENSE_REPORT, PURCHASE_ORDER, DOCUMENT_APPROVAL } // 工作流程狀態 public enum WorkflowStatus { PENDING, IN_PROGRESS, APPROVED, REJECTED, CANCELLED } // 工作流程步驟處理者 public abstract class WorkflowStepHandler { protected WorkflowStepHandler nextHandler; protected String stepName; public WorkflowStepHandler(String stepName) { this.stepName = stepName; } public void setNext(WorkflowStepHandler handler) { this.nextHandler = handler; } public abstract boolean canHandle(WorkflowRequest request); public abstract StepResult handle(WorkflowRequest request); public StepResult process(WorkflowRequest request) { if (canHandle(request)) { System.out.println(\u0026#34;執行步驟: \u0026#34; + stepName); StepResult result = handle(request); if (result.isSuccess() \u0026amp;\u0026amp; nextHandler != null) { return nextHandler.process(request); } return result; } else if (nextHandler != null) { return nextHandler.process(request); } else { return StepResult.failure(\u0026#34;沒有適當的處理者處理此請求\u0026#34;); } } } // 步驟結果 public class StepResult { private boolean success; private String message; private Object data; private StepResult(boolean success, String message, Object data) { this.success = success; this.message = message; this.data = data; } public static StepResult success(String message) { return new StepResult(true, message, null); } public static StepResult success(String message, Object data) { return new StepResult(true, message, data); } public static StepResult failure(String message) { return new StepResult(false, message, null); } // Getter 方法 public boolean isSuccess() { return success; } public String getMessage() { return message; } public Object getData() { return data; } } // 請假申請初始檢查處理者 public class LeaveRequestInitialCheckHandler extends WorkflowStepHandler { private final LeaveService leaveService; public LeaveRequestInitialCheckHandler(LeaveService leaveService) { super(\u0026#34;請假申請初始檢查\u0026#34;); this.leaveService = leaveService; } @Override public boolean canHandle(WorkflowRequest request) { return request.getType() == WorkflowType.LEAVE_REQUEST \u0026amp;\u0026amp; request.getStatus() == WorkflowStatus.PENDING; } @Override public StepResult handle(WorkflowRequest request) { try { // 檢查基本信息 String employeeId = (String) request.getData(\u0026#34;employeeId\u0026#34;); LocalDate startDate = (LocalDate) request.getData(\u0026#34;startDate\u0026#34;); LocalDate endDate = (LocalDate) request.getData(\u0026#34;endDate\u0026#34;); String reason = (String) request.getData(\u0026#34;reason\u0026#34;); if (employeeId == null || startDate == null || endDate == null || reason == null) { return StepResult.failure(\u0026#34;缺少必要的請假信息\u0026#34;); } // 檢查日期有效性 if (startDate.isAfter(endDate)) { return StepResult.failure(\u0026#34;開始日期不能晚於結束日期\u0026#34;); } if (startDate.isBefore(LocalDate.now())) { return StepResult.failure(\u0026#34;不能申請過去的日期\u0026#34;); } // 檢查請假天數 long days = ChronoUnit.DAYS.between(startDate, endDate) + 1; if (days \u0026gt; 30) { return StepResult.failure(\u0026#34;單次請假不能超過30天\u0026#34;); } // 檢查剩餘假期 int remainingDays = leaveService.getRemainingLeaveDays(employeeId); if (days \u0026gt; remainingDays) { return StepResult.failure(\u0026#34;請假天數超過剩餘假期\u0026#34;); } request.setStatus(WorkflowStatus.IN_PROGRESS); request.addData(\u0026#34;leaveDays\u0026#34;, days); request.addData(\u0026#34;checkTime\u0026#34;, LocalDateTime.now()); return StepResult.success(\u0026#34;初始檢查通過\u0026#34;); } catch (Exception e) { return StepResult.failure(\u0026#34;初始檢查失敗: \u0026#34; + e.getMessage()); } } } // 主管審批處理者 public class ManagerApprovalHandler extends WorkflowStepHandler { private final ManagerService managerService; public ManagerApprovalHandler(ManagerService managerService) { super(\u0026#34;主管審批\u0026#34;); this.managerService = managerService; } @Override public boolean canHandle(WorkflowRequest request) { return request.getType() == WorkflowType.LEAVE_REQUEST \u0026amp;\u0026amp; request.getStatus() == WorkflowStatus.IN_PROGRESS \u0026amp;\u0026amp; request.getData(\u0026#34;managerApproval\u0026#34;) == null; } @Override public StepResult handle(WorkflowRequest request) { try { String employeeId = (String) request.getData(\u0026#34;employeeId\u0026#34;); Long leaveDays = (Long) request.getData(\u0026#34;leaveDays\u0026#34;); // 獲取員工的直屬主管 String managerId = managerService.getDirectManager(employeeId); if (managerId == null) { return StepResult.failure(\u0026#34;無法找到直屬主管\u0026#34;); } // 模擬主管審批流程 ApprovalResult approval = managerService.requestApproval( managerId, request.getRequestId(), leaveDays ); if (approval.isApproved()) { request.addData(\u0026#34;managerApproval\u0026#34;, true); request.addData(\u0026#34;managerId\u0026#34;, managerId); request.addData(\u0026#34;managerApprovalTime\u0026#34;, LocalDateTime.now()); return StepResult.success(\u0026#34;主管審批通過\u0026#34;); } else { request.setStatus(WorkflowStatus.REJECTED); request.addData(\u0026#34;managerApproval\u0026#34;, false); request.addData(\u0026#34;rejectionReason\u0026#34;, approval.getReason()); return StepResult.failure(\u0026#34;主管審批拒絕: \u0026#34; + approval.getReason()); } } catch (Exception e) { return StepResult.failure(\u0026#34;主管審批失敗: \u0026#34; + e.getMessage()); } } } // HR 審批處理者 public class HrApprovalHandler extends WorkflowStepHandler { private final HrService hrService; public HrApprovalHandler(HrService hrService) { super(\u0026#34;HR 審批\u0026#34;); this.hrService = hrService; } @Override public boolean canHandle(WorkflowRequest request) { return request.getType() == WorkflowType.LEAVE_REQUEST \u0026amp;\u0026amp; request.getStatus() == WorkflowStatus.IN_PROGRESS \u0026amp;\u0026amp; Boolean.TRUE.equals(request.getData(\u0026#34;managerApproval\u0026#34;)) \u0026amp;\u0026amp; request.getData(\u0026#34;hrApproval\u0026#34;) == null; } @Override public StepResult handle(WorkflowRequest request) { try { String employeeId = (String) request.getData(\u0026#34;employeeId\u0026#34;); Long leaveDays = (Long) request.getData(\u0026#34;leaveDays\u0026#34;); // 長期請假需要 HR 審批 if (leaveDays \u0026gt; 5) { ApprovalResult approval = hrService.requestApproval( request.getRequestId(), employeeId, leaveDays ); if (approval.isApproved()) { request.addData(\u0026#34;hrApproval\u0026#34;, true); request.addData(\u0026#34;hrApprovalTime\u0026#34;, LocalDateTime.now()); return StepResult.success(\u0026#34;HR 審批通過\u0026#34;); } else { request.setStatus(WorkflowStatus.REJECTED); request.addData(\u0026#34;hrApproval\u0026#34;, false); request.addData(\u0026#34;rejectionReason\u0026#34;, approval.getReason()); return StepResult.failure(\u0026#34;HR 審批拒絕: \u0026#34; + approval.getReason()); } } else { // 短期請假自動通過 request.addData(\u0026#34;hrApproval\u0026#34;, true); request.addData(\u0026#34;hrApprovalTime\u0026#34;, LocalDateTime.now()); return StepResult.success(\u0026#34;HR 審批自動通過\u0026#34;); } } catch (Exception e) { return StepResult.failure(\u0026#34;HR 審批失敗: \u0026#34; + e.getMessage()); } } } // 最終處理者 public class FinalProcessingHandler extends WorkflowStepHandler { private final LeaveService leaveService; private final NotificationService notificationService; public FinalProcessingHandler(LeaveService leaveService, NotificationService notificationService) { super(\u0026#34;最終處理\u0026#34;); this.leaveService = leaveService; this.notificationService = notificationService; } @Override public boolean canHandle(WorkflowRequest request) { return request.getType() == WorkflowType.LEAVE_REQUEST \u0026amp;\u0026amp; request.getStatus() == WorkflowStatus.IN_PROGRESS \u0026amp;\u0026amp; Boolean.TRUE.equals(request.getData(\u0026#34;managerApproval\u0026#34;)) \u0026amp;\u0026amp; Boolean.TRUE.equals(request.getData(\u0026#34;hrApproval\u0026#34;)); } @Override public StepResult handle(WorkflowRequest request) { try { String employeeId = (String) request.getData(\u0026#34;employeeId\u0026#34;); LocalDate startDate = (LocalDate) request.getData(\u0026#34;startDate\u0026#34;); LocalDate endDate = (LocalDate) request.getData(\u0026#34;endDate\u0026#34;); Long leaveDays = (Long) request.getData(\u0026#34;leaveDays\u0026#34;); // 創建請假記錄 LeaveRecord record = leaveService.createLeaveRecord( employeeId, startDate, endDate, leaveDays.intValue() ); // 更新請假餘額 leaveService.updateLeaveBalance(employeeId, -leaveDays.intValue()); // 發送通知 notificationService.sendLeaveApprovalNotification( employeeId, record.getLeaveId(), startDate, endDate ); request.setStatus(WorkflowStatus.APPROVED); request.addData(\u0026#34;leaveRecordId\u0026#34;, record.getLeaveId()); request.addData(\u0026#34;completedTime\u0026#34;, LocalDateTime.now()); return StepResult.success(\u0026#34;請假申請處理完成\u0026#34;); } catch (Exception e) { return StepResult.failure(\u0026#34;最終處理失敗: \u0026#34; + e.getMessage()); } } } Spring Boot 整合 1. 配置類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Configuration @EnableAsync public class ChainOfResponsibilityConfig { @Bean public AuthenticationService authenticationService() { return new AuthenticationService(); } @Bean public AuthorizationService authorizationService() { return new AuthorizationService(); } @Bean public SecurityService securityService() { return new SecurityService(); } @Bean public LoggingService loggingService() { return new LoggingService(); } @Bean public BusinessService businessService() { return new BusinessService(); } @Bean public MiddlewareManager\u0026lt;HttpRequestContext\u0026gt; httpMiddlewareManager( SecurityService securityService, AuthenticationService authenticationService, AuthorizationService authorizationService, LoggingService loggingService, BusinessService businessService) { return new MiddlewareManager\u0026lt;HttpRequestContext\u0026gt;() .use(new LoggingMiddleware(loggingService)) .use(new SecurityMiddleware(securityService)) .use(new AuthenticationMiddleware(authenticationService)) .use(new AuthorizationMiddleware(authorizationService)) .use(new BusinessProcessingMiddleware(businessService)); } @Bean public WorkflowStepHandler workflowChain( LeaveService leaveService, ManagerService managerService, HrService hrService, NotificationService notificationService) { WorkflowStepHandler initialCheck = new LeaveRequestInitialCheckHandler(leaveService); WorkflowStepHandler managerApproval = new ManagerApprovalHandler(managerService); WorkflowStepHandler hrApproval = new HrApprovalHandler(hrService); WorkflowStepHandler finalProcessing = new FinalProcessingHandler(leaveService, notificationService); initialCheck.setNext(managerApproval); managerApproval.setNext(hrApproval); hrApproval.setNext(finalProcessing); return initialCheck; } } 2. 控制器實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @RestController @RequestMapping(\u0026#34;/api/requests\u0026#34;) public class RequestController { private final MiddlewareManager\u0026lt;HttpRequestContext\u0026gt; middlewareManager; public RequestController(MiddlewareManager\u0026lt;HttpRequestContext\u0026gt; middlewareManager) { this.middlewareManager = middlewareManager; } @GetMapping(\u0026#34;/secure-data\u0026#34;) public ResponseEntity\u0026lt;ApiResponse\u0026lt;Object\u0026gt;\u0026gt; getSecureData( HttpServletRequest servletRequest, @RequestParam String resource) { HttpRequestContext context = createRequestContext(servletRequest, resource); try { middlewareManager.process(context); Object result = context.getParameters().get(\u0026#34;result\u0026#34;); if (result != null) { return ResponseEntity.ok(ApiResponse.success(result) .message(\u0026#34;數據獲取成功\u0026#34;) .build()); } else { return ResponseEntity.status(HttpStatus.FORBIDDEN) .body(ApiResponse.failure(\u0026#34;請求被拒絕\u0026#34;).build()); } } catch (Exception e) { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(ApiResponse.failure(\u0026#34;處理請求時出錯\u0026#34;).build()); } } private HttpRequestContext createRequestContext(HttpServletRequest servletRequest, String resource) { HttpRequestContext context = new HttpRequestContext( servletRequest.getMethod(), servletRequest.getRequestURI() ); // 復制請求頭 Enumeration\u0026lt;String\u0026gt; headerNames = servletRequest.getHeaderNames(); while (headerNames.hasMoreElements()) { String headerName = headerNames.nextElement(); context.addHeader(headerName, servletRequest.getHeader(headerName)); } // 設置客戶端信息 context.setClientIp(getClientIp(servletRequest)); context.setUserAgent(servletRequest.getHeader(\u0026#34;User-Agent\u0026#34;)); // 添加資源參數 context.addParameter(\u0026#34;resource\u0026#34;, resource); return context; } private String getClientIp(HttpServletRequest request) { String xForwardedFor = request.getHeader(\u0026#34;X-Forwarded-For\u0026#34;); if (xForwardedFor != null \u0026amp;\u0026amp; !xForwardedFor.isEmpty()) { return xForwardedFor.split(\u0026#34;,\u0026#34;)[0].trim(); } String xRealIp = request.getHeader(\u0026#34;X-Real-IP\u0026#34;); if (xRealIp != null \u0026amp;\u0026amp; !xRealIp.isEmpty()) { return xRealIp; } return request.getRemoteAddr(); } } @RestController @RequestMapping(\u0026#34;/api/workflow\u0026#34;) public class WorkflowController { private final WorkflowStepHandler workflowChain; public WorkflowController(WorkflowStepHandler workflowChain) { this.workflowChain = workflowChain; } @PostMapping(\u0026#34;/leave-request\u0026#34;) public ResponseEntity\u0026lt;ApiResponse\u0026lt;String\u0026gt;\u0026gt; submitLeaveRequest( @RequestBody @Valid LeaveRequestDto requestDto) { try { WorkflowRequest workflowRequest = new WorkflowRequest( \u0026#34;leave-workflow\u0026#34;, requestDto.getEmployeeId(), WorkflowType.LEAVE_REQUEST ); workflowRequest.addData(\u0026#34;employeeId\u0026#34;, requestDto.getEmployeeId()); workflowRequest.addData(\u0026#34;startDate\u0026#34;, requestDto.getStartDate()); workflowRequest.addData(\u0026#34;endDate\u0026#34;, requestDto.getEndDate()); workflowRequest.addData(\u0026#34;reason\u0026#34;, requestDto.getReason()); StepResult result = workflowChain.process(workflowRequest); if (result.isSuccess()) { return ResponseEntity.ok(ApiResponse.success(workflowRequest.getRequestId()) .message(\u0026#34;請假申請提交成功\u0026#34;) .build()); } else { return ResponseEntity.badRequest() .body(ApiResponse.\u0026lt;String\u0026gt;failure(\u0026#34;請假申請被拒絕\u0026#34;) .error(result.getMessage()) .build()); } } catch (Exception e) { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(ApiResponse.\u0026lt;String\u0026gt;failure(\u0026#34;處理請假申請時出錯\u0026#34;) .error(e.getMessage()) .build()); } } } // 請假申請 DTO public class LeaveRequestDto { @NotBlank(message = \u0026#34;員工 ID 不能為空\u0026#34;) private String employeeId; @NotNull(message = \u0026#34;開始日期不能為空\u0026#34;) @Future(message = \u0026#34;開始日期必須是將來日期\u0026#34;) private LocalDate startDate; @NotNull(message = \u0026#34;結束日期不能為空\u0026#34;) @Future(message = \u0026#34;結束日期必須是將來日期\u0026#34;) private LocalDate endDate; @NotBlank(message = \u0026#34;請假原因不能為空\u0026#34;) @Size(max = 500, message = \u0026#34;請假原因不能超過500字\u0026#34;) private String reason; // 構造函數、getter、setter 略 } 3. 測試實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 @SpringBootTest class ChainOfResponsibilityTest { @Test void testMiddlewareChain() { // Given SecurityService securityService = new SecurityService(); AuthenticationService authService = new AuthenticationService(); AuthorizationService authzService = new AuthorizationService(); LoggingService loggingService = new LoggingService(); BusinessService businessService = new BusinessService(); MiddlewareManager\u0026lt;HttpRequestContext\u0026gt; manager = new MiddlewareManager\u0026lt;HttpRequestContext\u0026gt;() .use(new LoggingMiddleware(loggingService)) .use(new SecurityMiddleware(securityService)) .use(new AuthenticationMiddleware(authService)) .use(new AuthorizationMiddleware(authzService)) .use(new BusinessProcessingMiddleware(businessService)); HttpRequestContext context = new HttpRequestContext(\u0026#34;GET\u0026#34;, \u0026#34;/api/secure-data\u0026#34;); context.setClientIp(\u0026#34;192.168.1.100\u0026#34;); context.setUserAgent(\u0026#34;TestClient/1.0\u0026#34;); context.addHeader(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer valid-token\u0026#34;); // When manager.process(context); // Then assertThat(context.getParameters()).containsKey(\u0026#34;userId\u0026#34;); assertThat(context.getParameters()).containsKey(\u0026#34;result\u0026#34;); } @Test void testWorkflowChain() { // Given LeaveService leaveService = mock(LeaveService.class); ManagerService managerService = mock(ManagerService.class); HrService hrService = mock(HrService.class); NotificationService notificationService = mock(NotificationService.class); when(leaveService.getRemainingLeaveDays(\u0026#34;EMP001\u0026#34;)).thenReturn(10); when(managerService.getDirectManager(\u0026#34;EMP001\u0026#34;)).thenReturn(\u0026#34;MGR001\u0026#34;); when(managerService.requestApproval(any(), any(), any())) .thenReturn(new ApprovalResult(true, \u0026#34;批准\u0026#34;)); when(hrService.requestApproval(any(), any(), any())) .thenReturn(new ApprovalResult(true, \u0026#34;批准\u0026#34;)); WorkflowStepHandler initialCheck = new LeaveRequestInitialCheckHandler(leaveService); WorkflowStepHandler managerApproval = new ManagerApprovalHandler(managerService); WorkflowStepHandler hrApproval = new HrApprovalHandler(hrService); WorkflowStepHandler finalProcessing = new FinalProcessingHandler(leaveService, notificationService); initialCheck.setNext(managerApproval); managerApproval.setNext(hrApproval); hrApproval.setNext(finalProcessing); WorkflowRequest request = new WorkflowRequest(\u0026#34;leave-workflow\u0026#34;, \u0026#34;EMP001\u0026#34;, WorkflowType.LEAVE_REQUEST); request.addData(\u0026#34;employeeId\u0026#34;, \u0026#34;EMP001\u0026#34;); request.addData(\u0026#34;startDate\u0026#34;, LocalDate.now().plusDays(1)); request.addData(\u0026#34;endDate\u0026#34;, LocalDate.now().plusDays(3)); request.addData(\u0026#34;reason\u0026#34;, \u0026#34;個人事務\u0026#34;); // When StepResult result = initialCheck.process(request); // Then assertThat(result.isSuccess()).isTrue(); assertThat(request.getStatus()).isEqualTo(WorkflowStatus.APPROVED); verify(leaveService).createLeaveRecord(any(), any(), any(), anyInt()); verify(notificationService).sendLeaveApprovalNotification(any(), any(), any(), any()); } @Test void testProcessorChain() { // Given ProcessorChain\u0026lt;String\u0026gt; chain = new ProcessorChain\u0026lt;String\u0026gt;() .addProcessor(request -\u0026gt; request.startsWith(\u0026#34;A\u0026#34;) ? ProcessingResult.processed(\u0026#34;處理A: \u0026#34; + request) : ProcessingResult.notProcessed()) .addProcessor(request -\u0026gt; request.startsWith(\u0026#34;B\u0026#34;) ? ProcessingResult.processed(\u0026#34;處理B: \u0026#34; + request) : ProcessingResult.notProcessed()) .addProcessor(request -\u0026gt; ProcessingResult.processed(\u0026#34;默認處理: \u0026#34; + request)); // When \u0026amp; Then ProcessingResult\u0026lt;String\u0026gt; result1 = chain.process(\u0026#34;A123\u0026#34;); assertThat(result1.isProcessed()).isTrue(); assertThat(result1.getResult()).isEqualTo(\u0026#34;處理A: A123\u0026#34;); ProcessingResult\u0026lt;String\u0026gt; result2 = chain.process(\u0026#34;B456\u0026#34;); assertThat(result2.isProcessed()).isTrue(); assertThat(result2.getResult()).isEqualTo(\u0026#34;處理B: B456\u0026#34;); ProcessingResult\u0026lt;String\u0026gt; result3 = chain.process(\u0026#34;C789\u0026#34;); assertThat(result3.isProcessed()).isTrue(); assertThat(result3.getResult()).isEqualTo(\u0026#34;默認處理: C789\u0026#34;); } } 性能優化與最佳實踐 1. 異步處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // 異步責任鏈 @Component public class AsyncChainProcessor { private final ThreadPoolTaskExecutor executor; public AsyncChainProcessor() { this.executor = new ThreadPoolTaskExecutor(); this.executor.setCorePoolSize(5); this.executor.setMaxPoolSize(20); this.executor.setQueueCapacity(100); this.executor.setThreadNamePrefix(\u0026#34;async-chain-\u0026#34;); this.executor.initialize(); } public \u0026lt;T\u0026gt; CompletableFuture\u0026lt;ProcessingResult\u0026lt;T\u0026gt;\u0026gt; processAsync( ProcessorChain\u0026lt;T\u0026gt; chain, T request) { return CompletableFuture.supplyAsync(() -\u0026gt; chain.process(request), executor); } public \u0026lt;T\u0026gt; void processAsync(MiddlewareManager\u0026lt;T\u0026gt; manager, T request) { executor.submit(() -\u0026gt; manager.process(request)); } } // 批量處理 @Component public class BatchChainProcessor { private final AsyncChainProcessor asyncProcessor; public BatchChainProcessor(AsyncChainProcessor asyncProcessor) { this.asyncProcessor = asyncProcessor; } public \u0026lt;T\u0026gt; CompletableFuture\u0026lt;List\u0026lt;ProcessingResult\u0026lt;T\u0026gt;\u0026gt;\u0026gt; processBatch( ProcessorChain\u0026lt;T\u0026gt; chain, List\u0026lt;T\u0026gt; requests) { List\u0026lt;CompletableFuture\u0026lt;ProcessingResult\u0026lt;T\u0026gt;\u0026gt;\u0026gt; futures = requests.stream() .map(request -\u0026gt; asyncProcessor.processAsync(chain, request)) .collect(Collectors.toList()); return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])) .thenApply(v -\u0026gt; futures.stream() .map(CompletableFuture::join) .collect(Collectors.toList())); } } 2. 緩存優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 處理結果緩存 @Component public class CachedChainProcessor { private final Cache\u0026lt;String, ProcessingResult\u0026lt;?\u0026gt;\u0026gt; cache; public CachedChainProcessor() { this.cache = Caffeine.newBuilder() .maximumSize(1000) .expireAfterWrite(Duration.ofMinutes(15)) .build(); } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T\u0026gt; ProcessingResult\u0026lt;T\u0026gt; processWithCache( ProcessorChain\u0026lt;T\u0026gt; chain, T request, String cacheKey) { return (ProcessingResult\u0026lt;T\u0026gt;) cache.get(cacheKey, key -\u0026gt; chain.process(request)); } public void invalidateCache(String cacheKey) { cache.invalidate(cacheKey); } public void invalidateAll() { cache.invalidateAll(); } } 監控與診斷 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 責任鏈監控 @Component public class ChainMonitor { private final MeterRegistry meterRegistry; private final Counter requestCounter; private final Counter processedCounter; private final Timer processingTimer; public ChainMonitor(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; this.requestCounter = Counter.builder(\u0026#34;chain.requests\u0026#34;) .description(\u0026#34;Total number of requests processed by chain\u0026#34;) .register(meterRegistry); this.processedCounter = Counter.builder(\u0026#34;chain.processed\u0026#34;) .description(\u0026#34;Number of successfully processed requests\u0026#34;) .register(meterRegistry); this.processingTimer = Timer.builder(\u0026#34;chain.processing.time\u0026#34;) .description(\u0026#34;Time spent processing requests\u0026#34;) .register(meterRegistry); } public \u0026lt;T\u0026gt; ProcessingResult\u0026lt;T\u0026gt; monitorProcess( ProcessorChain\u0026lt;T\u0026gt; chain, T request, String chainName) { requestCounter.increment(Tags.of(\u0026#34;chain\u0026#34;, chainName)); return processingTimer.recordCallable(() -\u0026gt; { ProcessingResult\u0026lt;T\u0026gt; result = chain.process(request); if (result.isProcessed()) { processedCounter.increment(Tags.of(\u0026#34;chain\u0026#34;, chainName)); } return result; }); } } 總結 責任鏈模式適用於：\n請求處理管道：HTTP 請求、消息處理、工作流程 動態責任分配：根據請求類型動態選擇處理者 中介軟體系統：Web 框架、API 網關、企業服務總線 擴展性需求：易於添加新的處理者，不影響現有代碼 關鍵最佳實踐 處理者解耦：每個處理者只關注自己的職責 鏈式組合：靈活組合不同的處理者 錯誤處理：每個處理者都要處理異常情況 性能優化：使用緩存、異步處理、批量操作 監控診斷：記錄處理流程和性能指標 測試策略：單元測試每個處理者，集成測試整個鏈 ","permalink":"https://xinqilin.github.io/post/architecture/chainofresponsibility/","tags":["Design Pattern","Chain of Responsibility","Behavioral Pattern","Request Processing","Loose Coupling","Flow Control","Java","Spring Boot","Enterprise Architecture","Handler Chain","Middleware","Pipeline Pattern","Request Response"],"title":"責任鏈模式 (Chain of Responsibility Pattern) 完整實作指南：請求處理的動態流程控制"},{"content":"Mediator Mediator 通過阻止對象顯式地相互引用來促進鬆散耦合，並且它允許您獨立地改變它們的交互。 我們使用中介者設計模式在系統中的不同對象之間提供集中的通信媒介。\n中介者模式專注於在對象之間提供一個中介者進行互動，並幫助實現對象之間的丟失耦合。對像要求中介者代表它們進行交互，而不是直接相互交互。它導致可重用性和鬆散耦合。此外，它封裝了對象之間的交互，使它們相互獨立。這也允許他們通過實現不同的中介以完全不同的方式改變與其他對象的交互。調解器有助於降低類的複雜性。此外，每個對像不再需要詳細了解如何與其他對象交互。對象之間的耦合從緊緻僵硬到鬆散優雅。 中介者設計模式在多個對象相互交互的企業應用程序中非常有用。如果對象直接相互交互，系統組件就會相互緊密耦合。它們還使可維護性成本更高，並且不能靈活地輕鬆擴展。\n例如，空中交通管制員是調解員模式的一個很好的例子，其中機場控制室充當不同航班之間通信的調解員。中介作為對象之間的路由器工作，它可以有自己的邏輯來提供通信方式。\nMediator: 定義一個與同事對象通信的 interface ConcreteMediator: 通過協調 Colleague 對象來實現協作行為。它還了解並維護其同事。 Colleague Classes: 每個 Colleague class 都知道它的 Mediator 對象。每位同事在本應與另一位同事溝通時都會與其調解員溝通。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public interface IMediator { public void talk(); public void fight(); public void registerA(ColleagueA a); public void registerB(ColleagueB b); } public class ConcreteMediator implements IMediator { ColleagueA talk; ColleagueB fight; @Override public void talk() { System.out.println(\u0026#34;Mediator is talking\u0026#34;); } @Override public void fight() { System.out.println(\u0026#34;Mediator is fighting\u0026#34;); } @Override public void registerA(ColleagueA a) { this.talk = a; } @Override public void registerB(ColleagueB b) { this.fight = b; } } // =========== public abstract class Colleague { IMediator mediator; public abstract void doSomething(); } public class ColleagueA extends Colleague { public ColleagueA(IMediator mediator) { this.mediator = mediator; this.mediator.registerA(this); } @Override public void doSomething() { this.mediator.talk(); } } public class ColleagueB extends Colleague { public ColleagueB(IMediator mediator) { this.mediator = mediator; this.mediator.registerB(this); } @Override public void doSomething() { this.mediator.fight(); } } 1 2 3 4 5 6 7 8 9 10 public static void main(String[] args) { IMediator mediator = new ConcreteMediator(); ColleagueA talkColleague= new ColleagueA(mediator); talkColleague.doSomething(); ColleagueB fightColleague = new ColleagueB(mediator); fightColleague.doSomething(); } 一組對像以定義明確但複雜的方式進行互動。由此產生的相互依賴是非結構化的並且難以理解。 重用一個對像很困難，因為它引用了許多其他對象並與之互動。 分佈在多個類之間的行為應該是可定制的，無需大量子類化。 ","permalink":"https://xinqilin.github.io/post/architecture/mediator/","tags":[],"title":"DesignPattern - Behavioral - Mediator"},{"content":"模板方法模式 (Template Method Pattern) 完整實作指南 模式概述 模板方法模式是一種行為設計模式，它在超類中定義了一個算法的骨架，允許子類在不改變算法結構的前提下重新定義算法的某些特定步驟。這個模式體現了「好萊塢原則」(Hollywood Principle) - \u0026ldquo;Don\u0026rsquo;t call us, we\u0026rsquo;ll call you\u0026rdquo;，即父類調用子類的方法，而不是子類調用父類方法。\n核心概念 1. 模板方法模式解決的問題 代碼重複：多個類別中存在相似的算法流程 算法變體：相同的算法骨架，但某些步驟需要不同實現 流程控制：需要確保算法執行的順序和完整性 擴展性：在不修改原有代碼的情況下增加新的算法變體 2. 模式結構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 // 抽象模板類別 public abstract class AbstractTemplate { // 模板方法 - 定義算法骨架 public final void templateMethod() { step1(); step2(); if (hook()) { step3(); } step4(); } // 具體方法 - 所有子類共同的實現 protected final void step1() { System.out.println(\u0026#34;執行通用步驟1\u0026#34;); } // 抽象方法 - 子類必須實現 protected abstract void step2(); protected abstract void step4(); // 可選步驟 - 預設實現 protected void step3() { System.out.println(\u0026#34;執行預設步驟3\u0026#34;); } // 鉤子方法 - 控制流程 protected boolean hook() { return true; } } // 具體實現類別 public class ConcreteTemplateA extends AbstractTemplate { @Override protected void step2() { System.out.println(\u0026#34;ConcreteA 實現步驟2\u0026#34;); } @Override protected void step4() { System.out.println(\u0026#34;ConcreteA 實現步驟4\u0026#34;); } @Override protected boolean hook() { return false; // 跳過步驟3 } } public class ConcreteTemplateB extends AbstractTemplate { @Override protected void step2() { System.out.println(\u0026#34;ConcreteB 實現步驟2\u0026#34;); } @Override protected void step4() { System.out.println(\u0026#34;ConcreteB 實現步驟4\u0026#34;); } @Override protected void step3() { System.out.println(\u0026#34;ConcreteB 自定義步驟3\u0026#34;); } } 基礎實作範例 1. 訂單處理流程模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 /** * 訂單處理抽象模板 */ public abstract class OrderProcessingTemplate { /** * 訂單處理主流程 - 模板方法 */ public final OrderResult processOrder(OrderRequest request) { try { // 1. 訂單驗證 validateOrder(request); logStep(\u0026#34;訂單驗證完成\u0026#34;); // 2. 庫存檢查 checkInventory(request); logStep(\u0026#34;庫存檢查完成\u0026#34;); // 3. 價格計算 BigDecimal totalPrice = calculatePrice(request); logStep(\u0026#34;價格計算完成: \u0026#34; + totalPrice); // 4. 支付處理 (可選) if (requiresPayment()) { processPayment(request, totalPrice); logStep(\u0026#34;支付處理完成\u0026#34;); } // 5. 訂單確認 String orderId = confirmOrder(request, totalPrice); logStep(\u0026#34;訂單確認完成: \u0026#34; + orderId); // 6. 後續處理 (鉤子方法) if (needsPostProcessing()) { performPostProcessing(request, orderId); logStep(\u0026#34;後續處理完成\u0026#34;); } return new OrderResult(orderId, totalPrice, \u0026#34;訂單處理成功\u0026#34;); } catch (Exception e) { handleError(request, e); return new OrderResult(null, null, \u0026#34;訂單處理失敗: \u0026#34; + e.getMessage()); } } // 通用方法 - final，不可覆寫 protected final void logStep(String message) { System.out.println(\u0026#34;[\u0026#34; + LocalDateTime.now() + \u0026#34;] \u0026#34; + message); } // 抽象方法 - 子類必須實現 protected abstract void validateOrder(OrderRequest request); protected abstract void checkInventory(OrderRequest request); protected abstract BigDecimal calculatePrice(OrderRequest request); protected abstract String confirmOrder(OrderRequest request, BigDecimal totalPrice); // 可選方法 - 有預設實現 protected void processPayment(OrderRequest request, BigDecimal amount) { System.out.println(\u0026#34;執行預設支付處理: \u0026#34; + amount); } protected void performPostProcessing(OrderRequest request, String orderId) { System.out.println(\u0026#34;執行預設後續處理\u0026#34;); } protected void handleError(OrderRequest request, Exception e) { System.err.println(\u0026#34;訂單處理錯誤: \u0026#34; + e.getMessage()); } // 鉤子方法 - 控制流程 protected boolean requiresPayment() { return true; } protected boolean needsPostProcessing() { return false; } } /** * 線上訂單處理 */ public class OnlineOrderProcessor extends OrderProcessingTemplate { @Override protected void validateOrder(OrderRequest request) { if (request.getCustomerId() == null) { throw new IllegalArgumentException(\u0026#34;線上訂單必須有客戶ID\u0026#34;); } if (request.getShippingAddress() == null) { throw new IllegalArgumentException(\u0026#34;線上訂單必須有配送地址\u0026#34;); } } @Override protected void checkInventory(OrderRequest request) { // 檢查線上庫存 for (OrderItem item : request.getItems()) { System.out.println(\u0026#34;檢查線上庫存: \u0026#34; + item.getProductName()); // 模擬庫存檢查邏輯 } } @Override protected BigDecimal calculatePrice(OrderRequest request) { BigDecimal total = request.getItems().stream() .map(item -\u0026gt; item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity()))) .reduce(BigDecimal.ZERO, BigDecimal::add); // 線上訂單加上運費 BigDecimal shippingFee = new BigDecimal(\u0026#34;50\u0026#34;); return total.add(shippingFee); } @Override protected void processPayment(OrderRequest request, BigDecimal amount) { System.out.println(\u0026#34;處理線上支付: \u0026#34; + amount); // 整合線上支付系統 } @Override protected String confirmOrder(OrderRequest request, BigDecimal totalPrice) { String orderId = \u0026#34;ON-\u0026#34; + System.currentTimeMillis(); System.out.println(\u0026#34;確認線上訂單: \u0026#34; + orderId); return orderId; } @Override protected void performPostProcessing(OrderRequest request, String orderId) { System.out.println(\u0026#34;發送訂單確認郵件\u0026#34;); System.out.println(\u0026#34;安排配送\u0026#34;); } @Override protected boolean needsPostProcessing() { return true; // 線上訂單需要後續處理 } } /** * 實體店訂單處理 */ public class StoreOrderProcessor extends OrderProcessingTemplate { @Override protected void validateOrder(OrderRequest request) { if (request.getStoreId() == null) { throw new IllegalArgumentException(\u0026#34;實體店訂單必須有店鋪ID\u0026#34;); } } @Override protected void checkInventory(OrderRequest request) { // 檢查店鋪庫存 for (OrderItem item : request.getItems()) { System.out.println(\u0026#34;檢查店鋪庫存: \u0026#34; + item.getProductName()); } } @Override protected BigDecimal calculatePrice(OrderRequest request) { BigDecimal total = request.getItems().stream() .map(item -\u0026gt; item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity()))) .reduce(BigDecimal.ZERO, BigDecimal::add); // 實體店可能有會員折扣 if (request.isMember()) { total = total.multiply(new BigDecimal(\u0026#34;0.9\u0026#34;)); // 9折 } return total; } @Override protected void processPayment(OrderRequest request, BigDecimal amount) { System.out.println(\u0026#34;處理現金/刷卡支付: \u0026#34; + amount); } @Override protected String confirmOrder(OrderRequest request, BigDecimal totalPrice) { String orderId = \u0026#34;ST-\u0026#34; + System.currentTimeMillis(); System.out.println(\u0026#34;確認實體店訂單: \u0026#34; + orderId); return orderId; } @Override protected boolean requiresPayment() { return true; // 實體店即時付款 } @Override protected boolean needsPostProcessing() { return false; // 實體店通常不需要後續處理 } } /** * 批發訂單處理 */ public class WholesaleOrderProcessor extends OrderProcessingTemplate { @Override protected void validateOrder(OrderRequest request) { if (request.getCompanyId() == null) { throw new IllegalArgumentException(\u0026#34;批發訂單必須有公司ID\u0026#34;); } // 批發訂單最小數量限制 int totalQuantity = request.getItems().stream() .mapToInt(OrderItem::getQuantity) .sum(); if (totalQuantity \u0026lt; 100) { throw new IllegalArgumentException(\u0026#34;批發訂單最小數量為100件\u0026#34;); } } @Override protected void checkInventory(OrderRequest request) { System.out.println(\u0026#34;檢查批發倉庫庫存\u0026#34;); // 批發可能需要預留庫存 } @Override protected BigDecimal calculatePrice(OrderRequest request) { BigDecimal total = request.getItems().stream() .map(item -\u0026gt; { BigDecimal unitPrice = item.getPrice(); int quantity = item.getQuantity(); // 批發價格階梯折扣 if (quantity \u0026gt;= 1000) { unitPrice = unitPrice.multiply(new BigDecimal(\u0026#34;0.7\u0026#34;)); // 7折 } else if (quantity \u0026gt;= 500) { unitPrice = unitPrice.multiply(new BigDecimal(\u0026#34;0.8\u0026#34;)); // 8折 } else if (quantity \u0026gt;= 100) { unitPrice = unitPrice.multiply(new BigDecimal(\u0026#34;0.9\u0026#34;)); // 9折 } return unitPrice.multiply(BigDecimal.valueOf(quantity)); }) .reduce(BigDecimal.ZERO, BigDecimal::add); return total; } @Override protected void processPayment(OrderRequest request, BigDecimal amount) { System.out.println(\u0026#34;處理批發付款（可能是賒帳）: \u0026#34; + amount); } @Override protected String confirmOrder(OrderRequest request, BigDecimal totalPrice) { String orderId = \u0026#34;WS-\u0026#34; + System.currentTimeMillis(); System.out.println(\u0026#34;確認批發訂單: \u0026#34; + orderId); return orderId; } @Override protected void performPostProcessing(OrderRequest request, String orderId) { System.out.println(\u0026#34;生成批發發票\u0026#34;); System.out.println(\u0026#34;安排物流配送\u0026#34;); System.out.println(\u0026#34;更新客戶信用記錄\u0026#34;); } @Override protected boolean requiresPayment() { return false; // 批發可能允許賒帳 } @Override protected boolean needsPostProcessing() { return true; // 批發需要更多後續處理 } } 2. 輔助類別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 /** * 訂單請求 */ public class OrderRequest { private String customerId; private String storeId; private String companyId; private List\u0026lt;OrderItem\u0026gt; items; private String shippingAddress; private boolean member; public OrderRequest(List\u0026lt;OrderItem\u0026gt; items) { this.items = items; } // Getters and Setters public String getCustomerId() { return customerId; } public void setCustomerId(String customerId) { this.customerId = customerId; } public String getStoreId() { return storeId; } public void setStoreId(String storeId) { this.storeId = storeId; } public String getCompanyId() { return companyId; } public void setCompanyId(String companyId) { this.companyId = companyId; } public List\u0026lt;OrderItem\u0026gt; getItems() { return items; } public String getShippingAddress() { return shippingAddress; } public void setShippingAddress(String shippingAddress) { this.shippingAddress = shippingAddress; } public boolean isMember() { return member; } public void setMember(boolean member) { this.member = member; } } /** * 訂單項目 */ public class OrderItem { private String productId; private String productName; private BigDecimal price; private int quantity; public OrderItem(String productId, String productName, BigDecimal price, int quantity) { this.productId = productId; this.productName = productName; this.price = price; this.quantity = quantity; } // Getters public String getProductId() { return productId; } public String getProductName() { return productName; } public BigDecimal getPrice() { return price; } public int getQuantity() { return quantity; } } /** * 訂單結果 */ public class OrderResult { private String orderId; private BigDecimal totalPrice; private String message; private LocalDateTime timestamp; public OrderResult(String orderId, BigDecimal totalPrice, String message) { this.orderId = orderId; this.totalPrice = totalPrice; this.message = message; this.timestamp = LocalDateTime.now(); } // Getters public String getOrderId() { return orderId; } public BigDecimal getTotalPrice() { return totalPrice; } public String getMessage() { return message; } public LocalDateTime getTimestamp() { return timestamp; } @Override public String toString() { return String.format(\u0026#34;OrderResult{orderId=\u0026#39;%s\u0026#39;, totalPrice=%s, message=\u0026#39;%s\u0026#39;}\u0026#34;, orderId, totalPrice, message); } } 3. 使用範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /** * 訂單處理系統示範 */ public class OrderProcessingExample { public static void main(String[] args) { // 創建測試數據 List\u0026lt;OrderItem\u0026gt; items = Arrays.asList( new OrderItem(\u0026#34;P001\u0026#34;, \u0026#34;筆記型電腦\u0026#34;, new BigDecimal(\u0026#34;30000\u0026#34;), 2), new OrderItem(\u0026#34;P002\u0026#34;, \u0026#34;滑鼠\u0026#34;, new BigDecimal(\u0026#34;500\u0026#34;), 5) ); // 測試線上訂單 System.out.println(\u0026#34;=== 線上訂單處理 ===\u0026#34;); testOnlineOrder(items); // 測試實體店訂單 System.out.println(\u0026#34;\\n=== 實體店訂單處理 ===\u0026#34;); testStoreOrder(items); // 測試批發訂單 System.out.println(\u0026#34;\\n=== 批發訂單處理 ===\u0026#34;); testWholesaleOrder(items); } private static void testOnlineOrder(List\u0026lt;OrderItem\u0026gt; items) { OrderProcessingTemplate processor = new OnlineOrderProcessor(); OrderRequest request = new OrderRequest(items); request.setCustomerId(\u0026#34;CUST-001\u0026#34;); request.setShippingAddress(\u0026#34;台北市信義區xxx路123號\u0026#34;); OrderResult result = processor.processOrder(request); System.out.println(\u0026#34;線上訂單結果: \u0026#34; + result); } private static void testStoreOrder(List\u0026lt;OrderItem\u0026gt; items) { OrderProcessingTemplate processor = new StoreOrderProcessor(); OrderRequest request = new OrderRequest(items); request.setStoreId(\u0026#34;STORE-001\u0026#34;); request.setMember(true); OrderResult result = processor.processOrder(request); System.out.println(\u0026#34;實體店訂單結果: \u0026#34; + result); } private static void testWholesaleOrder(List\u0026lt;OrderItem\u0026gt; items) { // 批發訂單需要更大數量 List\u0026lt;OrderItem\u0026gt; wholesaleItems = Arrays.asList( new OrderItem(\u0026#34;P001\u0026#34;, \u0026#34;筆記型電腦\u0026#34;, new BigDecimal(\u0026#34;30000\u0026#34;), 50), new OrderItem(\u0026#34;P002\u0026#34;, \u0026#34;滑鼠\u0026#34;, new BigDecimal(\u0026#34;500\u0026#34;), 200) ); OrderProcessingTemplate processor = new WholesaleOrderProcessor(); OrderRequest request = new OrderRequest(wholesaleItems); request.setCompanyId(\u0026#34;COMP-001\u0026#34;); OrderResult result = processor.processOrder(request); System.out.println(\u0026#34;批發訂單結果: \u0026#34; + result); } } Spring Boot 整合 1. Spring Boot 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 /** * 模板方法模式 Spring Boot 配置 */ @Configuration @EnableConfigurationProperties(OrderProcessingProperties.class) public class TemplateMethodConfig { @Bean @ConditionalOnProperty(name = \u0026#34;order.processing.type\u0026#34;, havingValue = \u0026#34;online\u0026#34;) public OrderProcessingTemplate onlineOrderProcessor() { return new OnlineOrderProcessor(); } @Bean @ConditionalOnProperty(name = \u0026#34;order.processing.type\u0026#34;, havingValue = \u0026#34;store\u0026#34;) public OrderProcessingTemplate storeOrderProcessor() { return new StoreOrderProcessor(); } @Bean @ConditionalOnProperty(name = \u0026#34;order.processing.type\u0026#34;, havingValue = \u0026#34;wholesale\u0026#34;) public OrderProcessingTemplate wholesaleOrderProcessor() { return new WholesaleOrderProcessor(); } @Bean public OrderProcessingService orderProcessingService( List\u0026lt;OrderProcessingTemplate\u0026gt; processors) { return new OrderProcessingService(processors); } } /** * 配置屬性 */ @ConfigurationProperties(prefix = \u0026#34;order.processing\u0026#34;) @Data public class OrderProcessingProperties { private String type = \u0026#34;online\u0026#34;; private boolean enablePostProcessing = true; private Duration timeout = Duration.ofMinutes(5); private int maxRetries = 3; } /** * Spring Boot 訂單處理服務 */ @Service @Transactional public class OrderProcessingService { private final Map\u0026lt;String, OrderProcessingTemplate\u0026gt; processorMap; private final ApplicationEventPublisher eventPublisher; public OrderProcessingService(List\u0026lt;OrderProcessingTemplate\u0026gt; processors, ApplicationEventPublisher eventPublisher) { this.eventPublisher = eventPublisher; this.processorMap = processors.stream() .collect(Collectors.toMap( processor -\u0026gt; determineProcessorType(processor), processor -\u0026gt; processor )); } public OrderResult processOrder(OrderRequest request, String processorType) { OrderProcessingTemplate processor = processorMap.get(processorType); if (processor == null) { throw new IllegalArgumentException(\u0026#34;不支援的處理器類型: \u0026#34; + processorType); } // 發布處理開始事件 eventPublisher.publishEvent(new OrderProcessingStartedEvent(request)); try { OrderResult result = processor.processOrder(request); // 發布處理完成事件 eventPublisher.publishEvent(new OrderProcessingCompletedEvent(request, result)); return result; } catch (Exception e) { // 發布處理失敗事件 eventPublisher.publishEvent(new OrderProcessingFailedEvent(request, e)); throw e; } } private String determineProcessorType(OrderProcessingTemplate processor) { if (processor instanceof OnlineOrderProcessor) return \u0026#34;online\u0026#34;; if (processor instanceof StoreOrderProcessor) return \u0026#34;store\u0026#34;; if (processor instanceof WholesaleOrderProcessor) return \u0026#34;wholesale\u0026#34;; return \u0026#34;unknown\u0026#34;; } } 2. REST API 控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /** * 訂單處理 REST API */ @RestController @RequestMapping(\u0026#34;/api/orders\u0026#34;) @Validated public class OrderController { private final OrderProcessingService orderService; public OrderController(OrderProcessingService orderService) { this.orderService = orderService; } @PostMapping(\u0026#34;/process/{type}\u0026#34;) public ResponseEntity\u0026lt;OrderResponse\u0026gt; processOrder( @PathVariable @Pattern(regexp = \u0026#34;online|store|wholesale\u0026#34;) String type, @Valid @RequestBody OrderRequest request) { try { OrderResult result = orderService.processOrder(request, type); return ResponseEntity.ok(OrderResponse.success(result)); } catch (IllegalArgumentException e) { return ResponseEntity.badRequest() .body(OrderResponse.error(e.getMessage())); } catch (Exception e) { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(OrderResponse.error(\u0026#34;訂單處理失敗: \u0026#34; + e.getMessage())); } } @GetMapping(\u0026#34;/processors\u0026#34;) public ResponseEntity\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; getAvailableProcessors() { List\u0026lt;String\u0026gt; processors = Arrays.asList(\u0026#34;online\u0026#34;, \u0026#34;store\u0026#34;, \u0026#34;wholesale\u0026#34;); return ResponseEntity.ok(processors); } } /** * API 回應封裝 */ public class OrderResponse { private boolean success; private String message; private OrderResult data; private LocalDateTime timestamp; private OrderResponse(boolean success, String message, OrderResult data) { this.success = success; this.message = message; this.data = data; this.timestamp = LocalDateTime.now(); } public static OrderResponse success(OrderResult result) { return new OrderResponse(true, \u0026#34;處理成功\u0026#34;, result); } public static OrderResponse error(String message) { return new OrderResponse(false, message, null); } // Getters public boolean isSuccess() { return success; } public String getMessage() { return message; } public OrderResult getData() { return data; } public LocalDateTime getTimestamp() { return timestamp; } } 進階主題 1. 效能優化策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /** * 高效能模板方法實作 */ public abstract class OptimizedOrderProcessingTemplate extends OrderProcessingTemplate { private final Cache\u0026lt;String, BigDecimal\u0026gt; priceCache; private final ExecutorService executorService; public OptimizedOrderProcessingTemplate() { this.priceCache = Caffeine.newBuilder() .maximumSize(1000) .expireAfterWrite(10, TimeUnit.MINUTES) .build(); this.executorService = Executors.newFixedThreadPool(5); } @Override protected BigDecimal calculatePrice(OrderRequest request) { String cacheKey = generatePriceCacheKey(request); return priceCache.get(cacheKey, key -\u0026gt; { return performActualPriceCalculation(request); }); } // 異步後續處理 @Override protected void performPostProcessing(OrderRequest request, String orderId) { CompletableFuture.runAsync(() -\u0026gt; { doAsyncPostProcessing(request, orderId); }, executorService); } protected abstract BigDecimal performActualPriceCalculation(OrderRequest request); protected abstract void doAsyncPostProcessing(OrderRequest request, String orderId); private String generatePriceCacheKey(OrderRequest request) { return request.getItems().stream() .map(item -\u0026gt; item.getProductId() + \u0026#34;:\u0026#34; + item.getQuantity()) .collect(Collectors.joining(\u0026#34;,\u0026#34;)); } } 2. 測試策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 /** * 模板方法模式單元測試 */ @ExtendWith(MockitoExtension.class) class OrderProcessingTemplateTest { @Test void testOnlineOrderProcessing() { // Given OnlineOrderProcessor processor = new OnlineOrderProcessor(); OrderRequest request = createTestOrderRequest(); request.setCustomerId(\u0026#34;CUST-001\u0026#34;); request.setShippingAddress(\u0026#34;Test Address\u0026#34;); // When OrderResult result = processor.processOrder(request); // Then assertThat(result.getOrderId()).startsWith(\u0026#34;ON-\u0026#34;); assertThat(result.getTotalPrice()).isGreaterThan(BigDecimal.ZERO); assertThat(result.getMessage()).contains(\u0026#34;成功\u0026#34;); } @Test void testTemplateMethodFlow() { // Given OrderProcessingTemplate processor = new TestOrderProcessor(); OrderRequest request = createTestOrderRequest(); // When OrderResult result = processor.processOrder(request); // Then // 驗證模板方法的執行順序 verify(processor).validateOrder(request); verify(processor).checkInventory(request); verify(processor).calculatePrice(request); verify(processor).confirmOrder(eq(request), any(BigDecimal.class)); } private OrderRequest createTestOrderRequest() { List\u0026lt;OrderItem\u0026gt; items = Arrays.asList( new OrderItem(\u0026#34;P001\u0026#34;, \u0026#34;Test Product\u0026#34;, new BigDecimal(\u0026#34;100\u0026#34;), 1) ); return new OrderRequest(items); } // 測試專用的處理器實現 private static class TestOrderProcessor extends OrderProcessingTemplate { @Override protected void validateOrder(OrderRequest request) {} @Override protected void checkInventory(OrderRequest request) {} @Override protected BigDecimal calculatePrice(OrderRequest request) { return new BigDecimal(\u0026#34;100\u0026#34;); } @Override protected String confirmOrder(OrderRequest request, BigDecimal totalPrice) { return \u0026#34;TEST-ORDER-123\u0026#34;; } } } 最佳實踐與建議 1. 設計原則 開閉原則：新增處理器類型不需修改現有代碼 里氏替換原則：確保子類能完全替換父類 單一職責原則：每個處理器負責特定類型的訂單處理 2. 常見陷阱 避免在模板方法中拋出異常 1 2 3 4 5 6 7 8 9 10 // ✅ 好的設計 - 統一異常處理 public final OrderResult processOrder(OrderRequest request) { try { // 模板方法邏輯 return createSuccessResult(); } catch (Exception e) { handleError(request, e); return createErrorResult(e); } } 適當使用 final 修飾符 1 2 3 4 // ✅ 模板方法應該是 final public final OrderResult processOrder(OrderRequest request) { // 算法骨架不可變 } 3. 使用建議 適用場景：業務流程固定，但實現細節不同 設計要點：明確區分變化和不變的部分 與其他模式結合：可與策略模式、工廠模式組合使用 總結 模板方法模式通過將算法骨架固定在父類中，讓子類實現特定的變化部分，實現了代碼重用和流程控制的統一。在企業級應用中，這個模式特別適合工作流程、數據處理管道、業務流程控制等場景。\n主要優點 代碼重用：提取公共邏輯到父類 流程控制：確保算法執行順序 擴展性強：易於增加新的算法變體 主要缺點 繼承限制：需要使用繼承關係 調試困難：父類調用子類方法的流程不直觀 正確使用模板方法模式可以大幅提升代碼的可維護性和可擴展性，是企業級應用開發中的重要設計模式。\n","permalink":"https://xinqilin.github.io/post/architecture/templatemethod/","tags":["Design Pattern","Template Method Pattern","Behavioral Pattern","Algorithm Framework","Inheritance","Hook Methods","Process Control","Java","Spring Boot","Enterprise Architecture","Workflow","Business Process","Code Reuse","Hollywood Principle","Abstract Methods","Final Methods","Best Practices"],"title":"模板方法模式 (Template Method Pattern) 完整實作指南：算法骨架設計與企業級流程控制最佳實踐"},{"content":"Decorator Pattern 概述 Decorator Pattern 是一種結構型設計模式，它允許在運行時動態地為對象添加新功能，而無需修改其原始類。通過創建包裝器對象，Decorator 提供了一種靈活的替代繼承的方法來擴展對象的行為。\n核心概念 關鍵特性 動態擴展: 在運行時添加或移除功能 透明性: 裝飾器與原始對象具有相同的接口 組合優於繼承: 避免複雜的繼承層次結構 責任鏈: 可以堆疊多個裝飾器 結構組件 Component: 定義原始對象和裝飾器的通用接口 ConcreteComponent: 具體的原始對象 BaseDecorator: 抽象裝飾器基類 ConcreteDecorator: 具體的裝飾器實現 基本實現 1. 經典 Decorator 實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 // 組件接口 public interface Coffee { String getDescription(); double getCost(); } // 具體組件 public class SimpleCoffee implements Coffee { @Override public String getDescription() { return \u0026#34;Simple Coffee\u0026#34;; } @Override public double getCost() { return 2.0; } } // 抽象裝飾器 public abstract class CoffeeDecorator implements Coffee { protected Coffee coffee; public CoffeeDecorator(Coffee coffee) { this.coffee = coffee; } @Override public String getDescription() { return coffee.getDescription(); } @Override public double getCost() { return coffee.getCost(); } } // 具體裝飾器 public class MilkDecorator extends CoffeeDecorator { public MilkDecorator(Coffee coffee) { super(coffee); } @Override public String getDescription() { return coffee.getDescription() + \u0026#34; + Milk\u0026#34;; } @Override public double getCost() { return coffee.getCost() + 0.5; } } public class SugarDecorator extends CoffeeDecorator { public SugarDecorator(Coffee coffee) { super(coffee); } @Override public String getDescription() { return coffee.getDescription() + \u0026#34; + Sugar\u0026#34;; } @Override public double getCost() { return coffee.getCost() + 0.3; } } public class WhippedCreamDecorator extends CoffeeDecorator { public WhippedCreamDecorator(Coffee coffee) { super(coffee); } @Override public String getDescription() { return coffee.getDescription() + \u0026#34; + Whipped Cream\u0026#34;; } @Override public double getCost() { return coffee.getCost() + 0.8; } } 2. 測試示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class DecoratorPatternDemo { public static void main(String[] args) { // 基本咖啡 Coffee coffee = new SimpleCoffee(); System.out.println(coffee.getDescription() + \u0026#34; - $\u0026#34; + coffee.getCost()); // 添加牛奶 coffee = new MilkDecorator(coffee); System.out.println(coffee.getDescription() + \u0026#34; - $\u0026#34; + coffee.getCost()); // 添加糖 coffee = new SugarDecorator(coffee); System.out.println(coffee.getDescription() + \u0026#34; - $\u0026#34; + coffee.getCost()); // 添加鮮奶油 coffee = new WhippedCreamDecorator(coffee); System.out.println(coffee.getDescription() + \u0026#34; - $\u0026#34; + coffee.getCost()); // 輸出: // Simple Coffee - $2.0 // Simple Coffee + Milk - $2.5 // Simple Coffee + Milk + Sugar - $2.8 // Simple Coffee + Milk + Sugar + Whipped Cream - $3.6 } } 現代 Java 實現 1. 使用 Java 8+ 功能式接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // 使用函數式接口 @FunctionalInterface public interface DataProcessor { String process(String data); } // 基本處理器 public class BaseProcessor implements DataProcessor { @Override public String process(String data) { return data; } } // 函數式裝飾器 public class FunctionalDecorator { public static DataProcessor withLogging(DataProcessor processor) { return data -\u0026gt; { System.out.println(\u0026#34;Processing: \u0026#34; + data); String result = processor.process(data); System.out.println(\u0026#34;Result: \u0026#34; + result); return result; }; } public static DataProcessor withUpperCase(DataProcessor processor) { return data -\u0026gt; processor.process(data).toUpperCase(); } public static DataProcessor withTrimming(DataProcessor processor) { return data -\u0026gt; processor.process(data.trim()); } public static DataProcessor withTimestamp(DataProcessor processor) { return data -\u0026gt; { String timestamp = LocalDateTime.now().toString(); return \u0026#34;[\u0026#34; + timestamp + \u0026#34;] \u0026#34; + processor.process(data); }; } } // 使用示例 public class FunctionalDecoratorDemo { public static void main(String[] args) { DataProcessor processor = new BaseProcessor(); // 組合多個裝飾器 DataProcessor decoratedProcessor = FunctionalDecorator.withLogging( FunctionalDecorator.withTimestamp( FunctionalDecorator.withUpperCase( FunctionalDecorator.withTrimming(processor) ) ) ); String result = decoratedProcessor.process(\u0026#34; hello world \u0026#34;); System.out.println(\u0026#34;Final result: \u0026#34; + result); } } 2. 使用 Builder 模式的裝飾器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class DecoratorBuilder\u0026lt;T\u0026gt; { private T component; private List\u0026lt;Function\u0026lt;T, T\u0026gt;\u0026gt; decorators = new ArrayList\u0026lt;\u0026gt;(); public DecoratorBuilder(T component) { this.component = component; } public DecoratorBuilder\u0026lt;T\u0026gt; addDecorator(Function\u0026lt;T, T\u0026gt; decorator) { decorators.add(decorator); return this; } public T build() { return decorators.stream() .reduce(Function.identity(), Function::compose) .apply(component); } } // 使用示例 public class BuilderDecoratorDemo { public static void main(String[] args) { DataProcessor processor = new DecoratorBuilder\u0026lt;\u0026gt;(new BaseProcessor()) .addDecorator(FunctionalDecorator::withTrimming) .addDecorator(FunctionalDecorator::withUpperCase) .addDecorator(FunctionalDecorator::withTimestamp) .addDecorator(FunctionalDecorator::withLogging) .build(); String result = processor.process(\u0026#34; hello world \u0026#34;); } } 企業級應用模式 1. 日誌裝飾器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 // 日誌裝飾器 public class LoggingDecorator\u0026lt;T\u0026gt; { private final T target; private final Logger logger; public LoggingDecorator(T target, Logger logger) { this.target = target; this.logger = logger; } public T getTarget() { return target; } // 通過反射創建代理 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static \u0026lt;T\u0026gt; T createProxy(T target, Logger logger) { return (T) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new LoggingInvocationHandler\u0026lt;\u0026gt;(target, logger) ); } private static class LoggingInvocationHandler\u0026lt;T\u0026gt; implements InvocationHandler { private final T target; private final Logger logger; public LoggingInvocationHandler(T target, Logger logger) { this.target = target; this.logger = logger; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String methodName = method.getName(); logger.info(\u0026#34;Calling method: {} with args: {}\u0026#34;, methodName, Arrays.toString(args)); long startTime = System.currentTimeMillis(); try { Object result = method.invoke(target, args); long endTime = System.currentTimeMillis(); logger.info(\u0026#34;Method {} completed in {} ms with result: {}\u0026#34;, methodName, endTime - startTime, result); return result; } catch (Exception e) { logger.error(\u0026#34;Method {} threw exception: {}\u0026#34;, methodName, e.getMessage()); throw e; } } } } // 業務服務接口 public interface UserService { User findById(Long id); User save(User user); void deleteById(Long id); } // 具體服務實現 @Service public class UserServiceImpl implements UserService { @Autowired private UserRepository userRepository; @Override public User findById(Long id) { return userRepository.findById(id).orElse(null); } @Override public User save(User user) { return userRepository.save(user); } @Override public void deleteById(Long id) { userRepository.deleteById(id); } } // 使用示例 @Configuration public class ServiceConfiguration { @Bean public UserService userService(UserServiceImpl userServiceImpl) { Logger logger = LoggerFactory.getLogger(UserService.class); return LoggingDecorator.createProxy(userServiceImpl, logger); } } 2. 緩存裝飾器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 // 緩存裝飾器 public class CacheDecorator\u0026lt;T\u0026gt; { private final T target; private final Cache cache; private final Set\u0026lt;String\u0026gt; cacheableMethods; public CacheDecorator(T target, Cache cache, Set\u0026lt;String\u0026gt; cacheableMethods) { this.target = target; this.cache = cache; this.cacheableMethods = cacheableMethods; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static \u0026lt;T\u0026gt; T createProxy(T target, Cache cache, Set\u0026lt;String\u0026gt; cacheableMethods) { return (T) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new CacheInvocationHandler\u0026lt;\u0026gt;(target, cache, cacheableMethods) ); } private static class CacheInvocationHandler\u0026lt;T\u0026gt; implements InvocationHandler { private final T target; private final Cache cache; private final Set\u0026lt;String\u0026gt; cacheableMethods; public CacheInvocationHandler(T target, Cache cache, Set\u0026lt;String\u0026gt; cacheableMethods) { this.target = target; this.cache = cache; this.cacheableMethods = cacheableMethods; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String methodName = method.getName(); if (cacheableMethods.contains(methodName)) { String cacheKey = generateCacheKey(methodName, args); // 嘗試從緩存獲取 Object cachedResult = cache.get(cacheKey); if (cachedResult != null) { return cachedResult; } // 調用原始方法 Object result = method.invoke(target, args); // 放入緩存 cache.put(cacheKey, result); return result; } return method.invoke(target, args); } private String generateCacheKey(String methodName, Object[] args) { return methodName + \u0026#34;:\u0026#34; + Arrays.toString(args); } } } // 簡單緩存實現 public class SimpleCache implements Cache { private final Map\u0026lt;String, Object\u0026gt; cache = new ConcurrentHashMap\u0026lt;\u0026gt;(); @Override public Object get(String key) { return cache.get(key); } @Override public void put(String key, Object value) { cache.put(key, value); } @Override public void evict(String key) { cache.remove(key); } @Override public void clear() { cache.clear(); } } // 使用示例 @Configuration public class CacheConfiguration { @Bean public Cache userCache() { return new SimpleCache(); } @Bean public UserService cachedUserService(UserServiceImpl userServiceImpl, Cache userCache) { Set\u0026lt;String\u0026gt; cacheableMethods = Set.of(\u0026#34;findById\u0026#34;, \u0026#34;findByUsername\u0026#34;); return CacheDecorator.createProxy(userServiceImpl, userCache, cacheableMethods); } } 3. 安全裝飾器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // 安全裝飾器 public class SecurityDecorator\u0026lt;T\u0026gt; { private final T target; private final SecurityContext securityContext; private final Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; methodPermissions; public SecurityDecorator(T target, SecurityContext securityContext, Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; methodPermissions) { this.target = target; this.securityContext = securityContext; this.methodPermissions = methodPermissions; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static \u0026lt;T\u0026gt; T createProxy(T target, SecurityContext securityContext, Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; methodPermissions) { return (T) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new SecurityInvocationHandler\u0026lt;\u0026gt;(target, securityContext, methodPermissions) ); } private static class SecurityInvocationHandler\u0026lt;T\u0026gt; implements InvocationHandler { private final T target; private final SecurityContext securityContext; private final Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; methodPermissions; public SecurityInvocationHandler(T target, SecurityContext securityContext, Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; methodPermissions) { this.target = target; this.securityContext = securityContext; this.methodPermissions = methodPermissions; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String methodName = method.getName(); // 檢查方法權限 if (methodPermissions.containsKey(methodName)) { Set\u0026lt;String\u0026gt; requiredPermissions = methodPermissions.get(methodName); if (!securityContext.hasPermissions(requiredPermissions)) { throw new SecurityException(\u0026#34;Access denied: insufficient permissions for method \u0026#34; + methodName); } } return method.invoke(target, args); } } } // 安全上下文 public class SecurityContext { private final Set\u0026lt;String\u0026gt; userPermissions; public SecurityContext(Set\u0026lt;String\u0026gt; userPermissions) { this.userPermissions = userPermissions; } public boolean hasPermission(String permission) { return userPermissions.contains(permission); } public boolean hasPermissions(Set\u0026lt;String\u0026gt; permissions) { return userPermissions.containsAll(permissions); } } // 使用示例 @Configuration public class SecurityConfiguration { @Bean public UserService securedUserService(UserServiceImpl userServiceImpl, SecurityContext securityContext) { Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; methodPermissions = Map.of( \u0026#34;save\u0026#34;, Set.of(\u0026#34;USER_WRITE\u0026#34;), \u0026#34;deleteById\u0026#34;, Set.of(\u0026#34;USER_DELETE\u0026#34;), \u0026#34;findById\u0026#34;, Set.of(\u0026#34;USER_READ\u0026#34;) ); return SecurityDecorator.createProxy(userServiceImpl, securityContext, methodPermissions); } } Spring AOP 集成 1. 基於註解的 AOP 裝飾器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 // 自定義註解 @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Loggable { String value() default \u0026#34;\u0026#34;; boolean logParameters() default true; boolean logResult() default true; boolean logExecutionTime() default true; } @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Cacheable { String value() default \u0026#34;\u0026#34;; int ttl() default 300; // seconds String keyGenerator() default \u0026#34;\u0026#34;; } @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Secured { String[] permissions() default {}; String role() default \u0026#34;\u0026#34;; } // AOP 切面 @Aspect @Component public class LoggingAspect { private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class); @Around(\u0026#34;@annotation(loggable)\u0026#34;) public Object logExecutionTime(ProceedingJoinPoint joinPoint, Loggable loggable) throws Throwable { String methodName = joinPoint.getSignature().getName(); if (loggable.logParameters()) { logger.info(\u0026#34;Entering method: {} with parameters: {}\u0026#34;, methodName, Arrays.toString(joinPoint.getArgs())); } long startTime = System.currentTimeMillis(); try { Object result = joinPoint.proceed(); long endTime = System.currentTimeMillis(); if (loggable.logExecutionTime()) { logger.info(\u0026#34;Method {} executed in {} ms\u0026#34;, methodName, endTime - startTime); } if (loggable.logResult()) { logger.info(\u0026#34;Method {} returned: {}\u0026#34;, methodName, result); } return result; } catch (Exception e) { logger.error(\u0026#34;Method {} threw exception: {}\u0026#34;, methodName, e.getMessage()); throw e; } } } @Aspect @Component public class CacheAspect { @Autowired private CacheManager cacheManager; @Around(\u0026#34;@annotation(cacheable)\u0026#34;) public Object cacheResult(ProceedingJoinPoint joinPoint, Cacheable cacheable) throws Throwable { String cacheName = cacheable.value().isEmpty() ? joinPoint.getSignature().getDeclaringType().getSimpleName() : cacheable.value(); Cache cache = cacheManager.getCache(cacheName); if (cache == null) { return joinPoint.proceed(); } String key = generateKey(joinPoint); Cache.ValueWrapper cachedValue = cache.get(key); if (cachedValue != null) { return cachedValue.get(); } Object result = joinPoint.proceed(); cache.put(key, result); return result; } private String generateKey(ProceedingJoinPoint joinPoint) { StringBuilder keyBuilder = new StringBuilder(); keyBuilder.append(joinPoint.getSignature().getName()); for (Object arg : joinPoint.getArgs()) { keyBuilder.append(\u0026#34;:\u0026#34;).append(arg); } return keyBuilder.toString(); } } @Aspect @Component public class SecurityAspect { @Autowired private SecurityContext securityContext; @Before(\u0026#34;@annotation(secured)\u0026#34;) public void checkSecurity(JoinPoint joinPoint, Secured secured) { String[] requiredPermissions = secured.permissions(); String requiredRole = secured.role(); if (requiredPermissions.length \u0026gt; 0) { if (!securityContext.hasPermissions(Set.of(requiredPermissions))) { throw new SecurityException(\u0026#34;Access denied: insufficient permissions\u0026#34;); } } if (!requiredRole.isEmpty()) { if (!securityContext.hasRole(requiredRole)) { throw new SecurityException(\u0026#34;Access denied: insufficient role\u0026#34;); } } } } 2. 使用 AOP 註解的服務 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Service public class EnhancedUserService implements UserService { @Autowired private UserRepository userRepository; @Override @Loggable(logParameters = true, logResult = true, logExecutionTime = true) @Cacheable(value = \u0026#34;users\u0026#34;, ttl = 600) @Secured(permissions = {\u0026#34;USER_READ\u0026#34;}) public User findById(Long id) { return userRepository.findById(id).orElse(null); } @Override @Loggable(logParameters = true, logResult = false) @Secured(permissions = {\u0026#34;USER_WRITE\u0026#34;}) public User save(User user) { return userRepository.save(user); } @Override @Loggable(logParameters = true) @Secured(permissions = {\u0026#34;USER_DELETE\u0026#34;}) public void deleteById(Long id) { userRepository.deleteById(id); } @Loggable @Cacheable(value = \u0026#34;users\u0026#34;, ttl = 300) @Secured(permissions = {\u0026#34;USER_READ\u0026#34;}) public List\u0026lt;User\u0026gt; findByRole(String role) { return userRepository.findByRole(role); } } 3. Spring Boot 自動配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @Configuration @EnableAspectJAutoProxy public class AopConfiguration { @Bean public CacheManager cacheManager() { return new ConcurrentMapCacheManager(\u0026#34;users\u0026#34;, \u0026#34;roles\u0026#34;, \u0026#34;permissions\u0026#34;); } @Bean public SecurityContext securityContext() { // 在實際應用中，這會從 Spring Security 獲取 Set\u0026lt;String\u0026gt; permissions = Set.of(\u0026#34;USER_READ\u0026#34;, \u0026#34;USER_WRITE\u0026#34;, \u0026#34;USER_DELETE\u0026#34;); return new SecurityContext(permissions); } } // 自動配置類 @Configuration @ConditionalOnClass(ProceedingJoinPoint.class) @EnableConfigurationProperties(DecoratorProperties.class) public class DecoratorAutoConfiguration { @Bean @ConditionalOnMissingBean public LoggingAspect loggingAspect() { return new LoggingAspect(); } @Bean @ConditionalOnMissingBean public CacheAspect cacheAspect() { return new CacheAspect(); } @Bean @ConditionalOnMissingBean public SecurityAspect securityAspect() { return new SecurityAspect(); } } // 配置屬性 @ConfigurationProperties(prefix = \u0026#34;app.decorator\u0026#34;) public class DecoratorProperties { private boolean loggingEnabled = true; private boolean cachingEnabled = true; private boolean securityEnabled = true; private LoggingProperties logging = new LoggingProperties(); private CachingProperties caching = new CachingProperties(); // Getters and setters public static class LoggingProperties { private boolean logParameters = true; private boolean logResult = true; private boolean logExecutionTime = true; // Getters and setters } public static class CachingProperties { private int defaultTtl = 300; private String[] cacheNames = {\u0026#34;default\u0026#34;}; // Getters and setters } } 實際應用場景 1. HTTP 客戶端裝飾器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 // HTTP 客戶端接口 public interface HttpClient { HttpResponse get(String url); HttpResponse post(String url, String body); HttpResponse put(String url, String body); HttpResponse delete(String url); } // 基本實現 public class BasicHttpClient implements HttpClient { @Override public HttpResponse get(String url) { // 基本 HTTP GET 實現 return new HttpResponse(200, \u0026#34;GET response from \u0026#34; + url); } @Override public HttpResponse post(String url, String body) { // 基本 HTTP POST 實現 return new HttpResponse(201, \u0026#34;POST response from \u0026#34; + url); } @Override public HttpResponse put(String url, String body) { // 基本 HTTP PUT 實現 return new HttpResponse(200, \u0026#34;PUT response from \u0026#34; + url); } @Override public HttpResponse delete(String url) { // 基本 HTTP DELETE 實現 return new HttpResponse(204, \u0026#34;DELETE response from \u0026#34; + url); } } // 重試裝飾器 public class RetryHttpClient implements HttpClient { private final HttpClient httpClient; private final int maxRetries; private final long retryDelay; public RetryHttpClient(HttpClient httpClient, int maxRetries, long retryDelay) { this.httpClient = httpClient; this.maxRetries = maxRetries; this.retryDelay = retryDelay; } @Override public HttpResponse get(String url) { return executeWithRetry(() -\u0026gt; httpClient.get(url)); } @Override public HttpResponse post(String url, String body) { return executeWithRetry(() -\u0026gt; httpClient.post(url, body)); } @Override public HttpResponse put(String url, String body) { return executeWithRetry(() -\u0026gt; httpClient.put(url, body)); } @Override public HttpResponse delete(String url) { return executeWithRetry(() -\u0026gt; httpClient.delete(url)); } private HttpResponse executeWithRetry(Supplier\u0026lt;HttpResponse\u0026gt; operation) { for (int attempt = 0; attempt \u0026lt; maxRetries; attempt++) { try { HttpResponse response = operation.get(); if (response.isSuccess()) { return response; } if (attempt \u0026lt; maxRetries - 1) { Thread.sleep(retryDelay); } } catch (Exception e) { if (attempt == maxRetries - 1) { throw new RuntimeException(\u0026#34;Max retries exceeded\u0026#34;, e); } try { Thread.sleep(retryDelay); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); throw new RuntimeException(\u0026#34;Interrupted during retry\u0026#34;, ie); } } } throw new RuntimeException(\u0026#34;Max retries exceeded\u0026#34;); } } // 限流裝飾器 public class RateLimitedHttpClient implements HttpClient { private final HttpClient httpClient; private final RateLimiter rateLimiter; public RateLimitedHttpClient(HttpClient httpClient, int requestsPerSecond) { this.httpClient = httpClient; this.rateLimiter = RateLimiter.create(requestsPerSecond); } @Override public HttpResponse get(String url) { rateLimiter.acquire(); return httpClient.get(url); } @Override public HttpResponse post(String url, String body) { rateLimiter.acquire(); return httpClient.post(url, body); } @Override public HttpResponse put(String url, String body) { rateLimiter.acquire(); return httpClient.put(url, body); } @Override public HttpResponse delete(String url) { rateLimiter.acquire(); return httpClient.delete(url); } } // 使用示例 @Service public class HttpClientService { @Bean public HttpClient httpClient() { HttpClient basicClient = new BasicHttpClient(); // 添加重試功能 HttpClient retryClient = new RetryHttpClient(basicClient, 3, 1000); // 添加限流功能 HttpClient rateLimitedClient = new RateLimitedHttpClient(retryClient, 10); // 添加日誌功能 return LoggingDecorator.createProxy(rateLimitedClient, LoggerFactory.getLogger(HttpClient.class)); } } 2. 數據庫連接裝飾器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 // 數據庫連接接口 public interface DatabaseConnection { ResultSet executeQuery(String sql); int executeUpdate(String sql); void close(); } // 基本實現 public class BasicDatabaseConnection implements DatabaseConnection { private final Connection connection; public BasicDatabaseConnection(Connection connection) { this.connection = connection; } @Override public ResultSet executeQuery(String sql) { try { return connection.createStatement().executeQuery(sql); } catch (SQLException e) { throw new RuntimeException(\u0026#34;Query execution failed\u0026#34;, e); } } @Override public int executeUpdate(String sql) { try { return connection.createStatement().executeUpdate(sql); } catch (SQLException e) { throw new RuntimeException(\u0026#34;Update execution failed\u0026#34;, e); } } @Override public void close() { try { connection.close(); } catch (SQLException e) { throw new RuntimeException(\u0026#34;Connection close failed\u0026#34;, e); } } } // 事務裝飾器 public class TransactionalDatabaseConnection implements DatabaseConnection { private final DatabaseConnection connection; private boolean inTransaction = false; public TransactionalDatabaseConnection(DatabaseConnection connection) { this.connection = connection; } public void beginTransaction() { inTransaction = true; } public void commit() { inTransaction = false; } public void rollback() { inTransaction = false; } @Override public ResultSet executeQuery(String sql) { return connection.executeQuery(sql); } @Override public int executeUpdate(String sql) { return connection.executeUpdate(sql); } @Override public void close() { if (inTransaction) { rollback(); } connection.close(); } } // 連接池裝飾器 public class PooledDatabaseConnection implements DatabaseConnection { private final DatabaseConnection connection; private final ConnectionPool pool; public PooledDatabaseConnection(DatabaseConnection connection, ConnectionPool pool) { this.connection = connection; this.pool = pool; } @Override public ResultSet executeQuery(String sql) { return connection.executeQuery(sql); } @Override public int executeUpdate(String sql) { return connection.executeUpdate(sql); } @Override public void close() { pool.returnConnection(connection); } } 性能優化和最佳實踐 1. 性能監控裝飾器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 // 性能監控裝飾器 public class PerformanceMonitoringDecorator\u0026lt;T\u0026gt; { private final T target; private final MeterRegistry meterRegistry; private final String serviceName; public PerformanceMonitoringDecorator(T target, MeterRegistry meterRegistry, String serviceName) { this.target = target; this.meterRegistry = meterRegistry; this.serviceName = serviceName; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static \u0026lt;T\u0026gt; T createProxy(T target, MeterRegistry meterRegistry, String serviceName) { return (T) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new PerformanceInvocationHandler\u0026lt;\u0026gt;(target, meterRegistry, serviceName) ); } private static class PerformanceInvocationHandler\u0026lt;T\u0026gt; implements InvocationHandler { private final T target; private final MeterRegistry meterRegistry; private final String serviceName; public PerformanceInvocationHandler(T target, MeterRegistry meterRegistry, String serviceName) { this.target = target; this.meterRegistry = meterRegistry; this.serviceName = serviceName; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String methodName = method.getName(); Timer.Sample sample = Timer.start(meterRegistry); try { Object result = method.invoke(target, args); // 記錄成功指標 Counter.builder(\u0026#34;method.calls\u0026#34;) .tag(\u0026#34;service\u0026#34;, serviceName) .tag(\u0026#34;method\u0026#34;, methodName) .tag(\u0026#34;status\u0026#34;, \u0026#34;success\u0026#34;) .register(meterRegistry) .increment(); return result; } catch (Exception e) { // 記錄失敗指標 Counter.builder(\u0026#34;method.calls\u0026#34;) .tag(\u0026#34;service\u0026#34;, serviceName) .tag(\u0026#34;method\u0026#34;, methodName) .tag(\u0026#34;status\u0026#34;, \u0026#34;error\u0026#34;) .register(meterRegistry) .increment(); throw e; } finally { // 記錄執行時間 sample.stop(Timer.builder(\u0026#34;method.execution.time\u0026#34;) .tag(\u0026#34;service\u0026#34;, serviceName) .tag(\u0026#34;method\u0026#34;, methodName) .register(meterRegistry)); } } } } 2. 批量操作優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 批量操作裝飾器 public class BatchingDecorator\u0026lt;T\u0026gt; { private final T target; private final int batchSize; private final Map\u0026lt;String, List\u0026lt;Object[]\u0026gt;\u0026gt; batchQueue = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final ScheduledExecutorService scheduler; public BatchingDecorator(T target, int batchSize, long flushInterval) { this.target = target; this.batchSize = batchSize; this.scheduler = Executors.newScheduledThreadPool(1); // 定期刷新批量操作 scheduler.scheduleAtFixedRate(this::flushBatches, flushInterval, flushInterval, TimeUnit.MILLISECONDS); } private void flushBatches() { for (Map.Entry\u0026lt;String, List\u0026lt;Object[]\u0026gt;\u0026gt; entry : batchQueue.entrySet()) { String methodName = entry.getKey(); List\u0026lt;Object[]\u0026gt; batch = entry.getValue(); if (!batch.isEmpty()) { processBatch(methodName, batch); batch.clear(); } } } private void processBatch(String methodName, List\u0026lt;Object[]\u0026gt; batch) { try { Method method = target.getClass().getMethod(\u0026#34;batch\u0026#34; + methodName, List.class); method.invoke(target, batch); } catch (Exception e) { // 處理批量操作失敗 } } public void addToBatch(String methodName, Object[] args) { batchQueue.computeIfAbsent(methodName, k -\u0026gt; new CopyOnWriteArrayList\u0026lt;\u0026gt;()).add(args); List\u0026lt;Object[]\u0026gt; batch = batchQueue.get(methodName); if (batch.size() \u0026gt;= batchSize) { processBatch(methodName, batch); batch.clear(); } } } 測試策略 1. 裝飾器測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @ExtendWith(MockitoExtension.class) class DecoratorPatternTest { @Mock private UserService mockUserService; @Mock private Logger mockLogger; @Test void testLoggingDecorator() { User user = new User(1L, \u0026#34;testUser\u0026#34;); when(mockUserService.findById(1L)).thenReturn(user); UserService loggingService = LoggingDecorator.createProxy(mockUserService, mockLogger); User result = loggingService.findById(1L); assertEquals(user, result); verify(mockUserService).findById(1L); // 驗證日誌記錄 } @Test void testCacheDecorator() { Cache cache = new SimpleCache(); Set\u0026lt;String\u0026gt; cacheableMethods = Set.of(\u0026#34;findById\u0026#34;); User user = new User(1L, \u0026#34;testUser\u0026#34;); when(mockUserService.findById(1L)).thenReturn(user); UserService cachedService = CacheDecorator.createProxy(mockUserService, cache, cacheableMethods); // 第一次調用 User result1 = cachedService.findById(1L); assertEquals(user, result1); // 第二次調用應該從緩存獲取 User result2 = cachedService.findById(1L); assertEquals(user, result2); // 只應該調用一次實際方法 verify(mockUserService, times(1)).findById(1L); } @Test void testSecurityDecorator() { SecurityContext securityContext = new SecurityContext(Set.of(\u0026#34;USER_READ\u0026#34;)); Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; methodPermissions = Map.of( \u0026#34;findById\u0026#34;, Set.of(\u0026#34;USER_READ\u0026#34;), \u0026#34;save\u0026#34;, Set.of(\u0026#34;USER_WRITE\u0026#34;) ); UserService securedService = SecurityDecorator.createProxy( mockUserService, securityContext, methodPermissions); // 應該允許讀取操作 assertDoesNotThrow(() -\u0026gt; securedService.findById(1L)); // 應該拒絕寫入操作 assertThrows(SecurityException.class, () -\u0026gt; securedService.save(new User())); } } 2. AOP 測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @SpringBootTest @EnableAspectJAutoProxy class AopDecoratorTest { @Autowired private UserService userService; @MockBean private UserRepository userRepository; @Test void testLoggingAspect() { User user = new User(1L, \u0026#34;testUser\u0026#34;); when(userRepository.findById(1L)).thenReturn(Optional.of(user)); User result = userService.findById(1L); assertEquals(user, result); // 驗證日誌輸出 } @Test void testCacheAspect() { User user = new User(1L, \u0026#34;testUser\u0026#34;); when(userRepository.findById(1L)).thenReturn(Optional.of(user)); // 第一次調用 User result1 = userService.findById(1L); assertEquals(user, result1); // 第二次調用應該從緩存獲取 User result2 = userService.findById(1L); assertEquals(user, result2); // 只應該調用一次數據庫 verify(userRepository, times(1)).findById(1L); } } 最佳實踐 1. 設計原則 單一職責: 每個裝飾器只處理一個橫切關注點 開放封閉: 易於添加新裝飾器而不修改現有代碼 組合優於繼承: 使用組合來擴展行為 接口隔離: 定義清晰的接口契約 2. 實現建議 使用不可變對象提高線程安全性 考慮裝飾器的順序，特別是在鏈式調用中 實現適當的異常處理 提供配置選項來控制裝飾器行為 3. 性能考慮 避免過度裝飾導致性能下降 使用緩存來提高重複操作的性能 考慮異步處理來減少阻塞 監控裝飾器的性能影響 4. 常見陷阱 避免裝飾器鏈過長 注意循環依賴問題 正確處理異常傳播 考慮線程安全性 適用場景 何時使用 橫切關注點: 需要添加日誌、安全、緩存等橫切功能 動態行為: 需要在運行時動態添加或移除功能 避免繼承: 當繼承會導致類爆炸時 透明擴展: 需要透明地擴展對象功能 何時避免 簡單場景: 當功能擴展很簡單時 性能關鍵: 當性能是關鍵因素時 過度使用: 當裝飾器層次過多時 類型安全: 當需要強類型檢查時 總結 Decorator Pattern 是一個強大的結構型設計模式，特別適合在企業級應用中處理橫切關注點。通過與 Spring AOP 的結合使用，我們可以創建出非常靈活和可維護的系統。\n現代 Java 的函數式編程特性為 Decorator Pattern 提供了新的實現方式，使得代碼更加簡潔和易讀。在實際應用中，關鍵是要理解何時使用這個模式，以及如何正確地組合多個裝飾器來達到所需的效果。\n通過合理使用 Decorator Pattern，我們可以構建出既靈活又可維護的企業級應用，同時保持代碼的清晰性和可測試性。\n","permalink":"https://xinqilin.github.io/post/architecture/decorator/","tags":["Design Pattern","Structural","Decorator","AOP","Spring"],"title":"DesignPattern - Structural - Decorator"},{"content":"橋接模式 (Bridge Pattern) 完整實作指南 模式概述 橋接模式是一種結構型設計模式，它將抽象部分與實現部分分離，使它們都可以獨立地變化。橋接模式通過組合建立抽象和實現之間的橋梁，而不是使用繼承將它們結合在一起。\n核心思想 橋接模式的核心思想是**「組合優於繼承」**，它解決了在多個維度上變化的問題，避免了類爆炸的問題。\n模式結構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 // 抽象 (Abstraction) public abstract class Shape { protected Color color; public Shape(Color color) { this.color = color; } public abstract void draw(); public abstract double getArea(); } // 實現介面 (Implementor) public interface Color { void fill(); } // 具體實現 (Concrete Implementor) public class Red implements Color { @Override public void fill() { System.out.println(\u0026#34;填充紅色\u0026#34;); } } public class Blue implements Color { @Override public void fill() { System.out.println(\u0026#34;填充藍色\u0026#34;); } } // 細化抽象 (Refined Abstraction) public class Circle extends Shape { private double radius; public Circle(Color color, double radius) { super(color); this.radius = radius; } @Override public void draw() { System.out.print(\u0026#34;畫圓形，半徑：\u0026#34; + radius + \u0026#34;，\u0026#34;); color.fill(); } @Override public double getArea() { return Math.PI * radius * radius; } } public class Rectangle extends Shape { private double width; private double height; public Rectangle(Color color, double width, double height) { super(color); this.width = width; this.height = height; } @Override public void draw() { System.out.print(\u0026#34;畫矩形，寬：\u0026#34; + width + \u0026#34;，高：\u0026#34; + height + \u0026#34;，\u0026#34;); color.fill(); } @Override public double getArea() { return width * height; } } 企業級應用場景 1. 數據庫抽象層 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 // 數據庫操作抽象 public abstract class DatabaseOperation { protected DatabaseDriver driver; public DatabaseOperation(DatabaseDriver driver) { this.driver = driver; } public abstract void execute(String sql); public abstract ResultSet query(String sql); public abstract boolean update(String sql); protected void logOperation(String operation) { System.out.println(\u0026#34;執行數據庫操作: \u0026#34; + operation); } } // 數據庫驅動介面 public interface DatabaseDriver { Connection getConnection(); void closeConnection(Connection connection); PreparedStatement prepareStatement(String sql); boolean supportsTransaction(); void beginTransaction(); void commit(); void rollback(); } // MySQL驅動實現 @Component public class MySQLDriver implements DatabaseDriver { private static final String DRIVER_NAME = \u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;; private final String connectionUrl; private final String username; private final String password; public MySQLDriver(@Value(\u0026#34;${database.mysql.url}\u0026#34;) String connectionUrl, @Value(\u0026#34;${database.mysql.username}\u0026#34;) String username, @Value(\u0026#34;${database.mysql.password}\u0026#34;) String password) { this.connectionUrl = connectionUrl; this.username = username; this.password = password; } @Override public Connection getConnection() { try { Class.forName(DRIVER_NAME); return DriverManager.getConnection(connectionUrl, username, password); } catch (ClassNotFoundException | SQLException e) { throw new DatabaseConnectionException(\u0026#34;無法連接到MySQL數據庫\u0026#34;, e); } } @Override public void closeConnection(Connection connection) { try { if (connection != null \u0026amp;\u0026amp; !connection.isClosed()) { connection.close(); } } catch (SQLException e) { throw new DatabaseConnectionException(\u0026#34;關閉MySQL連接失敗\u0026#34;, e); } } @Override public PreparedStatement prepareStatement(String sql) { try { Connection connection = getConnection(); return connection.prepareStatement(sql); } catch (SQLException e) { throw new DatabaseOperationException(\u0026#34;創建MySQL PreparedStatement失敗\u0026#34;, e); } } @Override public boolean supportsTransaction() { return true; } @Override public void beginTransaction() { try { Connection connection = getConnection(); connection.setAutoCommit(false); } catch (SQLException e) { throw new DatabaseOperationException(\u0026#34;開始MySQL事務失敗\u0026#34;, e); } } @Override public void commit() { try { Connection connection = getConnection(); connection.commit(); } catch (SQLException e) { throw new DatabaseOperationException(\u0026#34;提交MySQL事務失敗\u0026#34;, e); } } @Override public void rollback() { try { Connection connection = getConnection(); connection.rollback(); } catch (SQLException e) { throw new DatabaseOperationException(\u0026#34;回滾MySQL事務失敗\u0026#34;, e); } } } // PostgreSQL驅動實現 @Component public class PostgreSQLDriver implements DatabaseDriver { private static final String DRIVER_NAME = \u0026#34;org.postgresql.Driver\u0026#34;; private final String connectionUrl; private final String username; private final String password; public PostgreSQLDriver(@Value(\u0026#34;${database.postgresql.url}\u0026#34;) String connectionUrl, @Value(\u0026#34;${database.postgresql.username}\u0026#34;) String username, @Value(\u0026#34;${database.postgresql.password}\u0026#34;) String password) { this.connectionUrl = connectionUrl; this.username = username; this.password = password; } @Override public Connection getConnection() { try { Class.forName(DRIVER_NAME); return DriverManager.getConnection(connectionUrl, username, password); } catch (ClassNotFoundException | SQLException e) { throw new DatabaseConnectionException(\u0026#34;無法連接到PostgreSQL數據庫\u0026#34;, e); } } @Override public void closeConnection(Connection connection) { try { if (connection != null \u0026amp;\u0026amp; !connection.isClosed()) { connection.close(); } } catch (SQLException e) { throw new DatabaseConnectionException(\u0026#34;關閉PostgreSQL連接失敗\u0026#34;, e); } } @Override public PreparedStatement prepareStatement(String sql) { try { Connection connection = getConnection(); return connection.prepareStatement(sql); } catch (SQLException e) { throw new DatabaseOperationException(\u0026#34;創建PostgreSQL PreparedStatement失敗\u0026#34;, e); } } @Override public boolean supportsTransaction() { return true; } @Override public void beginTransaction() { try { Connection connection = getConnection(); connection.setAutoCommit(false); } catch (SQLException e) { throw new DatabaseOperationException(\u0026#34;開始PostgreSQL事務失敗\u0026#34;, e); } } @Override public void commit() { try { Connection connection = getConnection(); connection.commit(); } catch (SQLException e) { throw new DatabaseOperationException(\u0026#34;提交PostgreSQL事務失敗\u0026#34;, e); } } @Override public void rollback() { try { Connection connection = getConnection(); connection.rollback(); } catch (SQLException e) { throw new DatabaseOperationException(\u0026#34;回滾PostgreSQL事務失敗\u0026#34;, e); } } } // 用戶數據操作 @Repository public class UserDatabaseOperation extends DatabaseOperation { public UserDatabaseOperation(DatabaseDriver driver) { super(driver); } @Override public void execute(String sql) { Connection connection = null; PreparedStatement statement = null; try { connection = driver.getConnection(); statement = connection.prepareStatement(sql); statement.execute(); logOperation(\u0026#34;執行用戶相關SQL: \u0026#34; + sql); } catch (SQLException e) { throw new DatabaseOperationException(\u0026#34;執行用戶SQL失敗\u0026#34;, e); } finally { closeResources(statement, connection); } } @Override public ResultSet query(String sql) { try { Connection connection = driver.getConnection(); PreparedStatement statement = connection.prepareStatement(sql); ResultSet resultSet = statement.executeQuery(); logOperation(\u0026#34;查詢用戶數據: \u0026#34; + sql); return resultSet; } catch (SQLException e) { throw new DatabaseOperationException(\u0026#34;查詢用戶數據失敗\u0026#34;, e); } } @Override public boolean update(String sql) { Connection connection = null; PreparedStatement statement = null; try { connection = driver.getConnection(); statement = connection.prepareStatement(sql); int affectedRows = statement.executeUpdate(); logOperation(\u0026#34;更新用戶數據: \u0026#34; + sql + \u0026#34;, 影響行數: \u0026#34; + affectedRows); return affectedRows \u0026gt; 0; } catch (SQLException e) { throw new DatabaseOperationException(\u0026#34;更新用戶數據失敗\u0026#34;, e); } finally { closeResources(statement, connection); } } public User findUserById(Long id) { String sql = \u0026#34;SELECT * FROM users WHERE id = ?\u0026#34;; try (Connection connection = driver.getConnection(); PreparedStatement statement = connection.prepareStatement(sql)) { statement.setLong(1, id); ResultSet resultSet = statement.executeQuery(); if (resultSet.next()) { return mapResultSetToUser(resultSet); } return null; } catch (SQLException e) { throw new DatabaseOperationException(\u0026#34;根據ID查詢用戶失敗\u0026#34;, e); } } public void createUser(User user) { String sql = \u0026#34;INSERT INTO users (name, email, created_at) VALUES (?, ?, ?)\u0026#34;; try (Connection connection = driver.getConnection(); PreparedStatement statement = connection.prepareStatement(sql)) { statement.setString(1, user.getName()); statement.setString(2, user.getEmail()); statement.setTimestamp(3, Timestamp.valueOf(user.getCreatedAt())); statement.executeUpdate(); logOperation(\u0026#34;創建用戶: \u0026#34; + user.getName()); } catch (SQLException e) { throw new DatabaseOperationException(\u0026#34;創建用戶失敗\u0026#34;, e); } } public void updateUser(User user) { if (!driver.supportsTransaction()) { throw new UnsupportedOperationException(\u0026#34;當前數據庫不支持事務操作\u0026#34;); } String sql = \u0026#34;UPDATE users SET name = ?, email = ?, updated_at = ? WHERE id = ?\u0026#34;; Connection connection = null; PreparedStatement statement = null; try { connection = driver.getConnection(); driver.beginTransaction(); statement = connection.prepareStatement(sql); statement.setString(1, user.getName()); statement.setString(2, user.getEmail()); statement.setTimestamp(3, Timestamp.valueOf(LocalDateTime.now())); statement.setLong(4, user.getId()); int affectedRows = statement.executeUpdate(); if (affectedRows == 0) { throw new DatabaseOperationException(\u0026#34;未找到要更新的用戶\u0026#34;); } driver.commit(); logOperation(\u0026#34;更新用戶: \u0026#34; + user.getName()); } catch (SQLException e) { driver.rollback(); throw new DatabaseOperationException(\u0026#34;更新用戶失敗\u0026#34;, e); } finally { closeResources(statement, connection); } } private User mapResultSetToUser(ResultSet resultSet) throws SQLException { return User.builder() .id(resultSet.getLong(\u0026#34;id\u0026#34;)) .name(resultSet.getString(\u0026#34;name\u0026#34;)) .email(resultSet.getString(\u0026#34;email\u0026#34;)) .createdAt(resultSet.getTimestamp(\u0026#34;created_at\u0026#34;).toLocalDateTime()) .build(); } private void closeResources(PreparedStatement statement, Connection connection) { try { if (statement != null) { statement.close(); } } catch (SQLException e) { // 記錄日誌但不拋出異常 } driver.closeConnection(connection); } } 2. 消息發送系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 // 消息抽象 public abstract class Message { protected MessageSender sender; protected String content; protected String recipient; protected LocalDateTime timestamp; public Message(MessageSender sender, String content, String recipient) { this.sender = sender; this.content = content; this.recipient = recipient; this.timestamp = LocalDateTime.now(); } public abstract void send(); public abstract boolean isDelivered(); public abstract void resend(); protected void logMessage(String action) { System.out.println(String.format(\u0026#34;[%s] %s - 收件人: %s\u0026#34;, timestamp.format(DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;)), action, recipient)); } } // 消息發送者介面 public interface MessageSender { void sendMessage(String recipient, String content); boolean isAvailable(); String getSenderType(); void configure(Map\u0026lt;String, Object\u0026gt; configuration); DeliveryStatus getDeliveryStatus(String messageId); } // 電子郵件發送器 @Component public class EmailSender implements MessageSender { private final JavaMailSender mailSender; private final EmailConfiguration emailConfig; public EmailSender(JavaMailSender mailSender, EmailConfiguration emailConfig) { this.mailSender = mailSender; this.emailConfig = emailConfig; } @Override public void sendMessage(String recipient, String content) { try { SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(emailConfig.getFromAddress()); message.setTo(recipient); message.setSubject(emailConfig.getDefaultSubject()); message.setText(content); mailSender.send(message); } catch (Exception e) { throw new MessageSendException(\u0026#34;發送電子郵件失敗\u0026#34;, e); } } @Override public boolean isAvailable() { try { return mailSender != null \u0026amp;\u0026amp; emailConfig.isEnabled(); } catch (Exception e) { return false; } } @Override public String getSenderType() { return \u0026#34;EMAIL\u0026#34;; } @Override public void configure(Map\u0026lt;String, Object\u0026gt; configuration) { if (configuration.containsKey(\u0026#34;subject\u0026#34;)) { emailConfig.setDefaultSubject((String) configuration.get(\u0026#34;subject\u0026#34;)); } if (configuration.containsKey(\u0026#34;fromAddress\u0026#34;)) { emailConfig.setFromAddress((String) configuration.get(\u0026#34;fromAddress\u0026#34;)); } } @Override public DeliveryStatus getDeliveryStatus(String messageId) { // 實際實現需要與郵件服務器API整合 return DeliveryStatus.DELIVERED; } } // SMS發送器 @Component public class SMSSender implements MessageSender { private final SmsClient smsClient; private final SmsConfiguration smsConfig; public SMSSender(SmsClient smsClient, SmsConfiguration smsConfig) { this.smsClient = smsClient; this.smsConfig = smsConfig; } @Override public void sendMessage(String recipient, String content) { try { SmsRequest request = SmsRequest.builder() .phoneNumber(recipient) .message(content) .apiKey(smsConfig.getApiKey()) .build(); SmsResponse response = smsClient.sendSms(request); if (!response.isSuccess()) { throw new MessageSendException(\u0026#34;SMS發送失敗: \u0026#34; + response.getErrorMessage()); } } catch (Exception e) { throw new MessageSendException(\u0026#34;發送SMS失敗\u0026#34;, e); } } @Override public boolean isAvailable() { return smsClient != null \u0026amp;\u0026amp; smsConfig.isEnabled() \u0026amp;\u0026amp; smsConfig.getApiKey() != null; } @Override public String getSenderType() { return \u0026#34;SMS\u0026#34;; } @Override public void configure(Map\u0026lt;String, Object\u0026gt; configuration) { if (configuration.containsKey(\u0026#34;apiKey\u0026#34;)) { smsConfig.setApiKey((String) configuration.get(\u0026#34;apiKey\u0026#34;)); } } @Override public DeliveryStatus getDeliveryStatus(String messageId) { try { return smsClient.getDeliveryStatus(messageId); } catch (Exception e) { return DeliveryStatus.UNKNOWN; } } } // 推送通知發送器 @Component public class PushNotificationSender implements MessageSender { private final PushNotificationService pushService; private final PushConfiguration pushConfig; public PushNotificationSender(PushNotificationService pushService, PushConfiguration pushConfig) { this.pushService = pushService; this.pushConfig = pushConfig; } @Override public void sendMessage(String recipient, String content) { try { PushNotification notification = PushNotification.builder() .deviceToken(recipient) .message(content) .badge(1) .sound(\u0026#34;default\u0026#34;) .build(); pushService.send(notification); } catch (Exception e) { throw new MessageSendException(\u0026#34;發送推送通知失敗\u0026#34;, e); } } @Override public boolean isAvailable() { return pushService != null \u0026amp;\u0026amp; pushConfig.isEnabled(); } @Override public String getSenderType() { return \u0026#34;PUSH\u0026#34;; } @Override public void configure(Map\u0026lt;String, Object\u0026gt; configuration) { if (configuration.containsKey(\u0026#34;appId\u0026#34;)) { pushConfig.setAppId((String) configuration.get(\u0026#34;appId\u0026#34;)); } } @Override public DeliveryStatus getDeliveryStatus(String messageId) { try { return pushService.getDeliveryStatus(messageId); } catch (Exception e) { return DeliveryStatus.UNKNOWN; } } } // 通知消息 public class NotificationMessage extends Message { private String messageId; private int retryCount; private final int maxRetries; public NotificationMessage(MessageSender sender, String content, String recipient) { super(sender, content, recipient); this.messageId = generateMessageId(); this.retryCount = 0; this.maxRetries = 3; } @Override public void send() { if (!sender.isAvailable()) { throw new MessageSendException(\u0026#34;消息發送器不可用: \u0026#34; + sender.getSenderType()); } try { sender.sendMessage(recipient, content); logMessage(\u0026#34;通知已發送 - \u0026#34; + sender.getSenderType()); } catch (Exception e) { logMessage(\u0026#34;通知發送失敗 - \u0026#34; + sender.getSenderType()); throw e; } } @Override public boolean isDelivered() { try { DeliveryStatus status = sender.getDeliveryStatus(messageId); return status == DeliveryStatus.DELIVERED; } catch (Exception e) { return false; } } @Override public void resend() { if (retryCount \u0026gt;= maxRetries) { throw new MessageSendException(\u0026#34;已達到最大重試次數\u0026#34;); } retryCount++; logMessage(\u0026#34;重新發送通知 (第\u0026#34; + retryCount + \u0026#34;次) - \u0026#34; + sender.getSenderType()); send(); } private String generateMessageId() { return UUID.randomUUID().toString(); } } // 營銷消息 public class MarketingMessage extends Message { private String campaignId; private Map\u0026lt;String, Object\u0026gt; personalizationData; public MarketingMessage(MessageSender sender, String content, String recipient, String campaignId, Map\u0026lt;String, Object\u0026gt; personalizationData) { super(sender, content, recipient); this.campaignId = campaignId; this.personalizationData = personalizationData; } @Override public void send() { if (!sender.isAvailable()) { throw new MessageSendException(\u0026#34;消息發送器不可用: \u0026#34; + sender.getSenderType()); } String personalizedContent = personalizeContent(); try { sender.sendMessage(recipient, personalizedContent); logMessage(\u0026#34;營銷消息已發送 - 活動ID: \u0026#34; + campaignId + \u0026#34; - \u0026#34; + sender.getSenderType()); } catch (Exception e) { logMessage(\u0026#34;營銷消息發送失敗 - 活動ID: \u0026#34; + campaignId + \u0026#34; - \u0026#34; + sender.getSenderType()); throw e; } } @Override public boolean isDelivered() { try { DeliveryStatus status = sender.getDeliveryStatus(campaignId); return status == DeliveryStatus.DELIVERED; } catch (Exception e) { return false; } } @Override public void resend() { logMessage(\u0026#34;重新發送營銷消息 - 活動ID: \u0026#34; + campaignId + \u0026#34; - \u0026#34; + sender.getSenderType()); send(); } private String personalizeContent() { String personalizedContent = content; if (personalizationData != null) { for (Map.Entry\u0026lt;String, Object\u0026gt; entry : personalizationData.entrySet()) { String placeholder = \u0026#34;{{\u0026#34; + entry.getKey() + \u0026#34;}}\u0026#34;; personalizedContent = personalizedContent.replace(placeholder, entry.getValue().toString()); } } return personalizedContent; } } 3. 報告生成系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 // 報告抽象 public abstract class Report { protected ReportGenerator generator; protected String title; protected LocalDateTime generatedAt; protected Map\u0026lt;String, Object\u0026gt; data; public Report(ReportGenerator generator, String title, Map\u0026lt;String, Object\u0026gt; data) { this.generator = generator; this.title = title; this.data = data; this.generatedAt = LocalDateTime.now(); } public abstract void generate(); public abstract void export(String filePath); public abstract String getContent(); protected void logReportActivity(String activity) { System.out.println(String.format(\u0026#34;[%s] %s - 報告: %s\u0026#34;, generatedAt.format(DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;)), activity, title)); } } // 報告生成器介面 public interface ReportGenerator { String generateContent(String title, Map\u0026lt;String, Object\u0026gt; data); void exportToFile(String content, String filePath); String getFormat(); boolean supportsCharts(); void setTemplate(String template); } // PDF報告生成器 @Component public class PDFReportGenerator implements ReportGenerator { private final PDFService pdfService; private String template; public PDFReportGenerator(PDFService pdfService) { this.pdfService = pdfService; } @Override public String generateContent(String title, Map\u0026lt;String, Object\u0026gt; data) { try { PDFDocument document = new PDFDocument(); // 添加標題 document.addTitle(title); document.addGeneratedDate(LocalDateTime.now()); // 添加數據內容 if (data.containsKey(\u0026#34;summary\u0026#34;)) { document.addSection(\u0026#34;摘要\u0026#34;, data.get(\u0026#34;summary\u0026#34;).toString()); } if (data.containsKey(\u0026#34;tableData\u0026#34;)) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; tableData = (List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt;) data.get(\u0026#34;tableData\u0026#34;); document.addTable(tableData); } if (data.containsKey(\u0026#34;chartData\u0026#34;) \u0026amp;\u0026amp; supportsCharts()) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Map\u0026lt;String, Object\u0026gt; chartData = (Map\u0026lt;String, Object\u0026gt;) data.get(\u0026#34;chartData\u0026#34;); document.addChart(chartData); } return document.build(); } catch (Exception e) { throw new ReportGenerationException(\u0026#34;生成PDF報告內容失敗\u0026#34;, e); } } @Override public void exportToFile(String content, String filePath) { try { pdfService.saveToPDF(content, filePath); } catch (Exception e) { throw new ReportGenerationException(\u0026#34;導出PDF報告失敗\u0026#34;, e); } } @Override public String getFormat() { return \u0026#34;PDF\u0026#34;; } @Override public boolean supportsCharts() { return true; } @Override public void setTemplate(String template) { this.template = template; } } // Excel報告生成器 @Component public class ExcelReportGenerator implements ReportGenerator { private final ExcelService excelService; private String template; public ExcelReportGenerator(ExcelService excelService) { this.excelService = excelService; } @Override public String generateContent(String title, Map\u0026lt;String, Object\u0026gt; data) { try { Workbook workbook = new XSSFWorkbook(); Sheet sheet = workbook.createSheet(title); int rowIndex = 0; // 添加標題行 Row titleRow = sheet.createRow(rowIndex++); Cell titleCell = titleRow.createCell(0); titleCell.setCellValue(title); // 添加生成時間 Row dateRow = sheet.createRow(rowIndex++); Cell dateCell = dateRow.createCell(0); dateCell.setCellValue(\u0026#34;生成時間: \u0026#34; + LocalDateTime.now().format(DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;))); // 空行 rowIndex++; // 添加數據表格 if (data.containsKey(\u0026#34;tableData\u0026#34;)) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; tableData = (List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt;) data.get(\u0026#34;tableData\u0026#34;); if (!tableData.isEmpty()) { // 添加表頭 Row headerRow = sheet.createRow(rowIndex++); Set\u0026lt;String\u0026gt; headers = tableData.get(0).keySet(); int colIndex = 0; for (String header : headers) { Cell headerCell = headerRow.createCell(colIndex++); headerCell.setCellValue(header); } // 添加數據行 for (Map\u0026lt;String, Object\u0026gt; row : tableData) { Row dataRow = sheet.createRow(rowIndex++); colIndex = 0; for (String header : headers) { Cell dataCell = dataRow.createCell(colIndex++); Object value = row.get(header); if (value != null) { dataCell.setCellValue(value.toString()); } } } } } // 自動調整列寬 for (int i = 0; i \u0026lt; sheet.getRow(0).getLastCellNum(); i++) { sheet.autoSizeColumn(i); } return workbook.toString(); // 實際實現需要序列化workbook } catch (Exception e) { throw new ReportGenerationException(\u0026#34;生成Excel報告內容失敗\u0026#34;, e); } } @Override public void exportToFile(String content, String filePath) { try { excelService.saveToExcel(content, filePath); } catch (Exception e) { throw new ReportGenerationException(\u0026#34;導出Excel報告失敗\u0026#34;, e); } } @Override public String getFormat() { return \u0026#34;EXCEL\u0026#34;; } @Override public boolean supportsCharts() { return true; } @Override public void setTemplate(String template) { this.template = template; } } // HTML報告生成器 @Component public class HTMLReportGenerator implements ReportGenerator { private final TemplateEngine templateEngine; private String template; public HTMLReportGenerator(TemplateEngine templateEngine) { this.templateEngine = templateEngine; } @Override public String generateContent(String title, Map\u0026lt;String, Object\u0026gt; data) { try { Map\u0026lt;String, Object\u0026gt; templateData = new HashMap\u0026lt;\u0026gt;(); templateData.put(\u0026#34;title\u0026#34;, title); templateData.put(\u0026#34;generatedAt\u0026#34;, LocalDateTime.now()); templateData.putAll(data); if (template != null) { return templateEngine.process(template, templateData); } else { return generateDefaultHTML(title, data); } } catch (Exception e) { throw new ReportGenerationException(\u0026#34;生成HTML報告內容失敗\u0026#34;, e); } } @Override public void exportToFile(String content, String filePath) { try (FileWriter writer = new FileWriter(filePath)) { writer.write(content); } catch (IOException e) { throw new ReportGenerationException(\u0026#34;導出HTML報告失敗\u0026#34;, e); } } @Override public String getFormat() { return \u0026#34;HTML\u0026#34;; } @Override public boolean supportsCharts() { return true; // 支持JavaScript圖表 } @Override public void setTemplate(String template) { this.template = template; } private String generateDefaultHTML(String title, Map\u0026lt;String, Object\u0026gt; data) { StringBuilder html = new StringBuilder(); html.append(\u0026#34;\u0026lt;!DOCTYPE html\u0026gt;\u0026#34;) .append(\u0026#34;\u0026lt;html\u0026gt;\u0026#34;) .append(\u0026#34;\u0026lt;head\u0026gt;\u0026#34;) .append(\u0026#34;\u0026lt;title\u0026gt;\u0026#34;).append(title).append(\u0026#34;\u0026lt;/title\u0026gt;\u0026#34;) .append(\u0026#34;\u0026lt;style\u0026gt;\u0026#34;) .append(\u0026#34;body { font-family: Arial, sans-serif; margin: 20px; }\u0026#34;) .append(\u0026#34;table { border-collapse: collapse; width: 100%; }\u0026#34;) .append(\u0026#34;th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\u0026#34;) .append(\u0026#34;th { background-color: #f2f2f2; }\u0026#34;) .append(\u0026#34;\u0026lt;/style\u0026gt;\u0026#34;) .append(\u0026#34;\u0026lt;/head\u0026gt;\u0026#34;) .append(\u0026#34;\u0026lt;body\u0026gt;\u0026#34;) .append(\u0026#34;\u0026lt;h1\u0026gt;\u0026#34;).append(title).append(\u0026#34;\u0026lt;/h1\u0026gt;\u0026#34;) .append(\u0026#34;\u0026lt;p\u0026gt;生成時間: \u0026#34;).append(LocalDateTime.now().format(DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;))).append(\u0026#34;\u0026lt;/p\u0026gt;\u0026#34;); if (data.containsKey(\u0026#34;summary\u0026#34;)) { html.append(\u0026#34;\u0026lt;h2\u0026gt;摘要\u0026lt;/h2\u0026gt;\u0026#34;) .append(\u0026#34;\u0026lt;p\u0026gt;\u0026#34;).append(data.get(\u0026#34;summary\u0026#34;)).append(\u0026#34;\u0026lt;/p\u0026gt;\u0026#34;); } if (data.containsKey(\u0026#34;tableData\u0026#34;)) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; tableData = (List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt;) data.get(\u0026#34;tableData\u0026#34;); if (!tableData.isEmpty()) { html.append(\u0026#34;\u0026lt;h2\u0026gt;數據表格\u0026lt;/h2\u0026gt;\u0026#34;) .append(\u0026#34;\u0026lt;table\u0026gt;\u0026#34;); // 表頭 Set\u0026lt;String\u0026gt; headers = tableData.get(0).keySet(); html.append(\u0026#34;\u0026lt;tr\u0026gt;\u0026#34;); for (String header : headers) { html.append(\u0026#34;\u0026lt;th\u0026gt;\u0026#34;).append(header).append(\u0026#34;\u0026lt;/th\u0026gt;\u0026#34;); } html.append(\u0026#34;\u0026lt;/tr\u0026gt;\u0026#34;); // 數據行 for (Map\u0026lt;String, Object\u0026gt; row : tableData) { html.append(\u0026#34;\u0026lt;tr\u0026gt;\u0026#34;); for (String header : headers) { Object value = row.get(header); html.append(\u0026#34;\u0026lt;td\u0026gt;\u0026#34;).append(value != null ? value.toString() : \u0026#34;\u0026#34;).append(\u0026#34;\u0026lt;/td\u0026gt;\u0026#34;); } html.append(\u0026#34;\u0026lt;/tr\u0026gt;\u0026#34;); } html.append(\u0026#34;\u0026lt;/table\u0026gt;\u0026#34;); } } html.append(\u0026#34;\u0026lt;/body\u0026gt;\u0026#34;) .append(\u0026#34;\u0026lt;/html\u0026gt;\u0026#34;); return html.toString(); } } // 銷售報告 public class SalesReport extends Report { private String period; public SalesReport(ReportGenerator generator, String title, Map\u0026lt;String, Object\u0026gt; data, String period) { super(generator, title, data); this.period = period; } @Override public void generate() { logReportActivity(\u0026#34;開始生成銷售報告 - 期間: \u0026#34; + period); // 準備銷售數據 prepareSalesData(); // 生成報告內容 String content = generator.generateContent(title, data); logReportActivity(\u0026#34;銷售報告生成完成 - 格式: \u0026#34; + generator.getFormat()); } @Override public void export(String filePath) { String content = getContent(); generator.exportToFile(content, filePath); logReportActivity(\u0026#34;銷售報告已導出 - 文件: \u0026#34; + filePath); } @Override public String getContent() { return generator.generateContent(title, data); } private void prepareSalesData() { // 準備銷售摘要 data.put(\u0026#34;summary\u0026#34;, \u0026#34;本報告展示了\u0026#34; + period + \u0026#34;期間的銷售業績和趨勢分析\u0026#34;); // 準備銷售數據表格 List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; salesData = new ArrayList\u0026lt;\u0026gt;(); salesData.add(Map.of(\u0026#34;產品\u0026#34;, \u0026#34;產品A\u0026#34;, \u0026#34;銷售額\u0026#34;, 10000, \u0026#34;數量\u0026#34;, 100)); salesData.add(Map.of(\u0026#34;產品\u0026#34;, \u0026#34;產品B\u0026#34;, \u0026#34;銷售額\u0026#34;, 15000, \u0026#34;數量\u0026#34;, 150)); salesData.add(Map.of(\u0026#34;產品\u0026#34;, \u0026#34;產品C\u0026#34;, \u0026#34;銷售額\u0026#34;, 8000, \u0026#34;數量\u0026#34;, 80)); data.put(\u0026#34;tableData\u0026#34;, salesData); // 準備圖表數據 if (generator.supportsCharts()) { Map\u0026lt;String, Object\u0026gt; chartData = new HashMap\u0026lt;\u0026gt;(); chartData.put(\u0026#34;type\u0026#34;, \u0026#34;bar\u0026#34;); chartData.put(\u0026#34;labels\u0026#34;, List.of(\u0026#34;產品A\u0026#34;, \u0026#34;產品B\u0026#34;, \u0026#34;產品C\u0026#34;)); chartData.put(\u0026#34;values\u0026#34;, List.of(10000, 15000, 8000)); data.put(\u0026#34;chartData\u0026#34;, chartData); } } } // 用戶報告 public class UserReport extends Report { private String userSegment; public UserReport(ReportGenerator generator, String title, Map\u0026lt;String, Object\u0026gt; data, String userSegment) { super(generator, title, data); this.userSegment = userSegment; } @Override public void generate() { logReportActivity(\u0026#34;開始生成用戶報告 - 用戶群: \u0026#34; + userSegment); // 準備用戶數據 prepareUserData(); // 生成報告內容 String content = generator.generateContent(title, data); logReportActivity(\u0026#34;用戶報告生成完成 - 格式: \u0026#34; + generator.getFormat()); } @Override public void export(String filePath) { String content = getContent(); generator.exportToFile(content, filePath); logReportActivity(\u0026#34;用戶報告已導出 - 文件: \u0026#34; + filePath); } @Override public String getContent() { return generator.generateContent(title, data); } private void prepareUserData() { // 準備用戶分析摘要 data.put(\u0026#34;summary\u0026#34;, \u0026#34;本報告分析了\u0026#34; + userSegment + \u0026#34;用戶群的行為模式和特徵\u0026#34;); // 準備用戶數據表格 List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; userData = new ArrayList\u0026lt;\u0026gt;(); userData.add(Map.of(\u0026#34;用戶ID\u0026#34;, \u0026#34;U001\u0026#34;, \u0026#34;姓名\u0026#34;, \u0026#34;張三\u0026#34;, \u0026#34;活躍度\u0026#34;, \u0026#34;高\u0026#34;, \u0026#34;消費金額\u0026#34;, 5000)); userData.add(Map.of(\u0026#34;用戶ID\u0026#34;, \u0026#34;U002\u0026#34;, \u0026#34;姓名\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;活躍度\u0026#34;, \u0026#34;中\u0026#34;, \u0026#34;消費金額\u0026#34;, 3000)); userData.add(Map.of(\u0026#34;用戶ID\u0026#34;, \u0026#34;U003\u0026#34;, \u0026#34;姓名\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;活躍度\u0026#34;, \u0026#34;低\u0026#34;, \u0026#34;消費金額\u0026#34;, 1000)); data.put(\u0026#34;tableData\u0026#34;, userData); // 準備圖表數據 if (generator.supportsCharts()) { Map\u0026lt;String, Object\u0026gt; chartData = new HashMap\u0026lt;\u0026gt;(); chartData.put(\u0026#34;type\u0026#34;, \u0026#34;pie\u0026#34;); chartData.put(\u0026#34;labels\u0026#34;, List.of(\u0026#34;高活躍度\u0026#34;, \u0026#34;中活躍度\u0026#34;, \u0026#34;低活躍度\u0026#34;)); chartData.put(\u0026#34;values\u0026#34;, List.of(1, 1, 1)); data.put(\u0026#34;chartData\u0026#34;, chartData); } } } 配置和管理 1. Spring Boot配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @Configuration @EnableConfigurationProperties({DatabaseProperties.class, MessageProperties.class}) public class BridgePatternConfig { @Bean @ConditionalOnProperty(name = \u0026#34;database.type\u0026#34;, havingValue = \u0026#34;mysql\u0026#34;) public DatabaseDriver mysqlDriver(DatabaseProperties properties) { return new MySQLDriver( properties.getMysql().getUrl(), properties.getMysql().getUsername(), properties.getMysql().getPassword() ); } @Bean @ConditionalOnProperty(name = \u0026#34;database.type\u0026#34;, havingValue = \u0026#34;postgresql\u0026#34;) public DatabaseDriver postgresqlDriver(DatabaseProperties properties) { return new PostgreSQLDriver( properties.getPostgresql().getUrl(), properties.getPostgresql().getUsername(), properties.getPostgresql().getPassword() ); } @Bean @ConditionalOnProperty(name = \u0026#34;messaging.email.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public MessageSender emailSender(JavaMailSender mailSender, EmailConfiguration emailConfig) { return new EmailSender(mailSender, emailConfig); } @Bean @ConditionalOnProperty(name = \u0026#34;messaging.sms.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public MessageSender smsSender(SmsClient smsClient, SmsConfiguration smsConfig) { return new SMSSender(smsClient, smsConfig); } @Bean @ConditionalOnProperty(name = \u0026#34;messaging.push.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public MessageSender pushSender(PushNotificationService pushService, PushConfiguration pushConfig) { return new PushNotificationSender(pushService, pushConfig); } @Bean @ConditionalOnProperty(name = \u0026#34;reports.pdf.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public ReportGenerator pdfGenerator(PDFService pdfService) { return new PDFReportGenerator(pdfService); } @Bean @ConditionalOnProperty(name = \u0026#34;reports.excel.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public ReportGenerator excelGenerator(ExcelService excelService) { return new ExcelReportGenerator(excelService); } @Bean @ConditionalOnProperty(name = \u0026#34;reports.html.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public ReportGenerator htmlGenerator(TemplateEngine templateEngine) { return new HTMLReportGenerator(templateEngine); } } 2. 統一服務管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Service public class BridgePatternService { private final List\u0026lt;DatabaseDriver\u0026gt; databaseDrivers; private final List\u0026lt;MessageSender\u0026gt; messageSenders; private final List\u0026lt;ReportGenerator\u0026gt; reportGenerators; public BridgePatternService(List\u0026lt;DatabaseDriver\u0026gt; databaseDrivers, List\u0026lt;MessageSender\u0026gt; messageSenders, List\u0026lt;ReportGenerator\u0026gt; reportGenerators) { this.databaseDrivers = databaseDrivers; this.messageSenders = messageSenders; this.reportGenerators = reportGenerators; } public void processUserData(User user) { // 使用適當的數據庫驅動 DatabaseDriver driver = selectDatabaseDriver(); UserDatabaseOperation operation = new UserDatabaseOperation(driver); operation.createUser(user); // 發送通知 MessageSender sender = selectMessageSender(\u0026#34;EMAIL\u0026#34;); if (sender != null) { NotificationMessage message = new NotificationMessage( sender, \u0026#34;歡迎加入我們的服務！\u0026#34;, user.getEmail() ); message.send(); } // 生成用戶報告 ReportGenerator generator = selectReportGenerator(\u0026#34;PDF\u0026#34;); if (generator != null) { Map\u0026lt;String, Object\u0026gt; data = new HashMap\u0026lt;\u0026gt;(); data.put(\u0026#34;user\u0026#34;, user); UserReport report = new UserReport(generator, \u0026#34;新用戶報告\u0026#34;, data, \u0026#34;新用戶\u0026#34;); report.generate(); report.export(\u0026#34;/reports/user_\u0026#34; + user.getId() + \u0026#34;.pdf\u0026#34;); } } private DatabaseDriver selectDatabaseDriver() { return databaseDrivers.stream() .findFirst() .orElseThrow(() -\u0026gt; new RuntimeException(\u0026#34;沒有可用的數據庫驅動\u0026#34;)); } private MessageSender selectMessageSender(String type) { return messageSenders.stream() .filter(sender -\u0026gt; sender.getSenderType().equals(type)) .filter(MessageSender::isAvailable) .findFirst() .orElse(null); } private ReportGenerator selectReportGenerator(String format) { return reportGenerators.stream() .filter(generator -\u0026gt; generator.getFormat().equals(format)) .findFirst() .orElse(null); } } 測試策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 @ExtendWith(MockitoExtension.class) class BridgePatternTest { @Mock private DatabaseDriver mockDatabaseDriver; @Mock private MessageSender mockMessageSender; @Mock private ReportGenerator mockReportGenerator; @Test void testUserDatabaseOperation() { // Given Connection mockConnection = mock(Connection.class); PreparedStatement mockStatement = mock(PreparedStatement.class); when(mockDatabaseDriver.getConnection()).thenReturn(mockConnection); when(mockConnection.prepareStatement(anyString())).thenReturn(mockStatement); UserDatabaseOperation operation = new UserDatabaseOperation(mockDatabaseDriver); User user = User.builder() .name(\u0026#34;測試用戶\u0026#34;) .email(\u0026#34;test@example.com\u0026#34;) .createdAt(LocalDateTime.now()) .build(); // When operation.createUser(user); // Then verify(mockDatabaseDriver).getConnection(); verify(mockStatement).setString(1, \u0026#34;測試用戶\u0026#34;); verify(mockStatement).setString(2, \u0026#34;test@example.com\u0026#34;); verify(mockStatement).executeUpdate(); } @Test void testNotificationMessage() { // Given when(mockMessageSender.isAvailable()).thenReturn(true); when(mockMessageSender.getSenderType()).thenReturn(\u0026#34;EMAIL\u0026#34;); NotificationMessage message = new NotificationMessage( mockMessageSender, \u0026#34;測試消息\u0026#34;, \u0026#34;test@example.com\u0026#34; ); // When message.send(); // Then verify(mockMessageSender).sendMessage(\u0026#34;test@example.com\u0026#34;, \u0026#34;測試消息\u0026#34;); } @Test void testSalesReport() { // Given when(mockReportGenerator.getFormat()).thenReturn(\u0026#34;PDF\u0026#34;); when(mockReportGenerator.supportsCharts()).thenReturn(true); when(mockReportGenerator.generateContent(anyString(), any())).thenReturn(\u0026#34;PDF內容\u0026#34;); SalesReport report = new SalesReport( mockReportGenerator, \u0026#34;銷售報告\u0026#34;, new HashMap\u0026lt;\u0026gt;(), \u0026#34;2023年第一季度\u0026#34; ); // When report.generate(); // Then verify(mockReportGenerator).generateContent(eq(\u0026#34;銷售報告\u0026#34;), any()); } } 性能優化與最佳實踐 1. 連接池管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Component public class DatabaseConnectionPool { private final Map\u0026lt;String, HikariDataSource\u0026gt; dataSources = new ConcurrentHashMap\u0026lt;\u0026gt;(); public Connection getConnection(String driverType) { HikariDataSource dataSource = dataSources.computeIfAbsent(driverType, this::createDataSource); try { return dataSource.getConnection(); } catch (SQLException e) { throw new DatabaseConnectionException(\u0026#34;無法從連接池獲取連接\u0026#34;, e); } } private HikariDataSource createDataSource(String driverType) { HikariConfig config = new HikariConfig(); // 根據驅動類型配置連接池 return new HikariDataSource(config); } } 2. 異步消息處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Component public class AsyncMessageProcessor { private final TaskExecutor taskExecutor; public AsyncMessageProcessor(TaskExecutor taskExecutor) { this.taskExecutor = taskExecutor; } public CompletableFuture\u0026lt;Void\u0026gt; sendMessageAsync(Message message) { return CompletableFuture.runAsync(() -\u0026gt; { try { message.send(); } catch (Exception e) { // 記錄錯誤並進行重試 handleMessageError(message, e); } }, taskExecutor); } private void handleMessageError(Message message, Exception e) { // 錯誤處理邏輯 } } 監控與診斷 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Component public class BridgePatternMonitor { private final MeterRegistry meterRegistry; public BridgePatternMonitor(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; } public void recordDatabaseOperation(String operation, String driver, boolean success) { Counter.builder(\u0026#34;bridge.database.operations\u0026#34;) .tag(\u0026#34;operation\u0026#34;, operation) .tag(\u0026#34;driver\u0026#34;, driver) .tag(\u0026#34;success\u0026#34;, String.valueOf(success)) .register(meterRegistry) .increment(); } public void recordMessageSent(String senderType, boolean success) { Counter.builder(\u0026#34;bridge.message.sent\u0026#34;) .tag(\u0026#34;sender\u0026#34;, senderType) .tag(\u0026#34;success\u0026#34;, String.valueOf(success)) .register(meterRegistry) .increment(); } public void recordReportGenerated(String format, long durationMs) { Timer.builder(\u0026#34;bridge.report.generation\u0026#34;) .tag(\u0026#34;format\u0026#34;, format) .register(meterRegistry) .record(durationMs, TimeUnit.MILLISECONDS); } } 總結 橋接模式是一種強大的結構型設計模式，特別適用於：\n多維度變化：當系統需要在多個維度上變化時 抽象與實現分離：需要將抽象和實現解耦 運行時切換：需要在運行時動態切換實現 避免類爆炸：減少繼承層次結構的複雜性 關鍵最佳實踐 明確職責分離：清楚區分抽象和實現的職責 介面設計：設計穩定的實現者介面 依賴注入：使用依賴注入管理實現者 配置驅動：通過配置選擇適當的實現 監控診斷：追蹤橋接模式的使用情況 橋接模式讓抽象和實現可以獨立變化，是構建靈活、可擴展系統的重要工具。正確使用橋接模式可以大幅提升系統的維護性和擴展性。\n","permalink":"https://xinqilin.github.io/post/architecture/bridge/","tags":["Design Pattern","Bridge Pattern","Structural Pattern","Abstraction","Implementation","Decoupling","Architecture","Java","Spring Boot","Best Practices","Enterprise Development","SOLID Principles","Software Design"],"title":"橋接模式 (Bridge Pattern) 完整實作指南：抽象與實現分離的架構設計最佳實踐"},{"content":"Facade Pattern 概述 Facade Pattern 是一種結構型設計模式，它為子系統中的一組接口提供統一的入口。Facade 定義了一個更高級別的接口，使子系統更易於使用。它通過隱藏複雜性並暴露簡單的接口來實現抽象，促進鬆散耦合。\n核心概念 關鍵特性 簡化接口: 提供更簡單的接口來訪問複雜的子系統 解耦: 將客戶端與子系統的內部工作解耦 統一訪問點: 為多個子系統提供統一的訪問入口 封裝複雜性: 隱藏子系統的複雜實現細節 與其他模式的區別 Facade vs Adapter: Facade 簡化接口，Adapter 轉換接口 Facade vs Mediator: Facade 子系統不知道 Facade 存在，Mediator 中各組件都知道 Mediator Facade vs Proxy: Facade 簡化訪問，Proxy 控制訪問 結構組件 Facade: 外觀類，提供簡化的接口 Subsystem Classes: 子系統類，實現具體功能 Client: 客戶端，通過 Facade 訪問子系統 基本實現 1. 經典 Facade 實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 // 子系統類 public class AudioSystem { public void turnOn() { System.out.println(\u0026#34;Audio system is now ON\u0026#34;); } public void turnOff() { System.out.println(\u0026#34;Audio system is now OFF\u0026#34;); } public void setVolume(int level) { System.out.println(\u0026#34;Audio volume set to \u0026#34; + level); } } public class VideoSystem { public void turnOn() { System.out.println(\u0026#34;Video system is now ON\u0026#34;); } public void turnOff() { System.out.println(\u0026#34;Video system is now OFF\u0026#34;); } public void setBrightness(int level) { System.out.println(\u0026#34;Video brightness set to \u0026#34; + level); } } public class LightingSystem { public void turnOn() { System.out.println(\u0026#34;Lighting system is now ON\u0026#34;); } public void turnOff() { System.out.println(\u0026#34;Lighting system is now OFF\u0026#34;); } public void setIntensity(int level) { System.out.println(\u0026#34;Lighting intensity set to \u0026#34; + level); } } // Facade 實現 public class HomeTheaterFacade { private final AudioSystem audioSystem; private final VideoSystem videoSystem; private final LightingSystem lightingSystem; public HomeTheaterFacade() { this.audioSystem = new AudioSystem(); this.videoSystem = new VideoSystem(); this.lightingSystem = new LightingSystem(); } public void watchMovie() { System.out.println(\u0026#34;Starting movie experience...\u0026#34;); lightingSystem.turnOn(); lightingSystem.setIntensity(20); audioSystem.turnOn(); audioSystem.setVolume(70); videoSystem.turnOn(); videoSystem.setBrightness(50); System.out.println(\u0026#34;Movie experience ready!\u0026#34;); } public void endMovie() { System.out.println(\u0026#34;Ending movie experience...\u0026#34;); videoSystem.turnOff(); audioSystem.turnOff(); lightingSystem.setIntensity(100); System.out.println(\u0026#34;Movie experience ended!\u0026#34;); } public void partyMode() { System.out.println(\u0026#34;Starting party mode...\u0026#34;); lightingSystem.turnOn(); lightingSystem.setIntensity(100); audioSystem.turnOn(); audioSystem.setVolume(90); System.out.println(\u0026#34;Party mode activated!\u0026#34;); } } 2. 測試示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class FacadePatternDemo { public static void main(String[] args) { HomeTheaterFacade homeTheater = new HomeTheaterFacade(); // 觀看電影 homeTheater.watchMovie(); System.out.println(\u0026#34;\\n--- After movie ---\\n\u0026#34;); // 結束電影 homeTheater.endMovie(); System.out.println(\u0026#34;\\n--- Starting party ---\\n\u0026#34;); // 派對模式 homeTheater.partyMode(); } } 現代 Java 實現 1. 函數式 Facade 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 使用函數式接口 @FunctionalInterface public interface ServiceOperation { void execute(); } public class FunctionalFacade { private final Map\u0026lt;String, List\u0026lt;ServiceOperation\u0026gt;\u0026gt; workflows = new HashMap\u0026lt;\u0026gt;(); public FunctionalFacade() { initializeWorkflows(); } private void initializeWorkflows() { // 定義工作流 workflows.put(\u0026#34;startup\u0026#34;, Arrays.asList( () -\u0026gt; System.out.println(\u0026#34;Initializing database connections\u0026#34;), () -\u0026gt; System.out.println(\u0026#34;Loading configuration\u0026#34;), () -\u0026gt; System.out.println(\u0026#34;Starting web server\u0026#34;), () -\u0026gt; System.out.println(\u0026#34;Registering services\u0026#34;) )); workflows.put(\u0026#34;shutdown\u0026#34;, Arrays.asList( () -\u0026gt; System.out.println(\u0026#34;Stopping web server\u0026#34;), () -\u0026gt; System.out.println(\u0026#34;Closing database connections\u0026#34;), () -\u0026gt; System.out.println(\u0026#34;Saving state\u0026#34;), () -\u0026gt; System.out.println(\u0026#34;Cleanup completed\u0026#34;) )); } public void executeWorkflow(String workflowName) { List\u0026lt;ServiceOperation\u0026gt; operations = workflows.get(workflowName); if (operations != null) { System.out.println(\u0026#34;Executing workflow: \u0026#34; + workflowName); operations.forEach(ServiceOperation::execute); } } public void addOperation(String workflowName, ServiceOperation operation) { workflows.computeIfAbsent(workflowName, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(operation); } } 2. Builder 模式的 Facade 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class FluentFacade { private final List\u0026lt;ServiceOperation\u0026gt; operations = new ArrayList\u0026lt;\u0026gt;(); public FluentFacade initialize() { operations.add(() -\u0026gt; System.out.println(\u0026#34;System initialized\u0026#34;)); return this; } public FluentFacade configure(String config) { operations.add(() -\u0026gt; System.out.println(\u0026#34;Configured with: \u0026#34; + config)); return this; } public FluentFacade start() { operations.add(() -\u0026gt; System.out.println(\u0026#34;System started\u0026#34;)); return this; } public FluentFacade stop() { operations.add(() -\u0026gt; System.out.println(\u0026#34;System stopped\u0026#34;)); return this; } public void execute() { operations.forEach(ServiceOperation::execute); operations.clear(); } } // 使用示例 public class FluentFacadeDemo { public static void main(String[] args) { FluentFacade facade = new FluentFacade(); facade.initialize() .configure(\u0026#34;production\u0026#34;) .start() .execute(); } } 企業級應用模式 1. 服務編排 Facade 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 // 服務接口 public interface UserService { User findById(Long id); User save(User user); void deleteById(Long id); } public interface OrderService { Order createOrder(Order order); List\u0026lt;Order\u0026gt; getOrdersByUserId(Long userId); void cancelOrder(Long orderId); } public interface PaymentService { Payment processPayment(Payment payment); PaymentStatus getPaymentStatus(Long paymentId); } public interface NotificationService { void sendEmail(String to, String subject, String body); void sendSms(String to, String message); } // 企業級 Facade 實現 @Service public class ECommerceFacade { @Autowired private UserService userService; @Autowired private OrderService orderService; @Autowired private PaymentService paymentService; @Autowired private NotificationService notificationService; @Transactional public OrderResult placeOrder(OrderRequest orderRequest) { try { // 1. 驗證用戶 User user = userService.findById(orderRequest.getUserId()); if (user == null) { throw new IllegalArgumentException(\u0026#34;User not found\u0026#34;); } // 2. 創建訂單 Order order = new Order(); order.setUserId(orderRequest.getUserId()); order.setItems(orderRequest.getItems()); order.setTotalAmount(calculateTotal(orderRequest.getItems())); Order createdOrder = orderService.createOrder(order); // 3. 處理支付 Payment payment = new Payment(); payment.setOrderId(createdOrder.getId()); payment.setAmount(createdOrder.getTotalAmount()); payment.setPaymentMethod(orderRequest.getPaymentMethod()); Payment processedPayment = paymentService.processPayment(payment); // 4. 發送通知 notificationService.sendEmail( user.getEmail(), \u0026#34;Order Confirmation\u0026#34;, \u0026#34;Your order #\u0026#34; + createdOrder.getId() + \u0026#34; has been placed successfully\u0026#34; ); return new OrderResult(createdOrder, processedPayment, \u0026#34;SUCCESS\u0026#34;); } catch (Exception e) { return new OrderResult(null, null, \u0026#34;ERROR: \u0026#34; + e.getMessage()); } } @Transactional public CancellationResult cancelOrder(Long orderId, Long userId) { try { // 1. 驗證用戶權限 User user = userService.findById(userId); if (user == null) { throw new IllegalArgumentException(\u0026#34;User not found\u0026#34;); } // 2. 取消訂單 orderService.cancelOrder(orderId); // 3. 處理退款 // (退款邏輯) // 4. 發送取消通知 notificationService.sendEmail( user.getEmail(), \u0026#34;Order Cancellation\u0026#34;, \u0026#34;Your order #\u0026#34; + orderId + \u0026#34; has been cancelled\u0026#34; ); return new CancellationResult(orderId, \u0026#34;SUCCESS\u0026#34;); } catch (Exception e) { return new CancellationResult(orderId, \u0026#34;ERROR: \u0026#34; + e.getMessage()); } } public UserDashboard getUserDashboard(Long userId) { User user = userService.findById(userId); List\u0026lt;Order\u0026gt; orders = orderService.getOrdersByUserId(userId); return new UserDashboard(user, orders); } private BigDecimal calculateTotal(List\u0026lt;OrderItem\u0026gt; items) { return items.stream() .map(item -\u0026gt; item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity()))) .reduce(BigDecimal.ZERO, BigDecimal::add); } } 2. 業務流程 Facade 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 // 業務流程定義 public interface BusinessProcess { ProcessResult execute(ProcessContext context); void rollback(ProcessContext context); String getProcessName(); } // 具體業務流程 @Component public class UserRegistrationProcess implements BusinessProcess { @Autowired private UserService userService; @Autowired private EmailService emailService; @Override public ProcessResult execute(ProcessContext context) { try { UserRegistrationData data = context.getData(UserRegistrationData.class); // 創建用戶 User user = new User(); user.setEmail(data.getEmail()); user.setName(data.getName()); user.setStatus(UserStatus.PENDING); User savedUser = userService.save(user); // 發送驗證郵件 emailService.sendVerificationEmail(savedUser.getEmail(), savedUser.getId()); context.setResult(\u0026#34;userId\u0026#34;, savedUser.getId()); return ProcessResult.success(\u0026#34;User registration initiated\u0026#34;); } catch (Exception e) { return ProcessResult.failure(\u0026#34;Registration failed: \u0026#34; + e.getMessage()); } } @Override public void rollback(ProcessContext context) { Long userId = context.getResult(\u0026#34;userId\u0026#34;, Long.class); if (userId != null) { userService.deleteById(userId); } } @Override public String getProcessName() { return \u0026#34;USER_REGISTRATION\u0026#34;; } } // 業務流程 Facade @Service public class BusinessProcessFacade { private final Map\u0026lt;String, BusinessProcess\u0026gt; processes; public BusinessProcessFacade(List\u0026lt;BusinessProcess\u0026gt; businessProcesses) { this.processes = businessProcesses.stream() .collect(Collectors.toMap( BusinessProcess::getProcessName, Function.identity() )); } public ProcessResult executeProcess(String processName, ProcessContext context) { BusinessProcess process = processes.get(processName); if (process == null) { return ProcessResult.failure(\u0026#34;Process not found: \u0026#34; + processName); } try { return process.execute(context); } catch (Exception e) { return ProcessResult.failure(\u0026#34;Process execution failed: \u0026#34; + e.getMessage()); } } public void rollbackProcess(String processName, ProcessContext context) { BusinessProcess process = processes.get(processName); if (process != null) { process.rollback(context); } } public List\u0026lt;String\u0026gt; getAvailableProcesses() { return new ArrayList\u0026lt;\u0026gt;(processes.keySet()); } } 微服務 Facade 1. API Gateway Facade 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 // 微服務客戶端 @FeignClient(name = \u0026#34;user-service\u0026#34;) public interface UserServiceClient { @GetMapping(\u0026#34;/users/{id}\u0026#34;) User getUser(@PathVariable Long id); @PostMapping(\u0026#34;/users\u0026#34;) User createUser(@RequestBody User user); } @FeignClient(name = \u0026#34;order-service\u0026#34;) public interface OrderServiceClient { @GetMapping(\u0026#34;/orders/{id}\u0026#34;) Order getOrder(@PathVariable Long id); @PostMapping(\u0026#34;/orders\u0026#34;) Order createOrder(@RequestBody Order order); @GetMapping(\u0026#34;/orders/user/{userId}\u0026#34;) List\u0026lt;Order\u0026gt; getOrdersByUserId(@PathVariable Long userId); } @FeignClient(name = \u0026#34;payment-service\u0026#34;) public interface PaymentServiceClient { @PostMapping(\u0026#34;/payments\u0026#34;) Payment processPayment(@RequestBody Payment payment); @GetMapping(\u0026#34;/payments/{id}\u0026#34;) Payment getPayment(@PathVariable Long id); } // API Gateway Facade @RestController @RequestMapping(\u0026#34;/api/v1\u0026#34;) public class ApiGatewayFacade { @Autowired private UserServiceClient userService; @Autowired private OrderServiceClient orderService; @Autowired private PaymentServiceClient paymentService; @GetMapping(\u0026#34;/users/{id}/profile\u0026#34;) public ResponseEntity\u0026lt;UserProfile\u0026gt; getUserProfile(@PathVariable Long id) { try { // 並行獲取用戶資料和訂單 CompletableFuture\u0026lt;User\u0026gt; userFuture = CompletableFuture.supplyAsync(() -\u0026gt; userService.getUser(id)); CompletableFuture\u0026lt;List\u0026lt;Order\u0026gt;\u0026gt; ordersFuture = CompletableFuture.supplyAsync(() -\u0026gt; orderService.getOrdersByUserId(id)); // 等待所有請求完成 User user = userFuture.get(); List\u0026lt;Order\u0026gt; orders = ordersFuture.get(); // 組合數據 UserProfile profile = new UserProfile(user, orders); return ResponseEntity.ok(profile); } catch (Exception e) { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(new UserProfile(null, null)); } } @PostMapping(\u0026#34;/checkout\u0026#34;) public ResponseEntity\u0026lt;CheckoutResult\u0026gt; checkout(@RequestBody CheckoutRequest request) { try { // 創建訂單 Order order = new Order(); order.setUserId(request.getUserId()); order.setItems(request.getItems()); order.setTotalAmount(request.getTotalAmount()); Order createdOrder = orderService.createOrder(order); // 處理支付 Payment payment = new Payment(); payment.setOrderId(createdOrder.getId()); payment.setAmount(createdOrder.getTotalAmount()); payment.setPaymentMethod(request.getPaymentMethod()); Payment processedPayment = paymentService.processPayment(payment); CheckoutResult result = new CheckoutResult(createdOrder, processedPayment); return ResponseEntity.ok(result); } catch (Exception e) { return ResponseEntity.status(HttpStatus.BAD_REQUEST) .body(new CheckoutResult(null, null)); } } } 2. 服務聚合 Facade 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 服務聚合器 @Service public class ServiceAggregatorFacade { @Autowired private UserServiceClient userService; @Autowired private OrderServiceClient orderService; @Autowired private PaymentServiceClient paymentService; @Autowired private ProductServiceClient productService; @Async public CompletableFuture\u0026lt;DashboardData\u0026gt; getUserDashboard(Long userId) { // 並行獲取多個服務的數據 CompletableFuture\u0026lt;User\u0026gt; userFuture = CompletableFuture.supplyAsync(() -\u0026gt; userService.getUser(userId)); CompletableFuture\u0026lt;List\u0026lt;Order\u0026gt;\u0026gt; ordersFuture = CompletableFuture.supplyAsync(() -\u0026gt; orderService.getOrdersByUserId(userId)); CompletableFuture\u0026lt;List\u0026lt;Product\u0026gt;\u0026gt; recommendationsFuture = CompletableFuture.supplyAsync(() -\u0026gt; productService.getRecommendations(userId)); // 組合所有結果 return CompletableFuture.allOf(userFuture, ordersFuture, recommendationsFuture) .thenApply(v -\u0026gt; { User user = userFuture.join(); List\u0026lt;Order\u0026gt; orders = ordersFuture.join(); List\u0026lt;Product\u0026gt; recommendations = recommendationsFuture.join(); return new DashboardData(user, orders, recommendations); }); } public OrderSummary getOrderSummary(Long orderId) { // 獲取訂單詳情 Order order = orderService.getOrder(orderId); // 並行獲取用戶和支付信息 CompletableFuture\u0026lt;User\u0026gt; userFuture = CompletableFuture.supplyAsync(() -\u0026gt; userService.getUser(order.getUserId())); CompletableFuture\u0026lt;Payment\u0026gt; paymentFuture = CompletableFuture.supplyAsync(() -\u0026gt; paymentService.getPayment(order.getPaymentId())); try { User user = userFuture.get(); Payment payment = paymentFuture.get(); return new OrderSummary(order, user, payment); } catch (Exception e) { throw new RuntimeException(\u0026#34;Failed to get order summary\u0026#34;, e); } } } 3. 微服務編排 Facade 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // 微服務編排模式 @Service public class MicroserviceOrchestrator { @Autowired private UserServiceClient userService; @Autowired private InventoryServiceClient inventoryService; @Autowired private OrderServiceClient orderService; @Autowired private PaymentServiceClient paymentService; @Autowired private NotificationServiceClient notificationService; @Transactional public CompletableFuture\u0026lt;OrderProcessingResult\u0026gt; processOrder(OrderRequest request) { return CompletableFuture.supplyAsync(() -\u0026gt; { try { // 1. 驗證用戶 User user = userService.getUser(request.getUserId()); if (user == null) { throw new IllegalArgumentException(\u0026#34;User not found\u0026#34;); } // 2. 檢查庫存 InventoryCheckResult inventoryResult = inventoryService.checkAvailability( request.getItems()); if (!inventoryResult.isAvailable()) { throw new IllegalStateException(\u0026#34;Insufficient inventory\u0026#34;); } // 3. 創建訂單 Order order = orderService.createOrder(buildOrder(request)); // 4. 處理支付 Payment payment = paymentService.processPayment( buildPayment(order, request.getPaymentMethod())); // 5. 更新庫存 inventoryService.reserveItems(request.getItems()); // 6. 發送通知 notificationService.sendOrderConfirmation(user.getEmail(), order.getId()); return new OrderProcessingResult(order, payment, \u0026#34;SUCCESS\u0026#34;); } catch (Exception e) { return new OrderProcessingResult(null, null, \u0026#34;ERROR: \u0026#34; + e.getMessage()); } }); } private Order buildOrder(OrderRequest request) { Order order = new Order(); order.setUserId(request.getUserId()); order.setItems(request.getItems()); order.setTotalAmount(calculateTotal(request.getItems())); order.setStatus(OrderStatus.PENDING); return order; } private Payment buildPayment(Order order, PaymentMethod method) { Payment payment = new Payment(); payment.setOrderId(order.getId()); payment.setAmount(order.getTotalAmount()); payment.setPaymentMethod(method); return payment; } private BigDecimal calculateTotal(List\u0026lt;OrderItem\u0026gt; items) { return items.stream() .map(item -\u0026gt; item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity()))) .reduce(BigDecimal.ZERO, BigDecimal::add); } } Spring Boot 集成 1. 自動配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 @Configuration @EnableConfigurationProperties(FacadeProperties.class) public class FacadeAutoConfiguration { @Bean @ConditionalOnMissingBean public BusinessProcessFacade businessProcessFacade(List\u0026lt;BusinessProcess\u0026gt; processes) { return new BusinessProcessFacade(processes); } @Bean @ConditionalOnMissingBean public ServiceAggregatorFacade serviceAggregatorFacade() { return new ServiceAggregatorFacade(); } @Bean @ConditionalOnProperty(prefix = \u0026#34;facade.api-gateway\u0026#34;, name = \u0026#34;enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public ApiGatewayFacade apiGatewayFacade() { return new ApiGatewayFacade(); } @Bean @ConditionalOnProperty(prefix = \u0026#34;facade.orchestrator\u0026#34;, name = \u0026#34;enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public MicroserviceOrchestrator microserviceOrchestrator() { return new MicroserviceOrchestrator(); } } // 配置屬性 @ConfigurationProperties(prefix = \u0026#34;facade\u0026#34;) @Data public class FacadeProperties { private ApiGateway apiGateway = new ApiGateway(); private Orchestrator orchestrator = new Orchestrator(); private CircuitBreaker circuitBreaker = new CircuitBreaker(); @Data public static class ApiGateway { private boolean enabled = true; private int timeout = 5000; private int maxConcurrentRequests = 100; } @Data public static class Orchestrator { private boolean enabled = true; private int maxRetries = 3; private long retryDelay = 1000; } @Data public static class CircuitBreaker { private boolean enabled = true; private int failureThreshold = 5; private long timeout = 60000; } } 2. 健康檢查 Facade 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @Component public class HealthCheckFacade { @Autowired private List\u0026lt;HealthIndicator\u0026gt; healthIndicators; @Autowired private MeterRegistry meterRegistry; public HealthStatus getOverallHealth() { Map\u0026lt;String, Health\u0026gt; healthDetails = new HashMap\u0026lt;\u0026gt;(); boolean allHealthy = true; for (HealthIndicator indicator : healthIndicators) { try { Health health = indicator.health(); healthDetails.put(indicator.getClass().getSimpleName(), health); if (health.getStatus() != Status.UP) { allHealthy = false; } } catch (Exception e) { Health errorHealth = Health.down() .withDetail(\u0026#34;error\u0026#34;, e.getMessage()) .build(); healthDetails.put(indicator.getClass().getSimpleName(), errorHealth); allHealthy = false; } } // 記錄健康狀態指標 meterRegistry.gauge(\u0026#34;health.status\u0026#34;, allHealthy ? 1 : 0); return new HealthStatus(allHealthy ? Status.UP : Status.DOWN, healthDetails); } public Health getServiceHealth(String serviceName) { return healthIndicators.stream() .filter(indicator -\u0026gt; indicator.getClass().getSimpleName().equals(serviceName)) .findFirst() .map(HealthIndicator::health) .orElse(Health.unknown().withDetail(\u0026#34;service\u0026#34;, \u0026#34;not found\u0026#34;).build()); } } 3. 配置管理 Facade 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 @Service public class ConfigurationFacade { @Autowired private Environment environment; @Autowired private ApplicationContext applicationContext; private final Map\u0026lt;String, Object\u0026gt; runtimeConfig = new ConcurrentHashMap\u0026lt;\u0026gt;(); public String getProperty(String key) { return environment.getProperty(key); } public String getProperty(String key, String defaultValue) { return environment.getProperty(key, defaultValue); } public \u0026lt;T\u0026gt; T getProperty(String key, Class\u0026lt;T\u0026gt; targetType) { return environment.getProperty(key, targetType); } public void setRuntimeProperty(String key, Object value) { runtimeConfig.put(key, value); } public Object getRuntimeProperty(String key) { return runtimeConfig.get(key); } public Map\u0026lt;String, Object\u0026gt; getAllRuntimeProperties() { return new HashMap\u0026lt;\u0026gt;(runtimeConfig); } public ConfigurationSummary getConfigurationSummary() { Map\u0026lt;String, Object\u0026gt; activeProfiles = Map.of( \u0026#34;active\u0026#34;, Arrays.asList(environment.getActiveProfiles()), \u0026#34;default\u0026#34;, Arrays.asList(environment.getDefaultProfiles()) ); return new ConfigurationSummary(activeProfiles, runtimeConfig); } public void refreshConfiguration() { // 刷新配置邏輯 applicationContext.publishEvent(new EnvironmentChangeEvent(runtimeConfig.keySet())); } } 性能優化和最佳實踐 1. 緩存 Facade 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @Service public class CachingFacade { @Autowired private CacheManager cacheManager; @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; public \u0026lt;T\u0026gt; T getFromCache(String cacheName, String key, Class\u0026lt;T\u0026gt; type, Supplier\u0026lt;T\u0026gt; valueLoader) { Cache cache = cacheManager.getCache(cacheName); if (cache != null) { Cache.ValueWrapper cached = cache.get(key); if (cached != null) { return type.cast(cached.get()); } } T value = valueLoader.get(); if (value != null \u0026amp;\u0026amp; cache != null) { cache.put(key, value); } return value; } public void evictFromCache(String cacheName, String key) { Cache cache = cacheManager.getCache(cacheName); if (cache != null) { cache.evict(key); } } public void clearCache(String cacheName) { Cache cache = cacheManager.getCache(cacheName); if (cache != null) { cache.clear(); } } public CacheStatistics getCacheStatistics(String cacheName) { // 獲取緩存統計信息 return new CacheStatistics(cacheName, 0, 0, 0); // 簡化實現 } } 2. 批處理 Facade 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @Service public class BatchProcessingFacade { @Autowired private TaskExecutor taskExecutor; private final Map\u0026lt;String, List\u0026lt;BatchOperation\u0026gt;\u0026gt; batchQueues = new ConcurrentHashMap\u0026lt;\u0026gt;(); public void addToBatch(String batchId, BatchOperation operation) { batchQueues.computeIfAbsent(batchId, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(operation); } public CompletableFuture\u0026lt;BatchResult\u0026gt; processBatch(String batchId) { List\u0026lt;BatchOperation\u0026gt; operations = batchQueues.remove(batchId); if (operations == null || operations.isEmpty()) { return CompletableFuture.completedFuture(new BatchResult(batchId, 0, 0)); } return CompletableFuture.supplyAsync(() -\u0026gt; { int successful = 0; int failed = 0; for (BatchOperation operation : operations) { try { operation.execute(); successful++; } catch (Exception e) { failed++; } } return new BatchResult(batchId, successful, failed); }, taskExecutor); } public void schedulePeriodicBatch(String batchId, long interval) { ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); scheduler.scheduleAtFixedRate(() -\u0026gt; { if (batchQueues.containsKey(batchId)) { processBatch(batchId); } }, interval, interval, TimeUnit.MILLISECONDS); } } 3. 監控 Facade 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @Service public class MonitoringFacade { @Autowired private MeterRegistry meterRegistry; private final Map\u0026lt;String, Timer\u0026gt; timers = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final Map\u0026lt;String, Counter\u0026gt; counters = new ConcurrentHashMap\u0026lt;\u0026gt;(); public \u0026lt;T\u0026gt; T monitorOperation(String operationName, Supplier\u0026lt;T\u0026gt; operation) { Timer timer = timers.computeIfAbsent(operationName, name -\u0026gt; Timer.builder(name).register(meterRegistry)); Counter successCounter = counters.computeIfAbsent(operationName + \u0026#34;.success\u0026#34;, name -\u0026gt; Counter.builder(name).register(meterRegistry)); Counter errorCounter = counters.computeIfAbsent(operationName + \u0026#34;.error\u0026#34;, name -\u0026gt; Counter.builder(name).register(meterRegistry)); return timer.recordCallable(() -\u0026gt; { try { T result = operation.get(); successCounter.increment(); return result; } catch (Exception e) { errorCounter.increment(); throw e; } }); } public void recordMetric(String name, double value) { Gauge.builder(name) .register(meterRegistry, value, val -\u0026gt; val); } public void incrementCounter(String name) { Counter counter = counters.computeIfAbsent(name, counterName -\u0026gt; Counter.builder(counterName).register(meterRegistry)); counter.increment(); } public MetricsSummary getMetricsSummary() { return new MetricsSummary( timers.size(), counters.size(), meterRegistry.getMeters().size() ); } } 測試策略 1. 單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @ExtendWith(MockitoExtension.class) class ECommerceFacadeTest { @Mock private UserService userService; @Mock private OrderService orderService; @Mock private PaymentService paymentService; @Mock private NotificationService notificationService; @InjectMocks private ECommerceFacade eCommerceFacade; @Test void testPlaceOrder_Success() { // 準備測試數據 OrderRequest request = new OrderRequest(); request.setUserId(1L); request.setItems(Arrays.asList(new OrderItem(\u0026#34;Product1\u0026#34;, 2, BigDecimal.valueOf(100)))); request.setPaymentMethod(PaymentMethod.CREDIT_CARD); User user = new User(1L, \u0026#34;John Doe\u0026#34;, \u0026#34;john@example.com\u0026#34;); Order order = new Order(1L, 1L, BigDecimal.valueOf(200)); Payment payment = new Payment(1L, 1L, BigDecimal.valueOf(200)); // 模擬服務調用 when(userService.findById(1L)).thenReturn(user); when(orderService.createOrder(any(Order.class))).thenReturn(order); when(paymentService.processPayment(any(Payment.class))).thenReturn(payment); // 執行測試 OrderResult result = eCommerceFacade.placeOrder(request); // 驗證結果 assertThat(result.getStatus()).isEqualTo(\u0026#34;SUCCESS\u0026#34;); assertThat(result.getOrder()).isNotNull(); assertThat(result.getPayment()).isNotNull(); // 驗證服務調用 verify(userService).findById(1L); verify(orderService).createOrder(any(Order.class)); verify(paymentService).processPayment(any(Payment.class)); verify(notificationService).sendEmail(eq(user.getEmail()), anyString(), anyString()); } @Test void testPlaceOrder_UserNotFound() { // 準備測試數據 OrderRequest request = new OrderRequest(); request.setUserId(999L); when(userService.findById(999L)).thenReturn(null); // 執行測試 OrderResult result = eCommerceFacade.placeOrder(request); // 驗證結果 assertThat(result.getStatus()).startsWith(\u0026#34;ERROR\u0026#34;); assertThat(result.getOrder()).isNull(); assertThat(result.getPayment()).isNull(); } } 2. 集成測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @SpringBootTest @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) class ApiGatewayFacadeIntegrationTest { @Autowired private TestRestTemplate restTemplate; @MockBean private UserServiceClient userServiceClient; @MockBean private OrderServiceClient orderServiceClient; @Test void testGetUserProfile() { // 準備測試數據 User user = new User(1L, \u0026#34;John Doe\u0026#34;, \u0026#34;john@example.com\u0026#34;); List\u0026lt;Order\u0026gt; orders = Arrays.asList( new Order(1L, 1L, BigDecimal.valueOf(100)), new Order(2L, 1L, BigDecimal.valueOf(200)) ); when(userServiceClient.getUser(1L)).thenReturn(user); when(orderServiceClient.getOrdersByUserId(1L)).thenReturn(orders); // 執行測試 ResponseEntity\u0026lt;UserProfile\u0026gt; response = restTemplate.getForEntity( \u0026#34;/api/v1/users/1/profile\u0026#34;, UserProfile.class); // 驗證結果 assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK); assertThat(response.getBody().getUser()).isEqualTo(user); assertThat(response.getBody().getOrders()).hasSize(2); } } 最佳實踐 1. 設計原則 單一職責: 每個 Facade 只負責一個業務領域 簡化接口: 提供簡潔易用的接口 松耦合: 避免 Facade 與子系統緊密耦合 可測試性: 確保 Facade 易於測試 2. 實現建議 使用依賴注入管理子系統依賴 實現適當的異常處理 考慮使用異步處理提高性能 提供詳細的日誌記錄 3. 性能考慮 使用緩存減少重複計算 實現批處理減少網絡調用 考慮使用並行處理 監控和優化關鍵路徑 4. 常見陷阱 避免 Facade 變得過於複雜 不要在 Facade 中實現業務邏輯 避免 Facade 之間的循環依賴 注意事務邊界和一致性 適用場景 何時使用 複雜子系統: 當子系統過於複雜時 多服務集成: 需要整合多個服務時 API 簡化: 需要簡化 API 接口時 微服務聚合: 需要聚合多個微服務時 何時避免 簡單系統: 當系統足夠簡單時 性能關鍵: 當額外的抽象層會影響性能時 頻繁變更: 當子系統頻繁變更時 總結 Facade Pattern 是一個非常實用的設計模式，特別適合現代企業級應用和微服務架構。通過提供統一的接口，它能夠有效地隱藏系統的複雜性，提高系統的可用性和可維護性。\n在微服務架構中，Facade Pattern 可以作為 API Gateway 或服務聚合器，幫助管理複雜的服務間通信。結合 Spring Boot 的自動配置和依賴注入功能，我們可以創建出既靈活又高效的 Facade 實現。\n關鍵是要理解何時使用 Facade Pattern，以及如何正確地設計和實現它。通過合理使用 Facade Pattern，我們可以構建出既簡潔又功能強大的企業級應用系統。\n","permalink":"https://xinqilin.github.io/post/architecture/facade/","tags":["Design Pattern","Structural","Facade","Spring","Microservices","Enterprise"],"title":"DesignPattern - Structural - Facade"},{"content":"Flyweight Flyweight 中，我們重複使用對象，而不是創建大量相似的對象。我們可以使用它來減少內存需求和實例化時間以及相關成本。\n在我們應用 Flyweight 之前，我們需要考慮以下因素：\n如果應用程序中所需的對像數量巨大。 如果對象創建佔用大量內存並且也可能很耗時。 太多的對象會降低應用程序的性能。顯然，太多的對象可能會消耗更大的內存。此外，它們可能會降低應用程序的速度，甚至可能導致內存不足問題。 在應用程序中控制它。當我們有很多相似的對象並且池中的兩個對象之間沒有太多差異時，尤其如此。 有時，應用程序中的對象可能具有很大的相似性並且屬於相似類型（此處的相似類型意味著它們的大多數屬性具有相似的值，並且只有少數屬性值不同）。如果它們也是要創建的重物，應用程序開發人員應該控制它們。否則，它們可能會消耗大量內存並最終減慢整個應用程序的速度。\nFlyweight 旨在控制此類對象的創建，並為您提供基本的緩存機制。它允許您為每種類型創建一個對象（此處的類型因該對象的屬性而異），如果您請求具有相同屬性的對象（已創建），它將返回相同的對象而不是創建一個新的對象一。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public interface Msg { public void show(String msg); } public class EmergentMsg implements Msg { private String key; EmergentMsg(String key) { this.key = key; System.out.println(\u0026#34;send \u0026#34; + key + \u0026#34; emergent msg\u0026#34;); } public void show(String msg) { System.out.println(msg); } } public class MsgFactory { private static MsgFactory FACTORY = new MsgFactory(); private static Map\u0026lt;String, Msg\u0026gt; msgs = new HashMap\u0026lt;\u0026gt;(); public static MsgFactory getInstance() { // 看要不要 double lock check return FACTORY; } public Msg getMsg(String key) { Msg msg = (Msg)msgs.get(key); if (msg != null) { System.out.println(\u0026#34;msg \u0026#34; + key + \u0026#34; exist\u0026#34;); } else { msg = new EmergentMsg(key); msgs.put(key, msg); } return msg; } } 有點像資源重複使用 maybe, service locator pattern !?\n","permalink":"https://xinqilin.github.io/post/architecture/flyweight/","tags":[],"title":"DesignPattern - Structural - Flyweight"},{"content":"Proxy Pattern 概述 Proxy Pattern 是一種結構型設計模式，它為另一個對象提供一個代理或占位符，以控制對它的訪問。代理對象與原始對象具有相同的接口，因此客戶端可以透明地使用代理而無需知道它們正在與代理交互。\n核心概念 關鍵特性 訪問控制: 控制對原始對象的訪問 懶加載: 延遲對象的創建直到真正需要時 緩存: 緩存結果以提高性能 日誌記錄: 記錄方法調用和結果 權限檢查: 在訪問前進行安全檢查 代理類型 虛擬代理: 控制對昂貴對象的訪問 遠程代理: 控制對遠程對象的訪問 保護代理: 控制對敏感對象的訪問 智能代理: 提供額外功能如引用計數、緩存等 結構組件 Subject: 定義代理和真實對象的共同接口 RealSubject: 真實對象，實現實際的業務邏輯 Proxy: 代理對象，控制對真實對象的訪問 基本實現 1. 經典代理實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 // 主題接口 public interface Subject { void request(); String getData(); } // 真實對象 public class RealSubject implements Subject { private String data; public RealSubject() { // 模擬昂貴的初始化過程 System.out.println(\u0026#34;RealSubject: Initializing...\u0026#34;); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } this.data = \u0026#34;Important data\u0026#34;; System.out.println(\u0026#34;RealSubject: Initialized\u0026#34;); } @Override public void request() { System.out.println(\u0026#34;RealSubject: Handling request\u0026#34;); } @Override public String getData() { return data; } } // 代理對象 public class Proxy implements Subject { private RealSubject realSubject; private String cachedData; private boolean accessGranted; public Proxy(boolean accessGranted) { this.accessGranted = accessGranted; } @Override public void request() { if (!accessGranted) { System.out.println(\u0026#34;Proxy: Access denied\u0026#34;); return; } System.out.println(\u0026#34;Proxy: Checking access before request\u0026#34;); if (realSubject == null) { realSubject = new RealSubject(); } System.out.println(\u0026#34;Proxy: Logging request\u0026#34;); realSubject.request(); System.out.println(\u0026#34;Proxy: Request completed\u0026#34;); } @Override public String getData() { if (!accessGranted) { return \u0026#34;Access denied\u0026#34;; } // 緩存實現 if (cachedData != null) { System.out.println(\u0026#34;Proxy: Returning cached data\u0026#34;); return cachedData; } if (realSubject == null) { realSubject = new RealSubject(); } cachedData = realSubject.getData(); System.out.println(\u0026#34;Proxy: Data cached\u0026#34;); return cachedData; } } 2. 測試示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ProxyPatternDemo { public static void main(String[] args) { System.out.println(\u0026#34;=== Testing with access granted ===\u0026#34;); Subject proxy1 = new Proxy(true); proxy1.request(); System.out.println(\u0026#34;\\n=== Testing caching ===\u0026#34;); String data1 = proxy1.getData(); String data2 = proxy1.getData(); // 應該返回緩存數據 System.out.println(\u0026#34;\\n=== Testing with access denied ===\u0026#34;); Subject proxy2 = new Proxy(false); proxy2.request(); String data3 = proxy2.getData(); System.out.println(\u0026#34;Data1: \u0026#34; + data1); System.out.println(\u0026#34;Data2: \u0026#34; + data2); System.out.println(\u0026#34;Data3: \u0026#34; + data3); } } 動態代理實現 1. Java 動態代理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 // 業務接口 public interface UserService { User findById(Long id); User save(User user); void deleteById(Long id); List\u0026lt;User\u0026gt; findAll(); } // 業務實現 public class UserServiceImpl implements UserService { private final Map\u0026lt;Long, User\u0026gt; users = new ConcurrentHashMap\u0026lt;\u0026gt;(); @Override public User findById(Long id) { System.out.println(\u0026#34;UserServiceImpl: Finding user with id \u0026#34; + id); return users.get(id); } @Override public User save(User user) { System.out.println(\u0026#34;UserServiceImpl: Saving user \u0026#34; + user.getName()); users.put(user.getId(), user); return user; } @Override public void deleteById(Long id) { System.out.println(\u0026#34;UserServiceImpl: Deleting user with id \u0026#34; + id); users.remove(id); } @Override public List\u0026lt;User\u0026gt; findAll() { System.out.println(\u0026#34;UserServiceImpl: Finding all users\u0026#34;); return new ArrayList\u0026lt;\u0026gt;(users.values()); } } // 動態代理處理器 public class ServiceInvocationHandler implements InvocationHandler { private final Object target; private final Map\u0026lt;String, Object\u0026gt; cache = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final Set\u0026lt;String\u0026gt; cacheableMethods = Set.of(\u0026#34;findById\u0026#34;, \u0026#34;findAll\u0026#34;); public ServiceInvocationHandler(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String methodName = method.getName(); // 日誌記錄 System.out.println(\u0026#34;Proxy: Before method \u0026#34; + methodName); long startTime = System.currentTimeMillis(); try { // 緩存邏輯 if (cacheableMethods.contains(methodName)) { String cacheKey = generateCacheKey(methodName, args); Object cachedResult = cache.get(cacheKey); if (cachedResult != null) { System.out.println(\u0026#34;Proxy: Returning cached result for \u0026#34; + methodName); return cachedResult; } Object result = method.invoke(target, args); cache.put(cacheKey, result); System.out.println(\u0026#34;Proxy: Result cached for \u0026#34; + methodName); return result; } // 清除緩存邏輯 if (methodName.startsWith(\u0026#34;save\u0026#34;) || methodName.startsWith(\u0026#34;delete\u0026#34;)) { cache.clear(); System.out.println(\u0026#34;Proxy: Cache cleared due to \u0026#34; + methodName); } return method.invoke(target, args); } catch (Exception e) { System.out.println(\u0026#34;Proxy: Exception in method \u0026#34; + methodName + \u0026#34;: \u0026#34; + e.getMessage()); throw e; } finally { long endTime = System.currentTimeMillis(); System.out.println(\u0026#34;Proxy: Method \u0026#34; + methodName + \u0026#34; completed in \u0026#34; + (endTime - startTime) + \u0026#34;ms\u0026#34;); } } private String generateCacheKey(String methodName, Object[] args) { return methodName + \u0026#34;:\u0026#34; + Arrays.toString(args); } } // 代理工廠 public class ProxyFactory { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static \u0026lt;T\u0026gt; T createProxy(T target, Class\u0026lt;T\u0026gt; interfaceClass) { return (T) Proxy.newProxyInstance( interfaceClass.getClassLoader(), new Class[]{interfaceClass}, new ServiceInvocationHandler(target) ); } } 2. 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class DynamicProxyDemo { public static void main(String[] args) { UserService userService = new UserServiceImpl(); UserService proxy = ProxyFactory.createProxy(userService, UserService.class); // 測試緩存 User user = new User(1L, \u0026#34;John Doe\u0026#34;); proxy.save(user); // 第一次查詢 User found1 = proxy.findById(1L); // 第二次查詢（應該從緩存獲取） User found2 = proxy.findById(1L); // 修改數據（應該清除緩存） proxy.save(new User(2L, \u0026#34;Jane Smith\u0026#34;)); // 再次查詢（應該重新執行） User found3 = proxy.findById(1L); } } Spring AOP 代理 1. Spring AOP 註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 自定義註解 @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Cacheable { String value() default \u0026#34;\u0026#34;; int ttl() default 300; boolean condition() default true; } @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface RateLimited { int value() default 10; // requests per second String key() default \u0026#34;\u0026#34;; } @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Audited { String value() default \u0026#34;\u0026#34;; AuditLevel level() default AuditLevel.INFO; } @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Secured { String[] roles() default {}; String[] permissions() default {}; } // 審計級別 public enum AuditLevel { INFO, WARN, ERROR } 2. Spring AOP 切面實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 @Aspect @Component public class CachingAspect { @Autowired private CacheManager cacheManager; @Around(\u0026#34;@annotation(cacheable)\u0026#34;) public Object cacheResult(ProceedingJoinPoint joinPoint, Cacheable cacheable) throws Throwable { String cacheName = cacheable.value().isEmpty() ? joinPoint.getSignature().getDeclaringType().getSimpleName() : cacheable.value(); Cache cache = cacheManager.getCache(cacheName); if (cache == null) { return joinPoint.proceed(); } String key = generateCacheKey(joinPoint); Cache.ValueWrapper cachedValue = cache.get(key); if (cachedValue != null) { return cachedValue.get(); } Object result = joinPoint.proceed(); cache.put(key, result); return result; } private String generateCacheKey(ProceedingJoinPoint joinPoint) { StringBuilder keyBuilder = new StringBuilder(); keyBuilder.append(joinPoint.getSignature().getName()); for (Object arg : joinPoint.getArgs()) { keyBuilder.append(\u0026#34;:\u0026#34;).append(arg); } return keyBuilder.toString(); } } @Aspect @Component public class RateLimitingAspect { private final Map\u0026lt;String, RateLimiter\u0026gt; rateLimiters = new ConcurrentHashMap\u0026lt;\u0026gt;(); @Before(\u0026#34;@annotation(rateLimited)\u0026#34;) public void checkRateLimit(JoinPoint joinPoint, RateLimited rateLimited) { String key = rateLimited.key().isEmpty() ? joinPoint.getSignature().toShortString() : rateLimited.key(); RateLimiter rateLimiter = rateLimiters.computeIfAbsent(key, k -\u0026gt; RateLimiter.create(rateLimited.value())); if (!rateLimiter.tryAcquire()) { throw new RateLimitExceededException(\u0026#34;Rate limit exceeded for \u0026#34; + key); } } } @Aspect @Component public class AuditingAspect { private static final Logger logger = LoggerFactory.getLogger(AuditingAspect.class); @Around(\u0026#34;@annotation(audited)\u0026#34;) public Object audit(ProceedingJoinPoint joinPoint, Audited audited) throws Throwable { String methodName = joinPoint.getSignature().getName(); String auditMessage = audited.value().isEmpty() ? methodName : audited.value(); logger.info(\u0026#34;Audit: Starting method {} with args: {}\u0026#34;, methodName, Arrays.toString(joinPoint.getArgs())); long startTime = System.currentTimeMillis(); try { Object result = joinPoint.proceed(); long endTime = System.currentTimeMillis(); logger.info(\u0026#34;Audit: Method {} completed successfully in {}ms\u0026#34;, methodName, endTime - startTime); return result; } catch (Exception e) { logger.error(\u0026#34;Audit: Method {} failed with exception: {}\u0026#34;, methodName, e.getMessage()); throw e; } } } @Aspect @Component public class SecurityAspect { @Autowired private SecurityService securityService; @Before(\u0026#34;@annotation(secured)\u0026#34;) public void checkSecurity(JoinPoint joinPoint, Secured secured) { String[] requiredRoles = secured.roles(); String[] requiredPermissions = secured.permissions(); Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (authentication == null || !authentication.isAuthenticated()) { throw new SecurityException(\u0026#34;User not authenticated\u0026#34;); } if (requiredRoles.length \u0026gt; 0) { for (String role : requiredRoles) { if (!securityService.hasRole(authentication, role)) { throw new SecurityException(\u0026#34;Insufficient role: \u0026#34; + role); } } } if (requiredPermissions.length \u0026gt; 0) { for (String permission : requiredPermissions) { if (!securityService.hasPermission(authentication, permission)) { throw new SecurityException(\u0026#34;Insufficient permission: \u0026#34; + permission); } } } } } 3. 使用 AOP 代理的服務 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @Service @Transactional public class EnhancedUserService implements UserService { @Autowired private UserRepository userRepository; @Override @Cacheable(value = \u0026#34;users\u0026#34;, ttl = 600) @RateLimited(value = 20) @Audited(\u0026#34;Finding user by ID\u0026#34;) @Secured(permissions = {\u0026#34;USER_READ\u0026#34;}) public User findById(Long id) { return userRepository.findById(id).orElse(null); } @Override @RateLimited(value = 5) @Audited(\u0026#34;Saving user\u0026#34;) @Secured(permissions = {\u0026#34;USER_WRITE\u0026#34;}) public User save(User user) { return userRepository.save(user); } @Override @RateLimited(value = 2) @Audited(value = \u0026#34;Deleting user\u0026#34;, level = AuditLevel.WARN) @Secured(permissions = {\u0026#34;USER_DELETE\u0026#34;}) public void deleteById(Long id) { userRepository.deleteById(id); } @Override @Cacheable(value = \u0026#34;users\u0026#34;, ttl = 300) @RateLimited(value = 10) @Audited(\u0026#34;Finding all users\u0026#34;) @Secured(permissions = {\u0026#34;USER_READ\u0026#34;}) public List\u0026lt;User\u0026gt; findAll() { return userRepository.findAll(); } } 企業級代理模式 1. 數據庫連接池代理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 // 數據庫連接接口 public interface DatabaseConnection { ResultSet executeQuery(String sql); int executeUpdate(String sql); void close(); boolean isClosed(); } // 真實連接實現 public class RealDatabaseConnection implements DatabaseConnection { private final Connection connection; public RealDatabaseConnection(String url, String username, String password) throws SQLException { this.connection = DriverManager.getConnection(url, username, password); } @Override public ResultSet executeQuery(String sql) { try { return connection.createStatement().executeQuery(sql); } catch (SQLException e) { throw new RuntimeException(\u0026#34;Query execution failed\u0026#34;, e); } } @Override public int executeUpdate(String sql) { try { return connection.createStatement().executeUpdate(sql); } catch (SQLException e) { throw new RuntimeException(\u0026#34;Update execution failed\u0026#34;, e); } } @Override public void close() { try { connection.close(); } catch (SQLException e) { throw new RuntimeException(\u0026#34;Connection close failed\u0026#34;, e); } } @Override public boolean isClosed() { try { return connection.isClosed(); } catch (SQLException e) { return true; } } } // 連接池代理 public class ConnectionPoolProxy implements DatabaseConnection { private final DatabaseConnection realConnection; private final ConnectionPool pool; private boolean closed = false; public ConnectionPoolProxy(DatabaseConnection realConnection, ConnectionPool pool) { this.realConnection = realConnection; this.pool = pool; } @Override public ResultSet executeQuery(String sql) { if (closed) { throw new IllegalStateException(\u0026#34;Connection is closed\u0026#34;); } return realConnection.executeQuery(sql); } @Override public int executeUpdate(String sql) { if (closed) { throw new IllegalStateException(\u0026#34;Connection is closed\u0026#34;); } return realConnection.executeUpdate(sql); } @Override public void close() { if (!closed) { closed = true; pool.returnConnection(realConnection); } } @Override public boolean isClosed() { return closed; } } // 連接池實現 @Component public class ConnectionPool { private final Queue\u0026lt;DatabaseConnection\u0026gt; availableConnections = new ConcurrentLinkedQueue\u0026lt;\u0026gt;(); private final Set\u0026lt;DatabaseConnection\u0026gt; usedConnections = ConcurrentHashMap.newKeySet(); private final String url; private final String username; private final String password; private final int maxPoolSize; public ConnectionPool(@Value(\u0026#34;${db.url}\u0026#34;) String url, @Value(\u0026#34;${db.username}\u0026#34;) String username, @Value(\u0026#34;${db.password}\u0026#34;) String password, @Value(\u0026#34;${db.pool.maxSize:10}\u0026#34;) int maxPoolSize) { this.url = url; this.username = username; this.password = password; this.maxPoolSize = maxPoolSize; // 初始化連接池 initializePool(); } private void initializePool() { for (int i = 0; i \u0026lt; maxPoolSize / 2; i++) { try { availableConnections.offer(new RealDatabaseConnection(url, username, password)); } catch (SQLException e) { throw new RuntimeException(\u0026#34;Failed to initialize connection pool\u0026#34;, e); } } } public DatabaseConnection getConnection() { DatabaseConnection connection = availableConnections.poll(); if (connection == null) { if (usedConnections.size() \u0026lt; maxPoolSize) { try { connection = new RealDatabaseConnection(url, username, password); } catch (SQLException e) { throw new RuntimeException(\u0026#34;Failed to create new connection\u0026#34;, e); } } else { throw new RuntimeException(\u0026#34;Connection pool exhausted\u0026#34;); } } usedConnections.add(connection); return new ConnectionPoolProxy(connection, this); } public void returnConnection(DatabaseConnection connection) { if (usedConnections.remove(connection)) { if (!connection.isClosed()) { availableConnections.offer(connection); } } } } 2. 微服務代理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 // 微服務客戶端接口 public interface OrderService { Order createOrder(Order order); Order getOrder(Long orderId); List\u0026lt;Order\u0026gt; getOrdersByUserId(Long userId); void cancelOrder(Long orderId); } // 遠程服務代理 @Component public class OrderServiceProxy implements OrderService { @Autowired private RestTemplate restTemplate; @Value(\u0026#34;${order.service.url}\u0026#34;) private String orderServiceUrl; private final CircuitBreaker circuitBreaker; private final Cache cache; public OrderServiceProxy(CircuitBreaker circuitBreaker, Cache cache) { this.circuitBreaker = circuitBreaker; this.cache = cache; } @Override @Retryable(value = {Exception.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000)) public Order createOrder(Order order) { return circuitBreaker.executeSupplier(() -\u0026gt; { String url = orderServiceUrl + \u0026#34;/orders\u0026#34;; return restTemplate.postForObject(url, order, Order.class); }); } @Override public Order getOrder(Long orderId) { String cacheKey = \u0026#34;order:\u0026#34; + orderId; Order cachedOrder = cache.get(cacheKey, Order.class); if (cachedOrder != null) { return cachedOrder; } Order order = circuitBreaker.executeSupplier(() -\u0026gt; { String url = orderServiceUrl + \u0026#34;/orders/\u0026#34; + orderId; return restTemplate.getForObject(url, Order.class); }); if (order != null) { cache.put(cacheKey, order); } return order; } @Override public List\u0026lt;Order\u0026gt; getOrdersByUserId(Long userId) { String cacheKey = \u0026#34;orders:user:\u0026#34; + userId; List\u0026lt;Order\u0026gt; cachedOrders = cache.get(cacheKey, List.class); if (cachedOrders != null) { return cachedOrders; } List\u0026lt;Order\u0026gt; orders = circuitBreaker.executeSupplier(() -\u0026gt; { String url = orderServiceUrl + \u0026#34;/orders?userId=\u0026#34; + userId; return Arrays.asList(restTemplate.getForObject(url, Order[].class)); }); if (orders != null) { cache.put(cacheKey, orders); } return orders; } @Override public void cancelOrder(Long orderId) { circuitBreaker.executeSupplier(() -\u0026gt; { String url = orderServiceUrl + \u0026#34;/orders/\u0026#34; + orderId + \u0026#34;/cancel\u0026#34;; restTemplate.put(url, null); // 清除相關緩存 cache.evict(\u0026#34;order:\u0026#34; + orderId); return null; }); } } 3. 緩存代理實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 // 多級緩存代理 @Component public class MultiLevelCacheProxy\u0026lt;T\u0026gt; { private final Cache l1Cache; // 本地緩存 private final Cache l2Cache; // 分布式緩存 private final int l1Ttl; private final int l2Ttl; public MultiLevelCacheProxy(@Qualifier(\u0026#34;l1Cache\u0026#34;) Cache l1Cache, @Qualifier(\u0026#34;l2Cache\u0026#34;) Cache l2Cache, @Value(\u0026#34;${cache.l1.ttl:300}\u0026#34;) int l1Ttl, @Value(\u0026#34;${cache.l2.ttl:3600}\u0026#34;) int l2Ttl) { this.l1Cache = l1Cache; this.l2Cache = l2Cache; this.l1Ttl = l1Ttl; this.l2Ttl = l2Ttl; } public T get(String key, Class\u0026lt;T\u0026gt; type, Supplier\u0026lt;T\u0026gt; dataLoader) { // 先查 L1 緩存 T value = l1Cache.get(key, type); if (value != null) { return value; } // 再查 L2 緩存 value = l2Cache.get(key, type); if (value != null) { // 回寫到 L1 緩存 l1Cache.put(key, value); return value; } // 從數據源加載 value = dataLoader.get(); if (value != null) { // 寫入 L2 緩存 l2Cache.put(key, value); // 寫入 L1 緩存 l1Cache.put(key, value); } return value; } public void put(String key, T value) { l1Cache.put(key, value); l2Cache.put(key, value); } public void evict(String key) { l1Cache.evict(key); l2Cache.evict(key); } } // 智能緩存代理 @Component public class SmartCacheProxy { private final RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; private final Map\u0026lt;String, LocalDateTime\u0026gt; accessTimes = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final Map\u0026lt;String, Integer\u0026gt; hitCounts = new ConcurrentHashMap\u0026lt;\u0026gt;(); public SmartCacheProxy(RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate) { this.redisTemplate = redisTemplate; } public \u0026lt;T\u0026gt; T get(String key, Class\u0026lt;T\u0026gt; type, Supplier\u0026lt;T\u0026gt; dataLoader) { // 記錄訪問時間 accessTimes.put(key, LocalDateTime.now()); // 嘗試從緩存獲取 Object cached = redisTemplate.opsForValue().get(key); if (cached != null) { // 增加命中次數 hitCounts.merge(key, 1, Integer::sum); return type.cast(cached); } // 從數據源加載 T value = dataLoader.get(); if (value != null) { // 動態 TTL 策略 int ttl = calculateTtl(key); redisTemplate.opsForValue().set(key, value, ttl, TimeUnit.SECONDS); } return value; } private int calculateTtl(String key) { int baseTime = 300; // 5分鐘 int hitCount = hitCounts.getOrDefault(key, 0); // 熱點數據延長緩存時間 if (hitCount \u0026gt; 100) { return baseTime * 4; // 20分鐘 } else if (hitCount \u0026gt; 50) { return baseTime * 2; // 10分鐘 } return baseTime; } } Spring Boot 集成 1. 自動配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @Configuration @EnableAspectJAutoProxy @EnableConfigurationProperties(ProxyProperties.class) public class ProxyAutoConfiguration { @Bean @ConditionalOnMissingBean public CacheManager cacheManager() { return new ConcurrentMapCacheManager(); } @Bean @ConditionalOnMissingBean public CachingAspect cachingAspect(CacheManager cacheManager) { return new CachingAspect(); } @Bean @ConditionalOnMissingBean public RateLimitingAspect rateLimitingAspect() { return new RateLimitingAspect(); } @Bean @ConditionalOnMissingBean public AuditingAspect auditingAspect() { return new AuditingAspect(); } @Bean @ConditionalOnMissingBean public SecurityAspect securityAspect() { return new SecurityAspect(); } @Bean @ConditionalOnProperty(prefix = \u0026#34;proxy.connection-pool\u0026#34;, name = \u0026#34;enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public ConnectionPool connectionPool(ProxyProperties properties) { ProxyProperties.ConnectionPool poolConfig = properties.getConnectionPool(); return new ConnectionPool( poolConfig.getUrl(), poolConfig.getUsername(), poolConfig.getPassword(), poolConfig.getMaxSize() ); } } // 配置屬性 @ConfigurationProperties(prefix = \u0026#34;proxy\u0026#34;) @Data public class ProxyProperties { private Cache cache = new Cache(); private RateLimit rateLimit = new RateLimit(); private ConnectionPool connectionPool = new ConnectionPool(); @Data public static class Cache { private boolean enabled = true; private int defaultTtl = 300; private String[] cacheNames = {\u0026#34;default\u0026#34;}; } @Data public static class RateLimit { private boolean enabled = true; private int defaultRate = 10; private TimeUnit timeUnit = TimeUnit.SECONDS; } @Data public static class ConnectionPool { private boolean enabled = false; private String url; private String username; private String password; private int maxSize = 10; private int minSize = 2; } } 2. 使用配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # application.yml proxy: cache: enabled: true default-ttl: 600 cache-names: - users - orders - products rate-limit: enabled: true default-rate: 20 time-unit: SECONDS connection-pool: enabled: true url: jdbc:mysql://localhost:3306/mydb username: user password: password max-size: 20 min-size: 5 spring: cache: type: redis redis: host: localhost port: 6379 性能監控和測試 1. 性能監控代理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @Component public class PerformanceMonitoringProxy { private final MeterRegistry meterRegistry; private final Map\u0026lt;String, Timer\u0026gt; timers = new ConcurrentHashMap\u0026lt;\u0026gt;(); public PerformanceMonitoringProxy(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; } public \u0026lt;T\u0026gt; T monitor(String operationName, Supplier\u0026lt;T\u0026gt; operation) { Timer timer = timers.computeIfAbsent(operationName, name -\u0026gt; Timer.builder(name) .description(\u0026#34;Operation performance timer\u0026#34;) .register(meterRegistry)); return timer.recordCallable(() -\u0026gt; { Counter.builder(\u0026#34;operation.calls\u0026#34;) .tag(\u0026#34;operation\u0026#34;, operationName) .register(meterRegistry) .increment(); try { T result = operation.get(); Counter.builder(\u0026#34;operation.success\u0026#34;) .tag(\u0026#34;operation\u0026#34;, operationName) .register(meterRegistry) .increment(); return result; } catch (Exception e) { Counter.builder(\u0026#34;operation.error\u0026#34;) .tag(\u0026#34;operation\u0026#34;, operationName) .tag(\u0026#34;error\u0026#34;, e.getClass().getSimpleName()) .register(meterRegistry) .increment(); throw e; } }); } } 2. 測試策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @ExtendWith(MockitoExtension.class) class ProxyPatternTest { @Mock private UserService mockUserService; @Mock private CacheManager mockCacheManager; @Mock private Cache mockCache; @Test void testCachingProxy() { // 準備測試數據 User user = new User(1L, \u0026#34;John Doe\u0026#34;); when(mockUserService.findById(1L)).thenReturn(user); when(mockCacheManager.getCache(\u0026#34;users\u0026#34;)).thenReturn(mockCache); when(mockCache.get(\u0026#34;findById:1\u0026#34;)).thenReturn(null, new SimpleValueWrapper(user)); // 創建代理 UserService proxy = ProxyFactory.createProxy(mockUserService, UserService.class); // 第一次調用 User result1 = proxy.findById(1L); assertEquals(user, result1); // 第二次調用應該從緩存獲取 User result2 = proxy.findById(1L); assertEquals(user, result2); // 驗證只調用了一次實際服務 verify(mockUserService, times(1)).findById(1L); } @Test void testRateLimitingProxy() throws InterruptedException { RateLimiter rateLimiter = RateLimiter.create(1.0); // 1 request per second // 第一次調用應該成功 assertTrue(rateLimiter.tryAcquire()); // 立即第二次調用應該失敗 assertFalse(rateLimiter.tryAcquire()); // 等待一秒後應該可以再次調用 Thread.sleep(1100); assertTrue(rateLimiter.tryAcquire()); } } @SpringBootTest class ProxyIntegrationTest { @Autowired private UserService userService; @MockBean private UserRepository userRepository; @Test void testAopProxy() { User user = new User(1L, \u0026#34;John Doe\u0026#34;); when(userRepository.findById(1L)).thenReturn(Optional.of(user)); // 測試緩存 User result1 = userService.findById(1L); User result2 = userService.findById(1L); assertEquals(user, result1); assertEquals(user, result2); // 由於緩存，只應該調用一次 verify(userRepository, times(1)).findById(1L); } } 最佳實踐 1. 設計原則 透明性: 代理應該對客戶端透明 單一職責: 每個代理只處理一個關注點 性能: 避免不必要的代理層 線程安全: 確保代理是線程安全的 2. 實現建議 使用接口而不是具體類 考慮使用組合而非繼承 實現適當的錯誤處理 提供配置選項 3. 性能考慮 避免過度代理 使用合適的緩存策略 監控代理性能 考慮異步處理 4. 常見陷阱 避免無限遞歸 注意內存洩漏 正確處理異常 考慮並發問題 適用場景 何時使用 訪問控制: 需要控制對對象的訪問 懶加載: 延遲對象的創建 緩存: 緩存昂貴的操作結果 遠程訪問: 訪問遠程對象 日誌記錄: 記錄方法調用 何時避免 簡單場景: 當代理沒有提供額外價值時 性能關鍵: 當代理會顯著影響性能時 過度複雜: 當代理層次過多時 總結 Proxy Pattern 是一個非常強大和靈活的設計模式，特別是在企業級應用中。通過與 Spring AOP 的結合，我們可以創建出非常優雅和功能豐富的代理實現。\n現代 Java 的動態代理機制為我們提供了強大的工具來實現各種代理模式，而 Spring Boot 的自動配置功能使得集成變得非常簡單。\n關鍵是要理解不同類型的代理模式，以及如何根據具體需求選擇合適的實現方式。通過合理使用代理模式，我們可以構建出既高效又易於維護的企業級應用系統。\n","permalink":"https://xinqilin.github.io/post/architecture/proxy/","tags":["Design Pattern","Structural","Proxy","AOP","Spring","Caching"],"title":"DesignPattern - Structural - Proxy"},{"content":"Composite Pattern 概述 Composite Pattern 讓客戶端可以統一處理單個對象和對象的組合。它將對象組織成樹狀結構，使得客戶端能夠以一致的方式處理個別對象和組合對象。\n核心概念 結構組件 Component: 所有組合對象的通用接口，定義了葉子和組合節點的共同操作 Leaf: 葉子節點，實現 Component 接口，不包含子節點 Composite: 組合節點，包含子節點（可以是葉子或其他組合節點） 關鍵特性 統一操作: 對葉子和組合節點執行相同的操作 樹狀結構: 支持遞歸組合 透明性: 客戶端不需要區分葉子和組合節點 基本實現 1. 員工層次結構示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 // Component 接口 public interface Employee { void add(Employee employee); void remove(Employee employee); Employee getChild(int index); String getName(); double getSalary(); void print(); void printStructure(String indent); } // Leaf 實現 - 開發者 public class Developer implements Employee { private String name; private double salary; private String position; public Developer(String name, double salary, String position) { this.name = name; this.salary = salary; this.position = position; } @Override public void add(Employee employee) { throw new UnsupportedOperationException(\u0026#34;Developer cannot add employees\u0026#34;); } @Override public void remove(Employee employee) { throw new UnsupportedOperationException(\u0026#34;Developer cannot remove employees\u0026#34;); } @Override public Employee getChild(int index) { throw new UnsupportedOperationException(\u0026#34;Developer has no children\u0026#34;); } @Override public String getName() { return name; } @Override public double getSalary() { return salary; } @Override public void print() { System.out.println(\u0026#34;Developer: \u0026#34; + name + \u0026#34;, Salary: \u0026#34; + salary + \u0026#34;, Position: \u0026#34; + position); } @Override public void printStructure(String indent) { System.out.println(indent + \u0026#34;└── \u0026#34; + name + \u0026#34; (\u0026#34; + position + \u0026#34;)\u0026#34;); } } // Composite 實現 - 管理者 public class Manager implements Employee { private String name; private double salary; private String department; private List\u0026lt;Employee\u0026gt; subordinates = new ArrayList\u0026lt;\u0026gt;(); public Manager(String name, double salary, String department) { this.name = name; this.salary = salary; this.department = department; } @Override public void add(Employee employee) { subordinates.add(employee); } @Override public void remove(Employee employee) { subordinates.remove(employee); } @Override public Employee getChild(int index) { return subordinates.get(index); } @Override public String getName() { return name; } @Override public double getSalary() { return salary; } @Override public void print() { System.out.println(\u0026#34;Manager: \u0026#34; + name + \u0026#34;, Salary: \u0026#34; + salary + \u0026#34;, Department: \u0026#34; + department); System.out.println(\u0026#34;Subordinates:\u0026#34;); for (Employee emp : subordinates) { emp.print(); } } @Override public void printStructure(String indent) { System.out.println(indent + \u0026#34;├── \u0026#34; + name + \u0026#34; (\u0026#34; + department + \u0026#34; Manager)\u0026#34;); for (int i = 0; i \u0026lt; subordinates.size(); i++) { String newIndent = indent + \u0026#34;│ \u0026#34;; if (i == subordinates.size() - 1) { newIndent = indent + \u0026#34; \u0026#34;; } subordinates.get(i).printStructure(newIndent); } } public double getTotalSalary() { double total = salary; for (Employee emp : subordinates) { total += emp.getSalary(); if (emp instanceof Manager) { total += ((Manager) emp).getTotalSalary() - emp.getSalary(); } } return total; } } 2. 測試示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class CompositePatternDemo { public static void main(String[] args) { // 創建開發者 Employee dev1 = new Developer(\u0026#34;Alice\u0026#34;, 80000, \u0026#34;Senior Java Developer\u0026#34;); Employee dev2 = new Developer(\u0026#34;Bob\u0026#34;, 70000, \u0026#34;Frontend Developer\u0026#34;); Employee dev3 = new Developer(\u0026#34;Charlie\u0026#34;, 85000, \u0026#34;Full Stack Developer\u0026#34;); // 創建團隊經理 Manager teamLead = new Manager(\u0026#34;David\u0026#34;, 100000, \u0026#34;Development Team\u0026#34;); teamLead.add(dev1); teamLead.add(dev2); // 創建技術經理 Manager techManager = new Manager(\u0026#34;Eve\u0026#34;, 120000, \u0026#34;Technology\u0026#34;); techManager.add(dev3); techManager.add(teamLead); // 創建部門經理 Manager deptManager = new Manager(\u0026#34;Frank\u0026#34;, 150000, \u0026#34;Engineering\u0026#34;); deptManager.add(techManager); // 打印組織結構 System.out.println(\u0026#34;=== Organization Structure ===\u0026#34;); deptManager.printStructure(\u0026#34;\u0026#34;); System.out.println(\u0026#34;\\n=== Total Department Salary: \u0026#34; + deptManager.getTotalSalary() + \u0026#34; ===\u0026#34;); } } 現代 Java 實現 1. 使用 Java 8+ 特性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // 使用 Optional 和 Stream API public interface ModernComponent { String getName(); double getValue(); Optional\u0026lt;List\u0026lt;ModernComponent\u0026gt;\u0026gt; getChildren(); default void process() { System.out.println(\u0026#34;Processing: \u0026#34; + getName()); getChildren().ifPresent(children -\u0026gt; children.forEach(ModernComponent::process) ); } default double getTotalValue() { return getValue() + getChildren().orElse(Collections.emptyList()) .stream() .mapToDouble(ModernComponent::getTotalValue) .sum(); } default long countElements() { return 1 + getChildren().orElse(Collections.emptyList()) .stream() .mapToLong(ModernComponent::countElements) .sum(); } } // 葉子節點實現 public class ModernLeaf implements ModernComponent { private final String name; private final double value; public ModernLeaf(String name, double value) { this.name = name; this.value = value; } @Override public String getName() { return name; } @Override public double getValue() { return value; } @Override public Optional\u0026lt;List\u0026lt;ModernComponent\u0026gt;\u0026gt; getChildren() { return Optional.empty(); } } // 組合節點實現 public class ModernComposite implements ModernComponent { private final String name; private final double value; private final List\u0026lt;ModernComponent\u0026gt; children = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); public ModernComposite(String name, double value) { this.name = name; this.value = value; } public void add(ModernComponent component) { children.add(component); } public void remove(ModernComponent component) { children.remove(component); } @Override public String getName() { return name; } @Override public double getValue() { return value; } @Override public Optional\u0026lt;List\u0026lt;ModernComponent\u0026gt;\u0026gt; getChildren() { return Optional.of(Collections.unmodifiableList(children)); } } 2. 函數式編程版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 使用函數式接口 @FunctionalInterface public interface ComponentProcessor\u0026lt;T\u0026gt; { void process(T item); } // 通用的組合模式操作 public class FunctionalComposite\u0026lt;T\u0026gt; { private final T value; private final List\u0026lt;FunctionalComposite\u0026lt;T\u0026gt;\u0026gt; children = new ArrayList\u0026lt;\u0026gt;(); public FunctionalComposite(T value) { this.value = value; } public void add(FunctionalComposite\u0026lt;T\u0026gt; child) { children.add(child); } public void forEach(ComponentProcessor\u0026lt;T\u0026gt; processor) { processor.process(value); children.forEach(child -\u0026gt; child.forEach(processor)); } public \u0026lt;R\u0026gt; R reduce(R identity, BinaryOperator\u0026lt;R\u0026gt; accumulator, Function\u0026lt;T, R\u0026gt; mapper) { R result = accumulator.apply(identity, mapper.apply(value)); for (FunctionalComposite\u0026lt;T\u0026gt; child : children) { result = accumulator.apply(result, child.reduce(identity, accumulator, mapper)); } return result; } public Stream\u0026lt;T\u0026gt; stream() { return Stream.concat( Stream.of(value), children.stream().flatMap(FunctionalComposite::stream) ); } } Spring Boot 集成 1. 服務層組合模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 // 抽象服務組件 public abstract class ServiceComponent { protected String name; protected boolean enabled; public ServiceComponent(String name) { this.name = name; this.enabled = true; } public abstract void execute(); public abstract List\u0026lt;ServiceComponent\u0026gt; getChildren(); public void setEnabled(boolean enabled) { this.enabled = enabled; } public boolean isEnabled() { return enabled; } public String getName() { return name; } } // 葉子服務 @Component public class EmailService extends ServiceComponent { private static final Logger logger = LoggerFactory.getLogger(EmailService.class); public EmailService() { super(\u0026#34;Email Service\u0026#34;); } @Override public void execute() { if (enabled) { logger.info(\u0026#34;Executing email service...\u0026#34;); // Email sending logic } } @Override public List\u0026lt;ServiceComponent\u0026gt; getChildren() { return Collections.emptyList(); } } // 組合服務 @Component public class NotificationService extends ServiceComponent { private static final Logger logger = LoggerFactory.getLogger(NotificationService.class); private final List\u0026lt;ServiceComponent\u0026gt; services = new ArrayList\u0026lt;\u0026gt;(); public NotificationService() { super(\u0026#34;Notification Service\u0026#34;); } @Autowired public void setServices(List\u0026lt;ServiceComponent\u0026gt; services) { this.services.addAll(services.stream() .filter(service -\u0026gt; !service.equals(this)) .collect(Collectors.toList())); } @Override public void execute() { if (enabled) { logger.info(\u0026#34;Executing notification service...\u0026#34;); services.forEach(ServiceComponent::execute); } } @Override public List\u0026lt;ServiceComponent\u0026gt; getChildren() { return Collections.unmodifiableList(services); } } // 服務編排器 @Service public class ServiceOrchestrator { private final List\u0026lt;ServiceComponent\u0026gt; rootServices; public ServiceOrchestrator(List\u0026lt;ServiceComponent\u0026gt; services) { this.rootServices = services.stream() .filter(service -\u0026gt; service instanceof NotificationService) .collect(Collectors.toList()); } public void executeAll() { rootServices.forEach(ServiceComponent::execute); } public void executeService(String serviceName) { findService(serviceName).ifPresent(ServiceComponent::execute); } private Optional\u0026lt;ServiceComponent\u0026gt; findService(String name) { return rootServices.stream() .filter(service -\u0026gt; service.getName().equals(name)) .findFirst(); } } 2. 配置管理組合模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @Configuration @ConfigurationProperties(prefix = \u0026#34;app\u0026#34;) public class CompositeConfiguration { @Component public static class ConfigNode { private String name; private String value; private List\u0026lt;ConfigNode\u0026gt; children = new ArrayList\u0026lt;\u0026gt;(); public void addChild(ConfigNode child) { children.add(child); } public Optional\u0026lt;String\u0026gt; getValue(String path) { if (path.equals(name)) { return Optional.ofNullable(value); } return children.stream() .map(child -\u0026gt; child.getValue(path)) .filter(Optional::isPresent) .findFirst() .orElse(Optional.empty()); } // Getters and setters } @Bean public ConfigNode rootConfig() { ConfigNode root = new ConfigNode(); root.setName(\u0026#34;application\u0026#34;); ConfigNode database = new ConfigNode(); database.setName(\u0026#34;database\u0026#34;); database.setValue(\u0026#34;mysql://localhost:3306/app\u0026#34;); ConfigNode cache = new ConfigNode(); cache.setName(\u0026#34;cache\u0026#34;); cache.setValue(\u0026#34;redis://localhost:6379\u0026#34;); root.addChild(database); root.addChild(cache); return root; } } 實際應用場景 1. 文件系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 // 文件系統組合模式 public abstract class FileSystemNode { protected String name; protected long size; protected Date lastModified; public FileSystemNode(String name) { this.name = name; this.lastModified = new Date(); } public abstract long getSize(); public abstract void display(String indent); public abstract List\u0026lt;FileSystemNode\u0026gt; getChildren(); public String getName() { return name; } } public class File extends FileSystemNode { private long fileSize; public File(String name, long size) { super(name); this.fileSize = size; } @Override public long getSize() { return fileSize; } @Override public void display(String indent) { System.out.println(indent + \u0026#34;📄 \u0026#34; + name + \u0026#34; (\u0026#34; + fileSize + \u0026#34; bytes)\u0026#34;); } @Override public List\u0026lt;FileSystemNode\u0026gt; getChildren() { return Collections.emptyList(); } } public class Directory extends FileSystemNode { private List\u0026lt;FileSystemNode\u0026gt; contents = new ArrayList\u0026lt;\u0026gt;(); public Directory(String name) { super(name); } public void add(FileSystemNode node) { contents.add(node); } @Override public long getSize() { return contents.stream() .mapToLong(FileSystemNode::getSize) .sum(); } @Override public void display(String indent) { System.out.println(indent + \u0026#34;📁 \u0026#34; + name + \u0026#34;/\u0026#34;); contents.forEach(node -\u0026gt; node.display(indent + \u0026#34; \u0026#34;)); } @Override public List\u0026lt;FileSystemNode\u0026gt; getChildren() { return Collections.unmodifiableList(contents); } } 2. GUI 組件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // GUI 組合模式 public abstract class UIComponent { protected String name; protected boolean visible = true; public UIComponent(String name) { this.name = name; } public abstract void render(); public abstract void addChild(UIComponent child); public abstract void removeChild(UIComponent child); public abstract List\u0026lt;UIComponent\u0026gt; getChildren(); public void setVisible(boolean visible) { this.visible = visible; } public boolean isVisible() { return visible; } } public class Button extends UIComponent { private String text; public Button(String name, String text) { super(name); this.text = text; } @Override public void render() { if (visible) { System.out.println(\u0026#34;Rendering button: \u0026#34; + text); } } @Override public void addChild(UIComponent child) { throw new UnsupportedOperationException(\u0026#34;Button cannot have children\u0026#34;); } @Override public void removeChild(UIComponent child) { throw new UnsupportedOperationException(\u0026#34;Button cannot have children\u0026#34;); } @Override public List\u0026lt;UIComponent\u0026gt; getChildren() { return Collections.emptyList(); } } public class Panel extends UIComponent { private List\u0026lt;UIComponent\u0026gt; children = new ArrayList\u0026lt;\u0026gt;(); public Panel(String name) { super(name); } @Override public void render() { if (visible) { System.out.println(\u0026#34;Rendering panel: \u0026#34; + name); children.forEach(UIComponent::render); } } @Override public void addChild(UIComponent child) { children.add(child); } @Override public void removeChild(UIComponent child) { children.remove(child); } @Override public List\u0026lt;UIComponent\u0026gt; getChildren() { return Collections.unmodifiableList(children); } } 性能優化 1. 懶加載和緩存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class OptimizedComposite { private final String name; private final Supplier\u0026lt;List\u0026lt;OptimizedComposite\u0026gt;\u0026gt; childrenSupplier; private List\u0026lt;OptimizedComposite\u0026gt; cachedChildren; private final Map\u0026lt;String, Object\u0026gt; computedValues = new ConcurrentHashMap\u0026lt;\u0026gt;(); public OptimizedComposite(String name, Supplier\u0026lt;List\u0026lt;OptimizedComposite\u0026gt;\u0026gt; childrenSupplier) { this.name = name; this.childrenSupplier = childrenSupplier; } public List\u0026lt;OptimizedComposite\u0026gt; getChildren() { if (cachedChildren == null) { cachedChildren = childrenSupplier.get(); } return cachedChildren; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T\u0026gt; T computeIfAbsent(String key, Function\u0026lt;OptimizedComposite, T\u0026gt; computer) { return (T) computedValues.computeIfAbsent(key, k -\u0026gt; computer.apply(this)); } public void invalidateCache() { cachedChildren = null; computedValues.clear(); } } 2. 並行處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class ParallelComposite { private final String name; private final List\u0026lt;ParallelComposite\u0026gt; children = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); private final ForkJoinPool customThreadPool; public ParallelComposite(String name, int parallelism) { this.name = name; this.customThreadPool = new ForkJoinPool(parallelism); } public void processParallel(Consumer\u0026lt;String\u0026gt; processor) { List\u0026lt;CompletableFuture\u0026lt;Void\u0026gt;\u0026gt; futures = new ArrayList\u0026lt;\u0026gt;(); // 處理當前節點 futures.add(CompletableFuture.runAsync(() -\u0026gt; processor.accept(name), customThreadPool)); // 並行處理子節點 for (ParallelComposite child : children) { futures.add(CompletableFuture.runAsync(() -\u0026gt; child.processParallel(processor), customThreadPool)); } // 等待所有任務完成 CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join(); } } 測試策略 1. 單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @ExtendWith(MockitoExtension.class) class CompositePatternTest { @Test void testLeafNode() { Employee developer = new Developer(\u0026#34;John\u0026#34;, 80000, \u0026#34;Java Developer\u0026#34;); assertEquals(\u0026#34;John\u0026#34;, developer.getName()); assertEquals(80000, developer.getSalary()); assertThrows(UnsupportedOperationException.class, () -\u0026gt; developer.add(null)); assertThrows(UnsupportedOperationException.class, () -\u0026gt; developer.remove(null)); assertThrows(UnsupportedOperationException.class, () -\u0026gt; developer.getChild(0)); } @Test void testCompositeNode() { Manager manager = new Manager(\u0026#34;Alice\u0026#34;, 120000, \u0026#34;Engineering\u0026#34;); Employee dev1 = new Developer(\u0026#34;Bob\u0026#34;, 80000, \u0026#34;Senior Developer\u0026#34;); Employee dev2 = new Developer(\u0026#34;Charlie\u0026#34;, 70000, \u0026#34;Junior Developer\u0026#34;); manager.add(dev1); manager.add(dev2); assertEquals(\u0026#34;Alice\u0026#34;, manager.getName()); assertEquals(120000, manager.getSalary()); assertEquals(270000, manager.getTotalSalary()); // 120000 + 80000 + 70000 assertEquals(dev1, manager.getChild(0)); assertEquals(dev2, manager.getChild(1)); } @Test void testHierarchicalStructure() { Employee dev = new Developer(\u0026#34;John\u0026#34;, 80000, \u0026#34;Developer\u0026#34;); Manager teamLead = new Manager(\u0026#34;Alice\u0026#34;, 100000, \u0026#34;Team Lead\u0026#34;); Manager director = new Manager(\u0026#34;Bob\u0026#34;, 150000, \u0026#34;Director\u0026#34;); teamLead.add(dev); director.add(teamLead); assertEquals(330000, director.getTotalSalary()); } } 2. 集成測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @SpringBootTest class CompositeServiceTest { @Autowired private ServiceOrchestrator orchestrator; @Test void testServiceExecution() { // 測試服務編排器是否正確執行所有服務 assertDoesNotThrow(() -\u0026gt; orchestrator.executeAll()); } @Test void testSpecificServiceExecution() { // 測試特定服務的執行 assertDoesNotThrow(() -\u0026gt; orchestrator.executeService(\u0026#34;Notification Service\u0026#34;)); } } 最佳實踐 1. 設計原則 統一接口: 確保葉子和組合節點實現相同的接口 透明性: 客戶端不需要知道處理的是葉子還是組合節點 安全性: 在不適當的操作上拋出異常 性能: 考慮懶加載和緩存機制 2. 實現建議 使用不可變對象提高線程安全性 實現 equals() 和 hashCode() 方法 提供便利的工廠方法 考慮使用 Builder 模式構建複雜結構 3. 常見陷阱 避免循環引用 注意內存洩漏（特別是在大型樹結構中） 正確處理併發訪問 避免過度使用（當結構簡單時） 適用場景 何時使用 層次結構: 需要表示部分-整體的層次結構 統一處理: 希望統一處理個別對象和組合對象 樹狀組織: 數據自然形成樹狀結構 遞歸操作: 需要對結構進行遞歸操作 何時避免 簡單結構: 當結構過於簡單時會增加不必要的複雜性 類型安全: 當需要強類型檢查時 性能關鍵: 當性能是關鍵因素且結構頻繁變化時 總結 Composite Pattern 是一個強大的結構型設計模式，它能夠優雅地處理樹狀結構的數據。通過統一的接口，它讓客戶端能夠透明地處理單個對象和對象組合，大大簡化了代碼的複雜性。在現代 Java 開發中，結合 Stream API、Optional 和 Spring Boot，我們可以創建更加靈活、高效和易於維護的組合模式實現。\n關鍵是要理解何時使用這個模式，並根據具體的業務需求選擇合適的實現方式。無論是簡單的組織結構還是複雜的企業級應用，Composite Pattern 都能提供清晰、可擴展的解決方案。\n","permalink":"https://xinqilin.github.io/post/architecture/composite/","tags":["Design Pattern","Structural","Composite","Tree Structure"],"title":"DesignPattern - Structural - Composite"},{"content":"適配器模式 (Adapter Pattern) 完整實作指南 模式概述 適配器模式是一種結構型設計模式，它允許原本由於介面不相容而不能一起工作的類別協同工作。適配器模式就像現實生活中的電源適配器，它能夠將一個類別的介面轉換成客戶端所期望的另一個介面。\n模式結構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 目標介面 - 客戶端所期望的介面 public interface Target { void request(); } // 適配者 - 需要被適配的現有類別 public class Adaptee { public void specificRequest() { System.out.println(\u0026#34;執行特定請求\u0026#34;); } } // 適配器 - 將 Adaptee 轉換為 Target 介面 public class Adapter implements Target { private Adaptee adaptee; public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } @Override public void request() { adaptee.specificRequest(); } } // 客戶端 public class Client { public void makeRequest(Target target) { target.request(); } } 適配器模式的兩種實現方式 1. 對象適配器 (Object Adapter) - 使用組合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // 支付介面 public interface PaymentProcessor { PaymentResult processPayment(double amount, String currency); } // 第三方支付SDK public class ThirdPartyPaymentSDK { public boolean makePayment(String amount, String currencyCode, Map\u0026lt;String, String\u0026gt; metadata) { System.out.println(\u0026#34;使用第三方SDK處理支付: \u0026#34; + amount + \u0026#34; \u0026#34; + currencyCode); // 模擬支付處理 return Math.random() \u0026gt; 0.1; // 90%成功率 } public String getTransactionId() { return \u0026#34;TXN_\u0026#34; + System.currentTimeMillis(); } } // 對象適配器 public class ThirdPartyPaymentAdapter implements PaymentProcessor { private ThirdPartyPaymentSDK thirdPartySDK; public ThirdPartyPaymentAdapter(ThirdPartyPaymentSDK thirdPartySDK) { this.thirdPartySDK = thirdPartySDK; } @Override public PaymentResult processPayment(double amount, String currency) { try { // 轉換參數格式 String amountStr = String.valueOf(amount); Map\u0026lt;String, String\u0026gt; metadata = new HashMap\u0026lt;\u0026gt;(); metadata.put(\u0026#34;source\u0026#34;, \u0026#34;adapter\u0026#34;); metadata.put(\u0026#34;timestamp\u0026#34;, String.valueOf(System.currentTimeMillis())); // 調用第三方SDK boolean success = thirdPartySDK.makePayment(amountStr, currency, metadata); // 轉換返回結果 return new PaymentResult( success, success ? \u0026#34;支付成功\u0026#34; : \u0026#34;支付失敗\u0026#34;, thirdPartySDK.getTransactionId(), amount, currency ); } catch (Exception e) { return new PaymentResult(false, \u0026#34;支付異常: \u0026#34; + e.getMessage(), null, amount, currency); } } } // 結果類 public class PaymentResult { private boolean success; private String message; private String transactionId; private double amount; private String currency; public PaymentResult(boolean success, String message, String transactionId, double amount, String currency) { this.success = success; this.message = message; this.transactionId = transactionId; this.amount = amount; this.currency = currency; } // getters and setters public boolean isSuccess() { return success; } public String getMessage() { return message; } public String getTransactionId() { return transactionId; } public double getAmount() { return amount; } public String getCurrency() { return currency; } } 2. 類適配器 (Class Adapter) - 使用繼承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 遺留系統的日誌類別 public class LegacyLogger { public void writeLog(String level, String message) { System.out.println(\u0026#34;[\u0026#34; + level + \u0026#34;] \u0026#34; + new Date() + \u0026#34; - \u0026#34; + message); } } // 現代日誌介面 public interface ModernLogger { void info(String message); void warn(String message); void error(String message); void debug(String message); } // 類適配器 public class LegacyLoggerAdapter extends LegacyLogger implements ModernLogger { @Override public void info(String message) { writeLog(\u0026#34;INFO\u0026#34;, message); } @Override public void warn(String message) { writeLog(\u0026#34;WARN\u0026#34;, message); } @Override public void error(String message) { writeLog(\u0026#34;ERROR\u0026#34;, message); } @Override public void debug(String message) { writeLog(\u0026#34;DEBUG\u0026#34;, message); } } 企業級應用場景 1. 數據源適配器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 // 統一數據源介面 public interface DataSource { List\u0026lt;Record\u0026gt; fetchData(QueryParameters params); void saveData(List\u0026lt;Record\u0026gt; records); } // 數據庫數據源 public class DatabaseDataSource implements DataSource { private JdbcTemplate jdbcTemplate; public DatabaseDataSource(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } @Override public List\u0026lt;Record\u0026gt; fetchData(QueryParameters params) { String sql = buildSqlQuery(params); return jdbcTemplate.query(sql, new RecordRowMapper()); } @Override public void saveData(List\u0026lt;Record\u0026gt; records) { String sql = \u0026#34;INSERT INTO records (id, name, value) VALUES (?, ?, ?)\u0026#34;; jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() { @Override public void setValues(PreparedStatement ps, int i) throws SQLException { Record record = records.get(i); ps.setString(1, record.getId()); ps.setString(2, record.getName()); ps.setString(3, record.getValue()); } @Override public int getBatchSize() { return records.size(); } }); } private String buildSqlQuery(QueryParameters params) { StringBuilder sql = new StringBuilder(\u0026#34;SELECT * FROM records WHERE 1=1\u0026#34;); if (params.getName() != null) { sql.append(\u0026#34; AND name = \u0026#39;\u0026#34;).append(params.getName()).append(\u0026#34;\u0026#39;\u0026#34;); } if (params.getDateRange() != null) { sql.append(\u0026#34; AND created_date BETWEEN \u0026#39;\u0026#34;) .append(params.getDateRange().getStart()) .append(\u0026#34;\u0026#39; AND \u0026#39;\u0026#34;) .append(params.getDateRange().getEnd()) .append(\u0026#34;\u0026#39;\u0026#34;); } return sql.toString(); } } // REST API 數據源適配器 public class RestApiDataSourceAdapter implements DataSource { private RestTemplate restTemplate; private String baseUrl; public RestApiDataSourceAdapter(RestTemplate restTemplate, String baseUrl) { this.restTemplate = restTemplate; this.baseUrl = baseUrl; } @Override public List\u0026lt;Record\u0026gt; fetchData(QueryParameters params) { String url = baseUrl + \u0026#34;/api/records\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); // 轉換查詢參數 Map\u0026lt;String, Object\u0026gt; requestBody = new HashMap\u0026lt;\u0026gt;(); if (params.getName() != null) { requestBody.put(\u0026#34;name\u0026#34;, params.getName()); } if (params.getDateRange() != null) { requestBody.put(\u0026#34;startDate\u0026#34;, params.getDateRange().getStart()); requestBody.put(\u0026#34;endDate\u0026#34;, params.getDateRange().getEnd()); } HttpEntity\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(requestBody, headers); try { ResponseEntity\u0026lt;ApiResponse\u0026gt; response = restTemplate.postForEntity(url, request, ApiResponse.class); return convertApiResponseToRecords(response.getBody()); } catch (RestClientException e) { throw new DataSourceException(\u0026#34;無法從REST API獲取數據\u0026#34;, e); } } @Override public void saveData(List\u0026lt;Record\u0026gt; records) { String url = baseUrl + \u0026#34;/api/records/batch\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; apiRecords = records.stream() .map(this::convertRecordToApiFormat) .collect(Collectors.toList()); HttpEntity\u0026lt;List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt;\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(apiRecords, headers); try { restTemplate.postForObject(url, request, ApiResponse.class); } catch (RestClientException e) { throw new DataSourceException(\u0026#34;無法保存數據到REST API\u0026#34;, e); } } private List\u0026lt;Record\u0026gt; convertApiResponseToRecords(ApiResponse response) { return response.getData().stream() .map(item -\u0026gt; new Record( item.get(\u0026#34;id\u0026#34;).toString(), item.get(\u0026#34;name\u0026#34;).toString(), item.get(\u0026#34;value\u0026#34;).toString() )) .collect(Collectors.toList()); } private Map\u0026lt;String, Object\u0026gt; convertRecordToApiFormat(Record record) { Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;id\u0026#34;, record.getId()); map.put(\u0026#34;name\u0026#34;, record.getName()); map.put(\u0026#34;value\u0026#34;, record.getValue()); return map; } } // 文件數據源適配器 public class FileDataSourceAdapter implements DataSource { private String filePath; private ObjectMapper objectMapper; public FileDataSourceAdapter(String filePath) { this.filePath = filePath; this.objectMapper = new ObjectMapper(); } @Override public List\u0026lt;Record\u0026gt; fetchData(QueryParameters params) { try { List\u0026lt;Record\u0026gt; allRecords = readRecordsFromFile(); return filterRecords(allRecords, params); } catch (IOException e) { throw new DataSourceException(\u0026#34;無法讀取文件數據\u0026#34;, e); } } @Override public void saveData(List\u0026lt;Record\u0026gt; records) { try { writeRecordsToFile(records); } catch (IOException e) { throw new DataSourceException(\u0026#34;無法保存數據到文件\u0026#34;, e); } } private List\u0026lt;Record\u0026gt; readRecordsFromFile() throws IOException { File file = new File(filePath); if (!file.exists()) { return new ArrayList\u0026lt;\u0026gt;(); } TypeReference\u0026lt;List\u0026lt;Record\u0026gt;\u0026gt; typeRef = new TypeReference\u0026lt;List\u0026lt;Record\u0026gt;\u0026gt;() {}; return objectMapper.readValue(file, typeRef); } private void writeRecordsToFile(List\u0026lt;Record\u0026gt; records) throws IOException { File file = new File(filePath); objectMapper.writeValue(file, records); } private List\u0026lt;Record\u0026gt; filterRecords(List\u0026lt;Record\u0026gt; records, QueryParameters params) { return records.stream() .filter(record -\u0026gt; { if (params.getName() != null \u0026amp;\u0026amp; !params.getName().equals(record.getName())) { return false; } // 添加其他過濾條件 return true; }) .collect(Collectors.toList()); } } 2. 消息系統適配器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 // 統一消息發送介面 public interface MessageSender { void sendMessage(String recipient, String subject, String content); void sendBroadcast(String subject, String content); boolean isAvailable(); } // 郵件服務適配器 public class EmailServiceAdapter implements MessageSender { private JavaMailSender mailSender; private String fromAddress; public EmailServiceAdapter(JavaMailSender mailSender, String fromAddress) { this.mailSender = mailSender; this.fromAddress = fromAddress; } @Override public void sendMessage(String recipient, String subject, String content) { try { SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(fromAddress); message.setTo(recipient); message.setSubject(subject); message.setText(content); mailSender.send(message); } catch (Exception e) { throw new MessageSendException(\u0026#34;郵件發送失敗\u0026#34;, e); } } @Override public void sendBroadcast(String subject, String content) { // 實現群發邏輯 List\u0026lt;String\u0026gt; recipients = getSubscriberEmails(); for (String recipient : recipients) { sendMessage(recipient, subject, content); } } @Override public boolean isAvailable() { try { // 檢查郵件服務是否可用 return mailSender != null; } catch (Exception e) { return false; } } private List\u0026lt;String\u0026gt; getSubscriberEmails() { // 獲取訂閱者郵箱列表 return Arrays.asList(\u0026#34;user1@example.com\u0026#34;, \u0026#34;user2@example.com\u0026#34;); } } // SMS 服務適配器 public class SmsServiceAdapter implements MessageSender { private SmsClient smsClient; private String apiKey; public SmsServiceAdapter(SmsClient smsClient, String apiKey) { this.smsClient = smsClient; this.apiKey = apiKey; } @Override public void sendMessage(String recipient, String subject, String content) { try { // SMS通常不支持主題，將主題併入內容 String fullContent = subject + \u0026#34;: \u0026#34; + content; SmsRequest request = new SmsRequest(); request.setApiKey(apiKey); request.setPhoneNumber(recipient); request.setMessage(fullContent); SmsResponse response = smsClient.sendSms(request); if (!response.isSuccess()) { throw new MessageSendException(\u0026#34;SMS發送失敗: \u0026#34; + response.getErrorMessage()); } } catch (Exception e) { throw new MessageSendException(\u0026#34;SMS發送異常\u0026#34;, e); } } @Override public void sendBroadcast(String subject, String content) { List\u0026lt;String\u0026gt; phoneNumbers = getSubscriberPhoneNumbers(); for (String phoneNumber : phoneNumbers) { sendMessage(phoneNumber, subject, content); } } @Override public boolean isAvailable() { try { return smsClient.checkConnection(); } catch (Exception e) { return false; } } private List\u0026lt;String\u0026gt; getSubscriberPhoneNumbers() { // 獲取訂閱者手機號碼列表 return Arrays.asList(\u0026#34;+1234567890\u0026#34;, \u0026#34;+0987654321\u0026#34;); } } // 推送通知適配器 public class PushNotificationAdapter implements MessageSender { private PushNotificationService pushService; public PushNotificationAdapter(PushNotificationService pushService) { this.pushService = pushService; } @Override public void sendMessage(String recipient, String subject, String content) { try { PushNotification notification = new PushNotification(); notification.setDeviceToken(recipient); notification.setTitle(subject); notification.setBody(content); notification.setBadge(1); pushService.send(notification); } catch (Exception e) { throw new MessageSendException(\u0026#34;推送通知發送失敗\u0026#34;, e); } } @Override public void sendBroadcast(String subject, String content) { try { BroadcastNotification broadcast = new BroadcastNotification(); broadcast.setTitle(subject); broadcast.setBody(content); broadcast.setTopic(\u0026#34;all_users\u0026#34;); pushService.sendBroadcast(broadcast); } catch (Exception e) { throw new MessageSendException(\u0026#34;廣播推送發送失敗\u0026#34;, e); } } @Override public boolean isAvailable() { return pushService.isConnected(); } } 3. 多通道消息管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @Service public class MessageManager { private final Map\u0026lt;String, MessageSender\u0026gt; messageSenders; private final MessageSender defaultSender; public MessageManager(@Qualifier(\u0026#34;emailSender\u0026#34;) MessageSender emailSender, @Qualifier(\u0026#34;smsSender\u0026#34;) MessageSender smsSender, @Qualifier(\u0026#34;pushSender\u0026#34;) MessageSender pushSender) { this.messageSenders = new HashMap\u0026lt;\u0026gt;(); this.messageSenders.put(\u0026#34;email\u0026#34;, emailSender); this.messageSenders.put(\u0026#34;sms\u0026#34;, smsSender); this.messageSenders.put(\u0026#34;push\u0026#34;, pushSender); this.defaultSender = emailSender; } public void sendMessage(String channel, String recipient, String subject, String content) { MessageSender sender = messageSenders.getOrDefault(channel, defaultSender); if (!sender.isAvailable()) { // 嘗試使用備用通道 sender = findAvailableSender(); if (sender == null) { throw new MessageSendException(\u0026#34;所有消息通道均不可用\u0026#34;); } } sender.sendMessage(recipient, subject, content); } public void sendMultiChannelMessage(List\u0026lt;String\u0026gt; channels, String recipient, String subject, String content) { List\u0026lt;Exception\u0026gt; exceptions = new ArrayList\u0026lt;\u0026gt;(); for (String channel : channels) { try { sendMessage(channel, recipient, subject, content); } catch (Exception e) { exceptions.add(e); } } if (exceptions.size() == channels.size()) { throw new MessageSendException(\u0026#34;所有通道發送失敗\u0026#34;, exceptions.get(0)); } } private MessageSender findAvailableSender() { return messageSenders.values().stream() .filter(MessageSender::isAvailable) .findFirst() .orElse(null); } } 緩存系統適配器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 // 統一緩存介面 public interface CacheService { void put(String key, Object value, Duration ttl); \u0026lt;T\u0026gt; T get(String key, Class\u0026lt;T\u0026gt; type); void remove(String key); void clear(); boolean exists(String key); } // Redis 緩存適配器 @Service public class RedisCacheAdapter implements CacheService { private final RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; public RedisCacheAdapter(RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate) { this.redisTemplate = redisTemplate; } @Override public void put(String key, Object value, Duration ttl) { redisTemplate.opsForValue().set(key, value, ttl); } @Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T\u0026gt; T get(String key, Class\u0026lt;T\u0026gt; type) { Object value = redisTemplate.opsForValue().get(key); if (value == null) { return null; } if (type.isAssignableFrom(value.getClass())) { return (T) value; } throw new ClassCastException(\u0026#34;無法將緩存值轉換為 \u0026#34; + type.getName()); } @Override public void remove(String key) { redisTemplate.delete(key); } @Override public void clear() { Set\u0026lt;String\u0026gt; keys = redisTemplate.keys(\u0026#34;*\u0026#34;); if (keys != null \u0026amp;\u0026amp; !keys.isEmpty()) { redisTemplate.delete(keys); } } @Override public boolean exists(String key) { return Boolean.TRUE.equals(redisTemplate.hasKey(key)); } } // 內存緩存適配器 @Service public class MemoryCacheAdapter implements CacheService { private final Map\u0026lt;String, CacheEntry\u0026gt; cache = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); public MemoryCacheAdapter() { // 定期清理過期項目 scheduler.scheduleAtFixedRate(this::cleanupExpiredEntries, 1, 1, TimeUnit.MINUTES); } @Override public void put(String key, Object value, Duration ttl) { long expirationTime = System.currentTimeMillis() + ttl.toMillis(); cache.put(key, new CacheEntry(value, expirationTime)); } @Override @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T\u0026gt; T get(String key, Class\u0026lt;T\u0026gt; type) { CacheEntry entry = cache.get(key); if (entry == null || entry.isExpired()) { cache.remove(key); return null; } Object value = entry.getValue(); if (type.isAssignableFrom(value.getClass())) { return (T) value; } throw new ClassCastException(\u0026#34;無法將緩存值轉換為 \u0026#34; + type.getName()); } @Override public void remove(String key) { cache.remove(key); } @Override public void clear() { cache.clear(); } @Override public boolean exists(String key) { CacheEntry entry = cache.get(key); return entry != null \u0026amp;\u0026amp; !entry.isExpired(); } private void cleanupExpiredEntries() { cache.entrySet().removeIf(entry -\u0026gt; entry.getValue().isExpired()); } private static class CacheEntry { private final Object value; private final long expirationTime; public CacheEntry(Object value, long expirationTime) { this.value = value; this.expirationTime = expirationTime; } public Object getValue() { return value; } public boolean isExpired() { return System.currentTimeMillis() \u0026gt; expirationTime; } } } 統一服務管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // 統一服務管理器 @Service public class UnifiedServiceManager { private final DataSource dataSource; private final MessageSender messageSender; private final CacheService cacheService; public UnifiedServiceManager( @Qualifier(\u0026#34;selectedDataSource\u0026#34;) DataSource dataSource, @Qualifier(\u0026#34;selectedMessageSender\u0026#34;) MessageSender messageSender, @Qualifier(\u0026#34;selectedCacheService\u0026#34;) CacheService cacheService) { this.dataSource = dataSource; this.messageSender = messageSender; this.cacheService = cacheService; } public void processBusinessLogic(String userId, String action) { // 從緩存獲取用戶信息 String cacheKey = \u0026#34;user:\u0026#34; + userId; User user = cacheService.get(cacheKey, User.class); if (user == null) { // 緩存未命中，從數據源獲取 QueryParameters params = new QueryParameters(); params.setName(userId); List\u0026lt;Record\u0026gt; records = dataSource.fetchData(params); if (!records.isEmpty()) { user = convertRecordToUser(records.get(0)); cacheService.put(cacheKey, user, Duration.ofMinutes(30)); } } if (user != null) { // 處理業務邏輯 processAction(user, action); // 發送通知 messageSender.sendMessage( user.getEmail(), \u0026#34;操作通知\u0026#34;, \u0026#34;您的操作 \u0026#34; + action + \u0026#34; 已完成\u0026#34; ); } } private User convertRecordToUser(Record record) { return new User(record.getId(), record.getName(), record.getValue()); } private void processAction(User user, String action) { // 具體的業務邏輯處理 System.out.println(\u0026#34;處理用戶 \u0026#34; + user.getName() + \u0026#34; 的操作: \u0026#34; + action); } } Spring Boot 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @Configuration public class AdapterPatternConfig { @Bean @Primary @Qualifier(\u0026#34;selectedDataSource\u0026#34;) public DataSource dataSource( @Value(\u0026#34;${app.datasource.type:database}\u0026#34;) String type, JdbcTemplate jdbcTemplate, RestTemplate restTemplate, @Value(\u0026#34;${app.api.base-url}\u0026#34;) String apiBaseUrl, @Value(\u0026#34;${app.file.data-path}\u0026#34;) String filePath) { switch (type.toLowerCase()) { case \u0026#34;api\u0026#34;: return new RestApiDataSourceAdapter(restTemplate, apiBaseUrl); case \u0026#34;file\u0026#34;: return new FileDataSourceAdapter(filePath); case \u0026#34;database\u0026#34;: default: return new DatabaseDataSource(jdbcTemplate); } } @Bean @Qualifier(\u0026#34;selectedMessageSender\u0026#34;) public MessageSender messageSender( @Value(\u0026#34;${app.messaging.type:email}\u0026#34;) String type, JavaMailSender mailSender, @Value(\u0026#34;${app.email.from}\u0026#34;) String fromAddress, SmsClient smsClient, @Value(\u0026#34;${app.sms.api-key}\u0026#34;) String smsApiKey, PushNotificationService pushService) { switch (type.toLowerCase()) { case \u0026#34;sms\u0026#34;: return new SmsServiceAdapter(smsClient, smsApiKey); case \u0026#34;push\u0026#34;: return new PushNotificationAdapter(pushService); case \u0026#34;email\u0026#34;: default: return new EmailServiceAdapter(mailSender, fromAddress); } } @Bean @Qualifier(\u0026#34;selectedCacheService\u0026#34;) public CacheService cacheService( @Value(\u0026#34;${app.cache.type:redis}\u0026#34;) String type, RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate) { switch (type.toLowerCase()) { case \u0026#34;memory\u0026#34;: return new MemoryCacheAdapter(); case \u0026#34;redis\u0026#34;: default: return new RedisCacheAdapter(redisTemplate); } } } 測試策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @ExtendWith(MockitoExtension.class) class AdapterPatternTest { @Mock private ThirdPartyPaymentSDK mockPaymentSDK; @Mock private JavaMailSender mockMailSender; @InjectMocks private ThirdPartyPaymentAdapter paymentAdapter; @InjectMocks private EmailServiceAdapter emailAdapter; @Test void testPaymentAdapter_Success() { // Given when(mockPaymentSDK.makePayment(anyString(), anyString(), anyMap())) .thenReturn(true); when(mockPaymentSDK.getTransactionId()) .thenReturn(\u0026#34;TXN_12345\u0026#34;); // When PaymentResult result = paymentAdapter.processPayment(100.0, \u0026#34;USD\u0026#34;); // Then assertTrue(result.isSuccess()); assertEquals(\u0026#34;支付成功\u0026#34;, result.getMessage()); assertEquals(\u0026#34;TXN_12345\u0026#34;, result.getTransactionId()); assertEquals(100.0, result.getAmount()); assertEquals(\u0026#34;USD\u0026#34;, result.getCurrency()); verify(mockPaymentSDK).makePayment(\u0026#34;100.0\u0026#34;, \u0026#34;USD\u0026#34;, anyMap()); verify(mockPaymentSDK).getTransactionId(); } @Test void testPaymentAdapter_Failure() { // Given when(mockPaymentSDK.makePayment(anyString(), anyString(), anyMap())) .thenReturn(false); // When PaymentResult result = paymentAdapter.processPayment(100.0, \u0026#34;USD\u0026#34;); // Then assertFalse(result.isSuccess()); assertEquals(\u0026#34;支付失敗\u0026#34;, result.getMessage()); assertNull(result.getTransactionId()); } @Test void testEmailAdapter_SendMessage() { // Given doNothing().when(mockMailSender).send(any(SimpleMailMessage.class)); // When emailAdapter.sendMessage(\u0026#34;test@example.com\u0026#34;, \u0026#34;測試主題\u0026#34;, \u0026#34;測試內容\u0026#34;); // Then verify(mockMailSender).send(any(SimpleMailMessage.class)); } @Test void testEmailAdapter_SendMessageException() { // Given doThrow(new RuntimeException(\u0026#34;郵件服務不可用\u0026#34;)) .when(mockMailSender).send(any(SimpleMailMessage.class)); // When \u0026amp; Then assertThrows(MessageSendException.class, () -\u0026gt; emailAdapter.sendMessage(\u0026#34;test@example.com\u0026#34;, \u0026#34;測試主題\u0026#34;, \u0026#34;測試內容\u0026#34;)); } } @SpringBootTest class AdapterPatternIntegrationTest { @Autowired private UnifiedServiceManager serviceManager; @Test void testUnifiedServiceManager_ProcessBusinessLogic() { // Given String userId = \u0026#34;testUser\u0026#34;; String action = \u0026#34;login\u0026#34;; // When serviceManager.processBusinessLogic(userId, action); // Then // 驗證業務邏輯是否正確執行 // 這裡可以檢查日誌、數據庫狀態等 } } 性能優化與最佳實踐 1. 適配器快取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class CachedAdapterWrapper\u0026lt;T\u0026gt; implements DataSource { private final T originalAdapter; private final CacheService cacheService; private final Duration cacheTtl; public CachedAdapterWrapper(T originalAdapter, CacheService cacheService, Duration cacheTtl) { this.originalAdapter = originalAdapter; this.cacheService = cacheService; this.cacheTtl = cacheTtl; } @Override public List\u0026lt;Record\u0026gt; fetchData(QueryParameters params) { String cacheKey = generateCacheKey(params); List\u0026lt;Record\u0026gt; cachedResult = cacheService.get(cacheKey, List.class); if (cachedResult != null) { return cachedResult; } List\u0026lt;Record\u0026gt; result = ((DataSource) originalAdapter).fetchData(params); cacheService.put(cacheKey, result, cacheTtl); return result; } private String generateCacheKey(QueryParameters params) { return \u0026#34;query:\u0026#34; + params.hashCode(); } } 2. 異步適配器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @Service public class AsyncMessageAdapter implements MessageSender { private final MessageSender originalSender; private final TaskExecutor taskExecutor; public AsyncMessageAdapter(MessageSender originalSender, TaskExecutor taskExecutor) { this.originalSender = originalSender; this.taskExecutor = taskExecutor; } @Override public void sendMessage(String recipient, String subject, String content) { taskExecutor.execute(() -\u0026gt; { try { originalSender.sendMessage(recipient, subject, content); } catch (Exception e) { // 記錄錯誤，可能需要重試機制 log.error(\u0026#34;異步消息發送失敗\u0026#34;, e); } }); } @Override public void sendBroadcast(String subject, String content) { taskExecutor.execute(() -\u0026gt; { try { originalSender.sendBroadcast(subject, content); } catch (Exception e) { log.error(\u0026#34;異步廣播發送失敗\u0026#34;, e); } }); } @Override public boolean isAvailable() { return originalSender.isAvailable(); } } 監控與診斷 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Component public class AdapterMonitor { private final MeterRegistry meterRegistry; private final Counter adaptationCounter; private final Timer adaptationTimer; public AdapterMonitor(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; this.adaptationCounter = Counter.builder(\u0026#34;adapter.invocations\u0026#34;) .description(\u0026#34;Number of adapter invocations\u0026#34;) .register(meterRegistry); this.adaptationTimer = Timer.builder(\u0026#34;adapter.duration\u0026#34;) .description(\u0026#34;Time spent in adapter methods\u0026#34;) .register(meterRegistry); } public \u0026lt;T\u0026gt; T monitorAdapterCall(String adapterName, String methodName, Supplier\u0026lt;T\u0026gt; supplier) { return Timer.Sample.start(meterRegistry) .stop(adaptationTimer.withTag(\u0026#34;adapter\u0026#34;, adapterName).withTag(\u0026#34;method\u0026#34;, methodName)) .recordCallable(() -\u0026gt; { adaptationCounter.increment(Tags.of(\u0026#34;adapter\u0026#34;, adapterName, \u0026#34;method\u0026#34;, methodName)); return supplier.get(); }); } } 總結 適配器模式是一種強大的結構型設計模式，特別適用於：\n遺留系統整合：將舊系統介面適配到新系統 第三方API整合：統一不同第三方服務的介面 多資料源支援：提供統一的數據存取介面 系統解耦：減少系統間的直接依賴 關鍵最佳實踐 單一職責：每個適配器只負責一種介面轉換 介面統一：設計清晰、一致的目標介面 錯誤處理：妥善處理適配過程中的異常 性能考量：適當使用快取和異步處理 監控診斷：追蹤適配器的使用情況和性能 適配器模式讓不相容的介面能夠協同工作，是企業級應用中不可或缺的設計模式。正確使用適配器模式可以大幅提升系統的可維護性和擴展性。\n","permalink":"https://xinqilin.github.io/post/architecture/adapter/","tags":["Design Pattern","Adapter Pattern","Structural Pattern","Interface Conversion","System Integration","Legacy System","Third-party API","Java","Spring Boot","Best Practices","Enterprise Architecture"],"title":"適配器模式 (Adapter Pattern) 完整實作指南：介面轉換與系統整合最佳實踐"},{"content":"原型模式 (Prototype Pattern) 完整實作指南 模式概述 原型模式是一種創建型設計模式，它允許通過複製現有的實例來創建新對象，而不需要知道具體創建過程的細節。這個模式特別適用於創建成本高昂或複雜的對象，通過克隆已存在的原型實例來避免重複的初始化過程。\n核心概念 1. 原型模式解決的問題 昂貴的對象創建：避免重複執行耗時的初始化操作 複雜的對象構造：簡化具有多個參數或複雜狀態的對象創建 運行時對象創建：在運行時動態決定要創建的對象類型 框架級對象管理：如 Spring 容器中的 prototype scope beans 2. 淺拷貝 vs 深拷貝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 /** * 示範淺拷貝和深拷貝的差異 */ public class CopyExample { public static class Address { private String street; private String city; public Address(String street, String city) { this.street = street; this.city = city; } // Copy constructor for deep copy public Address(Address address) { this.street = address.street; this.city = address.city; } // Getters and setters public String getStreet() { return street; } public void setStreet(String street) { this.street = street; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } @Override public String toString() { return String.format(\u0026#34;Address{street=\u0026#39;%s\u0026#39;, city=\u0026#39;%s\u0026#39;}\u0026#34;, street, city); } } public static class Person implements Cloneable { private String name; private int age; private Address address; // Reference type public Person(String name, int age, Address address) { this.name = name; this.age = age; this.address = address; } /** * 淺拷貝 - 只複製基本類型和引用地址 */ @Override public Person clone() throws CloneNotSupportedException { return (Person) super.clone(); // 淺拷貝 } /** * 深拷貝 - 遞歸複製所有引用對象 */ public Person deepClone() { Address newAddress = new Address(this.address); return new Person(this.name, this.age, newAddress); } // Getters and setters public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } @Override public String toString() { return String.format(\u0026#34;Person{name=\u0026#39;%s\u0026#39;, age=%d, address=%s}\u0026#34;, name, age, address); } } public static void main(String[] args) throws CloneNotSupportedException { // 原始對象 Address originalAddress = new Address(\u0026#34;123 Main St\u0026#34;, \u0026#34;台北市\u0026#34;); Person originalPerson = new Person(\u0026#34;John\u0026#34;, 30, originalAddress); // 淺拷貝測試 Person shallowCopy = originalPerson.clone(); System.out.println(\u0026#34;=== 淺拷貝測試 ===\u0026#34;); System.out.println(\u0026#34;原始: \u0026#34; + originalPerson); System.out.println(\u0026#34;淺拷貝: \u0026#34; + shallowCopy); // 修改淺拷貝的地址 shallowCopy.getAddress().setStreet(\u0026#34;456 Oak Ave\u0026#34;); System.out.println(\u0026#34;修改淺拷貝地址後:\u0026#34;); System.out.println(\u0026#34;原始: \u0026#34; + originalPerson); // 也被改變！ System.out.println(\u0026#34;淺拷貝: \u0026#34; + shallowCopy); // 深拷貝測試 originalAddress.setStreet(\u0026#34;123 Main St\u0026#34;); // 重置 Person deepCopy = originalPerson.deepClone(); System.out.println(\u0026#34;\\n=== 深拷貝測試 ===\u0026#34;); System.out.println(\u0026#34;原始: \u0026#34; + originalPerson); System.out.println(\u0026#34;深拷貝: \u0026#34; + deepCopy); // 修改深拷貝的地址 deepCopy.getAddress().setStreet(\u0026#34;789 Pine Rd\u0026#34;); System.out.println(\u0026#34;修改深拷貝地址後:\u0026#34;); System.out.println(\u0026#34;原始: \u0026#34; + originalPerson); // 不受影響 System.out.println(\u0026#34;深拷貝: \u0026#34; + deepCopy); } } 基礎實作範例 1. 原型接口設計 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * 通用原型接口 */ public interface Prototype\u0026lt;T\u0026gt; { T clone(); T deepClone(); } /** * 可序列化的深拷貝接口 */ public interface SerializablePrototype\u0026lt;T\u0026gt; extends Prototype\u0026lt;T\u0026gt;, Serializable { /** * 使用序列化實現深拷貝 */ @SuppressWarnings(\u0026#34;unchecked\u0026#34;) default T deepCloneViaSerialization() { try (ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(bos)) { out.writeObject(this); try (ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream in = new ObjectInputStream(bis)) { return (T) in.readObject(); } } catch (IOException | ClassNotFoundException e) { throw new RuntimeException(\u0026#34;深拷貝失敗\u0026#34;, e); } } } 2. 企業級原型管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /** * 原型管理器 - 管理和創建各種原型實例 */ @Component public class PrototypeManager { private final Map\u0026lt;String, Prototype\u0026lt;?\u0026gt;\u0026gt; prototypes = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final Logger logger = LoggerFactory.getLogger(PrototypeManager.class); /** * 註冊原型 */ public \u0026lt;T\u0026gt; void registerPrototype(String key, Prototype\u0026lt;T\u0026gt; prototype) { prototypes.put(key, prototype); logger.info(\u0026#34;註冊原型: {} -\u0026gt; {}\u0026#34;, key, prototype.getClass().getSimpleName()); } /** * 獲取原型的淺拷貝 */ @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T\u0026gt; T getClone(String key) { Prototype\u0026lt;T\u0026gt; prototype = (Prototype\u0026lt;T\u0026gt;) prototypes.get(key); if (prototype == null) { throw new IllegalArgumentException(\u0026#34;找不到原型: \u0026#34; + key); } T clone = prototype.clone(); logger.debug(\u0026#34;創建淺拷貝: {} -\u0026gt; {}\u0026#34;, key, clone.getClass().getSimpleName()); return clone; } /** * 獲取原型的深拷貝 */ @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T\u0026gt; T getDeepClone(String key) { Prototype\u0026lt;T\u0026gt; prototype = (Prototype\u0026lt;T\u0026gt;) prototypes.get(key); if (prototype == null) { throw new IllegalArgumentException(\u0026#34;找不到原型: \u0026#34; + key); } T deepClone = prototype.deepClone(); logger.debug(\u0026#34;創建深拷貝: {} -\u0026gt; {}\u0026#34;, key, deepClone.getClass().getSimpleName()); return deepClone; } /** * 列出所有可用的原型 */ public Set\u0026lt;String\u0026gt; getAvailablePrototypes() { return Collections.unmodifiableSet(prototypes.keySet()); } /** * 清除所有原型 */ public void clearPrototypes() { prototypes.clear(); logger.info(\u0026#34;清除所有原型\u0026#34;); } } 3. 複雜對象原型實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 /** * 企業級用戶配置原型 */ public class UserProfile implements SerializablePrototype\u0026lt;UserProfile\u0026gt; { private String userId; private String username; private String email; private List\u0026lt;String\u0026gt; roles; private Map\u0026lt;String, Object\u0026gt; preferences; private UserSettings settings; private LocalDateTime createdAt; private LocalDateTime lastModified; public UserProfile() { this.roles = new ArrayList\u0026lt;\u0026gt;(); this.preferences = new HashMap\u0026lt;\u0026gt;(); this.settings = new UserSettings(); this.createdAt = LocalDateTime.now(); this.lastModified = LocalDateTime.now(); } public UserProfile(String userId, String username, String email) { this(); this.userId = userId; this.username = username; this.email = email; } /** * 淺拷貝實現 */ @Override public UserProfile clone() { try { return (UserProfile) super.clone(); } catch (CloneNotSupportedException e) { throw new RuntimeException(\u0026#34;克隆失敗\u0026#34;, e); } } /** * 深拷貝實現 */ @Override public UserProfile deepClone() { UserProfile cloned = new UserProfile(); cloned.userId = this.userId; cloned.username = this.username; cloned.email = this.email; cloned.roles = new ArrayList\u0026lt;\u0026gt;(this.roles); cloned.preferences = new HashMap\u0026lt;\u0026gt;(this.preferences); cloned.settings = this.settings.deepClone(); cloned.createdAt = this.createdAt; cloned.lastModified = LocalDateTime.now(); return cloned; } /** * 用戶設置內部類 */ public static class UserSettings implements Serializable { private String theme; private String language; private boolean emailNotifications; private Map\u0026lt;String, String\u0026gt; customSettings; public UserSettings() { this.theme = \u0026#34;default\u0026#34;; this.language = \u0026#34;zh-TW\u0026#34;; this.emailNotifications = true; this.customSettings = new HashMap\u0026lt;\u0026gt;(); } public UserSettings deepClone() { UserSettings cloned = new UserSettings(); cloned.theme = this.theme; cloned.language = this.language; cloned.emailNotifications = this.emailNotifications; cloned.customSettings = new HashMap\u0026lt;\u0026gt;(this.customSettings); return cloned; } // Getters and setters public String getTheme() { return theme; } public void setTheme(String theme) { this.theme = theme; } public String getLanguage() { return language; } public void setLanguage(String language) { this.language = language; } public boolean isEmailNotifications() { return emailNotifications; } public void setEmailNotifications(boolean emailNotifications) { this.emailNotifications = emailNotifications; } public Map\u0026lt;String, String\u0026gt; getCustomSettings() { return customSettings; } public void setCustomSettings(Map\u0026lt;String, String\u0026gt; customSettings) { this.customSettings = customSettings; } } // Getters and setters public String getUserId() { return userId; } public void setUserId(String userId) { this.userId = userId; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public List\u0026lt;String\u0026gt; getRoles() { return roles; } public void setRoles(List\u0026lt;String\u0026gt; roles) { this.roles = roles; } public Map\u0026lt;String, Object\u0026gt; getPreferences() { return preferences; } public void setPreferences(Map\u0026lt;String, Object\u0026gt; preferences) { this.preferences = preferences; } public UserSettings getSettings() { return settings; } public void setSettings(UserSettings settings) { this.settings = settings; } public LocalDateTime getCreatedAt() { return createdAt; } public LocalDateTime getLastModified() { return lastModified; } public void setLastModified(LocalDateTime lastModified) { this.lastModified = lastModified; } @Override public String toString() { return String.format(\u0026#34;UserProfile{userId=\u0026#39;%s\u0026#39;, username=\u0026#39;%s\u0026#39;, email=\u0026#39;%s\u0026#39;, roles=%s}\u0026#34;, userId, username, email, roles); } } Spring Boot 整合 1. Spring Prototype Scope 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 /** * Spring Prototype Scope 配置 */ @Configuration public class PrototypePatternConfig { /** * Prototype scope bean - 每次注入時創建新實例 */ @Bean @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) public UserProfile prototypeUserProfile() { UserProfile profile = new UserProfile(); profile.setUsername(\u0026#34;prototype-user\u0026#34;); profile.setEmail(\u0026#34;prototype@example.com\u0026#34;); profile.getRoles().add(\u0026#34;USER\u0026#34;); return profile; } /** * 使用 @Lookup 方法注入 prototype bean */ @Component public static abstract class UserProfileFactory { @Lookup public abstract UserProfile createUserProfile(); /** * 創建自定義用戶配置 */ public UserProfile createCustomUserProfile(String userId, String username, String email) { UserProfile profile = createUserProfile(); profile.setUserId(userId); profile.setUsername(username); profile.setEmail(email); return profile; } } /** * 原型管理器配置 */ @Bean public PrototypeManager prototypeManager() { PrototypeManager manager = new PrototypeManager(); // 註冊預設原型 manager.registerPrototype(\u0026#34;admin-user\u0026#34;, createAdminUserProfile()); manager.registerPrototype(\u0026#34;guest-user\u0026#34;, createGuestUserProfile()); manager.registerPrototype(\u0026#34;vip-user\u0026#34;, createVipUserProfile()); return manager; } private UserProfile createAdminUserProfile() { UserProfile admin = new UserProfile(\u0026#34;admin\u0026#34;, \u0026#34;Administrator\u0026#34;, \u0026#34;admin@company.com\u0026#34;); admin.getRoles().addAll(Arrays.asList(\u0026#34;ADMIN\u0026#34;, \u0026#34;USER\u0026#34;, \u0026#34;MODERATOR\u0026#34;)); admin.getPreferences().put(\u0026#34;theme\u0026#34;, \u0026#34;dark\u0026#34;); admin.getPreferences().put(\u0026#34;language\u0026#34;, \u0026#34;en-US\u0026#34;); return admin; } private UserProfile createGuestUserProfile() { UserProfile guest = new UserProfile(\u0026#34;guest\u0026#34;, \u0026#34;Guest User\u0026#34;, \u0026#34;guest@example.com\u0026#34;); guest.getRoles().add(\u0026#34;GUEST\u0026#34;); guest.getPreferences().put(\u0026#34;theme\u0026#34;, \u0026#34;light\u0026#34;); guest.getPreferences().put(\u0026#34;language\u0026#34;, \u0026#34;zh-TW\u0026#34;); return guest; } private UserProfile createVipUserProfile() { UserProfile vip = new UserProfile(\u0026#34;vip\u0026#34;, \u0026#34;VIP User\u0026#34;, \u0026#34;vip@company.com\u0026#34;); vip.getRoles().addAll(Arrays.asList(\u0026#34;VIP\u0026#34;, \u0026#34;USER\u0026#34;)); vip.getPreferences().put(\u0026#34;theme\u0026#34;, \u0026#34;premium\u0026#34;); vip.getPreferences().put(\u0026#34;notifications\u0026#34;, \u0026#34;immediate\u0026#34;); return vip; } } 2. Spring Boot 服務層整合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 /** * 用戶配置服務 */ @Service @Transactional public class UserProfileService { private final PrototypeManager prototypeManager; private final UserProfileFactory userProfileFactory; private final ApplicationEventPublisher eventPublisher; private final Logger logger = LoggerFactory.getLogger(UserProfileService.class); public UserProfileService(PrototypeManager prototypeManager, UserProfileFactory userProfileFactory, ApplicationEventPublisher eventPublisher) { this.prototypeManager = prototypeManager; this.userProfileFactory = userProfileFactory; this.eventPublisher = eventPublisher; } /** * 基於原型創建用戶配置 */ public UserProfile createUserProfileFromPrototype(String prototypeKey, String userId) { try { UserProfile template = prototypeManager.getDeepClone(prototypeKey); template.setUserId(userId); template.setLastModified(LocalDateTime.now()); logger.info(\u0026#34;基於原型 {} 創建用戶配置: {}\u0026#34;, prototypeKey, userId); eventPublisher.publishEvent(new UserProfileCreatedEvent(template, prototypeKey)); return template; } catch (Exception e) { logger.error(\u0026#34;創建用戶配置失敗: prototype={}, userId={}\u0026#34;, prototypeKey, userId, e); throw new UserProfileCreationException(\u0026#34;無法創建用戶配置\u0026#34;, e); } } /** * 批量創建用戶配置 */ public List\u0026lt;UserProfile\u0026gt; createBatchUserProfiles(String prototypeKey, List\u0026lt;String\u0026gt; userIds) { return userIds.stream() .map(userId -\u0026gt; createUserProfileFromPrototype(prototypeKey, userId)) .collect(Collectors.toList()); } /** * 從 Spring prototype scope 創建配置 */ public UserProfile createUserProfileFromSpringPrototype(String userId, String username, String email) { UserProfile profile = userProfileFactory.createCustomUserProfile(userId, username, email); logger.info(\u0026#34;從 Spring prototype 創建用戶配置: {}\u0026#34;, userId); eventPublisher.publishEvent(new UserProfileCreatedEvent(profile, \u0026#34;spring-prototype\u0026#34;)); return profile; } /** * 複製現有用戶配置 */ public UserProfile cloneUserProfile(UserProfile source, String newUserId, boolean deepCopy) { UserProfile cloned = deepCopy ? source.deepClone() : source.clone(); cloned.setUserId(newUserId); cloned.setCreatedAt(LocalDateTime.now()); cloned.setLastModified(LocalDateTime.now()); String copyType = deepCopy ? \u0026#34;深拷貝\u0026#34; : \u0026#34;淺拷貝\u0026#34;; logger.info(\u0026#34;{}用戶配置: {} -\u0026gt; {}\u0026#34;, copyType, source.getUserId(), newUserId); return cloned; } } /** * 用戶配置創建事件 */ public class UserProfileCreatedEvent { private final UserProfile userProfile; private final String sourceType; private final LocalDateTime timestamp; public UserProfileCreatedEvent(UserProfile userProfile, String sourceType) { this.userProfile = userProfile; this.sourceType = sourceType; this.timestamp = LocalDateTime.now(); } // Getters public UserProfile getUserProfile() { return userProfile; } public String getSourceType() { return sourceType; } public LocalDateTime getTimestamp() { return timestamp; } } /** * 自定義異常 */ public class UserProfileCreationException extends RuntimeException { public UserProfileCreationException(String message, Throwable cause) { super(message, cause); } } 3. REST API 控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 /** * 用戶配置 REST API */ @RestController @RequestMapping(\u0026#34;/api/user-profiles\u0026#34;) @Validated public class UserProfileController { private final UserProfileService userProfileService; private final PrototypeManager prototypeManager; public UserProfileController(UserProfileService userProfileService, PrototypeManager prototypeManager) { this.userProfileService = userProfileService; this.prototypeManager = prototypeManager; } /** * 基於原型創建用戶配置 */ @PostMapping(\u0026#34;/create/{prototypeKey}\u0026#34;) public ResponseEntity\u0026lt;UserProfileResponse\u0026gt; createFromPrototype( @PathVariable String prototypeKey, @RequestParam String userId) { try { UserProfile profile = userProfileService.createUserProfileFromPrototype(prototypeKey, userId); return ResponseEntity.ok(UserProfileResponse.success(profile)); } catch (IllegalArgumentException e) { return ResponseEntity.badRequest() .body(UserProfileResponse.error(\u0026#34;無效的原型: \u0026#34; + prototypeKey)); } catch (Exception e) { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(UserProfileResponse.error(\u0026#34;創建失敗: \u0026#34; + e.getMessage())); } } /** * 批量創建用戶配置 */ @PostMapping(\u0026#34;/batch/{prototypeKey}\u0026#34;) public ResponseEntity\u0026lt;BatchUserProfileResponse\u0026gt; createBatch( @PathVariable String prototypeKey, @RequestBody @Valid BatchCreateRequest request) { try { List\u0026lt;UserProfile\u0026gt; profiles = userProfileService.createBatchUserProfiles( prototypeKey, request.getUserIds()); return ResponseEntity.ok(BatchUserProfileResponse.success(profiles)); } catch (Exception e) { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(BatchUserProfileResponse.error(\u0026#34;批量創建失敗: \u0026#34; + e.getMessage())); } } /** * 複製用戶配置 */ @PostMapping(\u0026#34;/clone\u0026#34;) public ResponseEntity\u0026lt;UserProfileResponse\u0026gt; cloneProfile( @RequestBody @Valid CloneProfileRequest request) { // 這裡簡化為從原型克隆，實際應用中可能從現有用戶配置克隆 UserProfile source = userProfileService.createUserProfileFromPrototype( request.getSourcePrototype(), \u0026#34;temp\u0026#34;); UserProfile cloned = userProfileService.cloneUserProfile( source, request.getNewUserId(), request.isDeepCopy()); return ResponseEntity.ok(UserProfileResponse.success(cloned)); } /** * 獲取可用的原型 */ @GetMapping(\u0026#34;/prototypes\u0026#34;) public ResponseEntity\u0026lt;Set\u0026lt;String\u0026gt;\u0026gt; getAvailablePrototypes() { Set\u0026lt;String\u0026gt; prototypes = prototypeManager.getAvailablePrototypes(); return ResponseEntity.ok(prototypes); } } /** * 請求 DTO */ public static class BatchCreateRequest { @NotEmpty private List\u0026lt;String\u0026gt; userIds; public List\u0026lt;String\u0026gt; getUserIds() { return userIds; } public void setUserIds(List\u0026lt;String\u0026gt; userIds) { this.userIds = userIds; } } public static class CloneProfileRequest { @NotBlank private String sourcePrototype; @NotBlank private String newUserId; private boolean deepCopy = true; public String getSourcePrototype() { return sourcePrototype; } public void setSourcePrototype(String sourcePrototype) { this.sourcePrototype = sourcePrototype; } public String getNewUserId() { return newUserId; } public void setNewUserId(String newUserId) { this.newUserId = newUserId; } public boolean isDeepCopy() { return deepCopy; } public void setDeepCopy(boolean deepCopy) { this.deepCopy = deepCopy; } } /** * 回應 DTO */ public static class UserProfileResponse { private boolean success; private String message; private UserProfile data; private LocalDateTime timestamp; private UserProfileResponse(boolean success, String message, UserProfile data) { this.success = success; this.message = message; this.data = data; this.timestamp = LocalDateTime.now(); } public static UserProfileResponse success(UserProfile profile) { return new UserProfileResponse(true, \u0026#34;操作成功\u0026#34;, profile); } public static UserProfileResponse error(String message) { return new UserProfileResponse(false, message, null); } // Getters public boolean isSuccess() { return success; } public String getMessage() { return message; } public UserProfile getData() { return data; } public LocalDateTime getTimestamp() { return timestamp; } } public static class BatchUserProfileResponse { private boolean success; private String message; private List\u0026lt;UserProfile\u0026gt; data; private int totalCount; private LocalDateTime timestamp; private BatchUserProfileResponse(boolean success, String message, List\u0026lt;UserProfile\u0026gt; data) { this.success = success; this.message = message; this.data = data; this.totalCount = data != null ? data.size() : 0; this.timestamp = LocalDateTime.now(); } public static BatchUserProfileResponse success(List\u0026lt;UserProfile\u0026gt; profiles) { return new BatchUserProfileResponse(true, \u0026#34;批量操作成功\u0026#34;, profiles); } public static BatchUserProfileResponse error(String message) { return new BatchUserProfileResponse(false, message, null); } // Getters public boolean isSuccess() { return success; } public String getMessage() { return message; } public List\u0026lt;UserProfile\u0026gt; getData() { return data; } public int getTotalCount() { return totalCount; } public LocalDateTime getTimestamp() { return timestamp; } } 進階主題 1. 效能優化策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 /** * 高效能原型管理器 */ @Component public class OptimizedPrototypeManager extends PrototypeManager { private final Cache\u0026lt;String, Object\u0026gt; prototypeCache; private final ExecutorService executorService; private final AtomicLong cloneCounter = new AtomicLong(0); public OptimizedPrototypeManager() { this.prototypeCache = Caffeine.newBuilder() .maximumSize(500) .expireAfterAccess(30, TimeUnit.MINUTES) .recordStats() .build(); this.executorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); } /** * 異步批量克隆 */ public \u0026lt;T\u0026gt; CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; asyncBatchClone(String prototypeKey, int count) { return CompletableFuture.supplyAsync(() -\u0026gt; { List\u0026lt;T\u0026gt; results = new ArrayList\u0026lt;\u0026gt;(count); for (int i = 0; i \u0026lt; count; i++) { results.add(getDeepClone(prototypeKey)); } cloneCounter.addAndGet(count); return results; }, executorService); } /** * 帶快取的克隆 */ @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T\u0026gt; T getCachedClone(String key, Duration cacheDuration) { String cacheKey = key + \u0026#34;_cached\u0026#34;; return (T) prototypeCache.get(cacheKey, k -\u0026gt; { T clone = getDeepClone(key); // 設定快取過期時間（簡化實現） return clone; }); } /** * 效能統計 */ public PrototypeManagerStats getStats() { CacheStats cacheStats = prototypeCache.stats(); return new PrototypeManagerStats( cloneCounter.get(), cacheStats.hitRate(), cacheStats.missRate(), cacheStats.evictionCount() ); } public static class PrototypeManagerStats { private final long totalClones; private final double cacheHitRate; private final double cacheMissRate; private final long cacheEvictions; public PrototypeManagerStats(long totalClones, double cacheHitRate, double cacheMissRate, long cacheEvictions) { this.totalClones = totalClones; this.cacheHitRate = cacheHitRate; this.cacheMissRate = cacheMissRate; this.cacheEvictions = cacheEvictions; } // Getters public long getTotalClones() { return totalClones; } public double getCacheHitRate() { return cacheHitRate; } public double getCacheMissRate() { return cacheMissRate; } public long getCacheEvictions() { return cacheEvictions; } @Override public String toString() { return String.format(\u0026#34;PrototypeManagerStats{totalClones=%d, hitRate=%.2f%%, missRate=%.2f%%, evictions=%d}\u0026#34;, totalClones, cacheHitRate * 100, cacheMissRate * 100, cacheEvictions); } } } 2. 測試策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 /** * 原型模式單元測試 */ @ExtendWith(MockitoExtension.class) class PrototypePatternTest { @InjectMocks private PrototypeManager prototypeManager; @Test void testShallowVsDeepCopy() { // Given UserProfile original = createTestUserProfile(); // When - 淺拷貝 UserProfile shallowCopy = original.clone(); shallowCopy.getSettings().setTheme(\u0026#34;dark\u0026#34;); // Then - 原始對象也被修改 assertThat(original.getSettings().getTheme()).isEqualTo(\u0026#34;dark\u0026#34;); // When - 深拷貝 UserProfile deepCopy = original.deepClone(); deepCopy.getSettings().setTheme(\u0026#34;blue\u0026#34;); // Then - 原始對象不受影響 assertThat(original.getSettings().getTheme()).isEqualTo(\u0026#34;dark\u0026#34;); assertThat(deepCopy.getSettings().getTheme()).isEqualTo(\u0026#34;blue\u0026#34;); } @Test void testPrototypeManagerRegistration() { // Given UserProfile adminPrototype = createAdminUserProfile(); // When prototypeManager.registerPrototype(\u0026#34;admin\u0026#34;, adminPrototype); // Then assertThat(prototypeManager.getAvailablePrototypes()).contains(\u0026#34;admin\u0026#34;); UserProfile cloned = prototypeManager.getDeepClone(\u0026#34;admin\u0026#34;); assertThat(cloned).isNotSameAs(adminPrototype); assertThat(cloned.getUsername()).isEqualTo(adminPrototype.getUsername()); } @Test void testSerializationDeepCopy() { // Given UserProfile original = createTestUserProfile(); // When UserProfile serializedCopy = original.deepCloneViaSerialization(); // Then assertThat(serializedCopy).isNotSameAs(original); assertThat(serializedCopy.getSettings()).isNotSameAs(original.getSettings()); assertThat(serializedCopy.getUsername()).isEqualTo(original.getUsername()); } @Test void testPrototypeNotFound() { // When \u0026amp; Then assertThatThrownBy(() -\u0026gt; prototypeManager.getClone(\u0026#34;non-existent\u0026#34;)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(\u0026#34;找不到原型\u0026#34;); } private UserProfile createTestUserProfile() { UserProfile profile = new UserProfile(\u0026#34;test-001\u0026#34;, \u0026#34;testuser\u0026#34;, \u0026#34;test@example.com\u0026#34;); profile.getRoles().add(\u0026#34;USER\u0026#34;); profile.getPreferences().put(\u0026#34;language\u0026#34;, \u0026#34;zh-TW\u0026#34;); return profile; } private UserProfile createAdminUserProfile() { UserProfile admin = new UserProfile(\u0026#34;admin-001\u0026#34;, \u0026#34;admin\u0026#34;, \u0026#34;admin@company.com\u0026#34;); admin.getRoles().addAll(Arrays.asList(\u0026#34;ADMIN\u0026#34;, \u0026#34;USER\u0026#34;)); admin.getPreferences().put(\u0026#34;theme\u0026#34;, \u0026#34;admin\u0026#34;); return admin; } } /** * Spring Boot 整合測試 */ @SpringBootTest @TestPropertySource(properties = { \u0026#34;logging.level.com.example.prototype=DEBUG\u0026#34; }) class PrototypePatternIntegrationTest { @Autowired private UserProfileService userProfileService; @Autowired private PrototypeManager prototypeManager; @Test void testSpringPrototypeScopeCreation() { // When UserProfile profile1 = userProfileService.createUserProfileFromSpringPrototype( \u0026#34;user1\u0026#34;, \u0026#34;testuser1\u0026#34;, \u0026#34;test1@example.com\u0026#34;); UserProfile profile2 = userProfileService.createUserProfileFromSpringPrototype( \u0026#34;user2\u0026#34;, \u0026#34;testuser2\u0026#34;, \u0026#34;test2@example.com\u0026#34;); // Then assertThat(profile1).isNotSameAs(profile2); assertThat(profile1.getUserId()).isEqualTo(\u0026#34;user1\u0026#34;); assertThat(profile2.getUserId()).isEqualTo(\u0026#34;user2\u0026#34;); } @Test void testPrototypeManagerIntegration() { // Given Set\u0026lt;String\u0026gt; availablePrototypes = prototypeManager.getAvailablePrototypes(); assertThat(availablePrototypes).isNotEmpty(); // When String prototypeKey = availablePrototypes.iterator().next(); UserProfile profile = userProfileService.createUserProfileFromPrototype(prototypeKey, \u0026#34;integration-test\u0026#34;); // Then assertThat(profile).isNotNull(); assertThat(profile.getUserId()).isEqualTo(\u0026#34;integration-test\u0026#34;); } @Test void testBatchUserProfileCreation() { // Given List\u0026lt;String\u0026gt; userIds = Arrays.asList(\u0026#34;batch1\u0026#34;, \u0026#34;batch2\u0026#34;, \u0026#34;batch3\u0026#34;); // When List\u0026lt;UserProfile\u0026gt; profiles = userProfileService.createBatchUserProfiles(\u0026#34;guest-user\u0026#34;, userIds); // Then assertThat(profiles).hasSize(3); assertThat(profiles.stream().map(UserProfile::getUserId)) .containsExactlyInAnyOrder(\u0026#34;batch1\u0026#34;, \u0026#34;batch2\u0026#34;, \u0026#34;batch3\u0026#34;); } } 最佳實踐與建議 1. 設計原則 明確拷貝語義：清楚定義何時使用淺拷貝，何時使用深拷貝 異常處理：確保克隆過程中的異常得到適當處理 效能考量：對於頻繁克隆的對象考慮使用對象池或快取 2. 常見陷阱 避免在拷貝過程中修改狀態 1 2 3 4 5 6 7 8 9 10 11 12 // ❌ 錯誤的設計 - 在克隆中修改狀態 public UserProfile clone() { UserProfile cloned = (UserProfile) super.clone(); cloned.setLastModified(LocalDateTime.now()); // 可能導致併發問題 return cloned; } // ✅ 正確的設計 - 在克隆後設定狀態 public UserProfile clone() { UserProfile cloned = (UserProfile) super.clone(); return cloned; } 正確處理序列化版本 1 2 3 4 5 // ✅ 添加 serialVersionUID 確保序列化兼容性 public class UserProfile implements SerializablePrototype\u0026lt;UserProfile\u0026gt; { private static final long serialVersionUID = 1L; // ... } 3. 使用建議 適用場景：昂貴對象創建、複雜狀態初始化、動態對象類型選擇 Spring 整合：善用 prototype scope 和 @Lookup 方法注入 效能優化：考慮使用對象池、快取和異步處理 總結 原型模式通過複製現有對象來創建新實例，避免了重複的初始化過程，特別適合創建成本高昂或狀態複雜的對象。在企業級應用中，結合 Spring 框架的 prototype scope 和依賴注入機制，可以實現靈活且高效的對象創建策略。\n主要優點 效能提升：避免昂貴的對象創建過程 簡化創建：隱藏複雜的對象構造邏輯 動態類型：運行時決定創建的對象類型 狀態保持：保持原型對象的初始狀態 主要缺點 深拷貝複雜性：處理循環引用和深層嵌套對象 克隆實現要求：每個類都需要實現克隆邏輯 內存使用：可能增加內存佔用 正確使用原型模式可以有效提升對象創建的效率和靈活性，是企業級應用開發中重要的創建型設計模式。\n","permalink":"https://xinqilin.github.io/post/architecture/prototype/","tags":["Design Pattern","Prototype Pattern","Creational Pattern","Object Cloning","Deep Copy","Shallow Copy","Spring Prototype","Bean Scope","Java","Spring Boot","Enterprise Architecture","Object Creation","Memory Management","Performance Optimization","Serialization","Copy Constructor","Best Practices"],"title":"原型模式 (Prototype Pattern) 完整實作指南：深淺拷貝、Spring Prototype Scope 與企業級對象創建最佳實踐"},{"content":"建造者模式 (Builder Pattern) 完整實作指南 模式概述 建造者模式是一種創建型設計模式，它將複雜對象的構造與其表示分離，使得同樣的構造過程可以創建不同的表示。該模式特別適用於構造參數眾多、配置複雜的對象。\n核心概念 建造者模式解決的核心問題：\n複雜對象構造：當對象有多個可選參數時，避免構造函數參數過多 步驟化構造：將對象構造過程分解為多個步驟 不變性保證：確保構造完成的對象是不可變的 可讀性提升：提供清晰、直觀的對象構造方式 傳統建造者模式實現 1. 基本結構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 // 產品類 - 要構造的複雜對象 public class Computer { private String cpu; private String memory; private String storage; private String graphics; private String motherboard; private String powerSupply; private String coolingSystem; private boolean isOverclocked; // 私有構造函數，只能通過Builder創建 private Computer(Builder builder) { this.cpu = builder.cpu; this.memory = builder.memory; this.storage = builder.storage; this.graphics = builder.graphics; this.motherboard = builder.motherboard; this.powerSupply = builder.powerSupply; this.coolingSystem = builder.coolingSystem; this.isOverclocked = builder.isOverclocked; } // 抽象建造者接口 public interface ComputerBuilder { ComputerBuilder setCpu(String cpu); ComputerBuilder setMemory(String memory); ComputerBuilder setStorage(String storage); ComputerBuilder setGraphics(String graphics); ComputerBuilder setMotherboard(String motherboard); ComputerBuilder setPowerSupply(String powerSupply); ComputerBuilder setCoolingSystem(String coolingSystem); ComputerBuilder setOverclocked(boolean overclocked); Computer build(); } // 具體建造者實現 public static class Builder implements ComputerBuilder { private String cpu; private String memory; private String storage; private String graphics; private String motherboard; private String powerSupply; private String coolingSystem; private boolean isOverclocked; @Override public Builder setCpu(String cpu) { this.cpu = cpu; return this; } @Override public Builder setMemory(String memory) { this.memory = memory; return this; } @Override public Builder setStorage(String storage) { this.storage = storage; return this; } @Override public Builder setGraphics(String graphics) { this.graphics = graphics; return this; } @Override public Builder setMotherboard(String motherboard) { this.motherboard = motherboard; return this; } @Override public Builder setPowerSupply(String powerSupply) { this.powerSupply = powerSupply; return this; } @Override public Builder setCoolingSystem(String coolingSystem) { this.coolingSystem = coolingSystem; return this; } @Override public Builder setOverclocked(boolean overclocked) { this.isOverclocked = overclocked; return this; } @Override public Computer build() { validateConfiguration(); return new Computer(this); } private void validateConfiguration() { if (cpu == null) { throw new IllegalStateException(\u0026#34;CPU 是必需的組件\u0026#34;); } if (memory == null) { throw new IllegalStateException(\u0026#34;記憶體是必需的組件\u0026#34;); } if (storage == null) { throw new IllegalStateException(\u0026#34;儲存設備是必需的組件\u0026#34;); } if (isOverclocked \u0026amp;\u0026amp; coolingSystem == null) { throw new IllegalStateException(\u0026#34;超頻配置需要冷卻系統\u0026#34;); } } } // 指導者類 - 定義構造步驟 public static class Director { public Computer buildGamingComputer() { return new Builder() .setCpu(\u0026#34;Intel i9-13900K\u0026#34;) .setMemory(\u0026#34;32GB DDR5\u0026#34;) .setStorage(\u0026#34;1TB NVMe SSD\u0026#34;) .setGraphics(\u0026#34;RTX 4080\u0026#34;) .setMotherboard(\u0026#34;ASUS ROG Maximus\u0026#34;) .setPowerSupply(\u0026#34;850W 80+ Gold\u0026#34;) .setCoolingSystem(\u0026#34;AIO 240mm\u0026#34;) .setOverclocked(true) .build(); } public Computer buildOfficeComputer() { return new Builder() .setCpu(\u0026#34;Intel i5-13400\u0026#34;) .setMemory(\u0026#34;16GB DDR4\u0026#34;) .setStorage(\u0026#34;512GB SATA SSD\u0026#34;) .setGraphics(\u0026#34;Intel UHD Graphics\u0026#34;) .setMotherboard(\u0026#34;MSI B660\u0026#34;) .setPowerSupply(\u0026#34;500W 80+ Bronze\u0026#34;) .build(); } public Computer buildWorkstationComputer() { return new Builder() .setCpu(\u0026#34;AMD Ryzen 9 7950X\u0026#34;) .setMemory(\u0026#34;64GB DDR5\u0026#34;) .setStorage(\u0026#34;2TB NVMe SSD\u0026#34;) .setGraphics(\u0026#34;RTX 4090\u0026#34;) .setMotherboard(\u0026#34;ASUS ProArt\u0026#34;) .setPowerSupply(\u0026#34;1000W 80+ Platinum\u0026#34;) .setCoolingSystem(\u0026#34;Custom Loop\u0026#34;) .build(); } } // Getter 方法 public String getCpu() { return cpu; } public String getMemory() { return memory; } public String getStorage() { return storage; } public String getGraphics() { return graphics; } public String getMotherboard() { return motherboard; } public String getPowerSupply() { return powerSupply; } public String getCoolingSystem() { return coolingSystem; } public boolean isOverclocked() { return isOverclocked; } @Override public String toString() { return \u0026#34;Computer{\u0026#34; + \u0026#34;cpu=\u0026#39;\u0026#34; + cpu + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, memory=\u0026#39;\u0026#34; + memory + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, storage=\u0026#39;\u0026#34; + storage + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, graphics=\u0026#39;\u0026#34; + graphics + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, motherboard=\u0026#39;\u0026#34; + motherboard + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, powerSupply=\u0026#39;\u0026#34; + powerSupply + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, coolingSystem=\u0026#39;\u0026#34; + coolingSystem + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, isOverclocked=\u0026#34; + isOverclocked + \u0026#39;}\u0026#39;; } } 2. 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class BuilderPatternExample { public static void main(String[] args) { // 使用 Director 構造預定義配置 Computer.Director director = new Computer.Director(); Computer gamingPC = director.buildGamingComputer(); System.out.println(\u0026#34;遊戲電腦: \u0026#34; + gamingPC); Computer officePC = director.buildOfficeComputer(); System.out.println(\u0026#34;辦公電腦: \u0026#34; + officePC); // 直接使用 Builder 自定義配置 Computer customPC = new Computer.Builder() .setCpu(\u0026#34;AMD Ryzen 7 7800X3D\u0026#34;) .setMemory(\u0026#34;32GB DDR5\u0026#34;) .setStorage(\u0026#34;1TB NVMe SSD\u0026#34;) .setGraphics(\u0026#34;RTX 4070\u0026#34;) .setMotherboard(\u0026#34;MSI MAG X670E\u0026#34;) .setPowerSupply(\u0026#34;750W 80+ Gold\u0026#34;) .setCoolingSystem(\u0026#34;Air Cooler\u0026#34;) .build(); System.out.println(\u0026#34;自定義電腦: \u0026#34; + customPC); } } 現代建造者模式實現 1. 流式介面建造者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 // 現代化的建造者模式實現 public class DatabaseConfiguration { private final String host; private final int port; private final String database; private final String username; private final String password; private final int connectionPoolSize; private final int connectionTimeout; private final boolean useSSL; private final boolean autoReconnect; private final Map\u0026lt;String, String\u0026gt; properties; private DatabaseConfiguration(Builder builder) { this.host = builder.host; this.port = builder.port; this.database = builder.database; this.username = builder.username; this.password = builder.password; this.connectionPoolSize = builder.connectionPoolSize; this.connectionTimeout = builder.connectionTimeout; this.useSSL = builder.useSSL; this.autoReconnect = builder.autoReconnect; this.properties = Collections.unmodifiableMap(new HashMap\u0026lt;\u0026gt;(builder.properties)); } public static class Builder { // 必需參數 private String host; private int port; private String database; private String username; private String password; // 可選參數，提供默認值 private int connectionPoolSize = 10; private int connectionTimeout = 30000; private boolean useSSL = false; private boolean autoReconnect = true; private Map\u0026lt;String, String\u0026gt; properties = new HashMap\u0026lt;\u0026gt;(); // 必需參數的構造函數 public Builder(String host, int port, String database, String username, String password) { this.host = requireNonNull(host, \u0026#34;Host 不能為空\u0026#34;); this.port = requireValidPort(port); this.database = requireNonNull(database, \u0026#34;Database 不能為空\u0026#34;); this.username = requireNonNull(username, \u0026#34;Username 不能為空\u0026#34;); this.password = requireNonNull(password, \u0026#34;Password 不能為空\u0026#34;); } public Builder connectionPoolSize(int size) { if (size \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;連接池大小必須大於0\u0026#34;); } this.connectionPoolSize = size; return this; } public Builder connectionTimeout(int timeout) { if (timeout \u0026lt; 0) { throw new IllegalArgumentException(\u0026#34;連接超時不能為負數\u0026#34;); } this.connectionTimeout = timeout; return this; } public Builder useSSL(boolean useSSL) { this.useSSL = useSSL; return this; } public Builder autoReconnect(boolean autoReconnect) { this.autoReconnect = autoReconnect; return this; } public Builder property(String key, String value) { this.properties.put(requireNonNull(key), requireNonNull(value)); return this; } public Builder properties(Map\u0026lt;String, String\u0026gt; properties) { this.properties.putAll(requireNonNull(properties)); return this; } public DatabaseConfiguration build() { validateConfiguration(); return new DatabaseConfiguration(this); } private void validateConfiguration() { if (useSSL \u0026amp;\u0026amp; port == 3306) { throw new IllegalStateException(\u0026#34;SSL 連接建議使用非標準端口\u0026#34;); } if (connectionPoolSize \u0026gt; 100) { throw new IllegalStateException(\u0026#34;連接池大小過大，建議不超過100\u0026#34;); } } private String requireNonNull(String value, String message) { if (value == null || value.trim().isEmpty()) { throw new IllegalArgumentException(message); } return value; } private String requireNonNull(String value) { return requireNonNull(value, \u0026#34;值不能為空\u0026#34;); } private int requireValidPort(int port) { if (port \u0026lt; 1 || port \u0026gt; 65535) { throw new IllegalArgumentException(\u0026#34;端口必須在1-65535之間\u0026#34;); } return port; } } // Getter 方法 public String getHost() { return host; } public int getPort() { return port; } public String getDatabase() { return database; } public String getUsername() { return username; } public String getPassword() { return password; } public int getConnectionPoolSize() { return connectionPoolSize; } public int getConnectionTimeout() { return connectionTimeout; } public boolean isUseSSL() { return useSSL; } public boolean isAutoReconnect() { return autoReconnect; } public Map\u0026lt;String, String\u0026gt; getProperties() { return properties; } @Override public String toString() { return \u0026#34;DatabaseConfiguration{\u0026#34; + \u0026#34;host=\u0026#39;\u0026#34; + host + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, port=\u0026#34; + port + \u0026#34;, database=\u0026#39;\u0026#34; + database + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, username=\u0026#39;\u0026#34; + username + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, connectionPoolSize=\u0026#34; + connectionPoolSize + \u0026#34;, connectionTimeout=\u0026#34; + connectionTimeout + \u0026#34;, useSSL=\u0026#34; + useSSL + \u0026#34;, autoReconnect=\u0026#34; + autoReconnect + \u0026#34;, properties=\u0026#34; + properties + \u0026#39;}\u0026#39;; } } 2. 泛型建造者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 // 泛型建造者基類 public abstract class GenericBuilder\u0026lt;T\u0026gt; { protected abstract T build(); protected void validate() { // 子類可以重寫此方法進行驗證 } } // HTTP 客戶端配置建造者 public class HttpClientConfig { private final String baseUrl; private final int connectionTimeout; private final int readTimeout; private final Map\u0026lt;String, String\u0026gt; headers; private final boolean followRedirects; private final ProxyConfig proxy; private final SSLConfig sslConfig; private HttpClientConfig(Builder builder) { this.baseUrl = builder.baseUrl; this.connectionTimeout = builder.connectionTimeout; this.readTimeout = builder.readTimeout; this.headers = Collections.unmodifiableMap(builder.headers); this.followRedirects = builder.followRedirects; this.proxy = builder.proxy; this.sslConfig = builder.sslConfig; } public static class Builder extends GenericBuilder\u0026lt;HttpClientConfig\u0026gt; { private String baseUrl; private int connectionTimeout = 5000; private int readTimeout = 10000; private Map\u0026lt;String, String\u0026gt; headers = new HashMap\u0026lt;\u0026gt;(); private boolean followRedirects = true; private ProxyConfig proxy; private SSLConfig sslConfig; public Builder baseUrl(String baseUrl) { this.baseUrl = baseUrl; return this; } public Builder connectionTimeout(int timeout) { this.connectionTimeout = timeout; return this; } public Builder readTimeout(int timeout) { this.readTimeout = timeout; return this; } public Builder header(String name, String value) { this.headers.put(name, value); return this; } public Builder headers(Map\u0026lt;String, String\u0026gt; headers) { this.headers.putAll(headers); return this; } public Builder followRedirects(boolean follow) { this.followRedirects = follow; return this; } public Builder proxy(ProxyConfig proxy) { this.proxy = proxy; return this; } public Builder sslConfig(SSLConfig sslConfig) { this.sslConfig = sslConfig; return this; } @Override protected void validate() { if (baseUrl == null || baseUrl.trim().isEmpty()) { throw new IllegalStateException(\u0026#34;BaseUrl 不能為空\u0026#34;); } if (connectionTimeout \u0026lt; 0) { throw new IllegalStateException(\u0026#34;連接超時不能為負數\u0026#34;); } if (readTimeout \u0026lt; 0) { throw new IllegalStateException(\u0026#34;讀取超時不能為負數\u0026#34;); } } @Override protected HttpClientConfig build() { validate(); return new HttpClientConfig(this); } } // Getter 方法 public String getBaseUrl() { return baseUrl; } public int getConnectionTimeout() { return connectionTimeout; } public int getReadTimeout() { return readTimeout; } public Map\u0026lt;String, String\u0026gt; getHeaders() { return headers; } public boolean isFollowRedirects() { return followRedirects; } public ProxyConfig getProxy() { return proxy; } public SSLConfig getSslConfig() { return sslConfig; } // 輔助類 public static class ProxyConfig { private final String host; private final int port; private final String username; private final String password; public ProxyConfig(String host, int port, String username, String password) { this.host = host; this.port = port; this.username = username; this.password = password; } // Getter 方法 public String getHost() { return host; } public int getPort() { return port; } public String getUsername() { return username; } public String getPassword() { return password; } } public static class SSLConfig { private final boolean verifyHostname; private final String trustStore; private final String trustStorePassword; public SSLConfig(boolean verifyHostname, String trustStore, String trustStorePassword) { this.verifyHostname = verifyHostname; this.trustStore = trustStore; this.trustStorePassword = trustStorePassword; } // Getter 方法 public boolean isVerifyHostname() { return verifyHostname; } public String getTrustStore() { return trustStore; } public String getTrustStorePassword() { return trustStorePassword; } } } 企業級應用場景 1. 複雜 API 響應構造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 // API 響應建造者 public class ApiResponse\u0026lt;T\u0026gt; { private final boolean success; private final String message; private final T data; private final List\u0026lt;String\u0026gt; errors; private final Map\u0026lt;String, Object\u0026gt; metadata; private final long timestamp; private final String traceId; private ApiResponse(Builder\u0026lt;T\u0026gt; builder) { this.success = builder.success; this.message = builder.message; this.data = builder.data; this.errors = builder.errors != null ? Collections.unmodifiableList(new ArrayList\u0026lt;\u0026gt;(builder.errors)) : Collections.emptyList(); this.metadata = builder.metadata != null ? Collections.unmodifiableMap(new HashMap\u0026lt;\u0026gt;(builder.metadata)) : Collections.emptyMap(); this.timestamp = builder.timestamp; this.traceId = builder.traceId; } public static class Builder\u0026lt;T\u0026gt; { private boolean success = true; private String message; private T data; private List\u0026lt;String\u0026gt; errors; private Map\u0026lt;String, Object\u0026gt; metadata; private long timestamp = System.currentTimeMillis(); private String traceId = generateTraceId(); public Builder\u0026lt;T\u0026gt; success(boolean success) { this.success = success; return this; } public Builder\u0026lt;T\u0026gt; message(String message) { this.message = message; return this; } public Builder\u0026lt;T\u0026gt; data(T data) { this.data = data; return this; } public Builder\u0026lt;T\u0026gt; error(String error) { if (this.errors == null) { this.errors = new ArrayList\u0026lt;\u0026gt;(); } this.errors.add(error); this.success = false; return this; } public Builder\u0026lt;T\u0026gt; errors(List\u0026lt;String\u0026gt; errors) { this.errors = errors; this.success = false; return this; } public Builder\u0026lt;T\u0026gt; metadata(String key, Object value) { if (this.metadata == null) { this.metadata = new HashMap\u0026lt;\u0026gt;(); } this.metadata.put(key, value); return this; } public Builder\u0026lt;T\u0026gt; metadata(Map\u0026lt;String, Object\u0026gt; metadata) { if (this.metadata == null) { this.metadata = new HashMap\u0026lt;\u0026gt;(); } this.metadata.putAll(metadata); return this; } public Builder\u0026lt;T\u0026gt; timestamp(long timestamp) { this.timestamp = timestamp; return this; } public Builder\u0026lt;T\u0026gt; traceId(String traceId) { this.traceId = traceId; return this; } public ApiResponse\u0026lt;T\u0026gt; build() { return new ApiResponse\u0026lt;\u0026gt;(this); } private String generateTraceId() { return UUID.randomUUID().toString().replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;); } } // 靜態工廠方法 public static \u0026lt;T\u0026gt; Builder\u0026lt;T\u0026gt; success() { return new Builder\u0026lt;T\u0026gt;().success(true); } public static \u0026lt;T\u0026gt; Builder\u0026lt;T\u0026gt; success(T data) { return new Builder\u0026lt;T\u0026gt;().success(true).data(data); } public static \u0026lt;T\u0026gt; Builder\u0026lt;T\u0026gt; failure(String message) { return new Builder\u0026lt;T\u0026gt;().success(false).message(message); } public static \u0026lt;T\u0026gt; Builder\u0026lt;T\u0026gt; failure(List\u0026lt;String\u0026gt; errors) { return new Builder\u0026lt;T\u0026gt;().errors(errors); } // Getter 方法 public boolean isSuccess() { return success; } public String getMessage() { return message; } public T getData() { return data; } public List\u0026lt;String\u0026gt; getErrors() { return errors; } public Map\u0026lt;String, Object\u0026gt; getMetadata() { return metadata; } public long getTimestamp() { return timestamp; } public String getTraceId() { return traceId; } } // 使用示例 @RestController public class UserController { @GetMapping(\u0026#34;/users/{id}\u0026#34;) public ApiResponse\u0026lt;User\u0026gt; getUser(@PathVariable Long id) { try { User user = userService.findById(id); return ApiResponse.success(user) .message(\u0026#34;用戶查詢成功\u0026#34;) .metadata(\u0026#34;query_time\u0026#34;, System.currentTimeMillis()) .build(); } catch (UserNotFoundException e) { return ApiResponse.\u0026lt;User\u0026gt;failure(\u0026#34;用戶不存在\u0026#34;) .metadata(\u0026#34;user_id\u0026#34;, id) .build(); } } @PostMapping(\u0026#34;/users\u0026#34;) public ApiResponse\u0026lt;User\u0026gt; createUser(@RequestBody @Valid CreateUserRequest request) { try { User user = userService.create(request); return ApiResponse.success(user) .message(\u0026#34;用戶創建成功\u0026#34;) .metadata(\u0026#34;created_at\u0026#34;, user.getCreatedAt()) .build(); } catch (ValidationException e) { return ApiResponse.\u0026lt;User\u0026gt;failure(e.getErrors()) .metadata(\u0026#34;validation_failed\u0026#34;, true) .build(); } } } 2. 查詢條件建造者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 // 複雜查詢條件建造者 public class SearchCriteria { private final String keyword; private final List\u0026lt;String\u0026gt; categories; private final DateRange dateRange; private final PriceRange priceRange; private final SortOptions sortOptions; private final PaginationOptions paginationOptions; private final List\u0026lt;Filter\u0026gt; filters; private final boolean includeDeleted; private final boolean fuzzySearch; private SearchCriteria(Builder builder) { this.keyword = builder.keyword; this.categories = builder.categories != null ? Collections.unmodifiableList(new ArrayList\u0026lt;\u0026gt;(builder.categories)) : Collections.emptyList(); this.dateRange = builder.dateRange; this.priceRange = builder.priceRange; this.sortOptions = builder.sortOptions; this.paginationOptions = builder.paginationOptions; this.filters = builder.filters != null ? Collections.unmodifiableList(new ArrayList\u0026lt;\u0026gt;(builder.filters)) : Collections.emptyList(); this.includeDeleted = builder.includeDeleted; this.fuzzySearch = builder.fuzzySearch; } public static class Builder { private String keyword; private List\u0026lt;String\u0026gt; categories; private DateRange dateRange; private PriceRange priceRange; private SortOptions sortOptions; private PaginationOptions paginationOptions; private List\u0026lt;Filter\u0026gt; filters; private boolean includeDeleted = false; private boolean fuzzySearch = true; public Builder keyword(String keyword) { this.keyword = keyword; return this; } public Builder category(String category) { if (this.categories == null) { this.categories = new ArrayList\u0026lt;\u0026gt;(); } this.categories.add(category); return this; } public Builder categories(List\u0026lt;String\u0026gt; categories) { this.categories = categories; return this; } public Builder dateRange(LocalDate startDate, LocalDate endDate) { this.dateRange = new DateRange(startDate, endDate); return this; } public Builder priceRange(BigDecimal minPrice, BigDecimal maxPrice) { this.priceRange = new PriceRange(minPrice, maxPrice); return this; } public Builder sortBy(String field, SortDirection direction) { this.sortOptions = new SortOptions(field, direction); return this; } public Builder page(int page, int size) { this.paginationOptions = new PaginationOptions(page, size); return this; } public Builder filter(String field, FilterOperator operator, Object value) { if (this.filters == null) { this.filters = new ArrayList\u0026lt;\u0026gt;(); } this.filters.add(new Filter(field, operator, value)); return this; } public Builder includeDeleted(boolean includeDeleted) { this.includeDeleted = includeDeleted; return this; } public Builder fuzzySearch(boolean fuzzySearch) { this.fuzzySearch = fuzzySearch; return this; } public SearchCriteria build() { validateCriteria(); return new SearchCriteria(this); } private void validateCriteria() { if (keyword != null \u0026amp;\u0026amp; keyword.trim().isEmpty()) { throw new IllegalArgumentException(\u0026#34;關鍵字不能為空字符串\u0026#34;); } if (dateRange != null \u0026amp;\u0026amp; !dateRange.isValid()) { throw new IllegalArgumentException(\u0026#34;日期範圍無效\u0026#34;); } if (priceRange != null \u0026amp;\u0026amp; !priceRange.isValid()) { throw new IllegalArgumentException(\u0026#34;價格範圍無效\u0026#34;); } if (paginationOptions != null \u0026amp;\u0026amp; !paginationOptions.isValid()) { throw new IllegalArgumentException(\u0026#34;分頁參數無效\u0026#34;); } } } // Getter 方法 public String getKeyword() { return keyword; } public List\u0026lt;String\u0026gt; getCategories() { return categories; } public DateRange getDateRange() { return dateRange; } public PriceRange getPriceRange() { return priceRange; } public SortOptions getSortOptions() { return sortOptions; } public PaginationOptions getPaginationOptions() { return paginationOptions; } public List\u0026lt;Filter\u0026gt; getFilters() { return filters; } public boolean isIncludeDeleted() { return includeDeleted; } public boolean isFuzzySearch() { return fuzzySearch; } // 輔助類 public static class DateRange { private final LocalDate startDate; private final LocalDate endDate; public DateRange(LocalDate startDate, LocalDate endDate) { this.startDate = startDate; this.endDate = endDate; } public boolean isValid() { return startDate != null \u0026amp;\u0026amp; endDate != null \u0026amp;\u0026amp; !startDate.isAfter(endDate); } public LocalDate getStartDate() { return startDate; } public LocalDate getEndDate() { return endDate; } } public static class PriceRange { private final BigDecimal minPrice; private final BigDecimal maxPrice; public PriceRange(BigDecimal minPrice, BigDecimal maxPrice) { this.minPrice = minPrice; this.maxPrice = maxPrice; } public boolean isValid() { return minPrice != null \u0026amp;\u0026amp; maxPrice != null \u0026amp;\u0026amp; minPrice.compareTo(maxPrice) \u0026lt;= 0 \u0026amp;\u0026amp; minPrice.compareTo(BigDecimal.ZERO) \u0026gt;= 0; } public BigDecimal getMinPrice() { return minPrice; } public BigDecimal getMaxPrice() { return maxPrice; } } public static class SortOptions { private final String field; private final SortDirection direction; public SortOptions(String field, SortDirection direction) { this.field = field; this.direction = direction; } public String getField() { return field; } public SortDirection getDirection() { return direction; } } public static class PaginationOptions { private final int page; private final int size; public PaginationOptions(int page, int size) { this.page = page; this.size = size; } public boolean isValid() { return page \u0026gt;= 0 \u0026amp;\u0026amp; size \u0026gt; 0 \u0026amp;\u0026amp; size \u0026lt;= 1000; } public int getPage() { return page; } public int getSize() { return size; } } public static class Filter { private final String field; private final FilterOperator operator; private final Object value; public Filter(String field, FilterOperator operator, Object value) { this.field = field; this.operator = operator; this.value = value; } public String getField() { return field; } public FilterOperator getOperator() { return operator; } public Object getValue() { return value; } } public enum SortDirection { ASC, DESC } public enum FilterOperator { EQUALS, NOT_EQUALS, GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUAL, LESS_THAN_OR_EQUAL, CONTAINS, NOT_CONTAINS, IN, NOT_IN } } // 使用示例 @Service public class ProductSearchService { public Page\u0026lt;Product\u0026gt; searchProducts(SearchCriteria criteria) { return productRepository.search(criteria); } public void demonstrateUsage() { // 複雜查詢構造 SearchCriteria criteria = new SearchCriteria.Builder() .keyword(\u0026#34;智能手機\u0026#34;) .category(\u0026#34;電子產品\u0026#34;) .category(\u0026#34;手機\u0026#34;) .priceRange(new BigDecimal(\u0026#34;1000\u0026#34;), new BigDecimal(\u0026#34;5000\u0026#34;)) .dateRange(LocalDate.now().minusMonths(3), LocalDate.now()) .sortBy(\u0026#34;price\u0026#34;, SearchCriteria.SortDirection.ASC) .page(0, 20) .filter(\u0026#34;brand\u0026#34;, SearchCriteria.FilterOperator.IN, Arrays.asList(\u0026#34;Apple\u0026#34;, \u0026#34;Samsung\u0026#34;, \u0026#34;Huawei\u0026#34;)) .filter(\u0026#34;rating\u0026#34;, SearchCriteria.FilterOperator.GREATER_THAN_OR_EQUAL, 4.0) .fuzzySearch(true) .build(); Page\u0026lt;Product\u0026gt; results = searchProducts(criteria); System.out.println(\u0026#34;找到 \u0026#34; + results.getTotalElements() + \u0026#34; 個產品\u0026#34;); } } 3. 配置文件建造者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 // 應用配置建造者 public class ApplicationConfig { private final String applicationName; private final String version; private final ServerConfig serverConfig; private final DatabaseConfig databaseConfig; private final CacheConfig cacheConfig; private final SecurityConfig securityConfig; private final LoggingConfig loggingConfig; private final Map\u0026lt;String, String\u0026gt; customProperties; private ApplicationConfig(Builder builder) { this.applicationName = builder.applicationName; this.version = builder.version; this.serverConfig = builder.serverConfig; this.databaseConfig = builder.databaseConfig; this.cacheConfig = builder.cacheConfig; this.securityConfig = builder.securityConfig; this.loggingConfig = builder.loggingConfig; this.customProperties = builder.customProperties != null ? Collections.unmodifiableMap(new HashMap\u0026lt;\u0026gt;(builder.customProperties)) : Collections.emptyMap(); } public static class Builder { private String applicationName; private String version; private ServerConfig serverConfig; private DatabaseConfig databaseConfig; private CacheConfig cacheConfig; private SecurityConfig securityConfig; private LoggingConfig loggingConfig; private Map\u0026lt;String, String\u0026gt; customProperties; public Builder applicationName(String name) { this.applicationName = name; return this; } public Builder version(String version) { this.version = version; return this; } public Builder server(Consumer\u0026lt;ServerConfig.Builder\u0026gt; configurer) { ServerConfig.Builder builder = new ServerConfig.Builder(); configurer.accept(builder); this.serverConfig = builder.build(); return this; } public Builder database(Consumer\u0026lt;DatabaseConfig.Builder\u0026gt; configurer) { DatabaseConfig.Builder builder = new DatabaseConfig.Builder(); configurer.accept(builder); this.databaseConfig = builder.build(); return this; } public Builder cache(Consumer\u0026lt;CacheConfig.Builder\u0026gt; configurer) { CacheConfig.Builder builder = new CacheConfig.Builder(); configurer.accept(builder); this.cacheConfig = builder.build(); return this; } public Builder security(Consumer\u0026lt;SecurityConfig.Builder\u0026gt; configurer) { SecurityConfig.Builder builder = new SecurityConfig.Builder(); configurer.accept(builder); this.securityConfig = builder.build(); return this; } public Builder logging(Consumer\u0026lt;LoggingConfig.Builder\u0026gt; configurer) { LoggingConfig.Builder builder = new LoggingConfig.Builder(); configurer.accept(builder); this.loggingConfig = builder.build(); return this; } public Builder property(String key, String value) { if (this.customProperties == null) { this.customProperties = new HashMap\u0026lt;\u0026gt;(); } this.customProperties.put(key, value); return this; } public ApplicationConfig build() { validateConfiguration(); return new ApplicationConfig(this); } private void validateConfiguration() { if (applicationName == null || applicationName.trim().isEmpty()) { throw new IllegalStateException(\u0026#34;應用名稱不能為空\u0026#34;); } if (version == null || version.trim().isEmpty()) { throw new IllegalStateException(\u0026#34;版本號不能為空\u0026#34;); } } } // Getter 方法 public String getApplicationName() { return applicationName; } public String getVersion() { return version; } public ServerConfig getServerConfig() { return serverConfig; } public DatabaseConfig getDatabaseConfig() { return databaseConfig; } public CacheConfig getCacheConfig() { return cacheConfig; } public SecurityConfig getSecurityConfig() { return securityConfig; } public LoggingConfig getLoggingConfig() { return loggingConfig; } public Map\u0026lt;String, String\u0026gt; getCustomProperties() { return customProperties; } // 嵌套配置類 public static class ServerConfig { private final int port; private final String contextPath; private final boolean enableCompression; private final int maxConnections; private ServerConfig(Builder builder) { this.port = builder.port; this.contextPath = builder.contextPath; this.enableCompression = builder.enableCompression; this.maxConnections = builder.maxConnections; } public static class Builder { private int port = 8080; private String contextPath = \u0026#34;/\u0026#34;; private boolean enableCompression = true; private int maxConnections = 200; public Builder port(int port) { this.port = port; return this; } public Builder contextPath(String contextPath) { this.contextPath = contextPath; return this; } public Builder enableCompression(boolean enable) { this.enableCompression = enable; return this; } public Builder maxConnections(int maxConnections) { this.maxConnections = maxConnections; return this; } public ServerConfig build() { return new ServerConfig(this); } } // Getter 方法 public int getPort() { return port; } public String getContextPath() { return contextPath; } public boolean isEnableCompression() { return enableCompression; } public int getMaxConnections() { return maxConnections; } } public static class DatabaseConfig { private final String url; private final String username; private final String password; private final int maxPoolSize; private final int minPoolSize; private DatabaseConfig(Builder builder) { this.url = builder.url; this.username = builder.username; this.password = builder.password; this.maxPoolSize = builder.maxPoolSize; this.minPoolSize = builder.minPoolSize; } public static class Builder { private String url; private String username; private String password; private int maxPoolSize = 10; private int minPoolSize = 5; public Builder url(String url) { this.url = url; return this; } public Builder username(String username) { this.username = username; return this; } public Builder password(String password) { this.password = password; return this; } public Builder maxPoolSize(int maxPoolSize) { this.maxPoolSize = maxPoolSize; return this; } public Builder minPoolSize(int minPoolSize) { this.minPoolSize = minPoolSize; return this; } public DatabaseConfig build() { return new DatabaseConfig(this); } } // Getter 方法 public String getUrl() { return url; } public String getUsername() { return username; } public String getPassword() { return password; } public int getMaxPoolSize() { return maxPoolSize; } public int getMinPoolSize() { return minPoolSize; } } public static class CacheConfig { private final String type; private final int maxSize; private final int ttlMinutes; private CacheConfig(Builder builder) { this.type = builder.type; this.maxSize = builder.maxSize; this.ttlMinutes = builder.ttlMinutes; } public static class Builder { private String type = \u0026#34;redis\u0026#34;; private int maxSize = 1000; private int ttlMinutes = 60; public Builder type(String type) { this.type = type; return this; } public Builder maxSize(int maxSize) { this.maxSize = maxSize; return this; } public Builder ttlMinutes(int ttlMinutes) { this.ttlMinutes = ttlMinutes; return this; } public CacheConfig build() { return new CacheConfig(this); } } // Getter 方法 public String getType() { return type; } public int getMaxSize() { return maxSize; } public int getTtlMinutes() { return ttlMinutes; } } public static class SecurityConfig { private final boolean enableSecurity; private final String jwtSecret; private final int jwtExpirationHours; private SecurityConfig(Builder builder) { this.enableSecurity = builder.enableSecurity; this.jwtSecret = builder.jwtSecret; this.jwtExpirationHours = builder.jwtExpirationHours; } public static class Builder { private boolean enableSecurity = true; private String jwtSecret; private int jwtExpirationHours = 24; public Builder enableSecurity(boolean enable) { this.enableSecurity = enable; return this; } public Builder jwtSecret(String secret) { this.jwtSecret = secret; return this; } public Builder jwtExpirationHours(int hours) { this.jwtExpirationHours = hours; return this; } public SecurityConfig build() { return new SecurityConfig(this); } } // Getter 方法 public boolean isEnableSecurity() { return enableSecurity; } public String getJwtSecret() { return jwtSecret; } public int getJwtExpirationHours() { return jwtExpirationHours; } } public static class LoggingConfig { private final String level; private final String pattern; private final boolean enableFileOutput; private LoggingConfig(Builder builder) { this.level = builder.level; this.pattern = builder.pattern; this.enableFileOutput = builder.enableFileOutput; } public static class Builder { private String level = \u0026#34;INFO\u0026#34;; private String pattern = \u0026#34;%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\u0026#34;; private boolean enableFileOutput = false; public Builder level(String level) { this.level = level; return this; } public Builder pattern(String pattern) { this.pattern = pattern; return this; } public Builder enableFileOutput(boolean enable) { this.enableFileOutput = enable; return this; } public LoggingConfig build() { return new LoggingConfig(this); } } // Getter 方法 public String getLevel() { return level; } public String getPattern() { return pattern; } public boolean isEnableFileOutput() { return enableFileOutput; } } } // 使用示例 public class ApplicationConfigExample { public static void main(String[] args) { ApplicationConfig config = new ApplicationConfig.Builder() .applicationName(\u0026#34;電商系統\u0026#34;) .version(\u0026#34;1.0.0\u0026#34;) .server(server -\u0026gt; server .port(8080) .contextPath(\u0026#34;/api\u0026#34;) .enableCompression(true) .maxConnections(500)) .database(db -\u0026gt; db .url(\u0026#34;jdbc:mysql://localhost:3306/ecommerce\u0026#34;) .username(\u0026#34;root\u0026#34;) .password(\u0026#34;password\u0026#34;) .maxPoolSize(20) .minPoolSize(5)) .cache(cache -\u0026gt; cache .type(\u0026#34;redis\u0026#34;) .maxSize(10000) .ttlMinutes(30)) .security(security -\u0026gt; security .enableSecurity(true) .jwtSecret(\u0026#34;mySecretKey\u0026#34;) .jwtExpirationHours(24)) .logging(logging -\u0026gt; logging .level(\u0026#34;INFO\u0026#34;) .enableFileOutput(true)) .property(\u0026#34;custom.feature.enabled\u0026#34;, \u0026#34;true\u0026#34;) .property(\u0026#34;custom.timeout\u0026#34;, \u0026#34;5000\u0026#34;) .build(); System.out.println(\u0026#34;配置創建成功：\u0026#34; + config.getApplicationName()); } } Spring Boot 整合 1. 配置類建造者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @Configuration public class BuilderPatternConfig { @Bean @ConfigurationProperties(prefix = \u0026#34;app.database\u0026#34;) public DatabaseConfiguration databaseConfiguration() { return new DatabaseConfiguration.Builder( \u0026#34;localhost\u0026#34;, 3306, \u0026#34;myapp\u0026#34;, \u0026#34;user\u0026#34;, \u0026#34;password\u0026#34; ).build(); } @Bean @ConditionalOnProperty(name = \u0026#34;app.http.client.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public HttpClientConfig httpClientConfig( @Value(\u0026#34;${app.http.client.base-url}\u0026#34;) String baseUrl, @Value(\u0026#34;${app.http.client.timeout:5000}\u0026#34;) int timeout) { return new HttpClientConfig.Builder() .baseUrl(baseUrl) .connectionTimeout(timeout) .readTimeout(timeout * 2) .header(\u0026#34;User-Agent\u0026#34;, \u0026#34;MyApp/1.0\u0026#34;) .header(\u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;) .followRedirects(true) .build(); } } @RestController public class SearchController { @PostMapping(\u0026#34;/search\u0026#34;) public ApiResponse\u0026lt;Page\u0026lt;Product\u0026gt;\u0026gt; search(@RequestBody SearchRequest request) { try { SearchCriteria criteria = new SearchCriteria.Builder() .keyword(request.getKeyword()) .categories(request.getCategories()) .priceRange(request.getMinPrice(), request.getMaxPrice()) .sortBy(request.getSortField(), request.getSortDirection()) .page(request.getPage(), request.getSize()) .fuzzySearch(request.isFuzzySearch()) .build(); Page\u0026lt;Product\u0026gt; results = productService.search(criteria); return ApiResponse.\u0026lt;Page\u0026lt;Product\u0026gt;\u0026gt;success(results) .message(\u0026#34;搜索成功\u0026#34;) .metadata(\u0026#34;total\u0026#34;, results.getTotalElements()) .metadata(\u0026#34;pages\u0026#34;, results.getTotalPages()) .build(); } catch (Exception e) { return ApiResponse.\u0026lt;Page\u0026lt;Product\u0026gt;\u0026gt;failure(\u0026#34;搜索失敗\u0026#34;) .error(e.getMessage()) .build(); } } } 2. 測試建造者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 @ExtendWith(MockitoExtension.class) class BuilderPatternTest { @Test void testComputerBuilder_GamingConfiguration() { // Given Computer.Director director = new Computer.Director(); // When Computer gamingPC = director.buildGamingComputer(); // Then assertThat(gamingPC.getCpu()).isEqualTo(\u0026#34;Intel i9-13900K\u0026#34;); assertThat(gamingPC.getMemory()).isEqualTo(\u0026#34;32GB DDR5\u0026#34;); assertThat(gamingPC.getGraphics()).isEqualTo(\u0026#34;RTX 4080\u0026#34;); assertThat(gamingPC.isOverclocked()).isTrue(); assertThat(gamingPC.getCoolingSystem()).isNotNull(); } @Test void testDatabaseConfigurationBuilder_ValidConfiguration() { // When DatabaseConfiguration config = new DatabaseConfiguration.Builder( \u0026#34;localhost\u0026#34;, 3306, \u0026#34;testdb\u0026#34;, \u0026#34;user\u0026#34;, \u0026#34;pass\u0026#34; ) .connectionPoolSize(20) .connectionTimeout(5000) .useSSL(true) .property(\u0026#34;charset\u0026#34;, \u0026#34;utf8mb4\u0026#34;) .build(); // Then assertThat(config.getHost()).isEqualTo(\u0026#34;localhost\u0026#34;); assertThat(config.getPort()).isEqualTo(3306); assertThat(config.getConnectionPoolSize()).isEqualTo(20); assertThat(config.isUseSSL()).isTrue(); assertThat(config.getProperties()).containsEntry(\u0026#34;charset\u0026#34;, \u0026#34;utf8mb4\u0026#34;); } @Test void testApiResponseBuilder_SuccessResponse() { // Given User user = new User(\u0026#34;testUser\u0026#34;, \u0026#34;test@example.com\u0026#34;); // When ApiResponse\u0026lt;User\u0026gt; response = ApiResponse.success(user) .message(\u0026#34;用戶獲取成功\u0026#34;) .metadata(\u0026#34;cached\u0026#34;, true) .build(); // Then assertThat(response.isSuccess()).isTrue(); assertThat(response.getData()).isEqualTo(user); assertThat(response.getMessage()).isEqualTo(\u0026#34;用戶獲取成功\u0026#34;); assertThat(response.getMetadata()).containsEntry(\u0026#34;cached\u0026#34;, true); assertThat(response.getTraceId()).isNotNull(); assertThat(response.getErrors()).isEmpty(); } @Test void testApiResponseBuilder_FailureResponse() { // Given List\u0026lt;String\u0026gt; errors = Arrays.asList(\u0026#34;用戶不存在\u0026#34;, \u0026#34;請求參數無效\u0026#34;); // When ApiResponse\u0026lt;User\u0026gt; response = ApiResponse.\u0026lt;User\u0026gt;failure(errors) .metadata(\u0026#34;error_code\u0026#34;, \u0026#34;USER_NOT_FOUND\u0026#34;) .build(); // Then assertThat(response.isSuccess()).isFalse(); assertThat(response.getData()).isNull(); assertThat(response.getErrors()).hasSize(2); assertThat(response.getErrors()).contains(\u0026#34;用戶不存在\u0026#34;, \u0026#34;請求參數無效\u0026#34;); assertThat(response.getMetadata()).containsEntry(\u0026#34;error_code\u0026#34;, \u0026#34;USER_NOT_FOUND\u0026#34;); } @Test void testSearchCriteriaBuilder_ComplexQuery() { // Given LocalDate startDate = LocalDate.now().minusMonths(1); LocalDate endDate = LocalDate.now(); // When SearchCriteria criteria = new SearchCriteria.Builder() .keyword(\u0026#34;智能手機\u0026#34;) .category(\u0026#34;電子產品\u0026#34;) .dateRange(startDate, endDate) .priceRange(new BigDecimal(\u0026#34;1000\u0026#34;), new BigDecimal(\u0026#34;5000\u0026#34;)) .sortBy(\u0026#34;price\u0026#34;, SearchCriteria.SortDirection.ASC) .page(0, 20) .filter(\u0026#34;brand\u0026#34;, SearchCriteria.FilterOperator.IN, Arrays.asList(\u0026#34;Apple\u0026#34;, \u0026#34;Samsung\u0026#34;)) .fuzzySearch(true) .build(); // Then assertThat(criteria.getKeyword()).isEqualTo(\u0026#34;智能手機\u0026#34;); assertThat(criteria.getCategories()).contains(\u0026#34;電子產品\u0026#34;); assertThat(criteria.getDateRange().getStartDate()).isEqualTo(startDate); assertThat(criteria.getDateRange().getEndDate()).isEqualTo(endDate); assertThat(criteria.getPriceRange().getMinPrice()).isEqualTo(new BigDecimal(\u0026#34;1000\u0026#34;)); assertThat(criteria.isFuzzySearch()).isTrue(); assertThat(criteria.getFilters()).hasSize(1); } @Test void testBuilderValidation_ThrowsException() { // When \u0026amp; Then assertThatThrownBy(() -\u0026gt; new DatabaseConfiguration.Builder(null, 3306, \u0026#34;db\u0026#34;, \u0026#34;user\u0026#34;, \u0026#34;pass\u0026#34;).build() ).isInstanceOf(IllegalArgumentException.class) .hasMessage(\u0026#34;Host 不能為空\u0026#34;); assertThatThrownBy(() -\u0026gt; new Computer.Builder() .setMemory(\u0026#34;16GB\u0026#34;) .setStorage(\u0026#34;1TB SSD\u0026#34;) .setOverclocked(true) .build() ).isInstanceOf(IllegalStateException.class) .hasMessage(\u0026#34;超頻配置需要冷卻系統\u0026#34;); } } @SpringBootTest class BuilderPatternIntegrationTest { @Autowired private DatabaseConfiguration databaseConfig; @Autowired private HttpClientConfig httpClientConfig; @Test void testConfigurationBeans_LoadedCorrectly() { assertThat(databaseConfig).isNotNull(); assertThat(databaseConfig.getHost()).isNotNull(); assertThat(databaseConfig.getPort()).isPositive(); assertThat(httpClientConfig).isNotNull(); assertThat(httpClientConfig.getBaseUrl()).isNotNull(); assertThat(httpClientConfig.getConnectionTimeout()).isPositive(); } } 性能優化與最佳實踐 1. 建造者對象池 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // 建造者對象池 public class BuilderPool\u0026lt;T extends GenericBuilder\u0026lt;?\u0026gt;\u0026gt; { private final Queue\u0026lt;T\u0026gt; pool = new ConcurrentLinkedQueue\u0026lt;\u0026gt;(); private final Supplier\u0026lt;T\u0026gt; builderFactory; private final int maxPoolSize; public BuilderPool(Supplier\u0026lt;T\u0026gt; builderFactory, int maxPoolSize) { this.builderFactory = builderFactory; this.maxPoolSize = maxPoolSize; } public T acquire() { T builder = pool.poll(); if (builder == null) { builder = builderFactory.get(); } return builder; } public void release(T builder) { if (pool.size() \u0026lt; maxPoolSize) { // 重置建造者狀態 if (builder instanceof Resettable) { ((Resettable) builder).reset(); } pool.offer(builder); } } } // 可重置接口 public interface Resettable { void reset(); } // 實現可重置的建造者 public class PooledApiResponseBuilder\u0026lt;T\u0026gt; extends ApiResponse.Builder\u0026lt;T\u0026gt; implements Resettable { @Override public void reset() { this.success(true) .message(null) .data(null) .timestamp(System.currentTimeMillis()) .traceId(generateTraceId()); if (this.errors != null) { this.errors.clear(); } if (this.metadata != null) { this.metadata.clear(); } } } 2. 建造者快取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 建造者結果快取 @Component public class CachedBuilderService { private final Cache\u0026lt;String, Object\u0026gt; builderCache; public CachedBuilderService() { this.builderCache = Caffeine.newBuilder() .maximumSize(1000) .expireAfterWrite(Duration.ofMinutes(30)) .build(); } public \u0026lt;T\u0026gt; T getOrBuild(String key, Supplier\u0026lt;T\u0026gt; builderSupplier) { return (T) builderCache.get(key, k -\u0026gt; builderSupplier.get()); } public void invalidate(String key) { builderCache.invalidate(key); } public void invalidateAll() { builderCache.invalidateAll(); } } 監控與診斷 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 建造者監控 @Component public class BuilderMonitor { private final MeterRegistry meterRegistry; private final Counter builderUsageCounter; private final Timer builderBuildTimer; public BuilderMonitor(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; this.builderUsageCounter = Counter.builder(\u0026#34;builder.usage\u0026#34;) .description(\u0026#34;Number of builder usages\u0026#34;) .register(meterRegistry); this.builderBuildTimer = Timer.builder(\u0026#34;builder.build.time\u0026#34;) .description(\u0026#34;Time spent building objects\u0026#34;) .register(meterRegistry); } public \u0026lt;T\u0026gt; T monitorBuild(String builderType, Supplier\u0026lt;T\u0026gt; buildSupplier) { builderUsageCounter.increment(Tags.of(\u0026#34;type\u0026#34;, builderType)); return Timer.Sample.start(meterRegistry) .stop(builderBuildTimer.withTag(\u0026#34;type\u0026#34;, builderType)) .recordCallable(() -\u0026gt; buildSupplier.get()); } } 總結 建造者模式是一種強大的創建型設計模式，特別適用於：\n複雜對象構造：當對象有多個可選參數時 步驟化構造：需要按特定順序構造對象時 不變性保證：確保構造完成的對象不可變 可讀性提升：提供清晰的對象構造方式 關鍵最佳實踐 參數驗證：在 build() 方法中進行完整的參數驗證 不變性：確保構造的對象是不可變的 流式介面：提供鏈式調用的流式介面 預設值：為可選參數提供合理的預設值 異常處理：提供清晰的錯誤消息和異常處理 性能優化：適當使用對象池和快取機制 建造者模式讓複雜對象的構造變得簡單、直觀且安全，是企業級應用中不可或缺的設計模式。正確使用建造者模式可以大幅提升代碼的可讀性和維護性。\n","permalink":"https://xinqilin.github.io/post/architecture/builder/","tags":["Design Pattern","Builder Pattern","Creational Pattern","Object Construction","Fluent Interface","Method Chaining","Java","Spring Boot","Best Practices","Enterprise Development","Complex Objects","Configuration Management","API Design"],"title":"建造者模式 (Builder Pattern) 完整實作指南：複雜對象構造的最佳實踐"},{"content":"Factory Pattern 工廠模式 Factory Pattern 是創建型設計模式之一，提供了一種創建對象的最佳方式。在工廠模式中，我們在不向客戶端暴露創建邏輯的情況下創建對象，並且通過使用一個共同的接口來指向新創建的對象。\n核心概念 工廠模式解決了直接實例化對象所帶來的問題，它封裝了對象創建的複雜性，讓客戶端程序可以通過簡單的接口獲取所需的對象，而無需了解對象創建的具體過程。\n主要優勢 解耦: 客戶端代碼與具體實現類解耦 可擴展性: 容易添加新的產品類型 集中管理: 對象創建邏輯集中在工廠中 一致性: 確保對象創建的一致性 測試友好: 便於單元測試和模擬 1. Simple Factory Pattern 簡單工廠模式 最基本的工廠模式實現，通過一個工廠類來創建所有相關的對象。\n基礎實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 // 產品接口 public interface Vehicle { void start(); void stop(); void accelerate(); String getType(); } // 具體產品實現 public class Car implements Vehicle { private String brand; public Car(String brand) { this.brand = brand; } @Override public void start() { System.out.println(brand + \u0026#34; 汽車啟動引擎\u0026#34;); } @Override public void stop() { System.out.println(brand + \u0026#34; 汽車停止\u0026#34;); } @Override public void accelerate() { System.out.println(brand + \u0026#34; 汽車加速\u0026#34;); } @Override public String getType() { return \u0026#34;Car - \u0026#34; + brand; } } public class Motorcycle implements Vehicle { private String brand; public Motorcycle(String brand) { this.brand = brand; } @Override public void start() { System.out.println(brand + \u0026#34; 機車啟動\u0026#34;); } @Override public void stop() { System.out.println(brand + \u0026#34; 機車停止\u0026#34;); } @Override public void accelerate() { System.out.println(brand + \u0026#34; 機車加速\u0026#34;); } @Override public String getType() { return \u0026#34;Motorcycle - \u0026#34; + brand; } } public class Truck implements Vehicle { private String brand; private int capacity; public Truck(String brand, int capacity) { this.brand = brand; this.capacity = capacity; } @Override public void start() { System.out.println(brand + \u0026#34; 卡車啟動 (載重: \u0026#34; + capacity + \u0026#34;噸)\u0026#34;); } @Override public void stop() { System.out.println(brand + \u0026#34; 卡車停止\u0026#34;); } @Override public void accelerate() { System.out.println(brand + \u0026#34; 卡車緩慢加速\u0026#34;); } @Override public String getType() { return \u0026#34;Truck - \u0026#34; + brand + \u0026#34; (\u0026#34; + capacity + \u0026#34;t)\u0026#34;; } } 簡單工廠實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // 車輛類型枚舉 public enum VehicleType { CAR, MOTORCYCLE, TRUCK } // 簡單工廠類 public class VehicleFactory { public static Vehicle createVehicle(VehicleType type, String brand) { return createVehicle(type, brand, 0); } public static Vehicle createVehicle(VehicleType type, String brand, int capacity) { switch (type) { case CAR: return new Car(brand); case MOTORCYCLE: return new Motorcycle(brand); case TRUCK: if (capacity \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;卡車必須指定載重容量\u0026#34;); } return new Truck(brand, capacity); default: throw new IllegalArgumentException(\u0026#34;不支援的車輛類型: \u0026#34; + type); } } // 基於字符串的工廠方法（較不推薦） public static Vehicle createVehicle(String type, String brand) { if (type == null || type.trim().isEmpty()) { throw new IllegalArgumentException(\u0026#34;車輛類型不能為空\u0026#34;); } switch (type.toLowerCase()) { case \u0026#34;car\u0026#34;: return new Car(brand); case \u0026#34;motorcycle\u0026#34;: return new Motorcycle(brand); case \u0026#34;truck\u0026#34;: return new Truck(brand, 5); // 預設載重 default: throw new IllegalArgumentException(\u0026#34;不支援的車輛類型: \u0026#34; + type); } } } 使用範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class SimpleFactoryDemo { public static void main(String[] args) { // 使用枚舉創建車輛 Vehicle car = VehicleFactory.createVehicle(VehicleType.CAR, \u0026#34;BMW\u0026#34;); Vehicle motorcycle = VehicleFactory.createVehicle(VehicleType.MOTORCYCLE, \u0026#34;Harley-Davidson\u0026#34;); Vehicle truck = VehicleFactory.createVehicle(VehicleType.TRUCK, \u0026#34;Volvo\u0026#34;, 10); // 測試車輛功能 testVehicle(car); testVehicle(motorcycle); testVehicle(truck); // 使用字符串創建（不推薦但有時必要） Vehicle stringBasedCar = VehicleFactory.createVehicle(\u0026#34;car\u0026#34;, \u0026#34;Mercedes\u0026#34;); testVehicle(stringBasedCar); } private static void testVehicle(Vehicle vehicle) { System.out.println(\u0026#34;\\n=== 測試 \u0026#34; + vehicle.getType() + \u0026#34; ===\u0026#34;); vehicle.start(); vehicle.accelerate(); vehicle.stop(); } } 2. Factory Method Pattern 工廠方法模式 工廠方法模式定義了一個創建對象的接口，但讓子類決定要實例化的類是哪一個。工廠方法讓類把實例化推遲到子類。\n核心結構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // 抽象產品 public abstract class Document { protected String title; protected String content; public Document(String title) { this.title = title; } public abstract void create(); public abstract void save(); public abstract void export(String format); // 通用方法 public String getTitle() { return title; } public void setContent(String content) { this.content = content; } } // 具體產品實現 public class WordDocument extends Document { public WordDocument(String title) { super(title); } @Override public void create() { System.out.println(\u0026#34;創建 Word 文檔: \u0026#34; + title); this.content = \u0026#34;Word 文檔內容模板\u0026#34;; } @Override public void save() { System.out.println(\u0026#34;保存 Word 文檔: \u0026#34; + title + \u0026#34;.docx\u0026#34;); } @Override public void export(String format) { System.out.println(\u0026#34;將 Word 文檔導出為 \u0026#34; + format + \u0026#34; 格式\u0026#34;); } } public class PdfDocument extends Document { public PdfDocument(String title) { super(title); } @Override public void create() { System.out.println(\u0026#34;創建 PDF 文檔: \u0026#34; + title); this.content = \u0026#34;PDF 文檔內容模板\u0026#34;; } @Override public void save() { System.out.println(\u0026#34;保存 PDF 文檔: \u0026#34; + title + \u0026#34;.pdf\u0026#34;); } @Override public void export(String format) { System.out.println(\u0026#34;將 PDF 文檔導出為 \u0026#34; + format + \u0026#34; 格式\u0026#34;); } } public class ExcelDocument extends Document { public ExcelDocument(String title) { super(title); } @Override public void create() { System.out.println(\u0026#34;創建 Excel 文檔: \u0026#34; + title); this.content = \u0026#34;Excel 文檔數據模板\u0026#34;; } @Override public void save() { System.out.println(\u0026#34;保存 Excel 文檔: \u0026#34; + title + \u0026#34;.xlsx\u0026#34;); } @Override public void export(String format) { System.out.println(\u0026#34;將 Excel 文檔導出為 \u0026#34; + format + \u0026#34; 格式\u0026#34;); } } 抽象工廠創建者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // 抽象創建者 public abstract class DocumentCreator { protected String author; public DocumentCreator(String author) { this.author = author; } // 工廠方法 - 子類必須實現 public abstract Document createDocument(String title); // 模板方法 - 定義文檔創建流程 public Document processDocument(String title, String content) { Document document = createDocument(title); document.setContent(content); document.create(); return document; } // 通用方法 public String getAuthor() { return author; } } // 具體創建者實現 public class WordDocumentCreator extends DocumentCreator { public WordDocumentCreator(String author) { super(author); } @Override public Document createDocument(String title) { return new WordDocument(title); } } public class PdfDocumentCreator extends DocumentCreator { public PdfDocumentCreator(String author) { super(author); } @Override public Document createDocument(String title) { return new PdfDocument(title); } } public class ExcelDocumentCreator extends DocumentCreator { public ExcelDocumentCreator(String author) { super(author); } @Override public Document createDocument(String title) { return new ExcelDocument(title); } } 工廠方法使用範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class FactoryMethodDemo { public static void main(String[] args) { // 創建不同類型的文檔創建者 DocumentCreator wordCreator = new WordDocumentCreator(\u0026#34;Bill.Lin\u0026#34;); DocumentCreator pdfCreator = new PdfDocumentCreator(\u0026#34;Bill.Lin\u0026#34;); DocumentCreator excelCreator = new ExcelDocumentCreator(\u0026#34;Bill.Lin\u0026#34;); // 使用工廠方法創建文檔 Document reportWord = wordCreator.processDocument(\u0026#34;月報告\u0026#34;, \u0026#34;本月銷售數據分析...\u0026#34;); Document contractPdf = pdfCreator.processDocument(\u0026#34;合同\u0026#34;, \u0026#34;甲乙雙方協議條款...\u0026#34;); Document dataExcel = excelCreator.processDocument(\u0026#34;數據表\u0026#34;, \u0026#34;銷售數據統計...\u0026#34;); // 保存文檔 reportWord.save(); contractPdf.save(); dataExcel.save(); // 導出文檔 reportWord.export(\u0026#34;PDF\u0026#34;); contractPdf.export(\u0026#34;Word\u0026#34;); dataExcel.export(\u0026#34;CSV\u0026#34;); } } 3. Abstract Factory Pattern 抽象工廠模式 抽象工廠模式提供了一個創建一系列相關或相互依賴對象的接口，而無需指定它們具體的類。\n抽象工廠結構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 // 抽象產品族 - 用戶界面元件 public interface Button { void render(); void onClick(); } public interface CheckBox { void render(); void toggle(); } public interface TextField { void render(); void setText(String text); String getText(); } // Windows 風格實現 public class WindowsButton implements Button { @Override public void render() { System.out.println(\u0026#34;渲染 Windows 風格按鈕\u0026#34;); } @Override public void onClick() { System.out.println(\u0026#34;Windows 按鈕點擊事件\u0026#34;); } } public class WindowsCheckBox implements CheckBox { private boolean checked = false; @Override public void render() { System.out.println(\u0026#34;渲染 Windows 風格複選框\u0026#34;); } @Override public void toggle() { checked = !checked; System.out.println(\u0026#34;Windows 複選框狀態: \u0026#34; + (checked ? \u0026#34;選中\u0026#34; : \u0026#34;未選中\u0026#34;)); } } public class WindowsTextField implements TextField { private String text = \u0026#34;\u0026#34;; @Override public void render() { System.out.println(\u0026#34;渲染 Windows 風格文本框\u0026#34;); } @Override public void setText(String text) { this.text = text; System.out.println(\u0026#34;Windows 文本框設置內容: \u0026#34; + text); } @Override public String getText() { return text; } } // macOS 風格實現 public class MacButton implements Button { @Override public void render() { System.out.println(\u0026#34;渲染 macOS 風格按鈕\u0026#34;); } @Override public void onClick() { System.out.println(\u0026#34;macOS 按鈕點擊事件\u0026#34;); } } public class MacCheckBox implements CheckBox { private boolean checked = false; @Override public void render() { System.out.println(\u0026#34;渲染 macOS 風格複選框\u0026#34;); } @Override public void toggle() { checked = !checked; System.out.println(\u0026#34;macOS 複選框狀態: \u0026#34; + (checked ? \u0026#34;選中\u0026#34; : \u0026#34;未選中\u0026#34;)); } } public class MacTextField implements TextField { private String text = \u0026#34;\u0026#34;; @Override public void render() { System.out.println(\u0026#34;渲染 macOS 風格文本框\u0026#34;); } @Override public void setText(String text) { this.text = text; System.out.println(\u0026#34;macOS 文本框設置內容: \u0026#34; + text); } @Override public String getText() { return text; } } // Linux 風格實現 public class LinuxButton implements Button { @Override public void render() { System.out.println(\u0026#34;渲染 Linux 風格按鈕\u0026#34;); } @Override public void onClick() { System.out.println(\u0026#34;Linux 按鈕點擊事件\u0026#34;); } } public class LinuxCheckBox implements CheckBox { private boolean checked = false; @Override public void render() { System.out.println(\u0026#34;渲染 Linux 風格複選框\u0026#34;); } @Override public void toggle() { checked = !checked; System.out.println(\u0026#34;Linux 複選框狀態: \u0026#34; + (checked ? \u0026#34;選中\u0026#34; : \u0026#34;未選中\u0026#34;)); } } public class LinuxTextField implements TextField { private String text = \u0026#34;\u0026#34;; @Override public void render() { System.out.println(\u0026#34;渲染 Linux 風格文本框\u0026#34;); } @Override public void setText(String text) { this.text = text; System.out.println(\u0026#34;Linux 文本框設置內容: \u0026#34; + text); } @Override public String getText() { return text; } } 抽象工廠接口和實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // 抽象工廠接口 public interface GUIFactory { Button createButton(); CheckBox createCheckBox(); TextField createTextField(); } // 具體工廠實現 public class WindowsFactory implements GUIFactory { @Override public Button createButton() { return new WindowsButton(); } @Override public CheckBox createCheckBox() { return new WindowsCheckBox(); } @Override public TextField createTextField() { return new WindowsTextField(); } } public class MacFactory implements GUIFactory { @Override public Button createButton() { return new MacButton(); } @Override public CheckBox createCheckBox() { return new MacCheckBox(); } @Override public TextField createTextField() { return new MacTextField(); } } public class LinuxFactory implements GUIFactory { @Override public Button createButton() { return new LinuxButton(); } @Override public CheckBox createCheckBox() { return new LinuxCheckBox(); } @Override public TextField createTextField() { return new LinuxTextField(); } } 工廠註冊器和配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 工廠註冊器 public class GUIFactoryRegistry { private static final Map\u0026lt;String, GUIFactory\u0026gt; factories = new HashMap\u0026lt;\u0026gt;(); static { register(\u0026#34;windows\u0026#34;, new WindowsFactory()); register(\u0026#34;macos\u0026#34;, new MacFactory()); register(\u0026#34;linux\u0026#34;, new LinuxFactory()); } public static void register(String type, GUIFactory factory) { factories.put(type.toLowerCase(), factory); } public static GUIFactory getFactory(String type) { GUIFactory factory = factories.get(type.toLowerCase()); if (factory == null) { throw new IllegalArgumentException(\u0026#34;不支援的平台類型: \u0026#34; + type); } return factory; } public static GUIFactory detectPlatform() { String osName = System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase(); if (osName.contains(\u0026#34;windows\u0026#34;)) { return getFactory(\u0026#34;windows\u0026#34;); } else if (osName.contains(\u0026#34;mac\u0026#34;)) { return getFactory(\u0026#34;macos\u0026#34;); } else { return getFactory(\u0026#34;linux\u0026#34;); } } } // 應用程序類 public class Application { private Button button; private CheckBox checkBox; private TextField textField; public Application(GUIFactory factory) { this.button = factory.createButton(); this.checkBox = factory.createCheckBox(); this.textField = factory.createTextField(); } public void createUI() { System.out.println(\u0026#34;=== 創建用戶界面 ===\u0026#34;); button.render(); checkBox.render(); textField.render(); } public void simulateUserInteraction() { System.out.println(\u0026#34;\\n=== 模擬用戶交互 ===\u0026#34;); button.onClick(); checkBox.toggle(); textField.setText(\u0026#34;Hello Factory Pattern!\u0026#34;); System.out.println(\u0026#34;文本框內容: \u0026#34; + textField.getText()); } } 抽象工廠使用範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class AbstractFactoryDemo { public static void main(String[] args) { // 方式1: 手動指定平台 System.out.println(\u0026#34;=== 手動指定平台 ===\u0026#34;); testPlatform(\u0026#34;windows\u0026#34;); testPlatform(\u0026#34;macos\u0026#34;); testPlatform(\u0026#34;linux\u0026#34;); // 方式2: 自動檢測平台 System.out.println(\u0026#34;\\n=== 自動檢測平台 ===\u0026#34;); GUIFactory autoFactory = GUIFactoryRegistry.detectPlatform(); Application autoApp = new Application(autoFactory); autoApp.createUI(); autoApp.simulateUserInteraction(); } private static void testPlatform(String platform) { System.out.println(\u0026#34;\\n--- 測試 \u0026#34; + platform.toUpperCase() + \u0026#34; 平台 ---\u0026#34;); GUIFactory factory = GUIFactoryRegistry.getFactory(platform); Application app = new Application(factory); app.createUI(); app.simulateUserInteraction(); } } 4. 現代 Java Factory Pattern 實現 使用 Lambda 表達式和函數式接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import java.util.function.Supplier; import java.util.function.Function; // 函數式工廠接口 @FunctionalInterface public interface VehicleSupplier extends Supplier\u0026lt;Vehicle\u0026gt; { } // 函數式工廠實現 public class FunctionalVehicleFactory { private static final Map\u0026lt;VehicleType, Function\u0026lt;String, Vehicle\u0026gt;\u0026gt; factoryMap = Map.of( VehicleType.CAR, Car::new, VehicleType.MOTORCYCLE, Motorcycle::new, VehicleType.TRUCK, brand -\u0026gt; new Truck(brand, 5) ); public static Vehicle createVehicle(VehicleType type, String brand) { Function\u0026lt;String, Vehicle\u0026gt; factory = factoryMap.get(type); if (factory == null) { throw new IllegalArgumentException(\u0026#34;不支援的車輛類型: \u0026#34; + type); } return factory.apply(brand); } // 使用 Supplier 的工廠方法 public static Vehicle createVehicle(VehicleSupplier supplier) { return supplier.get(); } } // 使用範例 public class FunctionalFactoryDemo { public static void main(String[] args) { // 使用 Map-based 工廠 Vehicle car = FunctionalVehicleFactory.createVehicle(VehicleType.CAR, \u0026#34;Tesla\u0026#34;); // 使用 Lambda 表達式 Vehicle motorcycle = FunctionalVehicleFactory.createVehicle(() -\u0026gt; new Motorcycle(\u0026#34;Yamaha\u0026#34;)); // 使用方法引用 Vehicle truck = FunctionalVehicleFactory.createVehicle(() -\u0026gt; new Truck(\u0026#34;Mercedes\u0026#34;, 15)); // 測試車輛 Stream.of(car, motorcycle, truck) .forEach(vehicle -\u0026gt; { vehicle.start(); vehicle.accelerate(); vehicle.stop(); System.out.println(\u0026#34;---\u0026#34;); }); } } 使用 Enum 的工廠模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // 增強的枚舉工廠 public enum VehicleFactoryEnum { CAR(\u0026#34;汽車\u0026#34;) { @Override public Vehicle create(String brand, Object... params) { return new Car(brand); } }, MOTORCYCLE(\u0026#34;機車\u0026#34;) { @Override public Vehicle create(String brand, Object... params) { return new Motorcycle(brand); } }, TRUCK(\u0026#34;卡車\u0026#34;) { @Override public Vehicle create(String brand, Object... params) { if (params.length \u0026gt; 0 \u0026amp;\u0026amp; params[0] instanceof Integer) { return new Truck(brand, (Integer) params[0]); } return new Truck(brand, 5); // 預設載重 } }; private final String description; VehicleFactoryEnum(String description) { this.description = description; } public abstract Vehicle create(String brand, Object... params); public String getDescription() { return description; } // 靜態工廠方法 public static Vehicle createVehicle(String type, String brand, Object... params) { try { VehicleFactoryEnum factory = VehicleFactoryEnum.valueOf(type.toUpperCase()); return factory.create(brand, params); } catch (IllegalArgumentException e) { throw new IllegalArgumentException(\u0026#34;不支援的車輛類型: \u0026#34; + type); } } } 5. Spring Boot 中的 Factory Pattern Spring Configuration Factory 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Profile; import org.springframework.boot.context.properties.ConfigurationProperties; // 配置屬性 @ConfigurationProperties(prefix = \u0026#34;app.notification\u0026#34;) public class NotificationProperties { private String provider = \u0026#34;email\u0026#34;; private String apiKey; private String baseUrl; // getters and setters public String getProvider() { return provider; } public void setProvider(String provider) { this.provider = provider; } public String getApiKey() { return apiKey; } public void setApiKey(String apiKey) { this.apiKey = apiKey; } public String getBaseUrl() { return baseUrl; } public void setBaseUrl(String baseUrl) { this.baseUrl = baseUrl; } } // 通知服務接口 public interface NotificationService { void sendNotification(String recipient, String message); boolean isAvailable(); } // 具體實現 @Component public class EmailNotificationService implements NotificationService { private final String apiKey; public EmailNotificationService(@Value(\u0026#34;${app.notification.api-key}\u0026#34;) String apiKey) { this.apiKey = apiKey; } @Override public void sendNotification(String recipient, String message) { System.out.println(\u0026#34;發送郵件到 \u0026#34; + recipient + \u0026#34;: \u0026#34; + message); // 實際郵件發送邏輯 } @Override public boolean isAvailable() { return apiKey != null \u0026amp;\u0026amp; !apiKey.isEmpty(); } } @Component public class SmsNotificationService implements NotificationService { private final String apiKey; public SmsNotificationService(@Value(\u0026#34;${app.notification.api-key}\u0026#34;) String apiKey) { this.apiKey = apiKey; } @Override public void sendNotification(String recipient, String message) { System.out.println(\u0026#34;發送短信到 \u0026#34; + recipient + \u0026#34;: \u0026#34; + message); // 實際短信發送邏輯 } @Override public boolean isAvailable() { return apiKey != null \u0026amp;\u0026amp; !apiKey.isEmpty(); } } @Component public class PushNotificationService implements NotificationService { private final String baseUrl; public PushNotificationService(@Value(\u0026#34;${app.notification.base-url}\u0026#34;) String baseUrl) { this.baseUrl = baseUrl; } @Override public void sendNotification(String recipient, String message) { System.out.println(\u0026#34;發送推送通知到 \u0026#34; + recipient + \u0026#34;: \u0026#34; + message); // 實際推送通知邏輯 } @Override public boolean isAvailable() { return baseUrl != null \u0026amp;\u0026amp; !baseUrl.isEmpty(); } } Spring Factory Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 // 通知工廠接口 public interface NotificationFactory { NotificationService createNotificationService(String type); List\u0026lt;NotificationService\u0026gt; getAllAvailableServices(); } // Spring 管理的工廠實現 @Component public class SpringNotificationFactory implements NotificationFactory { private final Map\u0026lt;String, NotificationService\u0026gt; services; public SpringNotificationFactory(List\u0026lt;NotificationService\u0026gt; notificationServices) { this.services = notificationServices.stream() .collect(Collectors.toMap( service -\u0026gt; service.getClass().getSimpleName().toLowerCase().replace(\u0026#34;notificationservice\u0026#34;, \u0026#34;\u0026#34;), Function.identity() )); } @Override public NotificationService createNotificationService(String type) { NotificationService service = services.get(type.toLowerCase()); if (service == null) { throw new IllegalArgumentException(\u0026#34;不支援的通知類型: \u0026#34; + type); } if (!service.isAvailable()) { throw new IllegalStateException(\u0026#34;通知服務不可用: \u0026#34; + type); } return service; } @Override public List\u0026lt;NotificationService\u0026gt; getAllAvailableServices() { return services.values().stream() .filter(NotificationService::isAvailable) .collect(Collectors.toList()); } } // 配置類 @Configuration @EnableConfigurationProperties(NotificationProperties.class) public class NotificationConfig { @Bean @Primary public NotificationService primaryNotificationService( NotificationProperties properties, NotificationFactory factory) { return factory.createNotificationService(properties.getProvider()); } @Bean @Profile(\u0026#34;development\u0026#34;) public NotificationService devNotificationService() { return new NotificationService() { @Override public void sendNotification(String recipient, String message) { System.out.println(\u0026#34;[DEV] 模擬通知 - 收件人: \u0026#34; + recipient + \u0026#34;, 消息: \u0026#34; + message); } @Override public boolean isAvailable() { return true; } }; } } Spring Boot Factory 服務 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 // 通知管理器服務 @Service public class NotificationManager { private final NotificationFactory notificationFactory; private final NotificationProperties properties; public NotificationManager(NotificationFactory notificationFactory, NotificationProperties properties) { this.notificationFactory = notificationFactory; this.properties = properties; } public void sendNotification(String type, String recipient, String message) { try { NotificationService service = notificationFactory.createNotificationService(type); service.sendNotification(recipient, message); } catch (Exception e) { // 降級到主要通知服務 NotificationService fallbackService = notificationFactory.createNotificationService(properties.getProvider()); fallbackService.sendNotification(recipient, \u0026#34;原通知失敗，改用 \u0026#34; + properties.getProvider() + \u0026#34;: \u0026#34; + message); } } public void sendBroadcast(String message) { List\u0026lt;NotificationService\u0026gt; availableServices = notificationFactory.getAllAvailableServices(); availableServices.parallelStream() .forEach(service -\u0026gt; { try { service.sendNotification(\u0026#34;broadcast\u0026#34;, message); } catch (Exception e) { System.err.println(\u0026#34;廣播通知失敗: \u0026#34; + e.getMessage()); } }); } } // 控制器使用範例 @RestController @RequestMapping(\u0026#34;/api/notifications\u0026#34;) public class NotificationController { private final NotificationManager notificationManager; public NotificationController(NotificationManager notificationManager) { this.notificationManager = notificationManager; } @PostMapping(\u0026#34;/send\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; sendNotification( @RequestParam String type, @RequestParam String recipient, @RequestParam String message) { try { notificationManager.sendNotification(type, recipient, message); return ResponseEntity.ok(\u0026#34;通知發送成功\u0026#34;); } catch (Exception e) { return ResponseEntity.badRequest().body(\u0026#34;通知發送失敗: \u0026#34; + e.getMessage()); } } @PostMapping(\u0026#34;/broadcast\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; broadcast(@RequestParam String message) { notificationManager.sendBroadcast(message); return ResponseEntity.ok(\u0026#34;廣播通知已發送\u0026#34;); } } 6. 企業級 Factory Pattern 實現 數據源工廠 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 // 數據源類型 public enum DataSourceType { MYSQL(\u0026#34;MySQL 數據庫\u0026#34;), POSTGRESQL(\u0026#34;PostgreSQL 數據庫\u0026#34;), ORACLE(\u0026#34;Oracle 數據庫\u0026#34;), MONGODB(\u0026#34;MongoDB 數據庫\u0026#34;), REDIS(\u0026#34;Redis 緩存\u0026#34;); private final String description; DataSourceType(String description) { this.description = description; } public String getDescription() { return description; } } // 數據源配置 public class DataSourceConfig { private String url; private String username; private String password; private String driverClassName; private int maxPoolSize = 20; private int minPoolSize = 5; private long connectionTimeout = 30000; // 建構器模式 public static class Builder { private final DataSourceConfig config = new DataSourceConfig(); public Builder url(String url) { config.url = url; return this; } public Builder username(String username) { config.username = username; return this; } public Builder password(String password) { config.password = password; return this; } public Builder driverClassName(String driverClassName) { config.driverClassName = driverClassName; return this; } public Builder maxPoolSize(int maxPoolSize) { config.maxPoolSize = maxPoolSize; return this; } public Builder minPoolSize(int minPoolSize) { config.minPoolSize = minPoolSize; return this; } public Builder connectionTimeout(long connectionTimeout) { config.connectionTimeout = connectionTimeout; return this; } public DataSourceConfig build() { if (config.url == null) { throw new IllegalArgumentException(\u0026#34;數據源 URL 不能為空\u0026#34;); } return config; } } // getters public String getUrl() { return url; } public String getUsername() { return username; } public String getPassword() { return password; } public String getDriverClassName() { return driverClassName; } public int getMaxPoolSize() { return maxPoolSize; } public int getMinPoolSize() { return minPoolSize; } public long getConnectionTimeout() { return connectionTimeout; } } // 抽象數據源工廠 public abstract class DataSourceFactory { protected final DataSourceConfig config; public DataSourceFactory(DataSourceConfig config) { this.config = config; } public abstract DataSource createDataSource(); public abstract boolean testConnection(); // 模板方法 public DataSource createAndTestDataSource() { DataSource dataSource = createDataSource(); if (!testConnection()) { throw new RuntimeException(\u0026#34;數據源連接測試失敗\u0026#34;); } return dataSource; } } // 具體數據源工廠實現 public class MySQLDataSourceFactory extends DataSourceFactory { public MySQLDataSourceFactory(DataSourceConfig config) { super(config); } @Override public DataSource createDataSource() { HikariConfig hikariConfig = new HikariConfig(); hikariConfig.setJdbcUrl(config.getUrl()); hikariConfig.setUsername(config.getUsername()); hikariConfig.setPassword(config.getPassword()); hikariConfig.setDriverClassName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); hikariConfig.setMaximumPoolSize(config.getMaxPoolSize()); hikariConfig.setMinimumIdle(config.getMinPoolSize()); hikariConfig.setConnectionTimeout(config.getConnectionTimeout()); return new HikariDataSource(hikariConfig); } @Override public boolean testConnection() { try (Connection conn = createDataSource().getConnection()) { return conn.isValid(5); } catch (SQLException e) { return false; } } } public class PostgreSQLDataSourceFactory extends DataSourceFactory { public PostgreSQLDataSourceFactory(DataSourceConfig config) { super(config); } @Override public DataSource createDataSource() { HikariConfig hikariConfig = new HikariConfig(); hikariConfig.setJdbcUrl(config.getUrl()); hikariConfig.setUsername(config.getUsername()); hikariConfig.setPassword(config.getPassword()); hikariConfig.setDriverClassName(\u0026#34;org.postgresql.Driver\u0026#34;); hikariConfig.setMaximumPoolSize(config.getMaxPoolSize()); hikariConfig.setMinimumIdle(config.getMinPoolSize()); hikariConfig.setConnectionTimeout(config.getConnectionTimeout()); return new HikariDataSource(hikariConfig); } @Override public boolean testConnection() { try (Connection conn = createDataSource().getConnection()) { return conn.isValid(5); } catch (SQLException e) { return false; } } } 企業級工廠管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 數據源工廠管理器 @Component public class DataSourceFactoryManager { private static final Map\u0026lt;DataSourceType, Class\u0026lt;? extends DataSourceFactory\u0026gt;\u0026gt; factoryRegistry = Map.of( DataSourceType.MYSQL, MySQLDataSourceFactory.class, DataSourceType.POSTGRESQL, PostgreSQLDataSourceFactory.class ); private final ApplicationContext applicationContext; public DataSourceFactoryManager(ApplicationContext applicationContext) { this.applicationContext = applicationContext; } public DataSourceFactory createFactory(DataSourceType type, DataSourceConfig config) { Class\u0026lt;? extends DataSourceFactory\u0026gt; factoryClass = factoryRegistry.get(type); if (factoryClass == null) { throw new IllegalArgumentException(\u0026#34;不支援的數據源類型: \u0026#34; + type); } try { Constructor\u0026lt;? extends DataSourceFactory\u0026gt; constructor = factoryClass.getConstructor(DataSourceConfig.class); return constructor.newInstance(config); } catch (Exception e) { throw new RuntimeException(\u0026#34;創建數據源工廠失敗\u0026#34;, e); } } @Cacheable(\u0026#34;dataSources\u0026#34;) public DataSource getDataSource(DataSourceType type, DataSourceConfig config) { DataSourceFactory factory = createFactory(type, config); return factory.createAndTestDataSource(); } } 7. 工廠模式的最佳實踐 錯誤處理和驗證 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // 增強的工廠實現，包含完整的錯誤處理 public class RobustVehicleFactory { private static final Logger logger = LoggerFactory.getLogger(RobustVehicleFactory.class); // 產品驗證器 private static final Map\u0026lt;VehicleType, Predicate\u0026lt;String\u0026gt;\u0026gt; validators = Map.of( VehicleType.CAR, brand -\u0026gt; brand != null \u0026amp;\u0026amp; brand.length() \u0026gt; 2, VehicleType.MOTORCYCLE, brand -\u0026gt; brand != null \u0026amp;\u0026amp; brand.length() \u0026gt; 1, VehicleType.TRUCK, brand -\u0026gt; brand != null \u0026amp;\u0026amp; brand.length() \u0026gt; 3 ); public static Vehicle createVehicle(VehicleType type, String brand) { return createVehicle(type, brand, null); } public static Vehicle createVehicle(VehicleType type, String brand, Integer capacity) { // 輸入驗證 validateInputs(type, brand, capacity); try { Vehicle vehicle = createVehicleInternal(type, brand, capacity); logger.info(\u0026#34;成功創建車輛: {} - {}\u0026#34;, type, brand); return vehicle; } catch (Exception e) { logger.error(\u0026#34;創建車輛失敗: {} - {}\u0026#34;, type, brand, e); throw new VehicleCreationException(\u0026#34;創建車輛失敗: \u0026#34; + e.getMessage(), e); } } private static void validateInputs(VehicleType type, String brand, Integer capacity) { if (type == null) { throw new IllegalArgumentException(\u0026#34;車輛類型不能為空\u0026#34;); } Predicate\u0026lt;String\u0026gt; validator = validators.get(type); if (validator != null \u0026amp;\u0026amp; !validator.test(brand)) { throw new IllegalArgumentException(\u0026#34;品牌名稱不符合要求: \u0026#34; + brand); } if (type == VehicleType.TRUCK \u0026amp;\u0026amp; (capacity == null || capacity \u0026lt;= 0)) { throw new IllegalArgumentException(\u0026#34;卡車必須指定有效的載重容量\u0026#34;); } } private static Vehicle createVehicleInternal(VehicleType type, String brand, Integer capacity) { switch (type) { case CAR: return new Car(brand); case MOTORCYCLE: return new Motorcycle(brand); case TRUCK: return new Truck(brand, capacity != null ? capacity : 5); default: throw new UnsupportedOperationException(\u0026#34;不支援的車輛類型: \u0026#34; + type); } } } // 自定義異常 public class VehicleCreationException extends RuntimeException { public VehicleCreationException(String message) { super(message); } public VehicleCreationException(String message, Throwable cause) { super(message, cause); } } 工廠模式性能優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 緩存優化的工廠 public class CachedVehicleFactory { private static final Cache\u0026lt;String, Vehicle\u0026gt; vehicleCache = Caffeine.newBuilder() .maximumSize(1000) .expireAfterWrite(1, TimeUnit.HOURS) .build(); public static Vehicle createVehicle(VehicleType type, String brand) { String cacheKey = type + \u0026#34;:\u0026#34; + brand; return vehicleCache.get(cacheKey, key -\u0026gt; { // 只有當緩存中沒有時才創建新實例 return RobustVehicleFactory.createVehicle(type, brand); }); } // 原型模式結合 - 用於昂貴對象 public static Vehicle createVehicleWithPrototype(VehicleType type, String brand) { Vehicle prototype = createVehicle(type, brand); try { return (Vehicle) prototype.clone(); // 需要實現 Cloneable } catch (CloneNotSupportedException e) { throw new RuntimeException(\u0026#34;克隆車輛失敗\u0026#34;, e); } } // 清理緩存 public static void clearCache() { vehicleCache.invalidateAll(); } // 獲取緩存統計 public static void printCacheStats() { CacheStats stats = vehicleCache.stats(); System.out.printf(\u0026#34;緩存統計 - 命中率: %.2f%%, 命中次數: %d, 未命中次數: %d%n\u0026#34;, stats.hitRate() * 100, stats.hitCount(), stats.missCount()); } } 8. 工廠模式的反模式和注意事項 常見反模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // ❌ 反模式 1: 工廠類過於龐大 public class BadGiantFactory { // 違背了單一職責原則 public Object createAnything(String type, String subType, Map\u0026lt;String, Object\u0026gt; params) { if (\u0026#34;vehicle\u0026#34;.equals(type)) { if (\u0026#34;car\u0026#34;.equals(subType)) { // 100 行車輛創建邏輯 } else if (\u0026#34;motorcycle\u0026#34;.equals(subType)) { // 80 行機車創建邏輯 } } else if (\u0026#34;document\u0026#34;.equals(type)) { if (\u0026#34;word\u0026#34;.equals(subType)) { // 120 行文檔創建邏輯 } } // ... 更多類型 return null; } } // ✅ 正確做法: 按職責分離工廠 public interface SpecializedFactory\u0026lt;T\u0026gt; { T create(String type, Map\u0026lt;String, Object\u0026gt; params); } public class VehicleFactory implements SpecializedFactory\u0026lt;Vehicle\u0026gt; { @Override public Vehicle create(String type, Map\u0026lt;String, Object\u0026gt; params) { // 專注於車輛創建 return null; } } public class DocumentFactory implements SpecializedFactory\u0026lt;Document\u0026gt; { @Override public Document create(String type, Map\u0026lt;String, Object\u0026gt; params) { // 專注於文檔創建 return null; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // ❌ 反模式 2: 直接在工廠中硬編碼依賴 public class BadDependencyFactory { public UserService createUserService() { // 硬編碼依賴，難以測試和擴展 UserRepository repo = new DatabaseUserRepository(); EmailService email = new SmtpEmailService(); return new UserService(repo, email); } } // ✅ 正確做法: 使用依賴注入 @Component public class UserServiceFactory { private final UserRepository userRepository; private final EmailService emailService; public UserServiceFactory(UserRepository userRepository, EmailService emailService) { this.userRepository = userRepository; this.emailService = emailService; } public UserService createUserService() { return new UserService(userRepository, emailService); } } 最佳實踐總結 單一職責: 每個工廠只負責創建一類相關的對象 開閉原則: 對擴展開放，對修改關閉 依賴注入: 在 Spring 環境中優先使用依賴注入 異常處理: 提供清晰的錯誤信息和恢復機制 性能考慮: 對於昂貴對象使用緩存或對象池 類型安全: 使用枚舉和泛型提高類型安全 可測試性: 設計時考慮單元測試的便利性 9. 工廠模式 vs 其他創建型模式 Factory vs Builder 1 2 3 4 5 6 7 8 9 10 11 12 // Factory: 適合簡單對象創建 Vehicle car = VehicleFactory.createVehicle(VehicleType.CAR, \u0026#34;BMW\u0026#34;); // Builder: 適合複雜對象創建 Car complexCar = new Car.Builder() .brand(\u0026#34;BMW\u0026#34;) .model(\u0026#34;X5\u0026#34;) .year(2023) .color(\u0026#34;Black\u0026#34;) .engine(new Engine(\u0026#34;V8\u0026#34;, 400)) .transmission(\u0026#34;Automatic\u0026#34;) .build(); Factory vs Singleton 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Factory: 每次調用創建新實例 public class VehicleFactory { public static Vehicle createVehicle() { return new Car(\u0026#34;Default\u0026#34;); // 新實例 } } // Singleton: 確保只有一個實例 public class ConfigurationManager { private static ConfigurationManager instance; public static ConfigurationManager getInstance() { if (instance == null) { synchronized (ConfigurationManager.class) { if (instance == null) { instance = new ConfigurationManager(); } } } return instance; // 相同實例 } } 10. 測試策略 工廠模式單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @ExtendWith(MockitoExtension.class) class VehicleFactoryTest { @Test void should_create_car_when_type_is_car() { // Given VehicleType type = VehicleType.CAR; String brand = \u0026#34;BMW\u0026#34;; // When Vehicle vehicle = VehicleFactory.createVehicle(type, brand); // Then assertThat(vehicle).isInstanceOf(Car.class); assertThat(vehicle.getType()).contains(\u0026#34;BMW\u0026#34;); } @Test void should_create_truck_with_capacity() { // Given VehicleType type = VehicleType.TRUCK; String brand = \u0026#34;Volvo\u0026#34;; int capacity = 10; // When Vehicle vehicle = VehicleFactory.createVehicle(type, brand, capacity); // Then assertThat(vehicle).isInstanceOf(Truck.class); assertThat(vehicle.getType()).contains(\u0026#34;10t\u0026#34;); } @Test void should_throw_exception_when_invalid_type() { // Given String invalidType = \u0026#34;invalid\u0026#34;; String brand = \u0026#34;BMW\u0026#34;; // When \u0026amp; Then assertThatThrownBy(() -\u0026gt; VehicleFactory.createVehicle(invalidType, brand)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(\u0026#34;不支援的車輛類型\u0026#34;); } @Test void should_throw_exception_when_truck_without_capacity() { // Given VehicleType type = VehicleType.TRUCK; String brand = \u0026#34;Volvo\u0026#34;; // When \u0026amp; Then assertThatThrownBy(() -\u0026gt; VehicleFactory.createVehicle(type, brand)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(\u0026#34;卡車必須指定載重容量\u0026#34;); } } // Spring Boot 集成測試 @SpringBootTest class NotificationFactoryIntegrationTest { @Autowired private NotificationFactory notificationFactory; @Test void should_create_email_service_when_configured() { // When NotificationService service = notificationFactory.createNotificationService(\u0026#34;email\u0026#34;); // Then assertThat(service).isInstanceOf(EmailNotificationService.class); assertThat(service.isAvailable()).isTrue(); } @Test void should_return_all_available_services() { // When List\u0026lt;NotificationService\u0026gt; services = notificationFactory.getAllAvailableServices(); // Then assertThat(services).isNotEmpty(); assertThat(services).allMatch(NotificationService::isAvailable); } } 11. 總結 適用場景 簡單工廠模式:\n產品類較少且相對穩定 客戶端只需要知道傳入工廠類的參數 不需要頻繁擴展產品類 工廠方法模式:\n需要靈活的產品創建機制 產品類可能會頻繁擴展 需要遵循開閉原則 抽象工廠模式:\n需要創建一系列相關的產品 系統需要在多個產品族中切換 需要確保產品族的一致性 關鍵要點 職責分離: 將對象創建邏輯與業務邏輯分離 擴展性: 新增產品類型時不需要修改現有代碼 一致性: 通過工廠確保對象創建的一致性 可測試性: 便於進行單元測試和模擬 Spring Boot 集成優勢 依賴注入: 自動管理工廠和產品的依賴關係 配置驅動: 通過配置文件動態選擇實現 AOP 支持: 可以在對象創建過程中添加橫切關注點 自動配置: 基於條件自動配置合適的工廠實現 工廠模式是企業級應用開發中最重要的設計模式之一，合理使用可以大大提高代碼的可維護性、可擴展性和可測試性。在 Spring Boot 環境中，結合依賴注入和自動配置，可以構建出更加靈活和強大的應用系統。\n","permalink":"https://xinqilin.github.io/post/architecture/factory/","tags":[],"title":"DesignPattern - Creational - Factory Pattern"},{"content":"概述 Singleton（單例模式）是最常見的創建型設計模式之一，它確保一個類別在整個應用程式生命週期中只有一個實例存在，並提供全域訪問點。這個模式廣泛應用於資料庫連線池、日志記錄器、快取管理器、設定管理器等場景。\n單例模式的核心特徵 唯一實例：確保類別只有一個實例 全域訪問：提供全域訪問該實例的方法 自我實例化：類別自己負責創建和管理實例 延遲初始化：通常在首次需要時才創建實例 傳統實作方式 1. 餓漢式（Eager Initialization） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * 餓漢式單例 - 類別載入時立即創建實例 * 優點：執行緒安全、實作簡單 * 缺點：不管是否使用都會創建實例，可能造成資源浪費 */ public class EagerSingleton { // 在類別載入時就創建實例 private static final EagerSingleton INSTANCE = new EagerSingleton(); // 私有建構子防止外部實例化 private EagerSingleton() { // 防止反射攻擊 if (INSTANCE != null) { throw new IllegalStateException(\u0026#34;單例已存在，不能創建新實例\u0026#34;); } System.out.println(\u0026#34;EagerSingleton 實例創建\u0026#34;); } public static EagerSingleton getInstance() { return INSTANCE; } // 業務方法範例 public void doSomething() { System.out.println(\u0026#34;執行 EagerSingleton 業務邏輯\u0026#34;); } // 防止克隆攻擊 @Override protected Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(\u0026#34;單例不支援克隆\u0026#34;); } // 防止序列化攻擊 private Object readResolve() { return INSTANCE; } } 2. 懶漢式（Lazy Initialization） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 懶漢式單例 - 延遲創建實例 * 問題：執行緒不安全 */ public class LazySingleton { private static LazySingleton instance; private LazySingleton() { System.out.println(\u0026#34;LazySingleton 實例創建\u0026#34;); } // ❌ 執行緒不安全的實作 public static LazySingleton getInstance() { if (instance == null) { instance = new LazySingleton(); } return instance; } } 3. 執行緒安全的懶漢式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * 執行緒安全的懶漢式單例 * 優點：執行緒安全、延遲初始化 * 缺點：性能開銷大（每次訪問都需要同步） */ public class ThreadSafeLazySingleton { private static ThreadSafeLazySingleton instance; private ThreadSafeLazySingleton() { System.out.println(\u0026#34;ThreadSafeLazySingleton 實例創建\u0026#34;); } // ❌ 性能較差的同步方法 public static synchronized ThreadSafeLazySingleton getInstance() { if (instance == null) { instance = new ThreadSafeLazySingleton(); } return instance; } } 推薦的現代化實作方式 1. Double-Checked Locking（雙重檢查鎖定） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 /** * 雙重檢查鎖定單例 * 優點：執行緒安全、性能好、延遲初始化 * 推薦：現代 Java 應用的標準實作 */ public class DoubleCheckedSingleton { // volatile 關鍵字確保可見性和禁止指令重排序 private static volatile DoubleCheckedSingleton instance; private DoubleCheckedSingleton() { // 防止反射攻擊 if (instance != null) { throw new IllegalStateException(\u0026#34;單例已存在，不能創建新實例\u0026#34;); } // 模擬複雜的初始化過程 try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } System.out.println(\u0026#34;DoubleCheckedSingleton 實例創建\u0026#34;); } public static DoubleCheckedSingleton getInstance() { // 第一次檢查：避免不必要的同步 if (instance == null) { synchronized (DoubleCheckedSingleton.class) { // 第二次檢查：確保只創建一個實例 if (instance == null) { instance = new DoubleCheckedSingleton(); } } } return instance; } public void performOperation() { System.out.println(\u0026#34;執行 DoubleCheckedSingleton 操作\u0026#34;); } // 防止克隆攻擊 @Override protected Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(\u0026#34;單例不支援克隆\u0026#34;); } // 防止序列化攻擊 private Object readResolve() { return instance; } } 2. 靜態內部類別（Initialization-on-demand Holder） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * 靜態內部類別單例 * 優點：執行緒安全、延遲初始化、性能最佳、程式碼簡潔 * 推薦：最優雅的實作方式 */ public class StaticHolderSingleton { private StaticHolderSingleton() { System.out.println(\u0026#34;StaticHolderSingleton 實例創建\u0026#34;); } // 靜態內部類別，只有在被引用時才會載入 private static class SingletonHolder { private static final StaticHolderSingleton INSTANCE = new StaticHolderSingleton(); } public static StaticHolderSingleton getInstance() { return SingletonHolder.INSTANCE; } public void executeTask() { System.out.println(\u0026#34;執行 StaticHolderSingleton 任務\u0026#34;); } } 3. 枚舉單例（推薦） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * 枚舉單例 * 優點：執行緒安全、防止反射和序列化攻擊、程式碼最簡潔 * 推薦：Joshua Bloch 推薦的最佳實作方式 */ public enum EnumSingleton { INSTANCE; // 實例變數 private String data; // 建構子（枚舉的建構子總是私有的） EnumSingleton() { this.data = \u0026#34;EnumSingleton 初始化資料\u0026#34;; System.out.println(\u0026#34;EnumSingleton 實例創建\u0026#34;); } // 業務方法 public void setData(String data) { this.data = data; } public String getData() { return data; } public void processData() { System.out.println(\u0026#34;處理資料: \u0026#34; + data); } // 可以實作介面 public void performAction() { System.out.println(\u0026#34;執行 EnumSingleton 動作\u0026#34;); } } // 使用範例 class EnumSingletonExample { public static void main(String[] args) { EnumSingleton singleton = EnumSingleton.INSTANCE; singleton.setData(\u0026#34;更新的資料\u0026#34;); singleton.processData(); } } 實際應用範例 1. 資料庫連線管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /** * 資料庫連線管理器單例 * 使用靜態內部類別實作 */ public class DatabaseManager { private final HikariDataSource dataSource; private DatabaseManager() { // 初始化連線池配置 HikariConfig config = new HikariConfig(); config.setJdbcUrl(\u0026#34;jdbc:mysql://localhost:3306/mydb\u0026#34;); config.setUsername(\u0026#34;user\u0026#34;); config.setPassword(\u0026#34;password\u0026#34;); config.setMaximumPoolSize(20); config.setMinimumIdle(5); config.setConnectionTimeout(30000); config.setIdleTimeout(600000); config.setMaxLifetime(1800000); this.dataSource = new HikariDataSource(config); System.out.println(\u0026#34;資料庫連線池初始化完成\u0026#34;); } private static class Holder { private static final DatabaseManager INSTANCE = new DatabaseManager(); } public static DatabaseManager getInstance() { return Holder.INSTANCE; } public Connection getConnection() throws SQLException { return dataSource.getConnection(); } public void closeDataSource() { if (dataSource != null \u0026amp;\u0026amp; !dataSource.isClosed()) { dataSource.close(); System.out.println(\u0026#34;資料庫連線池已關閉\u0026#34;); } } // JVM 關閉時清理資源 static { Runtime.getRuntime().addShutdownHook(new Thread(() -\u0026gt; { DatabaseManager.getInstance().closeDataSource(); })); } } 2. 應用程式設定管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 /** * 應用程式設定管理器 * 使用枚舉實作，支援動態設定更新 */ public enum ConfigurationManager { INSTANCE; private final Properties properties; private final Map\u0026lt;String, Object\u0026gt; runtimeConfig; private final ReadWriteLock lock; ConfigurationManager() { this.properties = new Properties(); this.runtimeConfig = new ConcurrentHashMap\u0026lt;\u0026gt;(); this.lock = new ReentrantReadWriteLock(); loadConfiguration(); } private void loadConfiguration() { try (InputStream input = getClass().getClassLoader() .getResourceAsStream(\u0026#34;application.properties\u0026#34;)) { if (input != null) { properties.load(input); System.out.println(\u0026#34;設定檔載入完成\u0026#34;); } else { System.out.println(\u0026#34;找不到設定檔，使用預設設定\u0026#34;); loadDefaultConfiguration(); } } catch (IOException e) { System.err.println(\u0026#34;載入設定檔失敗: \u0026#34; + e.getMessage()); loadDefaultConfiguration(); } } private void loadDefaultConfiguration() { properties.setProperty(\u0026#34;app.name\u0026#34;, \u0026#34;MyApplication\u0026#34;); properties.setProperty(\u0026#34;app.version\u0026#34;, \u0026#34;1.0.0\u0026#34;); properties.setProperty(\u0026#34;app.environment\u0026#34;, \u0026#34;development\u0026#34;); properties.setProperty(\u0026#34;database.pool.max\u0026#34;, \u0026#34;20\u0026#34;); properties.setProperty(\u0026#34;cache.ttl\u0026#34;, \u0026#34;3600\u0026#34;); } public String getProperty(String key) { lock.readLock().lock(); try { return properties.getProperty(key); } finally { lock.readLock().unlock(); } } public String getProperty(String key, String defaultValue) { lock.readLock().lock(); try { return properties.getProperty(key, defaultValue); } finally { lock.readLock().unlock(); } } public void setProperty(String key, String value) { lock.writeLock().lock(); try { properties.setProperty(key, value); System.out.println(\u0026#34;設定已更新: \u0026#34; + key + \u0026#34; = \u0026#34; + value); } finally { lock.writeLock().unlock(); } } public int getIntProperty(String key, int defaultValue) { try { String value = getProperty(key); return value != null ? Integer.parseInt(value) : defaultValue; } catch (NumberFormatException e) { return defaultValue; } } public boolean getBooleanProperty(String key, boolean defaultValue) { String value = getProperty(key); return value != null ? Boolean.parseBoolean(value) : defaultValue; } // 執行時設定（不會持久化） public void setRuntimeConfig(String key, Object value) { runtimeConfig.put(key, value); } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T\u0026gt; T getRuntimeConfig(String key, Class\u0026lt;T\u0026gt; type, T defaultValue) { Object value = runtimeConfig.get(key); return type.isInstance(value) ? (T) value : defaultValue; } public void reloadConfiguration() { lock.writeLock().lock(); try { properties.clear(); loadConfiguration(); System.out.println(\u0026#34;設定已重新載入\u0026#34;); } finally { lock.writeLock().unlock(); } } public Map\u0026lt;String, String\u0026gt; getAllProperties() { lock.readLock().lock(); try { Map\u0026lt;String, String\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); for (String key : properties.stringPropertyNames()) { result.put(key, properties.getProperty(key)); } return result; } finally { lock.readLock().unlock(); } } } 3. 日志管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 /** * 自訂日志管理器單例 * 使用雙重檢查鎖定實作 */ public class LoggerManager { private static volatile LoggerManager instance; private final Map\u0026lt;String, Logger\u0026gt; loggers; private final String logLevel; private final boolean enableConsoleOutput; private final String logFilePath; private LoggerManager() { this.loggers = new ConcurrentHashMap\u0026lt;\u0026gt;(); // 從設定管理器獲取設定 ConfigurationManager config = ConfigurationManager.INSTANCE; this.logLevel = config.getProperty(\u0026#34;log.level\u0026#34;, \u0026#34;INFO\u0026#34;); this.enableConsoleOutput = config.getBooleanProperty(\u0026#34;log.console.enabled\u0026#34;, true); this.logFilePath = config.getProperty(\u0026#34;log.file.path\u0026#34;, \u0026#34;logs/application.log\u0026#34;); initializeLoggers(); System.out.println(\u0026#34;日志管理器初始化完成\u0026#34;); } public static LoggerManager getInstance() { if (instance == null) { synchronized (LoggerManager.class) { if (instance == null) { instance = new LoggerManager(); } } } return instance; } private void initializeLoggers() { // 初始化預設日志記錄器 createLogger(\u0026#34;DEFAULT\u0026#34;); createLogger(\u0026#34;DATABASE\u0026#34;); createLogger(\u0026#34;SECURITY\u0026#34;); createLogger(\u0026#34;PERFORMANCE\u0026#34;); } public Logger getLogger(String name) { return loggers.computeIfAbsent(name, this::createLogger); } private Logger createLogger(String name) { Logger logger = LoggerFactory.getLogger(name); // 這裡可以根據需要配置 logger 的 appender 和 level // 實際應用中通常使用 logback.xml 或 log4j2.xml 配置 System.out.println(\u0026#34;創建 Logger: \u0026#34; + name); return logger; } public void logInfo(String loggerName, String message) { getLogger(loggerName).info(message); } public void logError(String loggerName, String message, Throwable throwable) { getLogger(loggerName).error(message, throwable); } public void logDebug(String loggerName, String message) { getLogger(loggerName).debug(message); } public void logWarn(String loggerName, String message) { getLogger(loggerName).warn(message); } // 獲取所有 logger 的統計資訊 public Map\u0026lt;String, String\u0026gt; getLoggerStats() { Map\u0026lt;String, String\u0026gt; stats = new HashMap\u0026lt;\u0026gt;(); stats.put(\u0026#34;totalLoggers\u0026#34;, String.valueOf(loggers.size())); stats.put(\u0026#34;logLevel\u0026#34;, logLevel); stats.put(\u0026#34;consoleOutput\u0026#34;, String.valueOf(enableConsoleOutput)); stats.put(\u0026#34;logFilePath\u0026#34;, logFilePath); return stats; } } Spring 框架中的單例模式 1. Spring Bean 的單例作用域 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /** * Spring 中的單例 Bean * Spring 預設使用單例作用域管理 Bean */ @Component @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON) // 預設值，可省略 public class SpringSingletonService { private final String instanceId; private final LocalDateTime createdAt; public SpringSingletonService() { this.instanceId = UUID.randomUUID().toString(); this.createdAt = LocalDateTime.now(); System.out.println(\u0026#34;SpringSingletonService 實例創建: \u0026#34; + instanceId); } public String getInstanceInfo() { return String.format(\u0026#34;實例ID: %s, 創建時間: %s\u0026#34;, instanceId, createdAt); } @PostConstruct private void init() { System.out.println(\u0026#34;SpringSingletonService 初始化完成\u0026#34;); } @PreDestroy private void destroy() { System.out.println(\u0026#34;SpringSingletonService 銷毀: \u0026#34; + instanceId); } } /** * 使用 @Configuration 和 @Bean 註解創建單例 */ @Configuration public class SingletonBeanConfiguration { @Bean @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON) public CacheManager cacheManager() { return new ConcurrentMapCacheManager(\u0026#34;users\u0026#34;, \u0026#34;products\u0026#34;, \u0026#34;orders\u0026#34;); } @Bean public TaskExecutor taskExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(5); executor.setMaxPoolSize(20); executor.setQueueCapacity(100); executor.setThreadNamePrefix(\u0026#34;App-\u0026#34;); executor.initialize(); return executor; } } 2. Spring Boot 中的單例服務 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Spring Boot 中的單例服務範例 */ @Service public class UserService { private final UserRepository userRepository; private final CacheManager cacheManager; private final String serviceId; public UserService(UserRepository userRepository, CacheManager cacheManager) { this.userRepository = userRepository; this.cacheManager = cacheManager; this.serviceId = UUID.randomUUID().toString(); System.out.println(\u0026#34;UserService 單例創建: \u0026#34; + serviceId); } @Cacheable(\u0026#34;users\u0026#34;) public User findById(Long id) { System.out.println(\u0026#34;從資料庫載入用戶: \u0026#34; + id); return userRepository.findById(id).orElse(null); } @CacheEvict(value = \u0026#34;users\u0026#34;, key = \u0026#34;#user.id\u0026#34;) public User save(User user) { return userRepository.save(user); } public String getServiceInfo() { return \u0026#34;UserService 實例ID: \u0026#34; + serviceId; } } 單例模式的潛在問題與解決方案 1. 反射攻擊防護 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /** * 防範反射攻擊的單例實作 */ public class ReflectionSafeSingleton { private static volatile ReflectionSafeSingleton instance; private static boolean instanceCreated = false; private ReflectionSafeSingleton() { synchronized (ReflectionSafeSingleton.class) { if (instanceCreated) { throw new IllegalStateException(\u0026#34;單例已存在，禁止透過反射創建新實例\u0026#34;); } instanceCreated = true; } System.out.println(\u0026#34;ReflectionSafeSingleton 實例創建\u0026#34;); } public static ReflectionSafeSingleton getInstance() { if (instance == null) { synchronized (ReflectionSafeSingleton.class) { if (instance == null) { instance = new ReflectionSafeSingleton(); } } } return instance; } } // 測試反射攻擊 class ReflectionAttackTest { public static void main(String[] args) { try { ReflectionSafeSingleton singleton1 = ReflectionSafeSingleton.getInstance(); Constructor\u0026lt;ReflectionSafeSingleton\u0026gt; constructor = ReflectionSafeSingleton.class.getDeclaredConstructor(); constructor.setAccessible(true); // 這裡會拋出 IllegalStateException ReflectionSafeSingleton singleton2 = constructor.newInstance(); } catch (Exception e) { System.out.println(\u0026#34;反射攻擊被阻止: \u0026#34; + e.getMessage()); } } } 2. 序列化攻擊防護 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * 防範序列化攻擊的單例實作 */ public class SerializationSafeSingleton implements Serializable { private static final long serialVersionUID = 1L; private static volatile SerializationSafeSingleton instance; private SerializationSafeSingleton() { System.out.println(\u0026#34;SerializationSafeSingleton 實例創建\u0026#34;); } public static SerializationSafeSingleton getInstance() { if (instance == null) { synchronized (SerializationSafeSingleton.class) { if (instance == null) { instance = new SerializationSafeSingleton(); } } } return instance; } // 防止序列化攻擊的關鍵方法 private Object readResolve() { return getInstance(); } // 可選：自訂序列化邏輯 private void writeObject(ObjectOutputStream out) throws IOException { out.defaultWriteObject(); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); } } 3. 多執行緒測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * 多執行緒環境下的單例測試 */ public class SingletonThreadTest { public static void main(String[] args) throws InterruptedException { final int threadCount = 1000; final CountDownLatch startLatch = new CountDownLatch(1); final CountDownLatch endLatch = new CountDownLatch(threadCount); final Set\u0026lt;Integer\u0026gt; instanceHashCodes = ConcurrentHashMap.newKeySet(); // 創建多個執行緒同時獲取單例 for (int i = 0; i \u0026lt; threadCount; i++) { new Thread(() -\u0026gt; { try { startLatch.await(); // 等待開始信號 // 測試不同的單例實作 DoubleCheckedSingleton instance1 = DoubleCheckedSingleton.getInstance(); StaticHolderSingleton instance2 = StaticHolderSingleton.getInstance(); EnumSingleton instance3 = EnumSingleton.INSTANCE; instanceHashCodes.add(System.identityHashCode(instance1)); instanceHashCodes.add(System.identityHashCode(instance2)); instanceHashCodes.add(System.identityHashCode(instance3)); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } finally { endLatch.countDown(); } }).start(); } System.out.println(\u0026#34;開始多執行緒單例測試...\u0026#34;); startLatch.countDown(); // 發出開始信號 endLatch.await(); // 等待所有執行緒完成 System.out.println(\u0026#34;測試完成\u0026#34;); System.out.println(\u0026#34;DoubleCheckedSingleton 不同實例數量: \u0026#34; + (instanceHashCodes.size() \u0026gt;= 3 ? \u0026#34;3 個（正常）\u0026#34; : \u0026#34;異常\u0026#34;)); } } 單例模式的效能比較 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /** * 不同單例實作的效能測試 */ public class SingletonPerformanceTest { private static final int ITERATIONS = 10_000_000; public static void main(String[] args) { // 預熱 JVM warmUp(); // 測試不同實作的效能 testEagerSingleton(); testDoubleCheckedSingleton(); testStaticHolderSingleton(); testEnumSingleton(); } private static void warmUp() { for (int i = 0; i \u0026lt; 100_000; i++) { EagerSingleton.getInstance(); DoubleCheckedSingleton.getInstance(); StaticHolderSingleton.getInstance(); EnumSingleton.INSTANCE.getData(); } } private static void testEagerSingleton() { long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; ITERATIONS; i++) { EagerSingleton.getInstance(); } long endTime = System.nanoTime(); System.out.printf(\u0026#34;EagerSingleton: %.2f ms%n\u0026#34;, (endTime - startTime) / 1_000_000.0); } private static void testDoubleCheckedSingleton() { long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; ITERATIONS; i++) { DoubleCheckedSingleton.getInstance(); } long endTime = System.nanoTime(); System.out.printf(\u0026#34;DoubleCheckedSingleton: %.2f ms%n\u0026#34;, (endTime - startTime) / 1_000_000.0); } private static void testStaticHolderSingleton() { long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; ITERATIONS; i++) { StaticHolderSingleton.getInstance(); } long endTime = System.nanoTime(); System.out.printf(\u0026#34;StaticHolderSingleton: %.2f ms%n\u0026#34;, (endTime - startTime) / 1_000_000.0); } private static void testEnumSingleton() { long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; ITERATIONS; i++) { EnumSingleton.INSTANCE.getData(); } long endTime = System.nanoTime(); System.out.printf(\u0026#34;EnumSingleton: %.2f ms%n\u0026#34;, (endTime - startTime) / 1_000_000.0); } } 總結與最佳實踐 推薦的實作方式 枚舉單例：適合大多數情況，最安全、最簡潔 靜態內部類別：適合需要延遲初始化的場景 雙重檢查鎖定：適合複雜初始化邏輯的場景 選擇指南 場景 推薦實作 原因 一般用途 枚舉單例 最安全、最簡潔 Spring 應用 Spring Bean 框架管理生命週期 延遲初始化 靜態內部類別 性能最佳、執行緒安全 複雜初始化 雙重檢查鎖定 靈活性高 簡單場景 餓漢式 實作簡單 注意事項 避免過度使用：單例會增加程式碼的耦合度 考慮測試性：單例可能影響單元測試的獨立性 執行緒安全：確保在多執行緒環境下的正確性 資源清理：適當時候釋放單例持有的資源 序列化考慮：實作 readResolve() 方法防止序列化攻擊 現代替代方案 在現代應用開發中，可以考慮以下替代方案：\n依賴注入容器：如 Spring IoC 容器 靜態工廠方法：提供更好的測試性 Builder 模式：適合複雜對象的創建 Registry 模式：管理多個相關的單例 單例模式雖然簡單，但在實際應用中需要謹慎考慮其適用性和實作方式。選擇合適的實作方案能夠確保程式碼的健壯性和可維護性。\n參考資料 Effective Java by Joshua Bloch Design Patterns: Elements of Reusable Object-Oriented Software Java Concurrency in Practice Spring Framework Documentation ","permalink":"https://xinqilin.github.io/post/architecture/singleton/","tags":["Design Pattern","Singleton","Java","Thread Safety","Best Practices","Creational Pattern"],"title":"Singleton 設計模式完整指南：單例實作與現代化最佳實踐"}]