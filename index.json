[{"content":"👋 歡迎來到 Bill.Lin\u0026rsquo;s Notes 這裡是我的技術學習筆記和心得分享空間。主要記錄程式開發過程中遇到的問題、解決方案，以及對各種技術的理解和實踐經驗。\n📚 主要內容 🧮 演算法與資料結構 經典演算法實作與分析 LeetCode 解題思路與技巧 資料結構的應用場景 💻 後端開發 Java: 語言特性、集合框架、並發程式設計 Kotlin: 語法糖、協程、與 Java 互操作 Spring: IoC/DI、AOP、MVC、Security、Boot 🏗️ 架構設計 設計模式: GoF 23 種設計模式的理論與實踐 SOLID 原則: 物件導向設計的五大原則 分散式系統: 微服務、訊息佇列、分散式鎖 🐳 DevOps Docker: 容器化部署與最佳實踐 CI/CD: 自動化建構與部署流程 監控: 應用效能監控與日誌管理 🛠️ 開發工具 Linux: 常用指令與腳本編寫 Git: 版本控制與協作工作流 Hugo: 靜態網站生成器的使用心得 🎯 寫作目標 記錄學習過程: 將學習到的知識點整理成筆記，加深理解 分享實踐經驗: 分享在實際專案中遇到的問題和解決方案 建立知識體系: 透過持續寫作，建立完整的技術知識架構 幫助他人學習: 希望這些筆記能對其他開發者有所幫助 📖 文章特色 理論與實踐並重: 不僅說明原理，更著重實際應用 程式碼範例豐富: 提供完整可執行的程式碼示例 循序漸進: 從基礎概念到進階應用，逐步深入 持續更新: 根據新的學習心得和技術發展持續更新內容 🤝 聯絡方式 如果您對文章內容有任何問題或建議，歡迎透過以下方式聯絡：\nGitHub: xinqilin Email: 請透過 GitHub 聯絡 🙏 致謝 感謝所有在技術學習路上給予幫助的同事、朋友和開源社群。特別感謝那些無私分享技術知識的部落格作者和教程創作者，您們的分享讓我受益良多。\n「學而時習之，不亦說乎」- 論語\n希望這個小小的技術筆記空間，能成為知識分享和交流的平台。讓我們一起在技術的海洋中探索和成長！\n","permalink":"https://xinqilin.github.io/about/","tags":null,"title":"關於 Bill.Lin's Notes"},{"content":"概述 FTP（File Transfer Protocol）是企業環境中常用的檔案傳輸協定。本文提供一個完整、安全且可靠的 FTP 工具類實作，適用於生產環境的檔案上傳、下載和管理需求。\n核心特性 ✅ 配置外部化：所有連線資訊透過配置檔案管理 ✅ 連線池管理：支援連線複用，提升效能 ✅ 完整錯誤處理：詳細的異常處理和重試機制 ✅ 檔案操作：上傳、下載、刪除、列表等完整功能 ✅ 安全考量：密碼加密、連線超時、資源釋放 ✅ 日誌記錄：完整的操作日誌和監控 依賴配置 Maven 依賴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;dependencies\u0026gt; \u0026lt;!-- Apache Commons Net --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-net\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-net\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.9.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot Starter --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 配置處理 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Gradle 依賴 1 2 3 4 5 dependencies { implementation \u0026#39;commons-net:commons-net:3.9.0\u0026#39; implementation \u0026#39;org.springframework.boot:spring-boot-starter\u0026#39; annotationProcessor \u0026#39;org.springframework.boot:spring-boot-configuration-processor\u0026#39; } 配置類設計 FTP 配置屬性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package com.example.config; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; @Component @ConfigurationProperties(prefix = \u0026#34;ftp\u0026#34;) public class FtpProperties { private String host; private int port = 21; private String username; private String password; private String basePath = \u0026#34;/\u0026#34;; private int connectTimeout = 30000; // 30 秒 private int dataTimeout = 60000; // 60 秒 private int bufferSize = 8192; // 8KB private String encoding = \u0026#34;UTF-8\u0026#34;; private boolean passiveMode = true; private int maxConnections = 10; // Getters and Setters public String getHost() { return host; } public void setHost(String host) { this.host = host; } public int getPort() { return port; } public void setPort(int port) { this.port = port; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getBasePath() { return basePath; } public void setBasePath(String basePath) { this.basePath = basePath; } public int getConnectTimeout() { return connectTimeout; } public void setConnectTimeout(int connectTimeout) { this.connectTimeout = connectTimeout; } public int getDataTimeout() { return dataTimeout; } public void setDataTimeout(int dataTimeout) { this.dataTimeout = dataTimeout; } public int getBufferSize() { return bufferSize; } public void setBufferSize(int bufferSize) { this.bufferSize = bufferSize; } public String getEncoding() { return encoding; } public void setEncoding(String encoding) { this.encoding = encoding; } public boolean isPassiveMode() { return passiveMode; } public void setPassiveMode(boolean passiveMode) { this.passiveMode = passiveMode; } public int getMaxConnections() { return maxConnections; } public void setMaxConnections(int maxConnections) { this.maxConnections = maxConnections; } } 應用配置檔案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # application.yml ftp: host: ${FTP_HOST:ftp.example.com} port: ${FTP_PORT:21} username: ${FTP_USERNAME:} password: ${FTP_PASSWORD:} base-path: ${FTP_BASE_PATH:/uploads} connect-timeout: 30000 data-timeout: 60000 buffer-size: 8192 encoding: UTF-8 passive-mode: true max-connections: 10 # 生產環境建議使用環境變數 # export FTP_HOST=your-ftp-server.com # export FTP_USERNAME=your-username # export FTP_PASSWORD=your-secure-password 核心工具類實作 FTP 連線工廠 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 package com.example.util; import org.apache.commons.net.ftp.FTPClient; import org.apache.commons.net.ftp.FTPReply; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import com.example.config.FtpProperties; import java.io.IOException; import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; @Component public class FtpConnectionFactory { private static final Logger logger = LoggerFactory.getLogger(FtpConnectionFactory.class); @Autowired private FtpProperties ftpProperties; private final BlockingQueue\u0026lt;FTPClient\u0026gt; connectionPool = new LinkedBlockingQueue\u0026lt;\u0026gt;(); /** * 建立 FTP 連線 */ public FTPClient createConnection() throws IOException { FTPClient ftpClient = new FTPClient(); try { // 設定連線參數 ftpClient.setConnectTimeout(ftpProperties.getConnectTimeout()); ftpClient.setDataTimeout(ftpProperties.getDataTimeout()); ftpClient.setControlEncoding(ftpProperties.getEncoding()); ftpClient.setBufferSize(ftpProperties.getBufferSize()); // 建立連線 ftpClient.connect(ftpProperties.getHost(), ftpProperties.getPort()); // 檢查連線回應 int replyCode = ftpClient.getReplyCode(); if (!FTPReply.isPositiveCompletion(replyCode)) { ftpClient.disconnect(); throw new IOException(\u0026#34;FTP 伺服器拒絕連線，回應碼：\u0026#34; + replyCode); } // 登入 boolean loginSuccess = ftpClient.login(ftpProperties.getUsername(), ftpProperties.getPassword()); if (!loginSuccess) { ftpClient.disconnect(); throw new IOException(\u0026#34;FTP 登入失敗，請檢查使用者名稱和密碼\u0026#34;); } // 設定檔案傳輸模式 ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); // 設定被動/主動模式 if (ftpProperties.isPassiveMode()) { ftpClient.enterLocalPassiveMode(); } else { ftpClient.enterLocalActiveMode(); } logger.info(\u0026#34;FTP 連線建立成功：{}:{}\u0026#34;, ftpProperties.getHost(), ftpProperties.getPort()); return ftpClient; } catch (IOException e) { logger.error(\u0026#34;建立 FTP 連線失敗：{}\u0026#34;, e.getMessage()); if (ftpClient.isConnected()) { try { ftpClient.disconnect(); } catch (IOException ex) { logger.warn(\u0026#34;關閉失敗的 FTP 連線時發生錯誤：{}\u0026#34;, ex.getMessage()); } } throw e; } } /** * 歸還連線到連線池 */ public void returnConnection(FTPClient ftpClient) { if (ftpClient != null \u0026amp;\u0026amp; ftpClient.isConnected()) { if (connectionPool.size() \u0026lt; ftpProperties.getMaxConnections()) { connectionPool.offer(ftpClient); } else { closeConnection(ftpClient); } } } /** * 從連線池獲取連線 */ public FTPClient getConnection() throws IOException { FTPClient ftpClient = connectionPool.poll(); if (ftpClient == null || !ftpClient.isConnected()) { return createConnection(); } return ftpClient; } /** * 關閉連線 */ public void closeConnection(FTPClient ftpClient) { if (ftpClient != null) { try { if (ftpClient.isConnected()) { ftpClient.logout(); ftpClient.disconnect(); } } catch (IOException e) { logger.warn(\u0026#34;關閉 FTP 連線時發生錯誤：{}\u0026#34;, e.getMessage()); } } } } 主要 FTP 工具類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 package com.example.util; import org.apache.commons.net.ftp.FTPClient; import org.apache.commons.net.ftp.FTPFile; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import com.example.config.FtpProperties; import java.io.*; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import java.util.ArrayList; import java.util.List; @Component public class FtpUtil { private static final Logger logger = LoggerFactory.getLogger(FtpUtil.class); @Autowired private FtpConnectionFactory connectionFactory; @Autowired private FtpProperties ftpProperties; /** * 上傳檔案 * * @param localFile 本地檔案 * @param remotePath 遠端路徑（相對於 basePath） * @return 上傳是否成功 */ public boolean uploadFile(File localFile, String remotePath) { if (!localFile.exists() || !localFile.isFile()) { logger.error(\u0026#34;本地檔案不存在或不是檔案：{}\u0026#34;, localFile.getAbsolutePath()); return false; } try (FileInputStream fis = new FileInputStream(localFile)) { return uploadFile(fis, remotePath, localFile.getName()); } catch (IOException e) { logger.error(\u0026#34;讀取本地檔案失敗：{}\u0026#34;, e.getMessage()); return false; } } /** * 上傳檔案流 * * @param inputStream 輸入流 * @param remotePath 遠端路徑 * @param fileName 檔案名稱 * @return 上傳是否成功 */ public boolean uploadFile(InputStream inputStream, String remotePath, String fileName) { FTPClient ftpClient = null; try { ftpClient = connectionFactory.getConnection(); // 確保遠端目錄存在 String fullPath = buildFullPath(remotePath); createDirectoryIfNotExists(ftpClient, fullPath); // 切換到目標目錄 if (!ftpClient.changeWorkingDirectory(fullPath)) { logger.error(\u0026#34;無法切換到目錄：{}\u0026#34;, fullPath); return false; } // 上傳檔案 boolean result = ftpClient.storeFile(fileName, inputStream); if (result) { logger.info(\u0026#34;檔案上傳成功：{}/{}\u0026#34;, fullPath, fileName); } else { logger.error(\u0026#34;檔案上傳失敗：{}/{}\u0026#34;, fullPath, fileName); } return result; } catch (IOException e) { logger.error(\u0026#34;上傳檔案時發生錯誤：{}\u0026#34;, e.getMessage()); return false; } finally { connectionFactory.returnConnection(ftpClient); closeQuietly(inputStream); } } /** * 下載檔案 * * @param remotePath 遠端路徑 * @param fileName 檔案名稱 * @param localFile 本地檔案 * @return 下載是否成功 */ public boolean downloadFile(String remotePath, String fileName, File localFile) { FTPClient ftpClient = null; try { ftpClient = connectionFactory.getConnection(); String fullPath = buildFullPath(remotePath); if (!ftpClient.changeWorkingDirectory(fullPath)) { logger.error(\u0026#34;遠端目錄不存在：{}\u0026#34;, fullPath); return false; } // 確保本地目錄存在 File parentDir = localFile.getParentFile(); if (!parentDir.exists()) { parentDir.mkdirs(); } try (FileOutputStream fos = new FileOutputStream(localFile)) { boolean result = ftpClient.retrieveFile(fileName, fos); if (result) { logger.info(\u0026#34;檔案下載成功：{}/{} -\u0026gt; {}\u0026#34;, fullPath, fileName, localFile.getAbsolutePath()); } else { logger.error(\u0026#34;檔案下載失敗：{}/{}\u0026#34;, fullPath, fileName); } return result; } } catch (IOException e) { logger.error(\u0026#34;下載檔案時發生錯誤：{}\u0026#34;, e.getMessage()); return false; } finally { connectionFactory.returnConnection(ftpClient); } } /** * 刪除檔案 * * @param remotePath 遠端路徑 * @param fileName 檔案名稱 * @return 刪除是否成功 */ public boolean deleteFile(String remotePath, String fileName) { FTPClient ftpClient = null; try { ftpClient = connectionFactory.getConnection(); String fullPath = buildFullPath(remotePath); if (!ftpClient.changeWorkingDirectory(fullPath)) { logger.error(\u0026#34;遠端目錄不存在：{}\u0026#34;, fullPath); return false; } boolean result = ftpClient.deleteFile(fileName); if (result) { logger.info(\u0026#34;檔案刪除成功：{}/{}\u0026#34;, fullPath, fileName); } else { logger.error(\u0026#34;檔案刪除失敗：{}/{}\u0026#34;, fullPath, fileName); } return result; } catch (IOException e) { logger.error(\u0026#34;刪除檔案時發生錯誤：{}\u0026#34;, e.getMessage()); return false; } finally { connectionFactory.returnConnection(ftpClient); } } /** * 列出目錄中的檔案 * * @param remotePath 遠端路徑 * @return 檔案列表 */ public List\u0026lt;FtpFileInfo\u0026gt; listFiles(String remotePath) { FTPClient ftpClient = null; List\u0026lt;FtpFileInfo\u0026gt; fileList = new ArrayList\u0026lt;\u0026gt;(); try { ftpClient = connectionFactory.getConnection(); String fullPath = buildFullPath(remotePath); if (!ftpClient.changeWorkingDirectory(fullPath)) { logger.error(\u0026#34;遠端目錄不存在：{}\u0026#34;, fullPath); return fileList; } FTPFile[] ftpFiles = ftpClient.listFiles(); for (FTPFile ftpFile : ftpFiles) { FtpFileInfo fileInfo = new FtpFileInfo(); fileInfo.setName(ftpFile.getName()); fileInfo.setSize(ftpFile.getSize()); fileInfo.setDirectory(ftpFile.isDirectory()); fileInfo.setModifyTime(ftpFile.getTimestamp()); fileList.add(fileInfo); } logger.info(\u0026#34;成功列出目錄 {} 中的 {} 個檔案\u0026#34;, fullPath, fileList.size()); } catch (IOException e) { logger.error(\u0026#34;列出檔案時發生錯誤：{}\u0026#34;, e.getMessage()); } finally { connectionFactory.returnConnection(ftpClient); } return fileList; } /** * 檢查檔案是否存在 * * @param remotePath 遠端路徑 * @param fileName 檔案名稱 * @return 檔案是否存在 */ public boolean fileExists(String remotePath, String fileName) { FTPClient ftpClient = null; try { ftpClient = connectionFactory.getConnection(); String fullPath = buildFullPath(remotePath); if (!ftpClient.changeWorkingDirectory(fullPath)) { return false; } FTPFile[] files = ftpClient.listFiles(fileName); return files != null \u0026amp;\u0026amp; files.length \u0026gt; 0; } catch (IOException e) { logger.error(\u0026#34;檢查檔案存在性時發生錯誤：{}\u0026#34;, e.getMessage()); return false; } finally { connectionFactory.returnConnection(ftpClient); } } /** * 建立完整路徑 */ private String buildFullPath(String remotePath) { String basePath = ftpProperties.getBasePath(); if (!StringUtils.hasText(remotePath)) { return basePath; } // 規範化路徑 String normalizedBasePath = basePath.endsWith(\u0026#34;/\u0026#34;) ? basePath : basePath + \u0026#34;/\u0026#34;; String normalizedRemotePath = remotePath.startsWith(\u0026#34;/\u0026#34;) ? remotePath.substring(1) : remotePath; return normalizedBasePath + normalizedRemotePath; } /** * 遞迴建立目錄 */ private void createDirectoryIfNotExists(FTPClient ftpClient, String path) throws IOException { String[] pathElements = path.split(\u0026#34;/\u0026#34;); StringBuilder currentPath = new StringBuilder(); for (String element : pathElements) { if (StringUtils.hasText(element)) { currentPath.append(\u0026#34;/\u0026#34;).append(element); if (!ftpClient.changeWorkingDirectory(currentPath.toString())) { if (ftpClient.makeDirectory(currentPath.toString())) { logger.debug(\u0026#34;建立目錄：{}\u0026#34;, currentPath.toString()); } else { throw new IOException(\u0026#34;無法建立目錄：\u0026#34; + currentPath.toString()); } } } } } /** * 安靜地關閉資源 */ private void closeQuietly(Closeable closeable) { if (closeable != null) { try { closeable.close(); } catch (IOException e) { // 忽略關閉時的錯誤 } } } } 檔案資訊實體類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.example.util; import java.util.Calendar; public class FtpFileInfo { private String name; private long size; private boolean isDirectory; private Calendar modifyTime; // Getters and Setters public String getName() { return name; } public void setName(String name) { this.name = name; } public long getSize() { return size; } public void setSize(long size) { this.size = size; } public boolean isDirectory() { return isDirectory; } public void setDirectory(boolean directory) { isDirectory = directory; } public Calendar getModifyTime() { return modifyTime; } public void setModifyTime(Calendar modifyTime) { this.modifyTime = modifyTime; } @Override public String toString() { return String.format(\u0026#34;FtpFileInfo{name=\u0026#39;%s\u0026#39;, size=%d, isDirectory=%s}\u0026#34;, name, size, isDirectory); } } 使用範例 基本使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @Service public class FileService { @Autowired private FtpUtil ftpUtil; /** * 上傳使用者頭像 */ public boolean uploadAvatar(MultipartFile file, String userId) { try { String remotePath = \u0026#34;avatars/\u0026#34; + userId; String fileName = generateFileName(file.getOriginalFilename()); return ftpUtil.uploadFile(file.getInputStream(), remotePath, fileName); } catch (IOException e) { logger.error(\u0026#34;上傳頭像失敗：{}\u0026#34;, e.getMessage()); return false; } } /** * 批量上傳檔案 */ public List\u0026lt;String\u0026gt; batchUpload(List\u0026lt;MultipartFile\u0026gt; files, String category) { List\u0026lt;String\u0026gt; successFiles = new ArrayList\u0026lt;\u0026gt;(); String remotePath = \u0026#34;uploads/\u0026#34; + category + \u0026#34;/\u0026#34; + getCurrentDate(); for (MultipartFile file : files) { try { String fileName = generateFileName(file.getOriginalFilename()); if (ftpUtil.uploadFile(file.getInputStream(), remotePath, fileName)) { successFiles.add(fileName); } } catch (IOException e) { logger.error(\u0026#34;批量上傳檔案失敗：{}\u0026#34;, file.getOriginalFilename()); } } return successFiles; } private String generateFileName(String originalName) { String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\u0026#34;yyyyMMddHHmmss\u0026#34;)); String extension = originalName.substring(originalName.lastIndexOf(\u0026#34;.\u0026#34;)); return timestamp + \u0026#34;_\u0026#34; + UUID.randomUUID().toString().substring(0, 8) + extension; } private String getCurrentDate() { return LocalDateTime.now().format(DateTimeFormatter.ofPattern(\u0026#34;yyyy/MM/dd\u0026#34;)); } } 進階功能：檔案同步 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @Component public class FtpSyncService { @Autowired private FtpUtil ftpUtil; /** * 同步本地目錄到 FTP */ public void syncDirectoryToFtp(String localDirPath, String remotePath) { File localDir = new File(localDirPath); if (!localDir.exists() || !localDir.isDirectory()) { logger.error(\u0026#34;本地目錄不存在：{}\u0026#34;, localDirPath); return; } syncDirectoryRecursive(localDir, remotePath); } private void syncDirectoryRecursive(File localDir, String remotePath) { File[] files = localDir.listFiles(); if (files == null) return; for (File file : files) { if (file.isDirectory()) { // 遞迴處理子目錄 String subRemotePath = remotePath + \u0026#34;/\u0026#34; + file.getName(); syncDirectoryRecursive(file, subRemotePath); } else { // 上傳檔案 if (!ftpUtil.fileExists(remotePath, file.getName())) { ftpUtil.uploadFile(file, remotePath); logger.info(\u0026#34;同步檔案：{} -\u0026gt; {}/{}\u0026#34;, file.getAbsolutePath(), remotePath, file.getName()); } } } } } 安全最佳實踐 1. 配置安全 1 2 3 4 5 # 使用環境變數或加密配置 ftp: host: ${FTP_HOST} username: ${FTP_USERNAME} password: ${FTP_PASSWORD:#{null}} # 可以為空，使用 SSH Key 2. 檔案驗證 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class FileValidator { private static final List\u0026lt;String\u0026gt; ALLOWED_EXTENSIONS = Arrays.asList(\u0026#34;.jpg\u0026#34;, \u0026#34;.png\u0026#34;, \u0026#34;.pdf\u0026#34;, \u0026#34;.doc\u0026#34;, \u0026#34;.docx\u0026#34;, \u0026#34;.xls\u0026#34;, \u0026#34;.xlsx\u0026#34;); private static final long MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB public boolean isValidFile(MultipartFile file) { // 檢查檔案大小 if (file.getSize() \u0026gt; MAX_FILE_SIZE) { return false; } // 檢查檔案副檔名 String fileName = file.getOriginalFilename(); if (fileName == null) return false; String extension = fileName.substring(fileName.lastIndexOf(\u0026#34;.\u0026#34;)).toLowerCase(); return ALLOWED_EXTENSIONS.contains(extension); } } 3. 存取控制 1 2 3 4 5 6 7 8 9 10 11 12 @Component public class FtpAccessControl { /** * 檢查使用者是否有權限存取指定路徑 */ public boolean hasAccess(String userId, String remotePath) { // 實作存取控制邏輯 // 例如：使用者只能存取自己的目錄 return remotePath.startsWith(\u0026#34;users/\u0026#34; + userId + \u0026#34;/\u0026#34;); } } 監控與維護 健康檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class FtpHealthIndicator implements HealthIndicator { @Autowired private FtpConnectionFactory connectionFactory; @Override public Health health() { try { FTPClient ftpClient = connectionFactory.getConnection(); boolean isConnected = ftpClient.isConnected(); connectionFactory.returnConnection(ftpClient); return isConnected ? Health.up().withDetail(\u0026#34;status\u0026#34;, \u0026#34;FTP connection available\u0026#34;).build() : Health.down().withDetail(\u0026#34;status\u0026#34;, \u0026#34;FTP connection failed\u0026#34;).build(); } catch (Exception e) { return Health.down().withDetail(\u0026#34;error\u0026#34;, e.getMessage()).build(); } } } 效能監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Aspect @Component public class FtpPerformanceAspect { private static final Logger logger = LoggerFactory.getLogger(FtpPerformanceAspect.class); @Around(\u0026#34;execution(* com.example.util.FtpUtil.*(..))\u0026#34;) public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable { long startTime = System.currentTimeMillis(); try { Object result = joinPoint.proceed(); long endTime = System.currentTimeMillis(); logger.info(\u0026#34;FTP 操作 {} 執行時間：{}ms\u0026#34;, joinPoint.getSignature().getName(), endTime - startTime); return result; } catch (Exception e) { long endTime = System.currentTimeMillis(); logger.error(\u0026#34;FTP 操作 {} 失敗，執行時間：{}ms，錯誤：{}\u0026#34;, joinPoint.getSignature().getName(), endTime - startTime, e.getMessage()); throw e; } } } 常見問題與解決方案 1. 連線逾時問題 1 2 3 4 5 // 增加重試機制 @Retryable(value = {IOException.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000)) public boolean uploadFileWithRetry(InputStream inputStream, String remotePath, String fileName) { return uploadFile(inputStream, remotePath, fileName); } 2. 中文檔名問題 1 2 3 4 5 // 在 FTP 配置中設定正確的編碼 ftpClient.setControlEncoding(\u0026#34;UTF-8\u0026#34;); // 或者對檔名進行編碼處理 String encodedFileName = new String(fileName.getBytes(\u0026#34;UTF-8\u0026#34;), \u0026#34;ISO-8859-1\u0026#34;); 3. 防火牆問題 1 2 3 # 使用被動模式避免防火牆問題 ftp: passive-mode: true 測試範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @SpringBootTest class FtpUtilTest { @Autowired private FtpUtil ftpUtil; @Test void testUploadFile() { // 建立測試檔案 File testFile = createTestFile(); // 執行上傳 boolean result = ftpUtil.uploadFile(testFile, \u0026#34;test\u0026#34;, \u0026#34;test.txt\u0026#34;); // 驗證結果 assertTrue(result); assertTrue(ftpUtil.fileExists(\u0026#34;test\u0026#34;, \u0026#34;test.txt\u0026#34;)); // 清理 ftpUtil.deleteFile(\u0026#34;test\u0026#34;, \u0026#34;test.txt\u0026#34;); } private File createTestFile() { try { File tempFile = File.createTempFile(\u0026#34;test\u0026#34;, \u0026#34;.txt\u0026#34;); Files.write(tempFile.toPath(), \u0026#34;測試內容\u0026#34;.getBytes()); return tempFile; } catch (IOException e) { throw new RuntimeException(e); } } } 總結 本文提供的 FTP 工具類具備以下優勢：\n安全性：配置外部化，避免硬編碼敏感資訊 可靠性：完整的錯誤處理和重試機制 效能：連線池管理，支援併發操作 可維護性：模組化設計，易於擴展和維護 生產就緒：包含監控、日誌和健康檢查 在實際使用時，請根據具體需求調整配置參數和安全設定，確保符合您的業務場景和安全要求。\n參考資料 Apache Commons Net 官方文檔 Spring Boot Configuration Properties FTP RFC 959 協定規範 Java FTP 最佳實踐 ","permalink":"https://xinqilin.github.io/post/backend/ftputil/","tags":["Java","FTP","FileTransfer","Spring","Commons-Net","Security"],"title":"FTP 工具類實作指南：安全、可靠的檔案傳輸解決方案"},{"content":"概述 在企業級應用程式開發中，Enum（列舉）是表示有限狀態集合的理想選擇，如訂單狀態、使用者角色、審核狀態等。本文深入探討如何在 JPA/Hibernate 中有效處理 Enum 型別，包含各種映射策略、效能考量和實際應用場景。\n基本 Enum 映射 1. @Enumerated 註解 JPA 提供 @Enumerated 註解來處理 Enum 映射，支援兩種策略：\nEnumType.ORDINAL（數字映射） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 定義狀態列舉 public enum OrderStatus { PENDING, // 0 CONFIRMED, // 1 SHIPPED, // 2 DELIVERED, // 3 CANCELLED // 4 } // 實體類使用 @Entity @Table(name = \u0026#34;orders\u0026#34;) public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Enumerated(EnumType.ORDINAL) @Column(name = \u0026#34;status\u0026#34;, nullable = false) private OrderStatus status = OrderStatus.PENDING; // 其他屬性... } 資料庫儲存：\n1 2 3 4 5 6 7 CREATE TABLE orders ( id BIGINT PRIMARY KEY AUTO_INCREMENT, status TINYINT NOT NULL DEFAULT 0, -- 其他欄位 ); -- 儲存的值：0=PENDING, 1=CONFIRMED, 2=SHIPPED, 3=DELIVERED, 4=CANCELLED EnumType.STRING（字串映射） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Entity @Table(name = \u0026#34;orders\u0026#34;) public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Enumerated(EnumType.STRING) @Column(name = \u0026#34;status\u0026#34;, length = 20, nullable = false) private OrderStatus status = OrderStatus.PENDING; // 其他屬性... } 資料庫儲存：\n1 2 3 4 5 6 7 CREATE TABLE orders ( id BIGINT PRIMARY KEY AUTO_INCREMENT, status VARCHAR(20) NOT NULL DEFAULT \u0026#39;PENDING\u0026#39;, -- 其他欄位 ); -- 儲存的值：\u0026#39;PENDING\u0026#39;, \u0026#39;CONFIRMED\u0026#39;, \u0026#39;SHIPPED\u0026#39;, \u0026#39;DELIVERED\u0026#39;, \u0026#39;CANCELLED\u0026#39; 2. 映射策略比較 特性 ORDINAL STRING 儲存空間 小（1-4 bytes） 大（字串長度） 可讀性 差（數字） 好（文字） 順序變更風險 高（破壞性） 無 新增項目 只能追加 任意位置 資料庫查詢 快速 較慢 除錯友善 困難 容易 建議：生產環境通常使用 EnumType.STRING，因為其具備更好的可維護性和可讀性。\n進階 Enum 處理 1. 自訂 Enum 值 當需要更具語意的資料庫值時，可以為 Enum 添加自訂屬性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public enum OrderStatus { PENDING(\u0026#34;PND\u0026#34;, \u0026#34;訂單待處理\u0026#34;), CONFIRMED(\u0026#34;CNF\u0026#34;, \u0026#34;訂單已確認\u0026#34;), SHIPPED(\u0026#34;SHP\u0026#34;, \u0026#34;商品已出貨\u0026#34;), DELIVERED(\u0026#34;DLV\u0026#34;, \u0026#34;商品已送達\u0026#34;), CANCELLED(\u0026#34;CXL\u0026#34;, \u0026#34;訂單已取消\u0026#34;); private final String code; private final String description; OrderStatus(String code, String description) { this.code = code; this.description = description; } public String getCode() { return code; } public String getDescription() { return description; } // 從代碼查找 Enum public static OrderStatus fromCode(String code) { return Arrays.stream(values()) .filter(status -\u0026gt; status.code.equals(code)) .findFirst() .orElseThrow(() -\u0026gt; new IllegalArgumentException(\u0026#34;未知的訂單狀態代碼: \u0026#34; + code)); } // 取得所有代碼 public static List\u0026lt;String\u0026gt; getAllCodes() { return Arrays.stream(values()) .map(OrderStatus::getCode) .collect(Collectors.toList()); } } 2. 自訂 AttributeConverter 使用 JPA 2.1 的 @Converter 註解來實現自訂轉換：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Converter(autoApply = true) public class OrderStatusConverter implements AttributeConverter\u0026lt;OrderStatus, String\u0026gt; { @Override public String convertToDatabaseColumn(OrderStatus orderStatus) { if (orderStatus == null) { return null; } return orderStatus.getCode(); } @Override public OrderStatus convertToEntityAttribute(String code) { if (code == null || code.isEmpty()) { return null; } return OrderStatus.fromCode(code); } } 實體類使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Entity @Table(name = \u0026#34;orders\u0026#34;) public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Convert(converter = OrderStatusConverter.class) @Column(name = \u0026#34;status\u0026#34;, length = 3, nullable = false) private OrderStatus status = OrderStatus.PENDING; // 其他屬性... } 資料庫儲存結果：\n1 2 -- 儲存的值：\u0026#39;PND\u0026#39;, \u0026#39;CNF\u0026#39;, \u0026#39;SHP\u0026#39;, \u0026#39;DLV\u0026#39;, \u0026#39;CXL\u0026#39; INSERT INTO orders (status) VALUES (\u0026#39;PND\u0026#39;); 3. 通用 Enum 轉換器 建立通用的 Enum 轉換器基類：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public interface CodedEnum { String getCode(); static \u0026lt;T extends Enum\u0026lt;T\u0026gt; \u0026amp; CodedEnum\u0026gt; T fromCode(Class\u0026lt;T\u0026gt; enumClass, String code) { return Arrays.stream(enumClass.getEnumConstants()) .filter(e -\u0026gt; e.getCode().equals(code)) .findFirst() .orElseThrow(() -\u0026gt; new IllegalArgumentException( \u0026#34;未知的 \u0026#34; + enumClass.getSimpleName() + \u0026#34; 代碼: \u0026#34; + code)); } } // 通用轉換器基類 public abstract class CodedEnumConverter\u0026lt;T extends Enum\u0026lt;T\u0026gt; \u0026amp; CodedEnum\u0026gt; implements AttributeConverter\u0026lt;T, String\u0026gt; { private final Class\u0026lt;T\u0026gt; enumClass; protected CodedEnumConverter(Class\u0026lt;T\u0026gt; enumClass) { this.enumClass = enumClass; } @Override public String convertToDatabaseColumn(T attribute) { return attribute != null ? attribute.getCode() : null; } @Override public T convertToEntityAttribute(String dbData) { return dbData != null ? CodedEnum.fromCode(enumClass, dbData) : null; } } 具體實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 實作 CodedEnum 介面 public enum Priority implements CodedEnum { LOW(\u0026#34;L\u0026#34;), MEDIUM(\u0026#34;M\u0026#34;), HIGH(\u0026#34;H\u0026#34;), URGENT(\u0026#34;U\u0026#34;); private final String code; Priority(String code) { this.code = code; } @Override public String getCode() { return code; } } // 具體轉換器 @Converter(autoApply = true) public class PriorityConverter extends CodedEnumConverter\u0026lt;Priority\u0026gt; { public PriorityConverter() { super(Priority.class); } } 複雜應用場景 1. 多狀態 Enum 設計 設計包含狀態轉換邏輯的 Enum：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public enum OrderStatus implements CodedEnum { DRAFT(\u0026#34;DFT\u0026#34;, \u0026#34;草稿\u0026#34;, Set.of()), PENDING(\u0026#34;PND\u0026#34;, \u0026#34;待處理\u0026#34;, Set.of(DRAFT)), CONFIRMED(\u0026#34;CNF\u0026#34;, \u0026#34;已確認\u0026#34;, Set.of(PENDING)), PAID(\u0026#34;PAD\u0026#34;, \u0026#34;已付款\u0026#34;, Set.of(CONFIRMED)), SHIPPED(\u0026#34;SHP\u0026#34;, \u0026#34;已出貨\u0026#34;, Set.of(PAID)), DELIVERED(\u0026#34;DLV\u0026#34;, \u0026#34;已送達\u0026#34;, Set.of(SHIPPED)), CANCELLED(\u0026#34;CXL\u0026#34;, \u0026#34;已取消\u0026#34;, Set.of(DRAFT, PENDING, CONFIRMED, PAID)), REFUNDED(\u0026#34;RFD\u0026#34;, \u0026#34;已退款\u0026#34;, Set.of(PAID, SHIPPED, DELIVERED)); private final String code; private final String description; private final Set\u0026lt;OrderStatus\u0026gt; allowedPreviousStatuses; OrderStatus(String code, String description, Set\u0026lt;OrderStatus\u0026gt; allowedPreviousStatuses) { this.code = code; this.description = description; this.allowedPreviousStatuses = allowedPreviousStatuses; } @Override public String getCode() { return code; } public String getDescription() { return description; } // 檢查狀態轉換是否合法 public boolean canTransitionFrom(OrderStatus currentStatus) { return allowedPreviousStatuses.contains(currentStatus); } // 取得可轉換到的狀態 public Set\u0026lt;OrderStatus\u0026gt; getNextPossibleStatuses() { return Arrays.stream(values()) .filter(status -\u0026gt; status.canTransitionFrom(this)) .collect(Collectors.toSet()); } // 檢查是否為終結狀態 public boolean isFinalStatus() { return this == DELIVERED || this == CANCELLED || this == REFUNDED; } // 檢查是否可取消 public boolean isCancellable() { return CANCELLED.canTransitionFrom(this); } } 2. 業務邏輯整合 在 Service 層中整合狀態轉換邏輯：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @Service @Transactional public class OrderService { @Autowired private OrderRepository orderRepository; @Autowired private OrderStatusHistoryService statusHistoryService; public void updateOrderStatus(Long orderId, OrderStatus newStatus, String reason) { Order order = orderRepository.findById(orderId) .orElseThrow(() -\u0026gt; new EntityNotFoundException(\u0026#34;訂單不存在: \u0026#34; + orderId)); OrderStatus currentStatus = order.getStatus(); // 驗證狀態轉換 if (!newStatus.canTransitionFrom(currentStatus)) { throw new IllegalStateException(String.format( \u0026#34;無法從 %s 轉換到 %s\u0026#34;, currentStatus.getDescription(), newStatus.getDescription() )); } // 更新狀態 order.setStatus(newStatus); order.setLastModified(LocalDateTime.now()); // 記錄狀態變更歷史 statusHistoryService.recordStatusChange(orderId, currentStatus, newStatus, reason); // 觸發相關業務邏輯 handleStatusChange(order, currentStatus, newStatus); orderRepository.save(order); } private void handleStatusChange(Order order, OrderStatus from, OrderStatus to) { switch (to) { case CONFIRMED: // 發送確認郵件 emailService.sendOrderConfirmation(order); break; case SHIPPED: // 發送出貨通知 emailService.sendShippingNotification(order); // 減少庫存 inventoryService.decreaseStock(order.getItems()); break; case DELIVERED: // 發送送達通知 emailService.sendDeliveryNotification(order); break; case CANCELLED: // 恢復庫存 inventoryService.restoreStock(order.getItems()); // 處理退款 if (from == OrderStatus.PAID) { paymentService.processRefund(order); } break; } } // 批量狀態查詢 public List\u0026lt;Order\u0026gt; findOrdersByStatuses(Set\u0026lt;OrderStatus\u0026gt; statuses) { return orderRepository.findByStatusIn(statuses); } // 取得可操作的訂單 public List\u0026lt;Order\u0026gt; findOrdersReadyForShipping() { return orderRepository.findByStatus(OrderStatus.PAID); } } 3. 狀態歷史追蹤 建立狀態變更歷史表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Entity @Table(name = \u0026#34;order_status_history\u0026#34;) public class OrderStatusHistory { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = \u0026#34;order_id\u0026#34;, nullable = false) private Long orderId; @Convert(converter = OrderStatusConverter.class) @Column(name = \u0026#34;from_status\u0026#34;, length = 3) private OrderStatus fromStatus; @Convert(converter = OrderStatusConverter.class) @Column(name = \u0026#34;to_status\u0026#34;, length = 3, nullable = false) private OrderStatus toStatus; @Column(name = \u0026#34;reason\u0026#34;, length = 500) private String reason; @Column(name = \u0026#34;changed_by\u0026#34;) private String changedBy; @Column(name = \u0026#34;changed_at\u0026#34;, nullable = false) private LocalDateTime changedAt; // 建構子、Getter、Setter... } 4. Repository 查詢方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Repository public interface OrderRepository extends JpaRepository\u0026lt;Order, Long\u0026gt; { // 基本狀態查詢 List\u0026lt;Order\u0026gt; findByStatus(OrderStatus status); List\u0026lt;Order\u0026gt; findByStatusIn(Collection\u0026lt;OrderStatus\u0026gt; statuses); List\u0026lt;Order\u0026gt; findByStatusNot(OrderStatus status); // 複合查詢 List\u0026lt;Order\u0026gt; findByStatusAndCreatedAtBetween( OrderStatus status, LocalDateTime start, LocalDateTime end ); // 統計查詢 @Query(\u0026#34;SELECT o.status, COUNT(o) FROM Order o GROUP BY o.status\u0026#34;) List\u0026lt;Object[]\u0026gt; countOrdersByStatus(); // 自訂查詢 @Query(\u0026#34;SELECT o FROM Order o WHERE o.status IN :statuses AND o.totalAmount \u0026gt; :minAmount\u0026#34;) List\u0026lt;Order\u0026gt; findHighValueOrdersByStatuses( @Param(\u0026#34;statuses\u0026#34;) Collection\u0026lt;OrderStatus\u0026gt; statuses, @Param(\u0026#34;minAmount\u0026#34;) BigDecimal minAmount ); // 原生 SQL 查詢 @Query(value = \u0026#34;SELECT * FROM orders WHERE status IN :statusCodes AND DATE(created_at) = CURDATE()\u0026#34;, nativeQuery = true) List\u0026lt;Order\u0026gt; findTodayOrdersByStatusCodes(@Param(\u0026#34;statusCodes\u0026#34;) Collection\u0026lt;String\u0026gt; statusCodes); } 效能優化 1. 索引設計 1 2 3 4 5 6 7 8 9 -- 狀態欄位索引 CREATE INDEX idx_orders_status ON orders(status); -- 複合索引 CREATE INDEX idx_orders_status_created ON orders(status, created_at); -- 部分索引（針對特定狀態） CREATE INDEX idx_orders_active_status ON orders(status) WHERE status IN (\u0026#39;PND\u0026#39;, \u0026#39;CNF\u0026#39;, \u0026#39;PAD\u0026#39;, \u0026#39;SHP\u0026#39;); 2. 查詢優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Service public class OrderQueryService { // 使用 Specification 進行動態查詢 public Page\u0026lt;Order\u0026gt; findOrdersWithCriteria(OrderSearchCriteria criteria, Pageable pageable) { return orderRepository.findAll(Specification .where(hasStatus(criteria.getStatuses())) .and(createdBetween(criteria.getStartDate(), criteria.getEndDate())) .and(hasCustomer(criteria.getCustomerId())), pageable); } private static Specification\u0026lt;Order\u0026gt; hasStatus(Set\u0026lt;OrderStatus\u0026gt; statuses) { return (root, query, cb) -\u0026gt; statuses == null || statuses.isEmpty() ? cb.conjunction() : root.get(\u0026#34;status\u0026#34;).in(statuses); } // 快取常用統計 @Cacheable(\u0026#34;orderStatusStats\u0026#34;) public Map\u0026lt;OrderStatus, Long\u0026gt; getOrderStatusStatistics() { List\u0026lt;Object[]\u0026gt; results = orderRepository.countOrdersByStatus(); return results.stream() .collect(Collectors.toMap( row -\u0026gt; (OrderStatus) row[0], row -\u0026gt; (Long) row[1] )); } } 3. 快取策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Service public class OrderStatusCacheService { private final Cache\u0026lt;String, List\u0026lt;Order\u0026gt;\u0026gt; orderCache; public OrderStatusCacheService() { this.orderCache = Caffeine.newBuilder() .maximumSize(1000) .expireAfterWrite(Duration.ofMinutes(5)) .build(); } public List\u0026lt;Order\u0026gt; getCachedOrdersByStatus(OrderStatus status) { return orderCache.get(status.getCode(), code -\u0026gt; orderRepository.findByStatus(status)); } @EventListener public void handleOrderStatusChanged(OrderStatusChangedEvent event) { // 清除相關快取 orderCache.invalidate(event.getOldStatus().getCode()); orderCache.invalidate(event.getNewStatus().getCode()); } } 測試策略 1. 單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @ExtendWith(MockitoExtension.class) class OrderServiceTest { @Mock private OrderRepository orderRepository; @Mock private OrderStatusHistoryService statusHistoryService; @InjectMocks private OrderService orderService; @Test void testValidStatusTransition() { // Given Order order = createOrderWithStatus(OrderStatus.PENDING); when(orderRepository.findById(1L)).thenReturn(Optional.of(order)); // When orderService.updateOrderStatus(1L, OrderStatus.CONFIRMED, \u0026#34;客戶確認\u0026#34;); // Then assertEquals(OrderStatus.CONFIRMED, order.getStatus()); verify(statusHistoryService).recordStatusChange( eq(1L), eq(OrderStatus.PENDING), eq(OrderStatus.CONFIRMED), eq(\u0026#34;客戶確認\u0026#34;)); } @Test void testInvalidStatusTransition() { // Given Order order = createOrderWithStatus(OrderStatus.DELIVERED); when(orderRepository.findById(1L)).thenReturn(Optional.of(order)); // When \u0026amp; Then assertThatThrownBy(() -\u0026gt; orderService.updateOrderStatus(1L, OrderStatus.PENDING, \u0026#34;無效轉換\u0026#34;)) .isInstanceOf(IllegalStateException.class) .hasMessageContaining(\u0026#34;無法從\u0026#34;); } @Test void testOrderStatusEnumProperties() { // 測試狀態轉換邏輯 assertTrue(OrderStatus.CONFIRMED.canTransitionFrom(OrderStatus.PENDING)); assertFalse(OrderStatus.PENDING.canTransitionFrom(OrderStatus.DELIVERED)); // 測試終結狀態 assertTrue(OrderStatus.DELIVERED.isFinalStatus()); assertFalse(OrderStatus.PENDING.isFinalStatus()); // 測試可取消狀態 assertTrue(OrderStatus.PENDING.isCancellable()); assertFalse(OrderStatus.DELIVERED.isCancellable()); } } 2. 整合測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @SpringBootTest @TestPropertySource(properties = \u0026#34;spring.jpa.hibernate.ddl-auto=create-drop\u0026#34;) class OrderStatusIntegrationTest { @Autowired private OrderService orderService; @Autowired private OrderRepository orderRepository; @Test @Transactional void testCompleteOrderWorkflow() { // 建立訂單 Order order = createTestOrder(); order = orderRepository.save(order); // 確認訂單 orderService.updateOrderStatus(order.getId(), OrderStatus.CONFIRMED, \u0026#34;自動確認\u0026#34;); // 付款 orderService.updateOrderStatus(order.getId(), OrderStatus.PAID, \u0026#34;信用卡付款\u0026#34;); // 出貨 orderService.updateOrderStatus(order.getId(), OrderStatus.SHIPPED, \u0026#34;物流出貨\u0026#34;); // 送達 orderService.updateOrderStatus(order.getId(), OrderStatus.DELIVERED, \u0026#34;客戶簽收\u0026#34;); // 驗證最終狀態 Order finalOrder = orderRepository.findById(order.getId()).orElseThrow(); assertEquals(OrderStatus.DELIVERED, finalOrder.getStatus()); } @Test void testDatabaseEnumPersistence() { // 測試 Enum 值正確儲存和讀取 Order order = createTestOrder(); order.setStatus(OrderStatus.CONFIRMED); order = orderRepository.save(order); // 清除 JPA 快取 orderRepository.flush(); entityManager.clear(); // 重新讀取 Order reloadedOrder = orderRepository.findById(order.getId()).orElseThrow(); assertEquals(OrderStatus.CONFIRMED, reloadedOrder.getStatus()); } } 最佳實踐與建議 1. 設計原則 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // ✅ 好的實踐：使用有意義的名稱和描述 public enum UserRole implements CodedEnum { ADMIN(\u0026#34;ADM\u0026#34;, \u0026#34;系統管理員\u0026#34;, Set.of(\u0026#34;*\u0026#34;)), MANAGER(\u0026#34;MGR\u0026#34;, \u0026#34;部門主管\u0026#34;, Set.of(\u0026#34;USER_MANAGE\u0026#34;, \u0026#34;REPORT_VIEW\u0026#34;)), USER(\u0026#34;USR\u0026#34;, \u0026#34;一般使用者\u0026#34;, Set.of(\u0026#34;PROFILE_EDIT\u0026#34;)); private final String code; private final String description; private final Set\u0026lt;String\u0026gt; permissions; // 建構子和方法... } // ❌ 避免：過於簡單或不清楚的列舉 public enum Status { A, B, C, D // 不清楚的含義 } 2. 版本管理策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 支援向後相容的 Enum 設計 public enum OrderStatus implements CodedEnum { // 新版本可以安全添加新狀態 PENDING(\u0026#34;PND\u0026#34;, \u0026#34;待處理\u0026#34;), CONFIRMED(\u0026#34;CNF\u0026#34;, \u0026#34;已確認\u0026#34;), SHIPPED(\u0026#34;SHP\u0026#34;, \u0026#34;已出貨\u0026#34;), DELIVERED(\u0026#34;DLV\u0026#34;, \u0026#34;已送達\u0026#34;), CANCELLED(\u0026#34;CXL\u0026#34;, \u0026#34;已取消\u0026#34;), // 新增狀態（向後相容） PARTIAL_SHIPPED(\u0026#34;PSH\u0026#34;, \u0026#34;部分出貨\u0026#34;), // v2.0 新增 RETURNED(\u0026#34;RET\u0026#34;, \u0026#34;已退貨\u0026#34;); // v2.1 新增 // 處理未知狀態的安全機制 public static OrderStatus fromCodeSafely(String code, OrderStatus defaultValue) { try { return fromCode(code); } catch (IllegalArgumentException e) { logger.warn(\u0026#34;遇到未知的訂單狀態代碼: {}, 使用預設值: {}\u0026#34;, code, defaultValue); return defaultValue; } } } 3. 國際化支援 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Component public class OrderStatusI18nService { @Autowired private MessageSource messageSource; public String getLocalizedDescription(OrderStatus status, Locale locale) { String key = \u0026#34;order.status.\u0026#34; + status.name().toLowerCase(); return messageSource.getMessage(key, null, status.getDescription(), locale); } public Map\u0026lt;OrderStatus, String\u0026gt; getAllLocalizedStatuses(Locale locale) { return Arrays.stream(OrderStatus.values()) .collect(Collectors.toMap( status -\u0026gt; status, status -\u0026gt; getLocalizedDescription(status, locale) )); } } 監控與維護 1. 狀態分佈監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Component public class OrderStatusMetrics { private final MeterRegistry meterRegistry; private final OrderRepository orderRepository; public OrderStatusMetrics(MeterRegistry meterRegistry, OrderRepository orderRepository) { this.meterRegistry = meterRegistry; this.orderRepository = orderRepository; // 註冊度量 Gauge.builder(\u0026#34;orders.by.status\u0026#34;) .description(\u0026#34;訂單狀態分佈\u0026#34;) .tag(\u0026#34;status\u0026#34;, \u0026#34;all\u0026#34;) .register(meterRegistry, this, OrderStatusMetrics::getTotalOrderCount); } @EventListener public void handleOrderStatusChanged(OrderStatusChangedEvent event) { // 記錄狀態轉換次數 Counter.builder(\u0026#34;order.status.transitions\u0026#34;) .description(\u0026#34;訂單狀態轉換次數\u0026#34;) .tag(\u0026#34;from\u0026#34;, event.getOldStatus().getCode()) .tag(\u0026#34;to\u0026#34;, event.getNewStatus().getCode()) .register(meterRegistry) .increment(); } private double getTotalOrderCount() { return orderRepository.count(); } } 2. 效能監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Aspect @Component public class OrderStatusPerformanceAspect { @Around(\u0026#34;execution(* com.example.service.OrderService.updateOrderStatus(..))\u0026#34;) public Object measureStatusUpdate(ProceedingJoinPoint joinPoint) throws Throwable { Timer.Sample sample = Timer.start(meterRegistry); try { return joinPoint.proceed(); } finally { sample.stop(Timer.builder(\u0026#34;order.status.update.duration\u0026#34;) .description(\u0026#34;訂單狀態更新耗時\u0026#34;) .register(meterRegistry)); } } } 總結 JPA 中的 Enum 處理是企業級應用程式開發的重要技能。透過本文的深入探討，我們了解到：\n核心要點 選擇適當的映射策略：生產環境建議使用 EnumType.STRING 或自訂轉換器 設計可擴展的 Enum：考慮未來需求，支援狀態轉換邏輯 效能優化：合理使用索引、快取和查詢優化 測試完整性：涵蓋狀態轉換邏輯和持久化測試 監控維護：建立適當的監控機制 實際應用建議 對於簡單狀態，使用基本的 @Enumerated(EnumType.STRING) 對於複雜業務邏輯，實作 CodedEnum 介面和自訂轉換器 建立狀態轉換規則和歷史追蹤機制 考慮國際化和向後相容性 實施適當的監控和效能優化策略 正確處理 Enum 型別不僅能提升程式碼的可讀性和維護性，還能確保資料的一致性和業務邏輯的正確執行。\n參考資料 JPA 2.2 Specification Hibernate ORM Documentation Spring Data JPA Reference Java Enum Best Practices Database Design Patterns ","permalink":"https://xinqilin.github.io/post/backend/ormenumtype/","tags":["Java","JPA","Hibernate","Enum","ORM","Database","Spring","MySQL"],"title":"JPA Enum 型別處理完整指南：映射策略與最佳實踐"},{"content":"概述 xargs（eXtended ARGuments）是 Unix/Linux 系統中的強大工具，用於從標準輸入讀取資料並將其作為參數傳遞給其他命令。它解決了命令行參數長度限制的問題，並提供了並行處理能力，是管道操作和批次處理的重要工具。\n核心特徵 參數轉換：將輸入流轉換為命令參數 批次處理：支援分批執行大量操作 並行執行：可同時執行多個程序提升效率 安全處理：正確處理包含空格的檔案名稱 靈活控制：豐富的選項控制執行行為 基本語法 1 xargs [選項] [命令 [初始參數]] 工作原理 1 2 3 4 5 # 基本概念 command1 | xargs command2 # 等同於 command2 arg1 arg2 arg3 ... 簡單範例 1 2 3 4 5 6 7 8 9 10 11 # 預設行為（使用 echo） echo \u0026#34;a b c d\u0026#34; | xargs # 輸出: a b c d # 指定命令 echo \u0026#34;file1 file2 file3\u0026#34; | xargs ls -l # 從檔案讀取 cat filelist.txt | xargs rm -f # 與 find 組合 find . -name \u0026#34;*.tmp\u0026#34; | xargs rm -f 核心選項詳解 基本控制選項 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # -t (--verbose) - 顯示執行的命令 echo \u0026#34;a b c\u0026#34; | xargs -t rm # 輸出: rm a b c # 然後執行 rm a b c # -p (--interactive) - 交互式確認 echo \u0026#34;file1 file2\u0026#34; | xargs -p rm # 輸出: rm file1 file2?... # 等待使用者輸入 y/n # -r (--no-run-if-empty) - 空輸入時不執行 echo \u0026#34;\u0026#34; | xargs -r echo \u0026#34;執行了\u0026#34; # 不會執行 echo \u0026#34;\u0026#34; | xargs echo \u0026#34;執行了\u0026#34; # 會執行 # --help - 顯示幫助資訊 xargs --help 參數分組選項 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # -n max-args - 限制每次執行的參數數量 echo \u0026#34;1 2 3 4 5 6\u0026#34; | xargs -n 2 echo # 輸出: # 1 2 # 3 4 # 5 6 # -L max-lines - 限制每次處理的行數 printf \u0026#34;a\\nb\\nc\\nd\\n\u0026#34; | xargs -L 2 echo # 輸出: # a b # c d # -s max-chars - 限制命令行長度 echo \u0026#34;very long arguments here\u0026#34; | xargs -s 20 echo 分隔符處理 1 2 3 4 5 6 7 8 9 # -d delimiter - 自訂分隔符 echo \u0026#34;a,b,c,d\u0026#34; | xargs -d, echo # 輸出: a b c d # -0 (--null) - 使用 null 字元作分隔符 find . -name \u0026#34;*.txt\u0026#34; -print0 | xargs -0 ls -l # 處理包含空格的檔案名 echo -e \u0026#34;file 1.txt\\nfile 2.txt\u0026#34; | xargs -d\u0026#39;\\n\u0026#39; ls -l 替換字串選項 1 2 3 4 5 6 7 8 # -I replace-str - 指定替換字串 echo \u0026#34;file1 file2 file3\u0026#34; | xargs -I {} cp {} {}.backup # -i 或 -I{} - 使用 {} 作為替換字串 ls *.txt | xargs -I{} cp {} backup/{} # 複雜替換範例 find . -name \u0026#34;*.log\u0026#34; | xargs -I{} sh -c \u0026#39;echo \u0026#34;Processing: {}\u0026#34;; gzip {}\u0026#39; 並行處理選項 1 2 3 4 5 6 7 8 9 # -P max-procs - 並行執行 echo \u0026#34;1 2 3 4 5\u0026#34; | xargs -n 1 -P 3 sleep # 同時執行最多 3 個 sleep 命令 # -P 0 - 無限制並行 seq 1 10 | xargs -n 1 -P 0 echo # 實際並行範例 find . -name \u0026#34;*.jpg\u0026#34; | xargs -n 1 -P 4 -I{} convert {} {}.thumb.jpg 實戰應用場景 1. 檔案管理操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 批次刪除檔案 find /tmp -name \u0026#34;*.tmp\u0026#34; -mtime +7 | xargs rm -f # 批次複製檔案 ls *.txt | xargs -I{} cp {} backup/ # 批次移動檔案 find . -name \u0026#34;*.old\u0026#34; | xargs -I{} mv {} archive/ # 批次重命名 ls *.jpeg | xargs -I{} sh -c \u0026#39;mv \u0026#34;$1\u0026#34; \u0026#34;${1%.jpeg}.jpg\u0026#34;\u0026#39; _ {} # 建立多個目錄 echo \u0026#34;dir1 dir2 dir3\u0026#34; | xargs mkdir -p # 修改檔案權限 find /var/www -name \u0026#34;*.php\u0026#34; | xargs chmod 644 find /var/www -type d | xargs chmod 755 # 批次壓縮檔案 find . -name \u0026#34;*.log\u0026#34; -size +100M | xargs -I{} gzip {} 2. 文本處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 批次搜尋文本 find . -name \u0026#34;*.txt\u0026#34; | xargs grep -l \u0026#34;pattern\u0026#34; # 批次替換文本 find . -name \u0026#34;*.conf\u0026#34; | xargs sed -i \u0026#39;s/old/new/g\u0026#39; # 統計行數 find . -name \u0026#34;*.py\u0026#34; | xargs wc -l # 批次編碼轉換 find . -name \u0026#34;*.txt\u0026#34; | xargs -I{} iconv -f gbk -t utf8 {} -o {}.utf8 # 批次格式化程式碼 find . -name \u0026#34;*.js\u0026#34; | xargs prettier --write # 批次檢查語法 find . -name \u0026#34;*.sh\u0026#34; | xargs -I{} bash -n {} 3. 系統管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 批次殺死程序 ps aux | grep \u0026#34;process_name\u0026#34; | awk \u0026#39;{print $2}\u0026#39; | xargs kill # 批次服務重啟 echo \u0026#34;nginx apache2 mysql\u0026#34; | xargs -n 1 systemctl restart # 批次安裝軟體包 cat package_list.txt | xargs apt-get install -y # 磁碟使用統計 find /var/log -name \u0026#34;*.log\u0026#34; | xargs du -sh # 批次下載檔案 cat urls.txt | xargs -n 1 -P 5 wget # 批次備份 echo \u0026#34;/etc /var/log /home\u0026#34; | xargs -I{} tar -czf {//}.tar.gz {} 4. 開發與部署 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 批次編譯 find . -name \u0026#34;*.c\u0026#34; | xargs gcc -o output # 批次測試 find . -name \u0026#34;*_test.py\u0026#34; | xargs -I{} python {} # 批次部署 cat server_list.txt | xargs -I{} scp deploy.sh user@{}:/tmp/ # 批次執行遠程命令 cat servers.txt | xargs -I{} ssh {} \u0026#34;uptime\u0026#34; # 批次 Git 操作 find . -name \u0026#34;.git\u0026#34; -type d | xargs -I{} sh -c \u0026#39;cd {} \u0026amp;\u0026amp; git pull\u0026#39; # 批次建構 Docker 映像 ls */Dockerfile | xargs -I{} sh -c \u0026#39;cd $(dirname {}) \u0026amp;\u0026amp; docker build -t $(basename $(pwd)) .\u0026#39; 5. 監控與日誌 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 批次監控檔案變化 find /var/log -name \u0026#34;*.log\u0026#34; | xargs -I{} tail -f {} # 批次日誌分析 find . -name \u0026#34;access.log*\u0026#34; | xargs zcat | grep \u0026#34;ERROR\u0026#34; # 批次清理日誌 find /var/log -name \u0026#34;*.log\u0026#34; -size +100M | xargs truncate -s 0 # 系統資訊收集 echo \u0026#34;/proc/cpuinfo /proc/meminfo /proc/loadavg\u0026#34; | xargs -I{} sh -c \u0026#39;echo \u0026#34;=== {} ===\u0026#34;; cat {}\u0026#39; # 批次檢查服務狀態 echo \u0026#34;nginx mysql redis\u0026#34; | xargs -I{} systemctl status {} 進階技巧 1. 複雜命令組合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 多命令執行 find . -name \u0026#34;*.log\u0026#34; | xargs -I{} sh -c \u0026#39;echo \u0026#34;Processing {}\u0026#34;; wc -l {}; echo \u0026#34;Done\u0026#34;\u0026#39; # 條件執行 find . -name \u0026#34;*.txt\u0026#34; | xargs -I{} sh -c \u0026#39;if [ -s \u0026#34;{}\u0026#34; ]; then echo \u0026#34;Non-empty: {}\u0026#34;; fi\u0026#39; # 錯誤處理 find . -name \u0026#34;*.sh\u0026#34; | xargs -I{} sh -c \u0026#39;bash -n \u0026#34;{}\u0026#34; || echo \u0026#34;Syntax error in {}\u0026#34;\u0026#39; # 結果收集 find . -name \u0026#34;*.py\u0026#34; | xargs -I{} sh -c \u0026#39;echo \u0026#34;{}: $(wc -l \u0026lt; \u0026#34;{}\u0026#34;)\u0026#34;\u0026#39; | sort -k2 -nr # 管道組合 find . -name \u0026#34;*.log\u0026#34; | xargs -I{} sh -c \u0026#39;cat \u0026#34;{}\u0026#34; | grep ERROR | wc -l\u0026#39; | awk \u0026#39;{sum+=$1} END {print sum}\u0026#39; 2. 並行處理最佳化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # CPU 密集型任務 seq 1 100 | xargs -n 1 -P $(nproc) sh -c \u0026#39;echo \u0026#34;Processing $1\u0026#34;; sleep 1; echo \u0026#34;Done $1\u0026#34;\u0026#39; _ # I/O 密集型任務 cat urls.txt | xargs -n 1 -P 10 -I{} sh -c \u0026#39;echo \u0026#34;Downloading {}\u0026#34;; wget -q {}\u0026#39; # 記憶體管理 find . -name \u0026#34;*.big\u0026#34; | xargs -n 1 -P 2 -I{} process_large_file {} # 並行日誌處理 find /var/log -name \u0026#34;*.log\u0026#34; | xargs -n 1 -P 4 -I{} sh -c \u0026#39;gzip \u0026#34;{}\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;Compressed {}\u0026#34;\u0026#39; # 負載均衡 seq 1 1000 | xargs -n 10 -P 8 -I{} process_batch {} 3. 安全性考慮 1 2 3 4 5 6 7 8 9 10 11 # 處理特殊字元 find . -name \u0026#34;*.txt\u0026#34; -print0 | xargs -0 ls -l # 避免命令注入 echo \u0026#34;file; rm -rf /\u0026#34; | xargs -I{} sh -c \u0026#39;ls \u0026#34;$1\u0026#34;\u0026#39; _ {} # 參數驗證 cat files.txt | xargs -I{} sh -c \u0026#39;if [ -f \u0026#34;$1\u0026#34; ]; then process \u0026#34;$1\u0026#34;; fi\u0026#39; _ {} # 路徑安全 find . -name \u0026#34;*.conf\u0026#34; | xargs -I{} sh -c \u0026#39;realpath \u0026#34;$1\u0026#34; | grep \u0026#34;^/safe/path\u0026#34; \u0026amp;\u0026amp; process \u0026#34;$1\u0026#34;\u0026#39; _ {} 4. 效能優化 1 2 3 4 5 6 7 8 9 10 11 # 批次大小優化 find . -name \u0026#34;*.txt\u0026#34; | xargs -n 100 process_files # 記憶體限制 find . -name \u0026#34;*.log\u0026#34; | xargs -s 4096 process_with_memory_limit # 並行數調整 find . -name \u0026#34;*.jpg\u0026#34; | xargs -n 1 -P $(nproc) optimize_image # 緩衝區優化 find . -name \u0026#34;*.data\u0026#34; | xargs -n 50 -P 4 process_data_batch 錯誤處理與除錯 1. 常見問題 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 問題：參數過長 # 解決：使用 -s 限制或分批處理 find . -name \u0026#34;*.txt\u0026#34; | xargs -s 1000 rm # 問題：檔案名包含空格 # 解決：使用 -0 和 -print0 find . -name \u0026#34;*.txt\u0026#34; -print0 | xargs -0 rm # 問題：空輸入執行 # 解決：使用 -r 選項 echo \u0026#34;\u0026#34; | xargs -r echo \u0026#34;不會執行\u0026#34; # 問題：並行競爭 # 解決：使用適當的鎖機制 find . -name \u0026#34;*.log\u0026#34; | xargs -n 1 -P 4 -I{} flock /tmp/lock process {} 2. 除錯技巧 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 使用 -t 查看執行命令 find . -name \u0026#34;*.txt\u0026#34; | xargs -t rm # 使用 -p 交互式確認 find . -name \u0026#34;*.tmp\u0026#34; | xargs -p rm # 逐步測試 echo \u0026#34;test1 test2\u0026#34; | xargs -n 1 echo # 檢查參數 find . -name \u0026#34;*.txt\u0026#34; | xargs -I{} echo \u0026#34;Will process: {}\u0026#34; # 錯誤日誌 find . -name \u0026#34;*.sh\u0026#34; | xargs -I{} sh -c \u0026#39;bash -n \u0026#34;{}\u0026#34; 2\u0026gt;\u0026gt;error.log || echo \u0026#34;Error in {}\u0026#34;\u0026#39; 3. 效能監控 1 2 3 4 5 6 7 8 9 # 執行時間測量 time find . -name \u0026#34;*.txt\u0026#34; | xargs wc -l # 並行效能比較 time seq 1 100 | xargs -n 1 sleep 0.1 # 串行 time seq 1 100 | xargs -n 1 -P 10 sleep 0.1 # 並行 # 資源使用監控 find . -name \u0026#34;*.big\u0026#34; | xargs -n 1 -P 4 -I{} sh -c \u0026#39;echo \u0026#34;Processing {}\u0026#34;; /usr/bin/time -v process {}\u0026#39; 與其他工具整合 1. 與 find 組合 1 2 3 4 5 6 7 8 9 10 11 # 基本組合 find /path -name \u0026#34;pattern\u0026#34; | xargs command # 安全處理 find /path -name \u0026#34;pattern\u0026#34; -print0 | xargs -0 command # 條件過濾 find /path -name \u0026#34;*.txt\u0026#34; -size +1M | xargs -I{} sh -c \u0026#39;echo \u0026#34;Large file: {}\u0026#34;\u0026#39; # 複雜搜尋 find /path -type f -mtime -7 \\( -name \u0026#34;*.log\u0026#34; -o -name \u0026#34;*.txt\u0026#34; \\) | xargs grep \u0026#34;pattern\u0026#34; 2. 與 grep 組合 1 2 3 4 5 6 7 8 9 10 11 # 檔案內容搜尋 find . -name \u0026#34;*.py\u0026#34; | xargs grep -l \u0026#34;import numpy\u0026#34; # 多模式搜尋 find . -name \u0026#34;*.conf\u0026#34; | xargs grep -E \u0026#34;(error|warning|critical)\u0026#34; # 統計匹配 find . -name \u0026#34;*.log\u0026#34; | xargs grep \u0026#34;ERROR\u0026#34; | wc -l # 結果處理 find . -name \u0026#34;*.txt\u0026#34; | xargs grep -H \u0026#34;pattern\u0026#34; | cut -d: -f1 | sort | uniq 3. 與 ssh 組合 1 2 3 4 5 6 7 8 9 10 11 # 遠程並行執行 cat servers.txt | xargs -n 1 -P 5 -I{} ssh {} \u0026#34;command\u0026#34; # 批次檔案傳輸 cat servers.txt | xargs -I{} scp file.txt user@{}:/tmp/ # 遠程監控 cat servers.txt | xargs -I{} ssh {} \u0026#34;uptime; df -h\u0026#34; # 分布式處理 cat servers.txt | xargs -n 1 -P 10 -I{} ssh {} \u0026#34;process_data input.txt\u0026#34; 實用腳本範例 1. 批次檔案處理腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/bin/bash # batch_process.sh - 批次處理檔案 SCRIPT_DIR=\u0026#34;$(cd \u0026#34;$(dirname \u0026#34;${BASH_SOURCE[0]}\u0026#34;)\u0026#34; \u0026amp;\u0026amp; pwd)\u0026#34; INPUT_DIR=\u0026#34;${1:-./input}\u0026#34; OUTPUT_DIR=\u0026#34;${2:-./output}\u0026#34; MAX_PARALLEL=\u0026#34;${3:-4}\u0026#34; # 建立輸出目錄 mkdir -p \u0026#34;$OUTPUT_DIR\u0026#34; # 批次處理 find \u0026#34;$INPUT_DIR\u0026#34; -name \u0026#34;*.txt\u0026#34; -print0 | \\ xargs -0 -n 1 -P \u0026#34;$MAX_PARALLEL\u0026#34; -I{} \\ sh -c \u0026#39; input_file=\u0026#34;$1\u0026#34; output_file=\u0026#34;\u0026#39;\u0026#34;$OUTPUT_DIR\u0026#34;\u0026#39;/$(basename \u0026#34;$1\u0026#34; .txt).processed.txt\u0026#34; echo \u0026#34;Processing: $input_file\u0026#34; # 處理邏輯 sed \u0026#34;s/old/new/g\u0026#34; \u0026#34;$input_file\u0026#34; \u0026gt; \u0026#34;$output_file\u0026#34; echo \u0026#34;Completed: $output_file\u0026#34; \u0026#39; _ {} echo \u0026#34;批次處理完成\u0026#34; 2. 系統清理腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #!/bin/bash # system_cleanup.sh - 系統清理腳本 LOG_FILE=\u0026#34;/var/log/cleanup.log\u0026#34; DRY_RUN=\u0026#34;${1:-false}\u0026#34; log() { echo \u0026#34;$(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;) - $1\u0026#34; | tee -a \u0026#34;$LOG_FILE\u0026#34; } cleanup_logs() { log \u0026#34;開始清理日誌檔案\u0026#34; if [ \u0026#34;$DRY_RUN\u0026#34; = \u0026#34;true\u0026#34; ]; then find /var/log -name \u0026#34;*.log\u0026#34; -size +100M | xargs -I{} echo \u0026#34;Will compress: {}\u0026#34; else find /var/log -name \u0026#34;*.log\u0026#34; -size +100M | \\ xargs -n 1 -P 4 -I{} sh -c \u0026#39;gzip \u0026#34;$1\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;Compressed: $1\u0026#34;\u0026#39; _ {} | \\ tee -a \u0026#34;$LOG_FILE\u0026#34; fi } cleanup_temp() { log \u0026#34;開始清理臨時檔案\u0026#34; if [ \u0026#34;$DRY_RUN\u0026#34; = \u0026#34;true\u0026#34; ]; then find /tmp -type f -mtime +7 | xargs -I{} echo \u0026#34;Will remove: {}\u0026#34; else find /tmp -type f -mtime +7 | \\ xargs -r rm -f fi } cleanup_cache() { log \u0026#34;開始清理快取檔案\u0026#34; if [ \u0026#34;$DRY_RUN\u0026#34; = \u0026#34;true\u0026#34; ]; then find /var/cache -name \u0026#34;*.cache\u0026#34; -mtime +30 | xargs -I{} echo \u0026#34;Will remove: {}\u0026#34; else find /var/cache -name \u0026#34;*.cache\u0026#34; -mtime +30 | \\ xargs -r rm -f fi } # 主執行 log \u0026#34;開始系統清理 (DRY_RUN: $DRY_RUN)\u0026#34; cleanup_logs cleanup_temp cleanup_cache log \u0026#34;系統清理完成\u0026#34; 3. 並行下載腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #!/bin/bash # parallel_download.sh - 並行下載腳本 URL_FILE=\u0026#34;${1:-urls.txt}\u0026#34; DOWNLOAD_DIR=\u0026#34;${2:-./downloads}\u0026#34; MAX_PARALLEL=\u0026#34;${3:-5}\u0026#34; TIMEOUT=\u0026#34;${4:-30}\u0026#34; # 檢查輸入檔案 if [ ! -f \u0026#34;$URL_FILE\u0026#34; ]; then echo \u0026#34;錯誤：找不到 URL 檔案 $URL_FILE\u0026#34; exit 1 fi # 建立下載目錄 mkdir -p \u0026#34;$DOWNLOAD_DIR\u0026#34; # 並行下載 cat \u0026#34;$URL_FILE\u0026#34; | \\ xargs -n 1 -P \u0026#34;$MAX_PARALLEL\u0026#34; -I{} \\ sh -c \u0026#39; url=\u0026#34;$1\u0026#34; dir=\u0026#34;$2\u0026#34; timeout=\u0026#34;$3\u0026#34; filename=$(basename \u0026#34;$url\u0026#34;) output_path=\u0026#34;$dir/$filename\u0026#34; echo \u0026#34;開始下載: $url\u0026#34; if timeout \u0026#34;$timeout\u0026#34; wget -q -O \u0026#34;$output_path\u0026#34; \u0026#34;$url\u0026#34;; then echo \u0026#34;下載成功: $filename\u0026#34; else echo \u0026#34;下載失敗: $url\u0026#34; rm -f \u0026#34;$output_path\u0026#34; fi \u0026#39; _ {} \u0026#34;$DOWNLOAD_DIR\u0026#34; \u0026#34;$TIMEOUT\u0026#34; echo \u0026#34;下載任務完成\u0026#34; # 統計結果 total_files=$(wc -l \u0026lt; \u0026#34;$URL_FILE\u0026#34;) downloaded_files=$(find \u0026#34;$DOWNLOAD_DIR\u0026#34; -type f | wc -l) echo \u0026#34;總計: $total_files 個檔案，成功下載: $downloaded_files 個檔案\u0026#34; 效能最佳化 1. 並行度調整 1 2 3 4 5 6 7 8 9 10 11 # CPU 綁定任務 CPU_CORES=$(nproc) find . -name \u0026#34;*.c\u0026#34; | xargs -n 1 -P \u0026#34;$CPU_CORES\u0026#34; gcc -c # I/O 綁定任務 IO_PARALLEL=$(($(nproc) * 2)) cat urls.txt | xargs -n 1 -P \u0026#34;$IO_PARALLEL\u0026#34; wget # 混合負載 MIXED_PARALLEL=$(($(nproc) + 2)) find . -name \u0026#34;*.log\u0026#34; | xargs -n 1 -P \u0026#34;$MIXED_PARALLEL\u0026#34; process_log 2. 記憶體管理 1 2 3 4 5 6 7 8 9 10 11 # 限制批次大小 find . -name \u0026#34;*.big\u0026#34; | xargs -n 1 process_large_file # 限制命令行長度 find . -name \u0026#34;*.txt\u0026#34; | xargs -s 4096 process_files # 分段處理 find . -name \u0026#34;*.data\u0026#34; | split -l 1000 - batch_ for batch in batch_*; do cat \u0026#34;$batch\u0026#34; | xargs -n 10 -P 4 process_data done 3. 網路優化 1 2 3 4 5 6 7 8 # 連接池 cat servers.txt | xargs -n 1 -P 10 -I{} ssh -o ControlMaster=auto -o ControlPath=/tmp/ssh-%r@%h:%p {} \u0026#34;command\u0026#34; # 重試機制 cat urls.txt | xargs -n 1 -I{} sh -c \u0026#39;for i in {1..3}; do wget \u0026#34;{}\u0026#34; \u0026amp;\u0026amp; break; sleep 5; done\u0026#39; # 頻寬限制 cat large_files.txt | xargs -n 1 -P 2 -I{} rsync --bwlimit=1000 {} destination/ 總結 核心優勢 參數處理：解決命令行參數長度限制 批次操作：高效處理大量檔案和資料 並行執行：充分利用多核心系統資源 管道友好：與其他 Unix 工具完美整合 靈活控制：豐富的選項滿足各種需求 最佳實踐 安全第一：處理包含空格的檔案名使用 -0 和 -print0 適當並行：根據任務類型調整並行度 錯誤處理：使用 -r 避免空輸入執行 測試先行：使用 -t 和 -p 選項測試命令 效能監控：測量並優化批次大小和並行度 常用模式記憶 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 基本模式 find . -name \u0026#34;pattern\u0026#34; | xargs command # 安全模式 find . -name \u0026#34;pattern\u0026#34; -print0 | xargs -0 command # 並行模式 command | xargs -n 1 -P 4 process # 替換模式 echo \u0026#34;files\u0026#34; | xargs -I{} cp {} backup/{} # 交互模式 find . -name \u0026#34;*.tmp\u0026#34; | xargs -p rm xargs 是命令行批次處理和並行執行的瑞士軍刀，掌握其核心概念和常用技巧，能夠大幅提升 Linux 系統管理和自動化任務的效率。記住：合理使用並行處理能夠顯著提升效能，但要注意資源管理和錯誤處理。\n參考資料 GNU Findutils Manual - xargs Linux man xargs Advanced Bash-Scripting Guide Unix Power Tools ","permalink":"https://xinqilin.github.io/post/tools/xargs/","tags":["Linux","Xargs","Command Line","Parallel Processing","Pipe","Shell","Unix"],"title":"Xargs 命令完整指南：Linux 參數處理與並行執行的強大工具"},{"content":"概述 find 是 Linux/Unix 系統中最強大且最常用的檔案搜尋命令之一。它不僅能夠根據各種條件搜尋檔案和目錄，還能對搜尋結果執行各種操作，是系統管理員和開發者必備的核心工具。\n核心特徵 遞歸搜尋：可深入子目錄進行搜尋 多重條件：支援檔名、類型、大小、時間等多種搜尋條件 動作執行：可對搜尋結果執行各種操作 邏輯組合：支援 AND、OR、NOT 等邏輯運算 高效能：針對大型檔案系統優化 基本語法 1 find [搜尋路徑] [搜尋條件] [動作] 基本使用範例 1 2 3 4 5 6 7 8 9 10 11 # 在當前目錄搜尋檔案 find . -name \u0026#34;test.txt\u0026#34; # 在指定目錄搜尋 find /home/user -name \u0026#34;*.log\u0026#34; # 忽略大小寫搜尋 find . -iname \u0026#34;README.md\u0026#34; # 搜尋多個目錄 find /var/log /tmp -name \u0026#34;*.tmp\u0026#34; 依據檔案名稱搜尋 基本檔名搜尋 1 2 3 4 5 6 7 8 9 10 11 # 精確檔名匹配 find /home -name \u0026#34;config.conf\u0026#34; # 萬用字元搜尋 find . -name \u0026#34;*.txt\u0026#34; # 所有 .txt 檔案 find . -name \u0026#34;test*\u0026#34; # 以 test 開頭的檔案 find . -name \u0026#34;*backup*\u0026#34; # 包含 backup 的檔案 # 忽略大小寫 find . -iname \u0026#34;*.PDF\u0026#34; # 不分大小寫搜尋 PDF 檔案 find . -iname \u0026#34;readme*\u0026#34; # 不分大小寫搜尋 readme 開頭的檔案 進階檔名搜尋 1 2 3 4 5 6 7 8 9 10 11 # 使用正規表達式 find . -regex \u0026#34;.*\\.\\(jpg\\|png\\|gif\\)$\u0026#34; # 搜尋圖片檔案 find . -iregex \u0026#34;.*\\.\\(mp3\\|mp4\\|avi\\)$\u0026#34; # 不分大小寫搜尋媒體檔案 # 排除特定檔案 find . -name \u0026#34;*.txt\u0026#34; ! -name \u0026#34;temp*\u0026#34; # 搜尋 txt 但排除 temp 開頭 find . ! -name \u0026#34;.*\u0026#34; # 排除隱藏檔案 # 多個條件組合 find . \\( -name \u0026#34;*.log\u0026#34; -o -name \u0026#34;*.tmp\u0026#34; \\) # OR 條件 find . -name \u0026#34;*.txt\u0026#34; -a -size +1M # AND 條件 依據檔案類型搜尋 基本檔案類型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 檔案類型參數說明 # f: 一般檔案 d: 目錄 # l: 符號連結 p: 命名管道 (FIFO) # s: socket b: 區塊裝置 # c: 字元裝置 # 搜尋目錄 find /var -type d -name \u0026#34;log*\u0026#34; # 搜尋一般檔案 find . -type f -name \u0026#34;*.sh\u0026#34; # 搜尋符號連結 find /usr/bin -type l # 搜尋空檔案 find /tmp -type f -empty # 搜尋空目錄 find /home -type d -empty 實際應用範例 1 2 3 4 5 6 7 8 # 找出所有 shell 腳本 find /usr/local/bin -type f -name \u0026#34;*.sh\u0026#34; -executable # 找出所有損壞的符號連結 find /usr -type l ! -exec test -e {} \\; -print # 找出包含特定副檔名的目錄 find . -type d -exec sh -c \u0026#39;ls \u0026#34;$1\u0026#34;/*.log \u0026gt;/dev/null 2\u0026gt;\u0026amp;1\u0026#39; _ {} \\; -print 依據檔案大小搜尋 基本大小搜尋 1 2 3 4 5 6 7 8 9 10 # 大小單位說明 # c: bytes k: KB (1024 bytes) # M: MB G: GB # +: 大於 -: 小於 精確值: 等於 # 基本大小搜尋 find . -size 50M # 等於 50MB find . -size +100M # 大於 100MB find . -size -1G # 小於 1GB find /var/log -size +10M -size -100M # 10MB 到 100MB 之間 進階大小操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 找出最大的檔案（前 10 個） find /home -type f -exec ls -la {} \\; | sort -k5 -nr | head -10 # 找出超過 1GB 的檔案並顯示大小 find / -size +1G -type f -exec du -h {} \\; 2\u0026gt;/dev/null # 找出空檔案並刪除 find /tmp -type f -empty -delete # 找出大檔案並詢問是否刪除 find /var/log -size +100M -type f -ok rm {} \\; # 按大小範圍分類顯示 find . -type f -size +10M -size -100M -printf \u0026#34;%s %p\\n\u0026#34; | sort -nr 依據時間搜尋 時間類型說明 1 2 3 4 5 6 7 8 9 10 # 時間類型 # mtime: 修改時間 (modify time) # atime: 存取時間 (access time) # ctime: 狀態改變時間 (change time) # 時間單位 # 預設單位: 天 (24小時) # +n: n天之前 # -n: n天之內 # n: 恰好n天前 基本時間搜尋 1 2 3 4 5 6 7 8 9 10 11 12 # 修改時間搜尋 find . -mtime 3 # 恰好 3 天前修改 find . -mtime -7 # 7 天內修改 find . -mtime +30 # 30 天前修改 find . -mtime +7 -mtime -30 # 7-30 天前修改 # 存取時間搜尋 find /home -atime -1 # 1 天內被存取 find /tmp -atime +7 # 7 天以上未被存取 # 狀態改變時間 find . -ctime -1 # 1 天內狀態改變 精確時間搜尋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 分鐘為單位的時間搜尋 find /var/log -mmin -60 # 60 分鐘內修改 find . -amin +120 # 120 分鐘前存取 find /tmp -cmin -30 # 30 分鐘內狀態改變 # 比較檔案時間 find . -newer reference.txt # 比 reference.txt 新的檔案 find . -cnewer backup.tar # 狀態比 backup.tar 新 # 指定日期範圍 find /var/log -newermt \u0026#34;2023-01-01\u0026#34; ! -newermt \u0026#34;2023-12-31\u0026#34; # 今天修改的檔案 find . -daystart -mtime 0 # 昨天修改的檔案 find . -daystart -mtime 1 依據權限搜尋 基本權限搜尋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 精確權限匹配 find /home -perm 755 # 權限恰好是 755 find . -perm 644 # 權限恰好是 644 # 包含指定權限 find /usr/bin -perm -755 # 至少有 755 權限 find . -perm -u+x # 擁有者有執行權限 # 任一符合權限 find /tmp -perm /222 # 任何人有寫入權限 find . -perm /u+w,g+w,o+w # 任何人有寫入權限 # 可執行檔案 find /usr/local/bin -type f -executable find . -type f -perm -u+x # 擁有者可執行 進階權限搜尋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 找出 SUID 檔案 find /usr -perm -4000 -type f 2\u0026gt;/dev/null # 找出 SGID 檔案 find /usr -perm -2000 -type f 2\u0026gt;/dev/null # 找出 sticky bit 目錄 find /tmp -perm -1000 -type d # 找出可寫的檔案（安全檢查） find /etc -type f -writable 2\u0026gt;/dev/null # 找出無權限讀取的檔案 find /home -type f ! -readable 2\u0026gt;/dev/null 依據擁有者搜尋 基本擁有者搜尋 1 2 3 4 5 6 7 8 9 10 11 12 # 依據使用者搜尋 find /home -user john # 屬於 john 的檔案 find /var -user root # 屬於 root 的檔案 find . -user $(whoami) # 屬於當前使用者的檔案 # 依據群組搜尋 find /home -group developers # 屬於 developers 群組 find /var/www -group www-data # 屬於 www-data 群組 # 依據 UID/GID 搜尋 find /home -uid 1000 # UID 為 1000 的檔案 find /var -gid 100 # GID 為 100 的檔案 進階擁有者搜尋 1 2 3 4 5 6 7 8 9 10 # 找出無主檔案（孤兒檔案） find /home -nouser # 沒有對應使用者的檔案 find /var -nogroup # 沒有對應群組的檔案 # 組合條件搜尋 find /home -user john -group staff # 屬於 john 且群組是 staff find /tmp -user root ! -group root # 屬於 root 但群組不是 root # 找出特定使用者的大檔案 find /home -user john -size +100M -type f 執行動作 (-exec 和 -ok) 基本 -exec 用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 基本語法：-exec command {} \\; # {} 代表找到的檔案 # \\; 表示命令結束 # 刪除找到的檔案 find /tmp -name \u0026#34;*.tmp\u0026#34; -exec rm {} \\; # 複製檔案 find . -name \u0026#34;*.txt\u0026#34; -exec cp {} backup/ \\; # 移動檔案 find . -name \u0026#34;*.log\u0026#34; -exec mv {} /var/log/ \\; # 修改權限 find /var/www -type f -exec chmod 644 {} \\; find /var/www -type d -exec chmod 755 {} \\; 進階 -exec 用法 1 2 3 4 5 6 7 8 9 10 11 12 # 使用 -exec {} + 提高效能（批次處理） find . -name \u0026#34;*.txt\u0026#34; -exec grep \u0026#34;pattern\u0026#34; {} + find /tmp -name \u0026#34;*.tmp\u0026#34; -exec rm {} + # 執行複雜命令 find . -type f -name \u0026#34;*.sh\u0026#34; -exec sh -c \u0026#39;echo \u0026#34;Processing: $1\u0026#34;; chmod +x \u0026#34;$1\u0026#34;\u0026#39; _ {} \\; # 在找到的目錄中執行命令 find /var/log -type d -exec sh -c \u0026#39;echo \u0026#34;Directory: $1\u0026#34;; ls -la \u0026#34;$1\u0026#34;\u0026#39; _ {} \\; # 條件執行 find . -name \u0026#34;*.txt\u0026#34; -exec test -s {} \\; -exec echo \u0026#34;Non-empty: {}\u0026#34; \\; 互動式 -ok 用法 1 2 3 4 5 6 7 8 # -ok 會在執行前詢問確認 find /tmp -name \u0026#34;*.old\u0026#34; -ok rm {} \\; # 互動式移動檔案 find . -name \u0026#34;*.bak\u0026#34; -ok mv {} backup/ \\; # 互動式權限修改 find /home -name \u0026#34;*.sh\u0026#34; -ok chmod +x {} \\; 邏輯運算符 基本邏輯運算 1 2 3 4 5 6 7 8 9 10 11 # AND 運算（預設） find . -name \u0026#34;*.txt\u0026#34; -size +1M # 名稱是 *.txt 且大小 \u0026gt; 1M find . -type f -user john # 是檔案且屬於 john # OR 運算 find . \\( -name \u0026#34;*.txt\u0026#34; -o -name \u0026#34;*.md\u0026#34; \\) # txt 或 md 檔案 find . -type f \\( -name \u0026#34;*.log\u0026#34; -o -name \u0026#34;*.tmp\u0026#34; \\) # NOT 運算 find . -type f ! -name \u0026#34;*.txt\u0026#34; # 不是 txt 的檔案 find . ! -path \u0026#34;*/.*\u0026#34; # 排除隱藏目錄 複雜邏輯組合 1 2 3 4 5 6 7 8 # 複雜條件組合 find . \\( -name \u0026#34;*.txt\u0026#34; -o -name \u0026#34;*.md\u0026#34; \\) -a -size +1k -a ! -path \u0026#34;*/tmp/*\u0026#34; # 多重排除條件 find /var/log \\( ! -name \u0026#34;*.gz\u0026#34; ! -name \u0026#34;*.old\u0026#34; \\) -type f -mtime -7 # 巢狀邏輯條件 find . \\( \\( -name \u0026#34;*.c\u0026#34; -o -name \u0026#34;*.h\u0026#34; \\) -a -mtime -7 \\) -o \\( -name \u0026#34;*.py\u0026#34; -a -size +10k \\) 輸出格式化 使用 -printf 格式化輸出 1 2 3 4 5 6 7 8 9 10 11 # 基本格式化 find . -type f -printf \u0026#34;%f\\n\u0026#34; # 只顯示檔名 find . -type f -printf \u0026#34;%p\\t%s\\n\u0026#34; # 路徑和大小 find . -type f -printf \u0026#34;%M %u %g %s %p\\n\u0026#34; # 權限、擁有者、群組、大小、路徑 # 時間格式化 find . -type f -printf \u0026#34;%TY-%Tm-%Td %TH:%TM %p\\n\u0026#34; # 修改時間和路徑 find . -type f -printf \u0026#34;%Ac %p\\n\u0026#34; # 存取時間 # 大小格式化 find . -type f -printf \u0026#34;%10s %p\\n\u0026#34; | sort -nr # 按大小排序 格式化參數說明 1 2 3 4 5 6 7 8 9 10 # 常用格式化參數 # %p: 檔案路徑 # %f: 檔案名稱 # %s: 檔案大小（bytes） # %M: 檔案權限 # %u: 擁有者名稱 # %g: 群組名稱 # %T: 時間相關（需配合時間格式） # %h: 目錄路徑 # %d: 檔案深度 實戰應用場景 系統清理與維護 1 2 3 4 5 6 7 8 9 # 清理臨時檔案 find /tmp -type f -atime +7 -delete # 刪除 7 天未存取的檔案 find /var/log -name \u0026#34;*.log\u0026#34; -size +100M -delete # 刪除大日誌檔案 # 清理快取檔案 find ~/.cache -type f -atime +30 -delete # 清理舊快取 # 備份前清理 find /backup -name \u0026#34;*.tar.gz\u0026#34; -mtime +30 -delete # 刪除 30 天前的備份 檔案整理與歸檔 1 2 3 4 5 6 7 8 # 按日期歸檔檔案 find /data -type f -name \u0026#34;*.log\u0026#34; -mtime +1 -exec gzip {} \\; # 按大小分類檔案 find /home -type f -size +1G -exec ls -lh {} \\; # 移動舊檔案到歸檔目錄 find /project -type f -mtime +90 -exec mv {} /archive/ \\; 安全檢查 1 2 3 4 5 6 7 8 9 10 11 # 檢查 SUID/SGID 檔案 find /usr -type f \\( -perm -4000 -o -perm -2000 \\) -exec ls -l {} \\; # 檢查可寫檔案 find /etc -type f -writable 2\u0026gt;/dev/null # 檢查無主檔案 find /home -nouser -o -nogroup # 檢查異常權限 find /var/www -type f ! -perm 644 -o -type d ! -perm 755 開發與除錯 1 2 3 4 5 6 7 8 9 10 11 12 # 搜尋程式碼 find . -name \u0026#34;*.java\u0026#34; -exec grep -l \u0026#34;className\u0026#34; {} \\; # 找出編譯產生的檔案 find . \\( -name \u0026#34;*.class\u0026#34; -o -name \u0026#34;*.o\u0026#34; -o -name \u0026#34;*.pyc\u0026#34; \\) -delete # 統計不同類型檔案數量 find . -type f -name \u0026#34;*.java\u0026#34; | wc -l find . -type f -name \u0026#34;*.py\u0026#34; -exec wc -l {} + | tail -1 # 檢查程式碼行數 find . -name \u0026#34;*.py\u0026#34; -exec wc -l {} + | sort -nr | head -10 監控與分析 1 2 3 4 5 6 7 8 9 10 11 # 找出最近修改的檔案 find /var/log -type f -mmin -60 -exec ls -lt {} \\; # 監控檔案系統變化 find /etc -newer /tmp/baseline -type f # 分析磁碟使用 find /home -type f -printf \u0026#34;%s %p\\n\u0026#34; | sort -nr | head -20 # 找出重複檔案（基於大小） find /data -type f -printf \u0026#34;%s %p\\n\u0026#34; | sort | uniq -d -w 10 效能優化技巧 提升搜尋效能 1 2 3 4 5 6 7 8 9 10 11 12 13 # 限制搜尋深度 find /usr -maxdepth 3 -name \u0026#34;*.conf\u0026#34; # 排除不必要的目錄 find / -path /proc -prune -o -path /sys -prune -o -name \u0026#34;*.txt\u0026#34; -print # 使用更具體的路徑 find /var/log -name \u0026#34;*.log\u0026#34; # 好 find / -name \u0026#34;*.log\u0026#34; # 較慢 # 將最具選擇性的條件放在前面 find . -name \u0026#34;*.txt\u0026#34; -size +1M # 好 find . -size +1M -name \u0026#34;*.txt\u0026#34; # 也可以，但順序影響效能 批次處理優化 1 2 3 4 5 6 7 8 9 # 使用 {} + 而非 {} \\; 提升效能 find . -name \u0026#34;*.txt\u0026#34; -exec wc -l {} + # 快 find . -name \u0026#34;*.txt\u0026#34; -exec wc -l {} \\; # 慢 # 使用管道處理大量結果 find /var/log -name \u0026#34;*.log\u0026#34; -print0 | xargs -0 grep \u0026#34;ERROR\u0026#34; # 並行處理 find . -name \u0026#34;*.jpg\u0026#34; -print0 | xargs -0 -P 4 -I {} convert {} {}.thumb.jpg 常見錯誤與解決方案 權限錯誤處理 1 2 3 4 5 6 7 8 # 忽略權限錯誤 find /var -name \u0026#34;*.log\u0026#34; 2\u0026gt;/dev/null # 只搜尋有權限的目錄 find /var -readable -name \u0026#34;*.log\u0026#34; # 使用 sudo 搜尋受保護的目錄 sudo find /root -name \u0026#34;*.conf\u0026#34; 特殊字元處理 1 2 3 4 5 6 # 處理檔名中的空格 find . -name \u0026#34;* *\u0026#34; -print0 | xargs -0 ls -l # 處理特殊字元 find . -name \u0026#34;file[1-3].txt\u0026#34; find . -name \u0026#34;*.txt\u0026#34; -not -name \u0026#34;*\\\u0026amp;*\u0026#34; 記憶體使用優化 1 2 3 4 5 6 7 8 9 10 # 避免一次載入過多結果 find /large_dir -name \u0026#34;*.txt\u0026#34; | head -100 # 使用 -quit 在找到第一個結果後停止 find . -name \u0026#34;target.txt\u0026#34; -quit # 分段處理大目錄 find /huge_dir -maxdepth 1 -type d | while read dir; do find \u0026#34;$dir\u0026#34; -name \u0026#34;*.txt\u0026#34; done 與其他工具組合 與 grep 組合 1 2 3 4 5 6 7 8 9 # 在檔案中搜尋內容 find . -name \u0026#34;*.txt\u0026#34; -exec grep -l \u0026#34;pattern\u0026#34; {} \\; # 搜尋並顯示匹配行 find . -name \u0026#34;*.log\u0026#34; -exec grep -Hn \u0026#34;ERROR\u0026#34; {} \\; # 使用 xargs 提升效能 find . -name \u0026#34;*.txt\u0026#34; | xargs grep \u0026#34;pattern\u0026#34; find . -name \u0026#34;*.txt\u0026#34; -print0 | xargs -0 grep \u0026#34;pattern\u0026#34; 與 tar 組合 1 2 3 4 5 # 備份找到的檔案 find /home -name \u0026#34;*.doc\u0026#34; -print0 | tar -czf backup.tar.gz --null -T - # 歸檔舊檔案 find /data -mtime +30 -print0 | tar -czf old_files.tar.gz --null -T - 與 rsync 組合 1 2 # 同步找到的檔案 find /source -name \u0026#34;*.txt\u0026#34; -print0 | rsync -av --files-from=- --from0 /source/ /destination/ 總結 核心優勢 強大的搜尋能力：支援多種條件組合搜尋 批次操作：可對搜尋結果執行各種動作 高度可配置：豐富的參數和選項 跨平台相容：在各種 Unix-like 系統中一致 最佳實踐 明確搜尋範圍：使用具體的路徑而非根目錄 合理使用條件：將最具選擇性的條件放在前面 善用邏輯運算：合理組合 AND、OR、NOT 條件 注意效能：大目錄搜尋時考慮使用 -maxdepth 限制 安全操作：使用 -ok 而非 -exec 進行危險操作 常用技巧記憶 1 2 3 4 5 6 # 日常最常用的模式 find . -name \u0026#34;*.txt\u0026#34; # 基本檔名搜尋 find . -type f -size +100M # 大檔案搜尋 find . -mtime -7 # 最近修改檔案 find . -name \u0026#34;*.tmp\u0026#34; -delete # 清理臨時檔案 find . -name \u0026#34;*.sh\u0026#34; -exec chmod +x {} \\; # 批次修改權限 find 命令的強大之處在於其靈活性和可組合性。熟練掌握這個工具，能夠大幅提升 Linux 系統管理和日常工作的效率。記住：實務中最重要的是理解各種條件的組合邏輯，並根據實際需求選擇最適合的搜尋策略。\n參考資料 GNU Findutils Manual Linux man find Advanced Bash-Scripting Guide Unix Power Tools ","permalink":"https://xinqilin.github.io/post/tools/find/","tags":["Linux","Find","Command Line","File Search","System Administration","Shell","Unix"],"title":"Find 命令完整指南：Linux 檔案搜尋與管理的瑞士軍刀"},{"content":"概述 Ubuntu 是基於 Debian 的 Linux 發行版，以其穩定性、易用性和豐富的軟體生態系統而聞名。它是雲端運算、伺服器部署和開發環境的首選平台，提供長期支援（LTS）版本和定期更新的標準版本。\n核心特徵 穩定可靠：基於 Debian 穩定分支，經過嚴格測試 套件豐富：APT 套件管理系統，數萬個軟體包 社群支援：活躍的開發者和使用者社群 容器友好：優秀的 Docker 和容器化支援 雲端整合：原生支援各大雲端平台 系統安裝與初始設置 基本安裝 1 2 3 4 5 6 7 8 9 10 11 12 13 # 檢查系統版本 lsb_release -a cat /etc/os-release # 檢查硬體資訊 uname -a lscpu free -h df -h # 檢查網路狀態 ip addr show netstat -tuln 系統更新 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 更新套件列表 sudo apt update # 升級已安裝的套件 sudo apt upgrade -y # 完整系統升級 sudo apt full-upgrade -y # 清理不需要的套件 sudo apt autoremove -y sudo apt autoclean # 檢查可升級的套件 apt list --upgradable 時區和語言設定 1 2 3 4 5 6 7 8 9 10 # 設定時區 sudo timedatectl set-timezone Asia/Taipei timedatectl status # 語言和地區設定 sudo locale-gen zh_TW.UTF-8 sudo update-locale LANG=zh_TW.UTF-8 # 檢查當前語言設定 locale 套件管理系統 APT 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 搜尋套件 apt search keyword apt-cache search keyword # 查看套件資訊 apt show package-name apt-cache show package-name # 安裝套件 sudo apt install package-name sudo apt install package1 package2 package3 # 重新安裝套件 sudo apt reinstall package-name # 移除套件 sudo apt remove package-name # 保留配置檔案 sudo apt purge package-name # 完全移除 # 檢查依賴關係 apt depends package-name apt rdepends package-name # 列出已安裝套件 dpkg -l apt list --installed 套件庫管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 添加 PPA 套件庫 sudo add-apt-repository ppa:user/ppa-name sudo apt update # 移除 PPA sudo add-apt-repository --remove ppa:user/ppa-name # 管理套件庫金鑰 wget -qO - https://example.com/key.gpg | sudo apt-key add - sudo apt-key list sudo apt-key del KEY_ID # 編輯套件來源 sudo nano /etc/apt/sources.list ls /etc/apt/sources.list.d/ DEB 套件處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 安裝本地 DEB 套件 sudo dpkg -i package.deb # 修復依賴問題 sudo apt install -f # 移除 DEB 套件 sudo dpkg -r package-name # 查詢 DEB 套件內容 dpkg -L package-name dpkg -c package.deb # 查詢檔案屬於哪個套件 dpkg -S /path/to/file 必備軟體安裝 開發工具 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 基本開發工具 sudo apt install build-essential git vim curl wget htop tree # 程式語言環境 sudo apt install python3 python3-pip nodejs npm default-jdk # 版本控制 sudo apt install git subversion # 編輯器和 IDE sudo apt install vim neovim emacs code # 資料庫工具 sudo apt install mysql-client postgresql-client redis-tools 系統監控工具 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 系統監控 sudo apt install htop iotop iftop nethogs # 系統資訊 sudo apt install neofetch screenfetch inxi # 網路工具 sudo apt install net-tools traceroute nmap tcpdump wireshark # 效能分析 sudo apt install sysstat dstat glances # 日誌分析 sudo apt install logwatch fail2ban 媒體和辦公軟體 1 2 3 4 5 6 7 8 9 10 11 # 媒體播放 sudo apt install vlc audacity gimp # 辦公軟體 sudo apt install libreoffice thunderbird firefox # 壓縮工具 sudo apt install zip unzip rar unrar 7zip # 文件處理 sudo apt install pandoc texlive-full Docker 環境設置 Docker 安裝與配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 移除舊版本 sudo apt remove docker docker-engine docker.io containerd runc # 安裝依賴 sudo apt update sudo apt install apt-transport-https ca-certificates curl gnupg lsb-release # 添加 Docker 官方 GPG 金鑰 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg # 添加套件庫 echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null # 安裝 Docker Engine sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io docker-compose-plugin # 啟動並啟用 Docker 服務 sudo systemctl start docker sudo systemctl enable docker # 將使用者加入 docker 群組 sudo usermod -aG docker $USER newgrp docker # 驗證安裝 docker --version docker run hello-world Ubuntu Docker 容器設置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # 拉取 Ubuntu 映像 docker pull ubuntu:latest docker pull ubuntu:20.04 docker pull ubuntu:22.04 # 建立 Docker 網路 docker network create ubuntu-network # 啟動 Ubuntu 容器 docker run -dit \\ --name ubuntu-container \\ --network ubuntu-network \\ -p 2222:22 \\ -p 8080:8080 \\ -v $(pwd)/workspace:/workspace \\ ubuntu:latest # 進入容器 docker exec -it ubuntu-container bash # 容器內初始化 apt update \u0026amp;\u0026amp; apt upgrade -y yes | unminimize # 安裝基本工具 apt install -y \\ curl \\ wget \\ git \\ vim \\ nano \\ htop \\ tree \\ less \\ man-db \\ openssh-server \\ sudo \\ zip \\ unzip \\ jq \\ python3 \\ python3-pip \\ nodejs \\ npm # 設定 SSH 服務 echo \u0026#39;PermitRootLogin yes\u0026#39; \u0026gt;\u0026gt; /etc/ssh/sshd_config echo \u0026#39;PasswordAuthentication yes\u0026#39; \u0026gt;\u0026gt; /etc/ssh/sshd_config service ssh start # 建立使用者 useradd -m -s /bin/bash developer echo \u0026#39;developer:password\u0026#39; | chpasswd usermod -aG sudo developer 容器管理腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #!/bin/bash # ubuntu_container_manager.sh - Ubuntu 容器管理腳本 CONTAINER_NAME=\u0026#34;ubuntu-dev\u0026#34; NETWORK_NAME=\u0026#34;ubuntu-network\u0026#34; IMAGE=\u0026#34;ubuntu:22.04\u0026#34; start_container() { echo \u0026#34;Starting Ubuntu development container...\u0026#34; # 檢查網路是否存在 if ! docker network ls | grep -q \u0026#34;$NETWORK_NAME\u0026#34;; then echo \u0026#34;Creating network: $NETWORK_NAME\u0026#34; docker network create \u0026#34;$NETWORK_NAME\u0026#34; fi # 檢查容器是否已存在 if docker ps -a | grep -q \u0026#34;$CONTAINER_NAME\u0026#34;; then echo \u0026#34;Starting existing container...\u0026#34; docker start \u0026#34;$CONTAINER_NAME\u0026#34; else echo \u0026#34;Creating new container...\u0026#34; docker run -dit \\ --name \u0026#34;$CONTAINER_NAME\u0026#34; \\ --network \u0026#34;$NETWORK_NAME\u0026#34; \\ -p 2222:22 \\ -p 8080:8080 \\ -p 3000:3000 \\ -v \u0026#34;$(pwd)/workspace:/workspace\u0026#34; \\ -v \u0026#34;$(pwd)/config:/config\u0026#34; \\ \u0026#34;$IMAGE\u0026#34; # 初始化容器 echo \u0026#34;Initializing container...\u0026#34; docker exec \u0026#34;$CONTAINER_NAME\u0026#34; bash -c \u0026#34; apt update \u0026amp;\u0026amp; apt upgrade -y yes | unminimize apt install -y curl wget git vim htop tree less man-db openssh-server sudo zip unzip jq python3 python3-pip nodejs npm echo \u0026#39;PermitRootLogin yes\u0026#39; \u0026gt;\u0026gt; /etc/ssh/sshd_config echo \u0026#39;PasswordAuthentication yes\u0026#39; \u0026gt;\u0026gt; /etc/ssh/sshd_config service ssh start useradd -m -s /bin/bash developer echo \u0026#39;developer:developer\u0026#39; | chpasswd usermod -aG sudo developer \u0026#34; fi echo \u0026#34;Container started successfully!\u0026#34; echo \u0026#34;SSH: ssh -p 2222 developer@localhost\u0026#34; echo \u0026#34;Enter: docker exec -it $CONTAINER_NAME bash\u0026#34; } stop_container() { echo \u0026#34;Stopping container...\u0026#34; docker stop \u0026#34;$CONTAINER_NAME\u0026#34; } remove_container() { echo \u0026#34;Removing container...\u0026#34; docker stop \u0026#34;$CONTAINER_NAME\u0026#34; 2\u0026gt;/dev/null || true docker rm \u0026#34;$CONTAINER_NAME\u0026#34; 2\u0026gt;/dev/null || true } status_container() { echo \u0026#34;Container status:\u0026#34; docker ps -a | grep \u0026#34;$CONTAINER_NAME\u0026#34; || echo \u0026#34;Container not found\u0026#34; } case \u0026#34;$1\u0026#34; in start) start_container ;; stop) stop_container ;; remove) remove_container ;; status) status_container ;; restart) stop_container sleep 2 start_container ;; *) echo \u0026#34;Usage: $0 {start|stop|remove|status|restart}\u0026#34; exit 1 ;; esac 系統管理與維護 服務管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 檢查服務狀態 sudo systemctl status service-name sudo systemctl list-units --type=service # 啟動/停止/重啟服務 sudo systemctl start service-name sudo systemctl stop service-name sudo systemctl restart service-name sudo systemctl reload service-name # 啟用/停用服務 sudo systemctl enable service-name sudo systemctl disable service-name # 檢查服務日誌 sudo journalctl -u service-name sudo journalctl -u service-name -f # 即時日誌 # 檢查開機啟動的服務 sudo systemctl list-unit-files --state=enabled 使用者和權限管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 使用者管理 sudo useradd -m -s /bin/bash username sudo passwd username sudo userdel username sudo usermod -aG group username # 群組管理 sudo groupadd groupname sudo groupdel groupname groups username # 權限管理 chmod 755 file chmod u+x file chown user:group file sudo chown -R user:group directory/ # 查看使用者資訊 id username who w last 系統監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # CPU 和記憶體使用率 top htop free -h cat /proc/meminfo # 磁碟使用情況 df -h du -sh directory/ lsblk fdisk -l # 網路狀態 netstat -tuln ss -tuln iftop nethogs # 系統負載 uptime cat /proc/loadavg vmstat 1 5 iostat 1 5 日誌管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 系統日誌 sudo journalctl sudo journalctl -f # 即時日誌 sudo journalctl --since \u0026#34;1 hour ago\u0026#34; sudo journalctl --until \u0026#34;2023-01-01\u0026#34; # 日誌大小管理 sudo journalctl --disk-usage sudo journalctl --vacuum-size=100M sudo journalctl --vacuum-time=30d # 傳統日誌檔案 tail -f /var/log/syslog tail -f /var/log/auth.log tail -f /var/log/apache2/access.log # 日誌輪轉 sudo logrotate -d /etc/logrotate.conf sudo logrotate -f /etc/logrotate.conf 網路配置 網路接口管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 檢查網路接口 ip addr show ip link show ifconfig # 網路配置（Netplan） sudo nano /etc/netplan/00-installer-config.yaml # 範例 Netplan 配置 network: version: 2 renderer: networkd ethernets: enp0s3: dhcp4: true enp0s8: addresses: - 192.168.1.100/24 gateway4: 192.168.1.1 nameservers: addresses: [8.8.8.8, 1.1.1.1] # 應用網路配置 sudo netplan try sudo netplan apply # 重啟網路服務 sudo systemctl restart networking sudo systemctl restart systemd-networkd 防火牆設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # UFW 防火牆 sudo ufw status sudo ufw enable sudo ufw disable # 開放連接埠 sudo ufw allow 22/tcp sudo ufw allow 80/tcp sudo ufw allow 443/tcp sudo ufw allow from 192.168.1.0/24 # 拒絕連接 sudo ufw deny 23/tcp sudo ufw deny from 192.168.2.100 # 檢查規則 sudo ufw status numbered sudo ufw delete 1 # 重設防火牆 sudo ufw --force reset SSH 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 安裝和啟動 SSH sudo apt install openssh-server sudo systemctl start ssh sudo systemctl enable ssh # SSH 配置 sudo nano /etc/ssh/sshd_config # 重要 SSH 設定 Port 22 PermitRootLogin no PasswordAuthentication yes PubkeyAuthentication yes AllowUsers username # 重啟 SSH 服務 sudo systemctl restart ssh # SSH 金鑰管理 ssh-keygen -t rsa -b 4096 ssh-copy-id user@host 安全加固 系統安全設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 更新系統 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y # 安裝安全工具 sudo apt install fail2ban ufw rkhunter chkrootkit # 設定 fail2ban sudo nano /etc/fail2ban/jail.local [DEFAULT] bantime = 3600 findtime = 600 maxretry = 3 [sshd] enabled = true port = ssh filter = sshd logpath = /var/log/auth.log sudo systemctl restart fail2ban # 檢查安全狀態 sudo rkhunter --check sudo chkrootkit 檔案系統安全 1 2 3 4 5 6 7 8 9 10 11 12 13 # 設定適當的檔案權限 sudo chmod 644 /etc/passwd sudo chmod 600 /etc/shadow sudo chmod 644 /etc/group # 查找具有特殊權限的檔案 find / -perm -4000 -type f 2\u0026gt;/dev/null # SUID find / -perm -2000 -type f 2\u0026gt;/dev/null # SGID find / -perm -1000 -type d 2\u0026gt;/dev/null # Sticky bit # 檔案系統掃描 sudo find / -nouser -print 2\u0026gt;/dev/null sudo find / -nogroup -print 2\u0026gt;/dev/null 效能調整與最佳化 系統效能監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 系統效能監控腳本 #!/bin/bash # system_monitor.sh echo \u0026#34;=== System Performance Monitor ===\u0026#34; echo \u0026#34;Timestamp: $(date)\u0026#34; echo echo \u0026#34;=== CPU Information ===\u0026#34; echo \u0026#34;CPU Usage:\u0026#34; top -bn1 | grep \u0026#34;Cpu(s)\u0026#34; | awk \u0026#39;{print \u0026#34;CPU Load: \u0026#34; $2}\u0026#39; echo -e \u0026#34;\\nCPU Cores:\u0026#34; nproc echo \u0026#34;=== Memory Information ===\u0026#34; free -h echo -e \u0026#34;\\n=== Disk Usage ===\u0026#34; df -h | grep -E \u0026#39;^/dev/\u0026#39; echo -e \u0026#34;\\n=== Network Statistics ===\u0026#34; ss -tuln | wc -l | awk \u0026#39;{print \u0026#34;Active Connections: \u0026#34; $1}\u0026#39; echo -e \u0026#34;\\n=== System Load ===\u0026#34; uptime echo -e \u0026#34;\\n=== Top Processes by CPU ===\u0026#34; ps aux --sort=-%cpu | head -6 echo -e \u0026#34;\\n=== Top Processes by Memory ===\u0026#34; ps aux --sort=-%mem | head -6 系統清理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/bin/bash # system_cleanup.sh - 系統清理腳本 echo \u0026#34;Starting system cleanup...\u0026#34; # 清理套件快取 echo \u0026#34;Cleaning package cache...\u0026#34; sudo apt autoclean sudo apt autoremove -y # 清理日誌檔案 echo \u0026#34;Cleaning log files...\u0026#34; sudo journalctl --vacuum-time=30d # 清理暫存檔案 echo \u0026#34;Cleaning temporary files...\u0026#34; sudo rm -rf /tmp/* sudo rm -rf /var/tmp/* # 清理使用者暫存 echo \u0026#34;Cleaning user cache...\u0026#34; rm -rf ~/.cache/* rm -rf ~/.local/share/Trash/* # 清理舊核心 echo \u0026#34;Cleaning old kernels...\u0026#34; dpkg -l | grep linux-image | awk \u0026#39;{print $2}\u0026#39; | sort -V | head -n -2 | xargs sudo apt purge -y # 檢查磁碟空間 echo \u0026#34;Disk space after cleanup:\u0026#34; df -h echo \u0026#34;System cleanup completed!\u0026#34; 備份與恢復 系統備份 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #!/bin/bash # backup_system.sh - 系統備份腳本 BACKUP_DIR=\u0026#34;/backup\u0026#34; DATE=$(date +%Y%m%d_%H%M%S) HOSTNAME=$(hostname) mkdir -p \u0026#34;$BACKUP_DIR\u0026#34; echo \u0026#34;Starting system backup...\u0026#34; # 備份重要配置檔案 echo \u0026#34;Backing up configuration files...\u0026#34; tar -czf \u0026#34;$BACKUP_DIR/config_$HOSTNAME_$DATE.tar.gz\u0026#34; \\ /etc \\ /var/log \\ /home \\ --exclude=/home/*/.cache \\ --exclude=/home/*/Downloads # 備份已安裝套件列表 echo \u0026#34;Backing up package list...\u0026#34; dpkg --get-selections \u0026gt; \u0026#34;$BACKUP_DIR/packages_$HOSTNAME_$DATE.txt\u0026#34; apt-mark showmanual \u0026gt; \u0026#34;$BACKUP_DIR/manual_packages_$HOSTNAME_$DATE.txt\u0026#34; # 備份系統資訊 echo \u0026#34;Backing up system information...\u0026#34; { echo \u0026#34;=== System Information ===\u0026#34; uname -a lsb_release -a echo -e \u0026#34;\\n=== Hardware Information ===\u0026#34; lscpu free -h df -h echo -e \u0026#34;\\n=== Network Configuration ===\u0026#34; ip addr show } \u0026gt; \u0026#34;$BACKUP_DIR/system_info_$HOSTNAME_$DATE.txt\u0026#34; echo \u0026#34;Backup completed: $BACKUP_DIR\u0026#34; ls -la \u0026#34;$BACKUP_DIR\u0026#34;/*$DATE* 系統恢復 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/bin/bash # restore_system.sh - 系統恢復腳本 BACKUP_FILE=\u0026#34;$1\u0026#34; if [ -z \u0026#34;$BACKUP_FILE\u0026#34; ]; then echo \u0026#34;Usage: $0 \u0026lt;backup_file.tar.gz\u0026gt;\u0026#34; exit 1 fi if [ ! -f \u0026#34;$BACKUP_FILE\u0026#34; ]; then echo \u0026#34;Backup file not found: $BACKUP_FILE\u0026#34; exit 1 fi echo \u0026#34;WARNING: This will restore system files from backup.\u0026#34; echo \u0026#34;Backup file: $BACKUP_FILE\u0026#34; read -p \u0026#34;Continue? (y/N): \u0026#34; confirm if [[ $confirm != [yY] ]]; then echo \u0026#34;Restore cancelled.\u0026#34; exit 0 fi echo \u0026#34;Starting system restore...\u0026#34; # 備份當前配置 echo \u0026#34;Backing up current configuration...\u0026#34; sudo tar -czf \u0026#34;/tmp/current_config_$(date +%Y%m%d_%H%M%S).tar.gz\u0026#34; /etc # 恢復檔案 echo \u0026#34;Restoring files...\u0026#34; sudo tar -xzf \u0026#34;$BACKUP_FILE\u0026#34; -C / echo \u0026#34;Restore completed. Please reboot the system.\u0026#34; 自動化腳本 系統初始化腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #!/bin/bash # ubuntu_setup.sh - Ubuntu 系統初始化腳本 set -e echo \u0026#34;=== Ubuntu System Setup Script ===\u0026#34; # 更新系統 echo \u0026#34;Updating system...\u0026#34; sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y # 安裝基本工具 echo \u0026#34;Installing essential tools...\u0026#34; sudo apt install -y \\ curl \\ wget \\ git \\ vim \\ htop \\ tree \\ unzip \\ zip \\ jq \\ build-essential \\ software-properties-common \\ apt-transport-https \\ ca-certificates \\ gnupg \\ lsb-release # 安裝開發工具 echo \u0026#34;Installing development tools...\u0026#34; sudo apt install -y \\ python3 \\ python3-pip \\ nodejs \\ npm \\ default-jdk \\ golang-go # 安裝 Docker echo \u0026#34;Installing Docker...\u0026#34; curl -fsSL https://get.docker.com | sh sudo usermod -aG docker $USER # 配置 Git echo \u0026#34;Configuring Git...\u0026#34; read -p \u0026#34;Enter your Git username: \u0026#34; git_username read -p \u0026#34;Enter your Git email: \u0026#34; git_email git config --global user.name \u0026#34;$git_username\u0026#34; git config --global user.email \u0026#34;$git_email\u0026#34; # 設定 SSH echo \u0026#34;Setting up SSH...\u0026#34; sudo systemctl enable ssh sudo systemctl start ssh # 安裝常用軟體 echo \u0026#34;Installing common applications...\u0026#34; sudo apt install -y \\ firefox \\ vlc \\ gimp \\ libreoffice \\ thunderbird # 清理 echo \u0026#34;Cleaning up...\u0026#34; sudo apt autoremove -y sudo apt autoclean echo \u0026#34;=== Setup completed! ===\u0026#34; echo \u0026#34;Please reboot the system to ensure all changes take effect.\u0026#34; 故障排除 常見問題解決 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 套件管理問題 sudo apt update --fix-missing sudo dpkg --configure -a sudo apt install -f # 網路連接問題 sudo systemctl restart networking sudo systemctl restart systemd-resolved sudo dhclient -r \u0026amp;\u0026amp; sudo dhclient # SSH 連接問題 sudo systemctl status ssh sudo systemctl restart ssh sudo tail -f /var/log/auth.log # 磁碟空間不足 sudo du -sh /* | sort -hr sudo find / -type f -size +100M sudo apt autoremove sudo apt autoclean # 記憶體不足 free -h sudo swapoff -a \u0026amp;\u0026amp; sudo swapon -a echo 3 | sudo tee /proc/sys/vm/drop_caches 總結 核心優勢 穩定可靠：企業級穩定性和長期支援 易於使用：友好的使用者介面和豐富的文檔 套件豐富：強大的 APT 套件管理系統 社群支援：活躍的開發者和使用者社群 容器化友好：優秀的 Docker 和雲端支援 最佳實踐 定期更新：保持系統和軟體包的最新狀態 安全加固：配置防火牆、fail2ban 和適當的使用者權限 監控系統：定期檢查系統效能和資源使用情況 備份重要資料：建立定期備份策略 文檔記錄：記錄系統配置和變更 學習路徑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 初學者階段 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade # 系統更新 sudo apt install package-name # 軟體安裝 systemctl status service-name # 服務管理 # 進階階段 docker run -it ubuntu:latest # 容器化應用 sudo ufw allow 80/tcp # 防火牆配置 sudo journalctl -u service-name # 日誌分析 # 專家階段 netplan apply # 網路配置 systemctl edit service-name # 服務自定義 crontab -e # 自動化任務 Ubuntu 是現代 Linux 發行版的代表，掌握其使用技巧能夠大幅提升系統管理和開發效率。記住：理解 Linux 基礎概念是有效使用 Ubuntu 的關鍵，善用社群資源和文檔可以解決大部分問題。\n參考資料 Ubuntu Official Documentation Ubuntu Community Help Wiki APT User\u0026rsquo;s Guide systemd Documentation Docker on Ubuntu ","permalink":"https://xinqilin.github.io/post/tools/ubuntu/","tags":["Ubuntu","Linux","System Administration","Package Management","Docker","Server","Command Line"],"title":"Ubuntu 系統管理完整指南：Linux 入門到進階實戰"},{"content":"Java TreeSet 完整實作指南 簡介 TreeSet 是 Java 集合框架中實現有序集合的核心類別，基於 TreeMap 實現並使用紅黑樹（Red-Black Tree）數據結構。它保證元素的唯一性和有序性，提供了 O(log n) 的時間複雜度進行搜索、插入和刪除操作。本文將深入探討 TreeSet 的內部實現、各種方法使用、效能特性以及在企業級開發中的最佳實踐。\nTreeSet 架構與繼承關係 類別繼承結構 1 2 3 4 5 6 7 8 9 Collection\u0026lt;E\u0026gt; ↑ Set\u0026lt;E\u0026gt; ↑ SortedSet\u0026lt;E\u0026gt; ↑ NavigableSet\u0026lt;E\u0026gt; ↑ TreeSet\u0026lt;E\u0026gt; 核心介面關係 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 基本集合介面 public interface Set\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt; { boolean add(E e); boolean remove(Object o); boolean contains(Object o); int size(); boolean isEmpty(); Iterator\u0026lt;E\u0026gt; iterator(); } // 有序集合介面 public interface SortedSet\u0026lt;E\u0026gt; extends Set\u0026lt;E\u0026gt; { Comparator\u0026lt;? super E\u0026gt; comparator(); SortedSet\u0026lt;E\u0026gt; subSet(E fromElement, E toElement); SortedSet\u0026lt;E\u0026gt; headSet(E toElement); SortedSet\u0026lt;E\u0026gt; tailSet(E fromElement); E first(); E last(); } // 可導航集合介面 public interface NavigableSet\u0026lt;E\u0026gt; extends SortedSet\u0026lt;E\u0026gt; { E lower(E e); E floor(E e); E ceiling(E e); E higher(E e); E pollFirst(); E pollLast(); Iterator\u0026lt;E\u0026gt; iterator(); NavigableSet\u0026lt;E\u0026gt; descendingSet(); Iterator\u0026lt;E\u0026gt; descendingIterator(); NavigableSet\u0026lt;E\u0026gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive); NavigableSet\u0026lt;E\u0026gt; headSet(E toElement, boolean inclusive); NavigableSet\u0026lt;E\u0026gt; tailSet(E fromElement, boolean inclusive); } TreeSet 核心特性 1. 基於 TreeMap 的實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // TreeSet 內部實現 public class TreeSet\u0026lt;E\u0026gt; extends AbstractSet\u0026lt;E\u0026gt; implements NavigableSet\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable { // 內部使用 TreeMap 存儲元素 private transient NavigableMap\u0026lt;E,Object\u0026gt; m; // 虛擬值，用於將 Set 轉換為 Map private static final Object PRESENT = new Object(); // 構造函數 public TreeSet() { this(new TreeMap\u0026lt;E,Object\u0026gt;()); } public TreeSet(Comparator\u0026lt;? super E\u0026gt; comparator) { this(new TreeMap\u0026lt;\u0026gt;(comparator)); } // 基本操作 public boolean add(E e) { return m.put(e, PRESENT) == null; } public boolean remove(Object o) { return m.remove(o) == PRESENT; } public boolean contains(Object o) { return m.containsKey(o); } public int size() { return m.size(); } } 2. 自然排序與自定義比較器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 自然排序 TreeSet TreeSet\u0026lt;String\u0026gt; naturalOrder = new TreeSet\u0026lt;\u0026gt;(); naturalOrder.add(\u0026#34;Charlie\u0026#34;); naturalOrder.add(\u0026#34;Alice\u0026#34;); naturalOrder.add(\u0026#34;Bob\u0026#34;); // 結果：[Alice, Bob, Charlie] // 自定義比較器 - 按長度排序 TreeSet\u0026lt;String\u0026gt; lengthOrder = new TreeSet\u0026lt;\u0026gt;( Comparator.comparing(String::length) .thenComparing(String::compareTo) // 長度相同時按字典序 ); lengthOrder.add(\u0026#34;Java\u0026#34;); lengthOrder.add(\u0026#34;C++\u0026#34;); lengthOrder.add(\u0026#34;Python\u0026#34;); lengthOrder.add(\u0026#34;Go\u0026#34;); // 結果：[Go, C++, Java, Python] // 降序排序 TreeSet\u0026lt;Integer\u0026gt; descendingOrder = new TreeSet\u0026lt;\u0026gt;(Collections.reverseOrder()); descendingOrder.add(5); descendingOrder.add(2); descendingOrder.add(8); descendingOrder.add(1); // 結果：[8, 5, 2, 1] // 複雜對象排序 TreeSet\u0026lt;Person\u0026gt; personSet = new TreeSet\u0026lt;\u0026gt;( Comparator.comparing(Person::getAge) .thenComparing(Person::getName) ); SortedSet 介面詳解 基本方法實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 public class TreeSetSortedExample { public static void main(String[] args) { TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); // 添加元素 treeSet.add(5); treeSet.add(2); treeSet.add(8); treeSet.add(1); treeSet.add(9); treeSet.add(3); demonstrateSortedSetMethods(treeSet); } private static void demonstrateSortedSetMethods(TreeSet\u0026lt;Integer\u0026gt; set) { System.out.println(\u0026#34;Original set: \u0026#34; + set); // [1, 2, 3, 5, 8, 9] // 獲取比較器 Comparator\u0026lt;? super Integer\u0026gt; comparator = set.comparator(); System.out.println(\u0026#34;Comparator: \u0026#34; + comparator); // null (natural ordering) // 第一個和最後一個元素 System.out.println(\u0026#34;First element: \u0026#34; + set.first()); // 1 System.out.println(\u0026#34;Last element: \u0026#34; + set.last()); // 9 // 子集合（含頭不含尾） SortedSet\u0026lt;Integer\u0026gt; subSet = set.subSet(2, 8); System.out.println(\u0026#34;SubSet [2, 8): \u0026#34; + subSet); // [2, 3, 5] // 頭部集合（不包含指定元素） SortedSet\u0026lt;Integer\u0026gt; headSet = set.headSet(5); System.out.println(\u0026#34;HeadSet (\u0026lt; 5): \u0026#34; + headSet); // [1, 2, 3] // 尾部集合（包含指定元素） SortedSet\u0026lt;Integer\u0026gt; tailSet = set.tailSet(5); System.out.println(\u0026#34;TailSet (\u0026gt;= 5): \u0026#34; + tailSet); // [5, 8, 9] // 迭代器 System.out.print(\u0026#34;Forward iteration: \u0026#34;); for (Integer value : set) { System.out.print(value + \u0026#34; \u0026#34;); } System.out.println(); // 降序迭代器 System.out.print(\u0026#34;Descending iteration: \u0026#34;); Iterator\u0026lt;Integer\u0026gt; descendingIterator = set.descendingIterator(); while (descendingIterator.hasNext()) { System.out.print(descendingIterator.next() + \u0026#34; \u0026#34;); } System.out.println(); } } NavigableSet 介面詳解 導航方法實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 public class TreeSetNavigableExample { public static void main(String[] args) { TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); // 添加測試數據 treeSet.add(1); treeSet.add(3); treeSet.add(5); treeSet.add(7); treeSet.add(9); demonstrateNavigableMethods(treeSet); } private static void demonstrateNavigableMethods(TreeSet\u0026lt;Integer\u0026gt; set) { System.out.println(\u0026#34;Original set: \u0026#34; + set); // [1, 3, 5, 7, 9] // Lower 方法：返回嚴格小於指定元素的最大元素 Integer lower = set.lower(5); System.out.println(\u0026#34;Lower (\u0026lt; 5): \u0026#34; + lower); // 3 // Floor 方法：返回小於或等於指定元素的最大元素 Integer floor1 = set.floor(4); Integer floor2 = set.floor(5); System.out.println(\u0026#34;Floor (\u0026lt;= 4): \u0026#34; + floor1); // 3 System.out.println(\u0026#34;Floor (\u0026lt;= 5): \u0026#34; + floor2); // 5 // Ceiling 方法：返回大於或等於指定元素的最小元素 Integer ceiling1 = set.ceiling(4); Integer ceiling2 = set.ceiling(5); System.out.println(\u0026#34;Ceiling (\u0026gt;= 4): \u0026#34; + ceiling1); // 5 System.out.println(\u0026#34;Ceiling (\u0026gt;= 5): \u0026#34; + ceiling2); // 5 // Higher 方法：返回嚴格大於指定元素的最小元素 Integer higher = set.higher(5); System.out.println(\u0026#34;Higher (\u0026gt; 5): \u0026#34; + higher); // 7 // 彈出首尾元素（會刪除元素） TreeSet\u0026lt;Integer\u0026gt; copySet = new TreeSet\u0026lt;\u0026gt;(set); Integer pollFirst = copySet.pollFirst(); Integer pollLast = copySet.pollLast(); System.out.println(\u0026#34;Poll first: \u0026#34; + pollFirst); // 1 System.out.println(\u0026#34;Poll last: \u0026#34; + pollLast); // 9 System.out.println(\u0026#34;After polling: \u0026#34; + copySet); // [3, 5, 7] // 降序視圖 NavigableSet\u0026lt;Integer\u0026gt; descendingSet = set.descendingSet(); System.out.println(\u0026#34;Descending set: \u0026#34; + descendingSet); // [9, 7, 5, 3, 1] // 範圍視圖 NavigableSet\u0026lt;Integer\u0026gt; rangeSet = set.subSet(3, true, 7, false); System.out.println(\u0026#34;Range [3, 7): \u0026#34; + rangeSet); // [3, 5] NavigableSet\u0026lt;Integer\u0026gt; headSet = set.headSet(5, true); System.out.println(\u0026#34;Head set (\u0026lt;= 5): \u0026#34; + headSet); // [1, 3, 5] NavigableSet\u0026lt;Integer\u0026gt; tailSet = set.tailSet(5, false); System.out.println(\u0026#34;Tail set (\u0026gt; 5): \u0026#34; + tailSet); // [7, 9] // 查找操作 demonstrateSearchOperations(set); } private static void demonstrateSearchOperations(TreeSet\u0026lt;Integer\u0026gt; set) { System.out.println(\u0026#34;\\n=== Search Operations ===\u0026#34;); // 測試不存在的元素 int target = 4; System.out.println(\u0026#34;Searching for: \u0026#34; + target); System.out.println(\u0026#34;Contains: \u0026#34; + set.contains(target)); // false System.out.println(\u0026#34;Lower: \u0026#34; + set.lower(target)); // 3 System.out.println(\u0026#34;Floor: \u0026#34; + set.floor(target)); // 3 System.out.println(\u0026#34;Ceiling: \u0026#34; + set.ceiling(target)); // 5 System.out.println(\u0026#34;Higher: \u0026#34; + set.higher(target)); // 5 // 測試邊界情況 System.out.println(\u0026#34;\\n=== Boundary Cases ===\u0026#34;); System.out.println(\u0026#34;Lower than first: \u0026#34; + set.lower(1)); // null System.out.println(\u0026#34;Higher than last: \u0026#34; + set.higher(9)); // null System.out.println(\u0026#34;Floor of first: \u0026#34; + set.floor(1)); // 1 System.out.println(\u0026#34;Ceiling of last: \u0026#34; + set.ceiling(9)); // 9 } } 企業級應用實例 1. 事件調度系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 public class EventScheduler { private final TreeSet\u0026lt;Event\u0026gt; eventQueue; private final ScheduledExecutorService scheduler; private final AtomicBoolean running; public EventScheduler() { // 按時間排序事件 this.eventQueue = new TreeSet\u0026lt;\u0026gt;(Comparator.comparing(Event::getScheduledTime)); this.scheduler = Executors.newScheduledThreadPool(2); this.running = new AtomicBoolean(false); } // 調度事件 public void scheduleEvent(Event event) { synchronized (eventQueue) { eventQueue.add(event); // 如果是最早的事件，重新調度 if (event.equals(eventQueue.first())) { rescheduleNext(); } } } // 取消事件 public boolean cancelEvent(Event event) { synchronized (eventQueue) { boolean removed = eventQueue.remove(event); if (removed \u0026amp;\u0026amp; !eventQueue.isEmpty()) { rescheduleNext(); } return removed; } } // 獲取即將執行的事件 public List\u0026lt;Event\u0026gt; getUpcomingEvents(int count) { synchronized (eventQueue) { return eventQueue.stream() .limit(count) .collect(Collectors.toList()); } } // 獲取指定時間範圍內的事件 public List\u0026lt;Event\u0026gt; getEventsInRange(LocalDateTime start, LocalDateTime end) { synchronized (eventQueue) { Event startEvent = new Event(\u0026#34;\u0026#34;, start, null); Event endEvent = new Event(\u0026#34;\u0026#34;, end, null); return eventQueue.subSet(startEvent, true, endEvent, false) .stream() .collect(Collectors.toList()); } } // 啟動調度器 public void start() { if (running.compareAndSet(false, true)) { rescheduleNext(); } } // 停止調度器 public void stop() { running.set(false); scheduler.shutdown(); } // 重新調度下一個事件 private void rescheduleNext() { if (!running.get()) { return; } synchronized (eventQueue) { if (eventQueue.isEmpty()) { return; } Event nextEvent = eventQueue.first(); LocalDateTime now = LocalDateTime.now(); if (nextEvent.getScheduledTime().isBefore(now)) { // 立即執行過期事件 scheduler.submit(this::processNextEvent); } else { // 計算延遲時間 long delay = Duration.between(now, nextEvent.getScheduledTime()).toMillis(); scheduler.schedule(this::processNextEvent, delay, TimeUnit.MILLISECONDS); } } } // 處理下一個事件 private void processNextEvent() { Event event = null; synchronized (eventQueue) { if (!eventQueue.isEmpty()) { event = eventQueue.pollFirst(); } } if (event != null) { try { event.execute(); } catch (Exception e) { System.err.println(\u0026#34;Event execution failed: \u0026#34; + event.getName()); e.printStackTrace(); } } // 調度下一個事件 rescheduleNext(); } // 清理過期事件 public int cleanupExpiredEvents() { synchronized (eventQueue) { LocalDateTime cutoff = LocalDateTime.now().minusHours(24); Event cutoffEvent = new Event(\u0026#34;\u0026#34;, cutoff, null); NavigableSet\u0026lt;Event\u0026gt; expiredEvents = eventQueue.headSet(cutoffEvent, true); int count = expiredEvents.size(); expiredEvents.clear(); return count; } } // 獲取統計信息 public EventStatistics getStatistics() { synchronized (eventQueue) { LocalDateTime now = LocalDateTime.now(); long pendingEvents = eventQueue.size(); long overdueEvents = eventQueue.stream() .filter(event -\u0026gt; event.getScheduledTime().isBefore(now)) .count(); LocalDateTime nextEventTime = eventQueue.isEmpty() ? null : eventQueue.first().getScheduledTime(); return new EventStatistics(pendingEvents, overdueEvents, nextEventTime); } } // 事件類 public static class Event { private final String name; private final LocalDateTime scheduledTime; private final Runnable action; public Event(String name, LocalDateTime scheduledTime, Runnable action) { this.name = name; this.scheduledTime = scheduledTime; this.action = action; } public void execute() { if (action != null) { action.run(); } } // Getters public String getName() { return name; } public LocalDateTime getScheduledTime() { return scheduledTime; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Event event = (Event) obj; return Objects.equals(name, event.name) \u0026amp;\u0026amp; Objects.equals(scheduledTime, event.scheduledTime); } @Override public int hashCode() { return Objects.hash(name, scheduledTime); } } // 統計信息類 public static class EventStatistics { private final long pendingEvents; private final long overdueEvents; private final LocalDateTime nextEventTime; public EventStatistics(long pendingEvents, long overdueEvents, LocalDateTime nextEventTime) { this.pendingEvents = pendingEvents; this.overdueEvents = overdueEvents; this.nextEventTime = nextEventTime; } // Getters public long getPendingEvents() { return pendingEvents; } public long getOverdueEvents() { return overdueEvents; } public LocalDateTime getNextEventTime() { return nextEventTime; } } } 2. 範圍查詢緩存系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 public class RangeQueryCache\u0026lt;T extends Comparable\u0026lt;T\u0026gt;\u0026gt; { private final TreeSet\u0026lt;CacheEntry\u0026lt;T\u0026gt;\u0026gt; cache; private final int maxSize; private final long ttlMillis; public RangeQueryCache(int maxSize, long ttlMillis) { this.cache = new TreeSet\u0026lt;\u0026gt;(Comparator.comparing(CacheEntry::getKey)); this.maxSize = maxSize; this.ttlMillis = ttlMillis; } // 添加緩存項 public void put(T key, Object value) { synchronized (cache) { // 移除舊值 cache.removeIf(entry -\u0026gt; entry.getKey().equals(key)); // 添加新值 CacheEntry\u0026lt;T\u0026gt; entry = new CacheEntry\u0026lt;\u0026gt;(key, value, System.currentTimeMillis() + ttlMillis); cache.add(entry); // 清理過期項 cleanupExpired(); // 如果超過容量，移除最舊的項 if (cache.size() \u0026gt; maxSize) { cache.pollFirst(); } } } // 獲取單個值 public Object get(T key) { synchronized (cache) { CacheEntry\u0026lt;T\u0026gt; searchEntry = new CacheEntry\u0026lt;\u0026gt;(key, null, 0); CacheEntry\u0026lt;T\u0026gt; found = cache.floor(searchEntry); if (found != null \u0026amp;\u0026amp; found.getKey().equals(key) \u0026amp;\u0026amp; !found.isExpired()) { return found.getValue(); } return null; } } // 範圍查詢 public List\u0026lt;Object\u0026gt; getRangeValues(T fromKey, T toKey) { synchronized (cache) { CacheEntry\u0026lt;T\u0026gt; fromEntry = new CacheEntry\u0026lt;\u0026gt;(fromKey, null, 0); CacheEntry\u0026lt;T\u0026gt; toEntry = new CacheEntry\u0026lt;\u0026gt;(toKey, null, 0); return cache.subSet(fromEntry, true, toEntry, true) .stream() .filter(entry -\u0026gt; !entry.isExpired()) .map(CacheEntry::getValue) .collect(Collectors.toList()); } } // 獲取最接近的值 public Object getClosest(T key) { synchronized (cache) { CacheEntry\u0026lt;T\u0026gt; searchEntry = new CacheEntry\u0026lt;\u0026gt;(key, null, 0); CacheEntry\u0026lt;T\u0026gt; floor = cache.floor(searchEntry); CacheEntry\u0026lt;T\u0026gt; ceiling = cache.ceiling(searchEntry); CacheEntry\u0026lt;T\u0026gt; closest = null; if (floor != null \u0026amp;\u0026amp; !floor.isExpired()) { closest = floor; } if (ceiling != null \u0026amp;\u0026amp; !ceiling.isExpired()) { if (closest == null || key.compareTo(ceiling.getKey()) \u0026lt; closest.getKey().compareTo(key)) { closest = ceiling; } } return closest != null ? closest.getValue() : null; } } // 獲取前 N 個值 public List\u0026lt;Object\u0026gt; getTopN(int n) { synchronized (cache) { return cache.stream() .filter(entry -\u0026gt; !entry.isExpired()) .limit(n) .map(CacheEntry::getValue) .collect(Collectors.toList()); } } // 清理過期項 private void cleanupExpired() { long now = System.currentTimeMillis(); cache.removeIf(entry -\u0026gt; entry.getExpirationTime() \u0026lt; now); } // 清空緩存 public void clear() { synchronized (cache) { cache.clear(); } } // 獲取緩存統計 public CacheStatistics getStatistics() { synchronized (cache) { cleanupExpired(); return new CacheStatistics(cache.size(), maxSize, getHitRatio()); } } private double getHitRatio() { // 簡化實現，實際應用中需要跟蹤命中率 return 0.85; // 示例值 } // 緩存項 private static class CacheEntry\u0026lt;T\u0026gt; { private final T key; private final Object value; private final long expirationTime; public CacheEntry(T key, Object value, long expirationTime) { this.key = key; this.value = value; this.expirationTime = expirationTime; } public boolean isExpired() { return System.currentTimeMillis() \u0026gt; expirationTime; } // Getters public T getKey() { return key; } public Object getValue() { return value; } public long getExpirationTime() { return expirationTime; } } // 統計信息 public static class CacheStatistics { private final int currentSize; private final int maxSize; private final double hitRatio; public CacheStatistics(int currentSize, int maxSize, double hitRatio) { this.currentSize = currentSize; this.maxSize = maxSize; this.hitRatio = hitRatio; } // Getters public int getCurrentSize() { return currentSize; } public int getMaxSize() { return maxSize; } public double getHitRatio() { return hitRatio; } } } 3. 分數排名系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 public class LeaderboardSystem { private final TreeSet\u0026lt;Player\u0026gt; leaderboard; private final Map\u0026lt;String, Player\u0026gt; playerMap; private final int maxSize; public LeaderboardSystem(int maxSize) { // 按分數降序排列，分數相同時按名稱升序 this.leaderboard = new TreeSet\u0026lt;\u0026gt;( Comparator.comparing(Player::getScore, Comparator.reverseOrder()) .thenComparing(Player::getName) ); this.playerMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); this.maxSize = maxSize; } // 更新玩家分數 public void updateScore(String playerName, int score) { synchronized (leaderboard) { // 移除舊記錄 Player oldPlayer = playerMap.get(playerName); if (oldPlayer != null) { leaderboard.remove(oldPlayer); } // 添加新記錄 Player newPlayer = new Player(playerName, score, System.currentTimeMillis()); leaderboard.add(newPlayer); playerMap.put(playerName, newPlayer); // 保持排行榜大小 if (leaderboard.size() \u0026gt; maxSize) { Player removed = leaderboard.pollLast(); playerMap.remove(removed.getName()); } } } // 獲取排行榜 public List\u0026lt;Player\u0026gt; getLeaderboard() { synchronized (leaderboard) { return new ArrayList\u0026lt;\u0026gt;(leaderboard); } } // 獲取前 N 名 public List\u0026lt;Player\u0026gt; getTopN(int n) { synchronized (leaderboard) { return leaderboard.stream() .limit(n) .collect(Collectors.toList()); } } // 獲取玩家排名 public int getPlayerRank(String playerName) { synchronized (leaderboard) { Player player = playerMap.get(playerName); if (player == null) { return -1; } return leaderboard.headSet(player, false).size() + 1; } } // 獲取玩家分數 public int getPlayerScore(String playerName) { Player player = playerMap.get(playerName); return player != null ? player.getScore() : -1; } // 獲取分數範圍內的玩家 public List\u0026lt;Player\u0026gt; getPlayersInScoreRange(int minScore, int maxScore) { synchronized (leaderboard) { // 創建邊界對象 Player minPlayer = new Player(\u0026#34;\u0026#34;, minScore, 0); Player maxPlayer = new Player(\u0026#34;\u0026#34;, maxScore, 0); return leaderboard.subSet(maxPlayer, true, minPlayer, true) .stream() .filter(p -\u0026gt; p.getScore() \u0026gt;= minScore \u0026amp;\u0026amp; p.getScore() \u0026lt;= maxScore) .collect(Collectors.toList()); } } // 獲取玩家周圍的排名 public List\u0026lt;Player\u0026gt; getPlayersAround(String playerName, int radius) { synchronized (leaderboard) { Player player = playerMap.get(playerName); if (player == null) { return new ArrayList\u0026lt;\u0026gt;(); } List\u0026lt;Player\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // 獲取前面的玩家 NavigableSet\u0026lt;Player\u0026gt; before = leaderboard.headSet(player, false); before.descendingSet().stream() .limit(radius) .forEach(result::add); Collections.reverse(result); // 添加當前玩家 result.add(player); // 獲取後面的玩家 NavigableSet\u0026lt;Player\u0026gt; after = leaderboard.tailSet(player, false); after.stream() .limit(radius) .forEach(result::add); return result; } } // 移除玩家 public boolean removePlayer(String playerName) { synchronized (leaderboard) { Player player = playerMap.remove(playerName); if (player != null) { return leaderboard.remove(player); } return false; } } // 清空排行榜 public void clear() { synchronized (leaderboard) { leaderboard.clear(); playerMap.clear(); } } // 獲取統計信息 public LeaderboardStatistics getStatistics() { synchronized (leaderboard) { if (leaderboard.isEmpty()) { return new LeaderboardStatistics(0, 0, 0, 0); } int totalPlayers = leaderboard.size(); int highestScore = leaderboard.first().getScore(); int lowestScore = leaderboard.last().getScore(); double averageScore = leaderboard.stream() .mapToInt(Player::getScore) .average() .orElse(0.0); return new LeaderboardStatistics(totalPlayers, highestScore, lowestScore, averageScore); } } // 玩家類 public static class Player { private final String name; private final int score; private final long timestamp; public Player(String name, int score, long timestamp) { this.name = name; this.score = score; this.timestamp = timestamp; } // Getters public String getName() { return name; } public int getScore() { return score; } public long getTimestamp() { return timestamp; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Player player = (Player) obj; return score == player.score \u0026amp;\u0026amp; Objects.equals(name, player.name); } @Override public int hashCode() { return Objects.hash(name, score); } @Override public String toString() { return String.format(\u0026#34;Player{name=\u0026#39;%s\u0026#39;, score=%d}\u0026#34;, name, score); } } // 統計信息 public static class LeaderboardStatistics { private final int totalPlayers; private final int highestScore; private final int lowestScore; private final double averageScore; public LeaderboardStatistics(int totalPlayers, int highestScore, int lowestScore, double averageScore) { this.totalPlayers = totalPlayers; this.highestScore = highestScore; this.lowestScore = lowestScore; this.averageScore = averageScore; } // Getters public int getTotalPlayers() { return totalPlayers; } public int getHighestScore() { return highestScore; } public int getLowestScore() { return lowestScore; } public double getAverageScore() { return averageScore; } } } 效能分析與優化 1. 時間複雜度分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 public class TreeSetPerformanceAnalysis { public static void main(String[] args) { performanceComparison(); memoryAnalysis(); concurrencyTest(); } // 效能比較 private static void performanceComparison() { int[] sizes = {1000, 10000, 100000, 1000000}; for (int size : sizes) { System.out.println(\u0026#34;Size: \u0026#34; + size); // TreeSet 測試 long startTime = System.nanoTime(); TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; size; i++) { treeSet.add(i); } long treeSetInsertTime = System.nanoTime() - startTime; // 搜索測試 startTime = System.nanoTime(); for (int i = 0; i \u0026lt; 1000; i++) { treeSet.contains(i * size / 1000); } long treeSetSearchTime = System.nanoTime() - startTime; // HashSet 比較 startTime = System.nanoTime(); HashSet\u0026lt;Integer\u0026gt; hashSet = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; size; i++) { hashSet.add(i); } long hashSetInsertTime = System.nanoTime() - startTime; startTime = System.nanoTime(); for (int i = 0; i \u0026lt; 1000; i++) { hashSet.contains(i * size / 1000); } long hashSetSearchTime = System.nanoTime() - startTime; System.out.printf(\u0026#34;TreeSet - Insert: %d ns, Search: %d ns\\n\u0026#34;, treeSetInsertTime, treeSetSearchTime); System.out.printf(\u0026#34;HashSet - Insert: %d ns, Search: %d ns\\n\\n\u0026#34;, hashSetInsertTime, hashSetSearchTime); } } // 記憶體分析 private static void memoryAnalysis() { Runtime runtime = Runtime.getRuntime(); runtime.gc(); long beforeMemory = runtime.totalMemory() - runtime.freeMemory(); TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100000; i++) { treeSet.add(i); } long afterMemory = runtime.totalMemory() - runtime.freeMemory(); System.out.println(\u0026#34;TreeSet memory usage: \u0026#34; + (afterMemory - beforeMemory) + \u0026#34; bytes\u0026#34;); // 對比 HashSet runtime.gc(); beforeMemory = runtime.totalMemory() - runtime.freeMemory(); HashSet\u0026lt;Integer\u0026gt; hashSet = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100000; i++) { hashSet.add(i); } afterMemory = runtime.totalMemory() - runtime.freeMemory(); System.out.println(\u0026#34;HashSet memory usage: \u0026#34; + (afterMemory - beforeMemory) + \u0026#34; bytes\u0026#34;); } // 並發測試 private static void concurrencyTest() { TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); ConcurrentSkipListSet\u0026lt;Integer\u0026gt; concurrentSet = new ConcurrentSkipListSet\u0026lt;\u0026gt;(); // 填充初始數據 for (int i = 0; i \u0026lt; 10000; i++) { treeSet.add(i); concurrentSet.add(i); } // 並發讀取測試 int threadCount = 4; ExecutorService executor = Executors.newFixedThreadPool(threadCount); System.out.println(\u0026#34;Concurrent read test:\u0026#34;); // TreeSet 同步讀取 long startTime = System.nanoTime(); CountDownLatch latch = new CountDownLatch(threadCount); for (int i = 0; i \u0026lt; threadCount; i++) { executor.submit(() -\u0026gt; { try { for (int j = 0; j \u0026lt; 10000; j++) { synchronized (treeSet) { treeSet.contains(j); } } } finally { latch.countDown(); } }); } try { latch.await(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } long treeSetTime = System.nanoTime() - startTime; System.out.println(\u0026#34;TreeSet (synchronized): \u0026#34; + treeSetTime + \u0026#34; ns\u0026#34;); // ConcurrentSkipListSet 測試 startTime = System.nanoTime(); latch = new CountDownLatch(threadCount); for (int i = 0; i \u0026lt; threadCount; i++) { executor.submit(() -\u0026gt; { try { for (int j = 0; j \u0026lt; 10000; j++) { concurrentSet.contains(j); } } finally { latch.countDown(); } }); } try { latch.await(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } long concurrentSetTime = System.nanoTime() - startTime; System.out.println(\u0026#34;ConcurrentSkipListSet: \u0026#34; + concurrentSetTime + \u0026#34; ns\u0026#34;); executor.shutdown(); } } 2. 最佳化建議 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 public class TreeSetOptimizationTips { // 1. 使用適當的比較器 public static void comparatorOptimization() { // 避免在比較器中進行複雜計算 TreeSet\u0026lt;String\u0026gt; badExample = new TreeSet\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { // 壞例子：每次比較都進行昂貴的計算 return expensiveCalculation(s1) - expensiveCalculation(s2); }); // 好例子：預先計算或使用緩存 Map\u0026lt;String, Integer\u0026gt; cache = new ConcurrentHashMap\u0026lt;\u0026gt;(); TreeSet\u0026lt;String\u0026gt; goodExample = new TreeSet\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { int val1 = cache.computeIfAbsent(s1, TreeSetOptimizationTips::expensiveCalculation); int val2 = cache.computeIfAbsent(s2, TreeSetOptimizationTips::expensiveCalculation); return val1 - val2; }); } // 2. 批量操作優化 public static void batchOperationOptimization() { TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); // 批量添加比單個添加效率更高 Collection\u0026lt;Integer\u0026gt; batchData = Arrays.asList(1, 2, 3, 4, 5); treeSet.addAll(batchData); // 使用子集合進行批量操作 NavigableSet\u0026lt;Integer\u0026gt; subSet = treeSet.subSet(2, true, 4, false); subSet.clear(); // 比逐個刪除效率更高 } // 3. 記憶體優化 public static void memoryOptimization() { // 使用原始類型包裝器時注意自動裝箱 TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 避免不必要的對象創建 for (int i = 0; i \u0026lt; 1000; i++) { set.add(i); // 會創建 Integer 對象 } // 考慮使用專門的原始類型集合庫 // 如 Eclipse Collections 的 IntSortedSet } // 4. 並發優化 public static void concurrencyOptimization() { TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); // 使用 ConcurrentSkipListSet 替代同步的 TreeSet ConcurrentSkipListSet\u0026lt;Integer\u0026gt; concurrentSet = new ConcurrentSkipListSet\u0026lt;\u0026gt;(); // 或者使用讀寫鎖 ReadWriteLock lock = new ReentrantReadWriteLock(); ReadLock readLock = lock.readLock(); WriteLock writeLock = lock.writeLock(); // 讀操作 readLock.lock(); try { treeSet.contains(1); } finally { readLock.unlock(); } // 寫操作 writeLock.lock(); try { treeSet.add(1); } finally { writeLock.unlock(); } } private static int expensiveCalculation(String s) { // 模擬昂貴的計算 return s.hashCode() * 31; } } 實際應用場景 1. LeetCode 問題解決 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 public class TreeSetLeetCodeSolutions { // LeetCode 1845: 座位預約管理系統 static class SeatManager { private TreeSet\u0026lt;Integer\u0026gt; availableSeats; public SeatManager(int n) { availableSeats = new TreeSet\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;= n; i++) { availableSeats.add(i); } } public int reserve() { return availableSeats.pollFirst(); } public void unreserve(int seatNumber) { availableSeats.add(seatNumber); } } // LeetCode 855: 考場就座 static class ExamRoom { private TreeSet\u0026lt;Integer\u0026gt; seats; private int n; public ExamRoom(int n) { this.n = n; this.seats = new TreeSet\u0026lt;\u0026gt;(); } public int seat() { int seat = 0; if (!seats.isEmpty()) { int maxDistance = seats.first(); // 檢查中間位置 Integer prev = null; for (Integer s : seats) { if (prev != null) { int distance = (s - prev) / 2; if (distance \u0026gt; maxDistance) { maxDistance = distance; seat = prev + distance; } } prev = s; } // 檢查最後位置 if (n - 1 - seats.last() \u0026gt; maxDistance) { seat = n - 1; } } seats.add(seat); return seat; } public void leave(int p) { seats.remove(p); } } // LeetCode 895: 最大頻率棧 static class FreqStack { private TreeSet\u0026lt;Element\u0026gt; elements; private Map\u0026lt;Integer, Integer\u0026gt; freq; private int timestamp; public FreqStack() { elements = new TreeSet\u0026lt;\u0026gt;((a, b) -\u0026gt; { if (a.frequency != b.frequency) { return b.frequency - a.frequency; // 頻率降序 } return b.timestamp - a.timestamp; // 時間降序 }); freq = new HashMap\u0026lt;\u0026gt;(); timestamp = 0; } public void push(int x) { int oldFreq = freq.getOrDefault(x, 0); int newFreq = oldFreq + 1; if (oldFreq \u0026gt; 0) { elements.remove(new Element(x, oldFreq, -1)); } elements.add(new Element(x, newFreq, timestamp++)); freq.put(x, newFreq); } public int pop() { Element top = elements.pollFirst(); int val = top.value; int newFreq = freq.get(val) - 1; if (newFreq \u0026gt; 0) { freq.put(val, newFreq); elements.add(new Element(val, newFreq, timestamp++)); } else { freq.remove(val); } return val; } static class Element { int value; int frequency; int timestamp; Element(int value, int frequency, int timestamp) { this.value = value; this.frequency = frequency; this.timestamp = timestamp; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Element element = (Element) obj; return value == element.value \u0026amp;\u0026amp; frequency == element.frequency; } @Override public int hashCode() { return Objects.hash(value, frequency); } } } // LeetCode 1499: 滿足不等式的最大值 public int findMaxValueOfEquation(int[][] points, int k) { // 使用 TreeSet 維護滑動窗口 TreeSet\u0026lt;Point\u0026gt; window = new TreeSet\u0026lt;\u0026gt;((a, b) -\u0026gt; { if (a.yMinusX != b.yMinusX) { return b.yMinusX - a.yMinusX; // 按 y-x 降序 } return a.x - b.x; // 按 x 升序 }); int maxValue = Integer.MIN_VALUE; for (int[] point : points) { int x = point[0]; int y = point[1]; // 移除窗口外的點 window.removeIf(p -\u0026gt; x - p.x \u0026gt; k); // 如果窗口不為空，計算最大值 if (!window.isEmpty()) { Point best = window.first(); maxValue = Math.max(maxValue, y + x + best.yMinusX); } // 添加當前點 window.add(new Point(x, y - x)); } return maxValue; } static class Point { int x; int yMinusX; Point(int x, int yMinusX) { this.x = x; this.yMinusX = yMinusX; } } } 2. 數據結構應用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 public class TreeSetDataStructureApplications { // 滑動窗口最大值 public static class SlidingWindowMaximum { private TreeSet\u0026lt;Element\u0026gt; window; private int windowSize; private int index; public SlidingWindowMaximum(int windowSize) { this.window = new TreeSet\u0026lt;\u0026gt;((a, b) -\u0026gt; { if (a.value != b.value) { return b.value - a.value; // 值降序 } return a.index - b.index; // 索引升序 }); this.windowSize = windowSize; this.index = 0; } public void addNumber(int num) { // 添加新元素 window.add(new Element(num, index)); // 移除窗口外的元素 if (index \u0026gt;= windowSize) { window.removeIf(e -\u0026gt; e.index \u0026lt;= index - windowSize); } index++; } public int getMaximum() { return window.isEmpty() ? 0 : window.first().value; } static class Element { int value; int index; Element(int value, int index) { this.value = value; this.index = index; } } } // 動態中位數 public static class DynamicMedian { private TreeSet\u0026lt;Element\u0026gt; elements; private int index; public DynamicMedian() { this.elements = new TreeSet\u0026lt;\u0026gt;((a, b) -\u0026gt; { if (a.value != b.value) { return a.value - b.value; // 值升序 } return a.index - b.index; // 索引升序 }); this.index = 0; } public void addNumber(int num) { elements.add(new Element(num, index++)); } public double getMedian() { int size = elements.size(); if (size == 0) return 0; List\u0026lt;Element\u0026gt; sortedElements = new ArrayList\u0026lt;\u0026gt;(elements); if (size % 2 == 1) { return sortedElements.get(size / 2).value; } else { return (sortedElements.get(size / 2 - 1).value + sortedElements.get(size / 2).value) / 2.0; } } static class Element { int value; int index; Element(int value, int index) { this.value = value; this.index = index; } } } // 區間調度 public static class IntervalScheduler { private TreeSet\u0026lt;Interval\u0026gt; intervals; public IntervalScheduler() { this.intervals = new TreeSet\u0026lt;\u0026gt;(Comparator.comparing(Interval::getStart)); } public boolean canSchedule(int start, int end) { Interval newInterval = new Interval(start, end); // 檢查是否與現有區間重疊 Interval floor = intervals.floor(newInterval); if (floor != null \u0026amp;\u0026amp; floor.getEnd() \u0026gt; start) { return false; } Interval ceiling = intervals.ceiling(newInterval); if (ceiling != null \u0026amp;\u0026amp; ceiling.getStart() \u0026lt; end) { return false; } return true; } public boolean schedule(int start, int end) { if (canSchedule(start, end)) { intervals.add(new Interval(start, end)); return true; } return false; } public List\u0026lt;Interval\u0026gt; getSchedule() { return new ArrayList\u0026lt;\u0026gt;(intervals); } static class Interval { private final int start; private final int end; public Interval(int start, int end) { this.start = start; this.end = end; } public int getStart() { return start; } public int getEnd() { return end; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Interval interval = (Interval) obj; return start == interval.start \u0026amp;\u0026amp; end == interval.end; } @Override public int hashCode() { return Objects.hash(start, end); } } } } 最佳實踐與建議 1. 選擇適當的比較策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 public class TreeSetBestPractices { // 1. 自然排序 vs 自定義比較器 public static void comparatorChoice() { // 對於實現 Comparable 的類型，使用自然排序 TreeSet\u0026lt;String\u0026gt; naturalOrder = new TreeSet\u0026lt;\u0026gt;(); // 對於需要自定義排序的情況，使用比較器 TreeSet\u0026lt;String\u0026gt; customOrder = new TreeSet\u0026lt;\u0026gt;(String.CASE_INSENSITIVE_ORDER); // 複雜對象的多字段排序 TreeSet\u0026lt;Person\u0026gt; personSet = new TreeSet\u0026lt;\u0026gt;( Comparator.comparing(Person::getAge) .thenComparing(Person::getName) ); } // 2. 空值處理 public static void nullHandling() { // TreeSet 不允許 null 元素 TreeSet\u0026lt;String\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // set.add(null); // 會拋出 NullPointerException // 如果需要支持 null 值，使用自定義比較器 TreeSet\u0026lt;String\u0026gt; nullSafeSet = new TreeSet\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { if (s1 == null \u0026amp;\u0026amp; s2 == null) return 0; if (s1 == null) return -1; if (s2 == null) return 1; return s1.compareTo(s2); }); } // 3. 線程安全處理 public static void threadSafety() { TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); // 方法1：使用 Collections.synchronizedSet Set\u0026lt;Integer\u0026gt; syncSet = Collections.synchronizedSet(treeSet); // 方法2：使用 ConcurrentSkipListSet ConcurrentSkipListSet\u0026lt;Integer\u0026gt; concurrentSet = new ConcurrentSkipListSet\u0026lt;\u0026gt;(); // 方法3：使用讀寫鎖 ReadWriteLock lock = new ReentrantReadWriteLock(); // 在讀寫操作時使用相應的鎖 } // 4. 效能考慮 public static void performanceConsiderations() { // 批量添加比單個添加效率更高 Collection\u0026lt;Integer\u0026gt; data = Arrays.asList(1, 2, 3, 4, 5); TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(data); // 避免頻繁的範圍查詢操作 NavigableSet\u0026lt;Integer\u0026gt; subSet = treeSet.subSet(2, true, 4, false); // 對 subSet 的操作會影響原始 set } static class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } } } 2. 常見錯誤避免 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 public class TreeSetCommonMistakes { // 錯誤1：在迭代過程中修改 TreeSet public static void avoidConcurrentModification() { TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 10; i++) { set.add(i); } // 錯誤的做法 // for (Integer value : set) { // if (value % 2 == 0) { // set.remove(value); // ConcurrentModificationException // } // } // 正確的做法1：使用迭代器 Iterator\u0026lt;Integer\u0026gt; iterator = set.iterator(); while (iterator.hasNext()) { if (iterator.next() % 2 == 0) { iterator.remove(); } } // 正確的做法2：收集要刪除的元素 Set\u0026lt;Integer\u0026gt; toRemove = set.stream() .filter(value -\u0026gt; value % 2 == 0) .collect(Collectors.toSet()); set.removeAll(toRemove); } // 錯誤2：比較器不一致 public static void avoidInconsistentComparator() { // 錯誤：比較器與 equals 不一致 TreeSet\u0026lt;String\u0026gt; badSet = new TreeSet\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { return s1.length() - s2.length(); // 只比較長度 }); badSet.add(\u0026#34;abc\u0026#34;); badSet.add(\u0026#34;def\u0026#34;); // 會被忽略，因為長度相同 // 正確：確保比較器一致性 TreeSet\u0026lt;String\u0026gt; goodSet = new TreeSet\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { int lengthCompare = s1.length() - s2.length(); if (lengthCompare != 0) { return lengthCompare; } return s1.compareTo(s2); // 長度相同時比較內容 }); } // 錯誤3：誤用子集合 public static void avoidSubSetMisuse() { TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 10; i++) { set.add(i); } // 錯誤：認為子集合是獨立的 NavigableSet\u0026lt;Integer\u0026gt; subSet = set.subSet(2, true, 8, false); subSet.clear(); // 這會影響原始 set // 正確：如果需要獨立的副本 NavigableSet\u0026lt;Integer\u0026gt; independentCopy = new TreeSet\u0026lt;\u0026gt;(subSet); } } 總結 TreeSet 是 Java 集合框架中功能強大的有序集合實現，基於紅黑樹提供了 O(log n) 的高效操作。通過本文的深入分析，我們了解了：\n核心特性：基於 TreeMap 的有序存儲，支持自然排序和自定義比較器 介面層次：從 Set 到 SortedSet 再到 NavigableSet 的完整功能 實用方法：豐富的範圍查詢、導航操作和視圖方法 企業應用：事件調度、範圍查詢、排名系統等實際場景 效能優化：比較器優化、批量操作、並發處理等最佳實踐 常見陷阱：並發修改、比較器一致性、子集合使用等需要注意的問題 正確使用 TreeSet 可以在需要有序集合的場景中提供高效、可靠的解決方案，是 Java 開發者必須掌握的重要工具之一。\n","permalink":"https://xinqilin.github.io/post/backend/treeset/","tags":["Java","TreeSet","Data Structure","Red-Black Tree","Collections","Sorting","NavigableSet","SortedSet","Binary Search Tree","Performance","Algorithms","Enterprise","Best Practices","Thread Safety","Concurrency"],"title":"Java TreeSet 完整實作指南：紅黑樹有序集合與 NavigableSet 介面詳解"},{"content":"概述 在撰寫 Shell Script 時，我們經常需要對檔案、目錄或字串的狀態進行判斷，例如檢查檔案是否存在、是否可讀，或判斷字串是否為空。這時就需要使用測試表達式 [ ... ] 或 test 指令。本文將詳細介紹這些常用的表達式及其用法。\n檔案測試表達式 檔案測試表達式用於判斷檔案的類型或權限狀態。其回傳值為布林值（true 或 false），可搭配 if 條件式使用。\n語法 1 2 3 if [ -\u0026lt;operator\u0026gt; \u0026lt;filename\u0026gt; ]; then # do something fi 常用運算子 運算子 說明 範例 -e 如果檔案存在 (exist)，則為 true [ -e /etc/hosts ] -d 如果檔案是目錄 (directory)，則為 true [ -d /home/user ] -f 如果檔案是常規檔案 (regular file)，則為 true [ -f /etc/passwd ] -L 如果檔案是符號連結 (symbolic link)，則為 true [ -L /usr/bin/python ] -h 與 -L 相同，如果檔案是符號連結，則為 true [ -h /usr/bin/python ] -r 如果檔案可讀 (readable)，則為 true [ -r /etc/shadow ] -w 如果檔案可寫 (writable)，則為 true [ -w /tmp/test.log ] -x 如果檔案可執行 (executable)，則為 true [ -x ./deploy.sh ] -s 如果檔案大小不為 0，則為 true [ -s /var/log/syslog ] 檔案比較運算子 用於比較兩個檔案的新舊關係。\n運算子 說明 範例 f1 -nt f2 如果檔案 f1 比 f2 新 (newer than)，則為 true [ file1.log -nt file2.log ] f1 -ot f2 如果檔案 f1 比 f2 舊 (older than)，則為 true [ file1.log -ot file2.log ] 字串與數值測試表達式 除了檔案，測試表達式也常用於比較數值或判斷字串狀態。\n數值比較 運算子 說明 等價符號 -eq 等於 (equal) == -ne 不等於 (not equal) != -gt 大於 (greater than) \u0026gt; -ge 大於或等於 (greater or equal) \u0026gt;= -lt 小於 (less than) \u0026lt; -le 小於或等於 (less or equal) \u0026lt;= 字串比較 運算子 說明 範例 -n 如果字串長度不為 0，則為 true [ -n \u0026quot;$my_var\u0026quot; ] -z 如果字串長度為 0 (zero)，則為 true [ -z \u0026quot;$my_var\u0026quot; ] $string 如果字串不為空，則為 true (與 -n 效果相同) [ \u0026quot;$my_var\u0026quot; ] 邏輯運算子 用於組合多個表達式。\n運算子 說明 範例 ! NOT：反轉表達式的結果 [ ! -d /tmp/non_existent ] -a AND：兩個表達式都為 true 時，結果才為 true [ -r \u0026quot;$file\u0026quot; -a -s \u0026quot;$file\u0026quot; ] -o OR：兩個表達式只要有一個為 true，結果就為 true [ -d \u0026quot;$dir\u0026quot; -o -f \u0026quot;$dir\u0026quot; ] 注意：建議使用 \u0026amp;\u0026amp; 和 || 來取代 -a 和 -o，因為它們更符合現代 Shell 的標準且更安全。\n1 2 3 4 5 6 7 8 9 # 使用 \u0026amp;\u0026amp; (AND) if [ -r \u0026#34;$file\u0026#34; ] \u0026amp;\u0026amp; [ -s \u0026#34;$file\u0026#34; ]; then echo \u0026#34;檔案可讀且內容不為空\u0026#34; fi # 使用 || (OR) if [ -d \u0026#34;$path\u0026#34; ] || [ -f \u0026#34;$path\u0026#34; ]; then echo \u0026#34;路徑是一個目錄或檔案\u0026#34; fi 實用範例 範例 1：檢查目錄是否存在，若不存在則建立 1 2 3 4 5 6 7 8 9 10 #!/bin/bash LOG_DIR=\u0026#34;/var/log/myapp\u0026#34; if [ ! -d \u0026#34;$LOG_DIR\u0026#34; ]; then echo \u0026#34;日誌目錄不存在，正在建立: $LOG_DIR\u0026#34; mkdir -p \u0026#34;$LOG_DIR\u0026#34; else echo \u0026#34;日誌目錄已存在。\u0026#34; fi 範例 2：檢查字串變數是否為空 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/bash USERNAME=\u0026#34;\u0026#34; # ... 從某處讀取使用者名稱 ... if [ -z \u0026#34;$USERNAME\u0026#34; ]; then echo \u0026#34;錯誤：使用者名稱不能為空！\u0026#34; exit 1 fi # 另一種寫法 if [ ! \u0026#34;$USERNAME\u0026#34; ]; then echo \u0026#34;錯誤：使用者名稱不能為空！\u0026#34; exit 1 fi 範例 3：結合多個條件 1 2 3 4 5 6 7 8 9 10 #!/bin/bash CONFIG_FILE=\u0026#34;config.conf\u0026#34; if [ -f \u0026#34;$CONFIG_FILE\u0026#34; ] \u0026amp;\u0026amp; [ -r \u0026#34;$CONFIG_FILE\u0026#34; ]; then echo \u0026#34;設定檔存在且可讀取，載入設定...\u0026#34; source \u0026#34;$CONFIG_FILE\u0026#34; else echo \u0026#34;警告：找不到設定檔或無法讀取。\u0026#34; fi ","permalink":"https://xinqilin.github.io/post/tools/fileexpress/","tags":["Shell","Bash","File System","Scripting"],"title":"Shell 檔案與字串表達式詳解"},{"content":"概述 鏈表反轉是數據結構與演算法中的經典問題，要求將單向鏈表的指向關係完全反轉。這個問題看似簡單，但涉及到指標操作的細節，是考驗編程基本功的重要題型。\n問題定義 給定一個單向鏈表，將其反轉並回傳新的頭節點。\n範例：\n1 2 輸入：1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; NULL 輸出：5 -\u0026gt; 4 -\u0026gt; 3 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; NULL 鏈表節點定義 1 2 3 4 5 6 7 8 9 10 11 public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } 解法一：迭代實作 基本思路 使用三個指標 prev、current、next 來逐步改變每個節點的指向關係。\n算法步驟 初始化 prev = null，current = head 當 current != null 時： 保存 current.next 到 next 將 current.next 指向 prev 移動 prev 和 current 指標 回傳 prev（新的頭節點） 實作代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode current = head; while (current != null) { ListNode next = current.next; // 保存下一個節點 current.next = prev; // 反轉指標 prev = current; // 移動 prev current = next; // 移動 current } return prev; // prev 現在是新的頭節點 } } 圖解過程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 初始狀態： prev = null, current = 1 null 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null 第一步： next = 2, current.next = prev null \u0026lt;- 1 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null prev current 第二步： next = 3, current.next = prev null \u0026lt;- 1 \u0026lt;- 2 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null prev current ... 最終狀態： null \u0026lt;- 1 \u0026lt;- 2 \u0026lt;- 3 \u0026lt;- 4 \u0026lt;- 5 null prev current 解法二：遞歸實作 基本思路 使用遞歸的方式，從鏈表尾部開始反轉，利用遞歸回溯的特性來改變指標指向。\n算法步驟 遞歸到鏈表最後一個節點 在回溯過程中，逐步反轉每個節點的指向 回傳原鏈表的尾節點（新的頭節點） 實作代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Solution { public ListNode reverseList(ListNode head) { // 基礎情況：空節點或只有一個節點 if (head == null || head.next == null) { return head; } // 遞歸反轉子鏈表 ListNode newHead = reverseList(head.next); // 反轉當前節點的指向 head.next.next = head; head.next = null; return newHead; } } 遞歸過程分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 原鏈表：1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null 遞歸調用棧： reverseList(1) -\u0026gt; reverseList(2) -\u0026gt; ... -\u0026gt; reverseList(5) 回溯階段： 1. reverseList(5) 回傳 5 2. reverseList(4)： - newHead = 5 - 4.next.next = 4 (即 5.next = 4) - 4.next = null - 回傳 5 3. reverseList(3)： - newHead = 5 - 3.next.next = 3 (即 4.next = 3) - 3.next = null - 回傳 5 ... 最終結果：5 -\u0026gt; 4 -\u0026gt; 3 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; null 時間與空間複雜度分析 方法 時間複雜度 空間複雜度 優點 缺點 迭代 O(n) O(1) 空間效率高，直觀易懂 需要處理多個指標 遞歸 O(n) O(n) 代碼簡潔，邏輯清晰 使用額外堆疊空間 進階應用 1. 反轉鏈表的前 N 個節點 問題：反轉鏈表的前 N 個節點。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Solution { private ListNode successor = null; // 後驅節點 public ListNode reverseN(ListNode head, int n) { if (n == 1) { // 記錄第 n+1 個節點 successor = head.next; return head; } // 以 head.next 為起點，需要反轉前 n-1 個節點 ListNode last = reverseN(head.next, n - 1); head.next.next = head; head.next = successor; // 讓反轉之後的 head 節點和後面的節點連起來 return last; } } 2. 反轉鏈表的指定區間（LeetCode 92） 問題：反轉從位置 m 到 n 的鏈表。請使用一趟掃描完成反轉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { // 創建虛擬頭節點 ListNode dummy = new ListNode(0); dummy.next = head; // 找到 left 的前一個節點 ListNode prev = dummy; for (int i = 0; i \u0026lt; left - 1; i++) { prev = prev.next; } // 開始反轉 ListNode current = prev.next; ListNode next = null; for (int i = 0; i \u0026lt; right - left; i++) { next = current.next; current.next = next.next; next.next = prev.next; prev.next = next; } return dummy.next; } } 3. K 個一組反轉鏈表（LeetCode 25） 問題：給定一個鏈表，每 k 個節點一組進行反轉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class Solution { public ListNode reverseKGroup(ListNode head, int k) { if (head == null) return null; // 檢查剩餘節點是否足夠 k 個 ListNode a = head, b = head; for (int i = 0; i \u0026lt; k; i++) { if (b == null) return head; // 不足 k 個，直接返回 b = b.next; } // 反轉前 k 個元素 ListNode newHead = reverse(a, b); // 遞歸反轉後續的鏈表並連接 a.next = reverseKGroup(b, k); return newHead; } // 反轉 [a, b) 區間的鏈表 private ListNode reverse(ListNode a, ListNode b) { ListNode prev = null; ListNode current = a; while (current != b) { ListNode next = current.next; current.next = prev; prev = current; current = next; } return prev; } } 實作技巧與注意事項 1. 邊界條件處理 1 2 3 4 // 檢查空鏈表和單節點鏈表 if (head == null || head.next == null) { return head; } 2. 使用虛擬頭節點 在處理鏈表頭部變化的問題時，虛擬頭節點可以簡化邏輯：\n1 2 3 4 ListNode dummy = new ListNode(0); dummy.next = head; // ... 操作 return dummy.next; 3. 指標操作的順序 在改變指標指向時，必須先保存下一個節點：\n1 2 ListNode next = current.next; // 先保存 current.next = prev; // 再修改 4. 遞歸終止條件 確保遞歸有明確的終止條件：\n1 2 3 if (head == null || head.next == null) { return head; // 基礎情況 } 常見變體問題 1. 判斷鏈表是否為回文 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public boolean isPalindrome(ListNode head) { if (head == null) return true; // 找到中點 ListNode slow = head, fast = head; while (fast.next != null \u0026amp;\u0026amp; fast.next.next != null) { slow = slow.next; fast = fast.next.next; } // 反轉後半部分 ListNode secondHalf = reverseList(slow.next); // 比較前後兩部分 ListNode p1 = head, p2 = secondHalf; while (p2 != null) { if (p1.val != p2.val) return false; p1 = p1.next; p2 = p2.next; } return true; } 2. 兩兩交換鏈表中的節點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode prev = dummy; while (prev.next != null \u0026amp;\u0026amp; prev.next.next != null) { ListNode first = prev.next; ListNode second = prev.next.next; // 交換 prev.next = second; first.next = second.next; second.next = first; // 移動 prev prev = first; } return dummy.next; } 最佳實踐 選擇合適的方法：對於簡單的鏈表反轉，推薦使用迭代方法 注意空間複雜度：在空間受限的環境下避免使用遞歸 處理邊界情況：始終檢查空鏈表和單節點情況 使用虛擬節點：簡化頭節點的處理邏輯 測試充分：測試各種邊界情況和特殊輸入 總結 鏈表反轉是一個看似簡單但細節豐富的問題。掌握這個問題的關鍵在於：\n理解指標操作：正確處理節點間的指向關係 選擇合適方法：根據場景選擇迭代或遞歸實作 處理邊界情況：確保算法在各種輸入下都能正確運行 靈活應用：將基本技巧應用到更複雜的變體問題中 通過反復練習和理解，鏈表反轉將成為解決更複雜鏈表問題的基礎技能。\n參考資料 LeetCode 206. Reverse Linked List LeetCode 92. Reverse Linked List II LeetCode 25. Reverse Nodes in k-Group LeetCode 234. Palindrome Linked List 演算法導論 - 鏈表操作 ","permalink":"https://xinqilin.github.io/post/algorithm/reverselinkedlist/","tags":["Algorithm","LinkedList","Recursion","Java","Pointer"],"title":"鏈表反轉（Reverse Linked List）完整解析"},{"content":"概述 並查集（Union-Find）又稱為不相交集合（Disjoint Set），是一種用來處理不相交集合的合併和查詢問題的數據結構。它支援兩種主要操作：\nFind：查找元素所屬的集合（返回集合的代表元素） Union：合併兩個不同的集合 並查集在圖論演算法中應用廣泛，特別適用於解決連通性問題。\n基本原理 核心概念 並查集將每個集合表示為一棵樹，樹的根節點作為該集合的代表元素。初始狀態下，每個元素都是獨立的集合（自己是自己的父節點）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 初始狀態： 0 1 2 3 4 ↓ ↓ ↓ ↓ ↓ 0 1 2 3 4 合併 0 和 1 後： 0 2 3 4 ↙ ↓ ↓ ↓ 1 2 3 4 合併 2 和 3 後： 0 2 4 ↙ ↙ ↓ 1 3 4 基本實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 public class UnionFind { private int[] parent; // parent[i] 表示元素 i 的父節點 private int[] rank; // rank[i] 表示以 i 為根的樹的高度 private int components; // 連通分量的數量 public UnionFind(int n) { parent = new int[n]; rank = new int[n]; components = n; // 初始化：每個元素都是獨立的集合 for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; // 自己是自己的父節點 rank[i] = 0; // 初始高度為 0 } } /** * 查找元素 x 所屬集合的代表元素 */ public int find(int x) { if (parent[x] != x) { // 路徑壓縮：將路徑上所有節點直接連接到根節點 parent[x] = find(parent[x]); } return parent[x]; } /** * 合併元素 x 和 y 所屬的集合 */ public boolean union(int x, int y) { int rootX = find(x); int rootY = find(y); // 如果已經在同一個集合中，返回 false if (rootX == rootY) { return false; } // 按秩合併：將較矮的樹合併到較高的樹下 if (rank[rootX] \u0026lt; rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] \u0026gt; rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; // 高度相同時，合併後高度加 1 } components--; // 連通分量減 1 return true; } /** * 檢查兩個元素是否在同一個集合中 */ public boolean connected(int x, int y) { return find(x) == find(y); } /** * 獲取連通分量的數量 */ public int getComponentCount() { return components; } } 優化技巧 1. 路徑壓縮（Path Compression） 在 find 操作中，將查找路徑上的所有節點直接連接到根節點，使樹變得更加扁平。\n1 2 3 4 5 6 public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); // 遞歸壓縮路徑 } return parent[x]; } 2. 按秩合併（Union by Rank） 總是將較矮的樹合併到較高的樹下，避免樹變得過高。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public boolean union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) return false; // 按秩合併 if (rank[rootX] \u0026lt; rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] \u0026gt; rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; } return true; } 3. 按大小合併（Union by Size） 另一種優化策略是將較小的集合合併到較大的集合中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class UnionFindBySize { private int[] parent; private int[] size; // size[i] 表示以 i 為根的集合大小 public UnionFindBySize(int n) { parent = new int[n]; size = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; size[i] = 1; // 初始每個集合大小為 1 } } public boolean union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) return false; // 按大小合併：將小集合合併到大集合 if (size[rootX] \u0026lt; size[rootY]) { parent[rootX] = rootY; size[rootY] += size[rootX]; } else { parent[rootY] = rootX; size[rootX] += size[rootY]; } return true; } } 時間複雜度 操作 時間複雜度 說明 初始化 O(n) 建立 n 個獨立集合 Find（無優化） O(n) 最壞情況下需要遍歷整條鏈 Union（無優化） O(n) 需要調用 Find 操作 Find（路徑壓縮） O(α(n)) α(n) 是阿克曼函數的反函數 Union（按秩合併） O(α(n)) 近似常數時間 其中 α(n) 是阿克曼函數的反函數，在實際應用中可視為常數。\n經典應用題型 1. 等式方程的可滿足性（LeetCode 990） 問題描述：給定一個由表示變數之間關係的字串組成的陣列 equations，每個字串 equations[i] 的長度為 4，有兩種形式：\u0026quot;a==b\u0026quot; 或 \u0026quot;a!=b\u0026quot;。判斷是否所有等式都能同時滿足。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { private int[] parent = new int[26]; // 26 個字母 public boolean equationsPossible(String[] equations) { // 初始化並查集 for (int i = 0; i \u0026lt; 26; i++) { parent[i] = i; } // 第一遍：處理所有等式，合併相等的變數 for (String equation : equations) { if (equation.charAt(1) == \u0026#39;=\u0026#39;) { union(equation.charAt(0) - \u0026#39;a\u0026#39;, equation.charAt(3) - \u0026#39;a\u0026#39;); } } // 第二遍：檢查不等式是否違反了等式的結果 for (String equation : equations) { if (equation.charAt(1) == \u0026#39;!\u0026#39;) { int x = equation.charAt(0) - \u0026#39;a\u0026#39;; int y = equation.charAt(3) - \u0026#39;a\u0026#39;; if (find(x) == find(y)) { return false; // 不等式矛盾 } } } return true; } private int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); } return parent[x]; } private void union(int x, int y) { parent[find(x)] = find(y); } } 2. 朋友圈數量（LeetCode 547） 問題描述：班上有 N 名學生。其中有些人是朋友，有些則不是。他們的友誼具有傳遞性。找出朋友圈的總數。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int findCircleNum(int[][] isConnected) { int n = isConnected.length; UnionFind uf = new UnionFind(n); // 遍歷所有學生對，如果是朋友就合併 for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (isConnected[i][j] == 1) { uf.union(i, j); } } } return uf.getComponentCount(); } } 3. 島嶼數量（LeetCode 200） 問題描述：給定一個由 \u0026lsquo;1\u0026rsquo;（陸地）和 \u0026lsquo;0\u0026rsquo;（水）組成的二維網格，計算島嶼的數量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) return 0; int rows = grid.length; int cols = grid[0].length; UnionFind uf = new UnionFind(rows * cols); int waterCells = 0; // 方向陣列：上、下、左、右 int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; cols; j++) { if (grid[i][j] == \u0026#39;0\u0026#39;) { waterCells++; } else { // 檢查四個方向的相鄰陸地 for (int[] dir : directions) { int newRow = i + dir[0]; int newCol = j + dir[1]; if (newRow \u0026gt;= 0 \u0026amp;\u0026amp; newRow \u0026lt; rows \u0026amp;\u0026amp; newCol \u0026gt;= 0 \u0026amp;\u0026amp; newCol \u0026lt; cols \u0026amp;\u0026amp; grid[newRow][newCol] == \u0026#39;1\u0026#39;) { uf.union(i * cols + j, newRow * cols + newCol); } } } } } return uf.getComponentCount() - waterCells; } } 4. 冗余連接（LeetCode 684） 問題描述：在無向圖中找到一條邊，移除它後圖將變成樹。如果有多個答案，返回最後出現在給定二維陣列中的邊。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int[] findRedundantConnection(int[][] edges) { UnionFind uf = new UnionFind(edges.length + 1); for (int[] edge : edges) { // 如果兩個節點已經連通，這條邊就是冗余的 if (!uf.union(edge[0], edge[1])) { return edge; } } return new int[0]; // 理論上不會到達這裡 } } 5. 賬戶合併（LeetCode 721） 問題描述：給定一個賬戶列表，每個元素 accounts[i] 是一個字串列表，其中第一個元素是名字，其餘元素是 emails。合併屬於同一人的賬戶。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accountsMerge(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accounts) { Map\u0026lt;String, Integer\u0026gt; emailToIndex = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;String, String\u0026gt; emailToName = new HashMap\u0026lt;\u0026gt;(); int emailCount = 0; // 為每個 email 分配唯一索引 for (List\u0026lt;String\u0026gt; account : accounts) { String name = account.get(0); for (int i = 1; i \u0026lt; account.size(); i++) { String email = account.get(i); if (!emailToIndex.containsKey(email)) { emailToIndex.put(email, emailCount++); } emailToName.put(email, name); } } UnionFind uf = new UnionFind(emailCount); // 合併同一賬戶下的所有 email for (List\u0026lt;String\u0026gt; account : accounts) { String firstEmail = account.get(1); for (int i = 2; i \u0026lt; account.size(); i++) { uf.union(emailToIndex.get(firstEmail), emailToIndex.get(account.get(i))); } } // 根據並查集結果分組 email Map\u0026lt;Integer, List\u0026lt;String\u0026gt;\u0026gt; groups = new HashMap\u0026lt;\u0026gt;(); for (String email : emailToIndex.keySet()) { int root = uf.find(emailToIndex.get(email)); groups.computeIfAbsent(root, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(email); } // 構建最終結果 List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (List\u0026lt;String\u0026gt; emails : groups.values()) { Collections.sort(emails); List\u0026lt;String\u0026gt; account = new ArrayList\u0026lt;\u0026gt;(); account.add(emailToName.get(emails.get(0))); account.addAll(emails); result.add(account); } return result; } } 高級應用 動態連通性問題 並查集特別適用於處理動態連通性問題，即在線回答「兩個節點是否連通」的查詢。\n最小生成樹（Kruskal 演算法） Kruskal 演算法使用並查集來檢測環的存在：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class KruskalMST { public int kruskalMST(int n, int[][] edges) { // 按權重排序邊 Arrays.sort(edges, (a, b) -\u0026gt; a[2] - b[2]); UnionFind uf = new UnionFind(n); int mstWeight = 0; int edgesUsed = 0; for (int[] edge : edges) { int u = edge[0], v = edge[1], weight = edge[2]; // 如果不會形成環，加入 MST if (uf.union(u, v)) { mstWeight += weight; edgesUsed++; // MST 有 n-1 條邊 if (edgesUsed == n - 1) { break; } } } return mstWeight; } } 實作技巧與注意事項 路徑壓縮：在 find 操作中使用路徑壓縮可以顯著提升性能 按秩合併：避免樹變得過高，保持操作的高效性 元素映射：當元素不是連續整數時，需要建立映射關係 連通分量計數：維護連通分量的數量可以快速回答相關查詢 總結 並查集是解決動態連通性問題的高效數據結構，在圖論、網路分析、集合劃分等領域有廣泛應用。掌握並查集的關鍵在於：\n理解基本原理：樹形結構表示集合，根節點作為代表元素 掌握優化技巧：路徑壓縮和按秩/按大小合併 靈活應用：根據問題特點選擇合適的實作方式 注意細節：邊界條件處理和元素映射 參考資料 LeetCode 990. Satisfiability of Equality Equations LeetCode 547. Number of Provinces LeetCode 200. Number of Islands LeetCode 684. Redundant Connection LeetCode 721. Accounts Merge 演算法導論 - 不相交集合的數據結構 ","permalink":"https://xinqilin.github.io/post/algorithm/unionfind/","tags":["Algorithm","UnionFind","DisjointSet","Graph","Java"],"title":"並查集（Union-Find）演算法完整指南"},{"content":"Snowflake - Distribution Key 單體式 ID 一般單體式 UUID(Universally Unique identifier) 8-4-4-4-12 總共 32 個 16 進位\n1 UUID.randomUUID() // 80e06459-942d-4a63-9fd4-81691b127363 優點 性能高 本地生成 無網路延遲 缺點 無順序性 字串不適合存 db 當 index or PK 且 32 長度太長 因無序 所以對 b+ Tree 來說 插入時效能低 極小機會但 會重複 =\u0026gt; ＤＢ 解法: replace into 跟insert功能類似, 但 replace into 會檢查是否存在, 如存在則先刪除, 再插入, 否则直接插入 分佈式 ID twitter 開發的 雪花算法 - snowflake 總共 64 bit\n1bit 不用，因為二進制中最高位是符號位，1表示負數，0表示正數。 生成的id一般都是用整數，所以最高位固定為0。\n41bit-時間戳，用來記錄時間戳，亳秒級。 41位可以表示 2^41-1個數字， 如果只用來表示正整數(計算機中正數包含0)，可以表示的數值範圍是: 0 至 2^41 - 1， 減1是因為可表示的數值範圍是從0開始算的，而不是1.也就是說41位可以表示 2^41 - 1 個毫秒的值，轉化成單位年則是( 2^41 - 1 )/ (1000* 60 * 60 * 24 *365)= 69年\n10bit-工作機器id,用來記錄工作機器id. 可以部署在 2^10 = 1024 個節點，包括5位 dataCenterId 和 15 位 workerId 5位(bit) 可以表示的最大正整數是 2^5-1 = 31，即可以用 0, 1, 2, 3\u0026hellip; 這 32 個數字來表示不同的 dataCenterId 或 workerId\n12bit, 序列號，序列號，用來記錄同毫秒內產生的不同id. 12位(bit) 可以表示的最大正整數是 2^12 - 1 = 4095，即可以用 0, 1, 2, 3\u0026hellip; 4094 這 4095 個數字, 來表示同一機器同一時間截(毫秒)內產生的 4095 個ID序號。\n優點 全局唯一性 递增性, 確保生成 ID 對於用户或業務是递增的。 高可用性, 確保任何時候都能生成正確的 ID 高性能, 在高併發下依然 ok 亳秒数在高位，自增序列在低位，整個 ID 都是遞增的。 缺點 依賴機器時鐘，如果機器時鐘回撥，會導致重複 ID 生成 在單機上是遞增的，但是由於設計到分佈式環境，每台機器上的時鐘不可能完全同步，有時候會出現不是全局遞增的情況(此缺點可以認為無所謂，- .般分佈式ID只要求趨勢遞增，並不會嚴格要求遞增，90%的需求都只要求趨勢遞增) additional 解決機器時鐘回撥問題 Leaf - 美團點評分佈式ID生成系統 百度 open source - UidGenerator java sample code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 public class SnowflakeIdWorker { /** * 开始时间截 (2015-01-01) */ private final long twepoch = 1420041600000L; /** * 机器id所占的位数 */ private final long workerIdBits = 5L; /** * 数据标识id所占的位数 */ private final long datacenterIdBits = 5L; /** * 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */ private final long maxWorkerId = -1L ^ (-1L \u0026lt;\u0026lt; workerIdBits); /** * 支持的最大数据标识id，结果是31 */ private final long maxDatacenterId = -1L ^ (-1L \u0026lt;\u0026lt; datacenterIdBits); /** * 序列在id中占的位数 */ private final long sequenceBits = 12L; /** * 机器ID向左移12位 */ private final long workerIdShift = sequenceBits; /** * 数据标识id向左移17位(12+5) */ private final long datacenterIdShift = sequenceBits + workerIdBits; /** * 时间截向左移22位(5+5+12) */ private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; /** * 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */ private final long sequenceMask = -1L ^ (-1L \u0026lt;\u0026lt; sequenceBits); /** * 工作机器ID(0~31) */ private long workerId; /** * 数据中心ID(0~31) */ private long datacenterId; /** * 毫秒内序列(0~4095) */ private long sequence = 0L; /** * 上次生成ID的时间截 */ private long lastTimestamp = -1L; /** * 构造函数 * @param workerId 工作ID (0~31) * @param datacenterId 数据中心ID (0~31) */ public SnowflakeIdWorker(long workerId, long datacenterId) { if (workerId \u0026gt; maxWorkerId || workerId \u0026lt; 0) { throw new IllegalArgumentException(String.format(\u0026#34;worker Id can\u0026#39;t be greater than %d or less than 0\u0026#34;, maxWorkerId)); } if (datacenterId \u0026gt; maxDatacenterId || datacenterId \u0026lt; 0) { throw new IllegalArgumentException(String.format(\u0026#34;datacenter Id can\u0026#39;t be greater than %d or less than 0\u0026#34;, maxDatacenterId)); } this.workerId = workerId; this.datacenterId = datacenterId; } /** * 获得下一个ID (该方法是线程安全的) * @return SnowflakeId */ public synchronized long nextId() { long timestamp = timeGen(); // 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常 if (timestamp \u0026lt; lastTimestamp) { throw new RuntimeException( String.format(\u0026#34;Clock moved backwards. Refusing to generate id for %d milliseconds\u0026#34;, lastTimestamp - timestamp)); } // 如果是同一时间生成的，则进行毫秒内序列 if (lastTimestamp == timestamp) { sequence = (sequence + 1) \u0026amp; sequenceMask; // 毫秒内序列溢出 if (sequence == 0) { //阻塞到下一个毫秒,获得新的时间戳 timestamp = tilNextMillis(lastTimestamp); } } // 时间戳改变，毫秒内序列重置 else { sequence = 0L; } // 上次生成ID的时间截 lastTimestamp = timestamp; // 移位并通过或运算拼到一起组成64位的ID return ((timestamp - twepoch) \u0026lt;\u0026lt; timestampLeftShift) // | (datacenterId \u0026lt;\u0026lt; datacenterIdShift) // | (workerId \u0026lt;\u0026lt; workerIdShift) // | sequence; } /** * 阻塞到下一个毫秒，直到获得新的时间戳 * @param lastTimestamp 上次生成ID的时间截 * @return 当前时间戳 */ protected long tilNextMillis(long lastTimestamp) { long timestamp = timeGen(); while (timestamp \u0026lt;= lastTimestamp) { timestamp = timeGen(); } return timestamp; } /** * 返回以毫秒为单位的当前时间 * @return 当前时间(毫秒) */ protected long timeGen() { return System.currentTimeMillis(); } public static void main(String[] args) throws InterruptedException { SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0); for (int i = 0; i \u0026lt; 10; i++) { long id = idWorker.nextId(); Thread.sleep(1); System.out.println(id); } } } reference: https://github.com/twitter-archive/snowflake https://github.com/beyondfengyu/SnowFlake/blob/master/SnowFlake.java https://blog.csdn.net/qq_45408390/article/details/119793810 ","permalink":"https://xinqilin.github.io/post/architecture/snowflake-distributionkey/","tags":[],"title":"SnowFlake DistributionKey"},{"content":"概述 回溯演算法（Backtracking）是一種透過試錯來尋找問題解決方案的算法策略。它系統性地搜尋所有可能的候選解，當發現候選解不可能完成有效解時，會放棄該候選解並「回溯」到上一步。\n基本原理 回溯演算法遵循三個核心步驟：\n選擇（Choose）：從當前狀態的可選項中做出選擇 探索（Explore）：Recursion地探索這個選擇的後果 撤銷（Un-choose）：撤銷選擇，恢復到選擇前的狀態 演算法模板 1 2 3 4 5 6 7 8 9 10 11 12 void backtrack(路徑, 選擇列表) { if (滿足結束條件) { result.add(路徑); return; } for (選擇 : 選擇列表) { 做選擇; // Choose backtrack(路徑, 選擇列表); // Explore 撤銷選擇; // Un-choose } } 時間複雜度 一般情況下，回溯演算法的時間複雜度為 O(b^d)，其中：\nb 是分支因子（每個節點的平均子節點數） d 是搜尋深度 經典應用題型 1. 子集問題（Subsets） 問題描述：給定一個整數陣列 nums，回傳該陣列所有可能的子集（冪集合）。\n解題思路：\n對於每個元素，我們都有「選擇」或「不選擇」兩種決策 使用回溯法遍歷所有可能的組合 每次Recursion都將當前路徑加入結果集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); // 排序便於處理 backtrack(result, new ArrayList\u0026lt;\u0026gt;(), nums, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] nums, int startIndex) { // 每個狀態都是一個有效的子集 result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); // 從 startIndex 開始遍歷，避免重複組合 for (int i = startIndex; i \u0026lt; nums.length; i++) { // 做選擇：將當前元素加入路徑 currentPath.add(nums[i]); // Recursion探索：繼續選擇下一個元素 backtrack(result, currentPath, nums, i + 1); // 撤銷選擇：移除當前元素，回溯 currentPath.remove(currentPath.size() - 1); } } 時間複雜度：O(2^n)，其中 n 是陣列長度，因為每個元素都有選或不選兩種狀態。\n2. 子集問題 II（Subsets II - 含重複元素） 問題描述：給定一個可能包含重複整數的陣列 nums，回傳該陣列所有可能的子集（不包含重複的子集）。\n解題思路：\n基於子集問題的解法，但需要處理重複元素 先排序陣列，讓相同元素相鄰 透過跳過重複元素來避免產生重複的子集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); // 排序是關鍵，讓重複元素相鄰 backtrack(result, new ArrayList\u0026lt;\u0026gt;(), nums, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] nums, int startIndex) { // 每個狀態都是一個有效的子集 result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); for (int i = startIndex; i \u0026lt; nums.length; i++) { // 跳過重複元素：當前元素與前一個元素相同，且不是起始位置 if (i \u0026gt; startIndex \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; // 跳過重複元素避免產生重複子集 } // 做選擇 currentPath.add(nums[i]); // Recursion探索 backtrack(result, currentPath, nums, i + 1); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); } } 去重關鍵：i \u0026gt; startIndex \u0026amp;\u0026amp; nums[i] == nums[i-1] 這個條件確保在同一層Recursion中跳過重複元素。\n3. 全排列（Permutations） 問題描述：給定一個不含重複數字的陣列 nums，回傳其所有可能的全排列。\n解題思路：\n全排列需要用到陣列中的每一個元素，且順序不同結果不同 使用 contains 檢查避免重複使用同一個元素 當路徑長度等於陣列長度時，找到一個完整的排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); backtrack(result, new ArrayList\u0026lt;\u0026gt;(), nums); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] nums) { // 達到目標長度，找到一個完整的排列 if (currentPath.size() == nums.length) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } // 嘗試添加每一個元素 for (int i = 0; i \u0026lt; nums.length; i++) { // 跳過已經使用的元素 if (currentPath.contains(nums[i])) { continue; // 該元素已在當前路徑中，跳過 } // 做選擇 currentPath.add(nums[i]); // Recursion探索 backtrack(result, currentPath, nums); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); } } 效能優化：使用 boolean[] used 陣列取代 contains 方法可以提升效能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private void backtrackOptimized(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] nums, boolean[] used) { if (currentPath.size() == nums.length) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) continue; // O(1) 時間檢查 used[i] = true; currentPath.add(nums[i]); backtrackOptimized(result, currentPath, nums, used); currentPath.remove(currentPath.size() - 1); used[i] = false; } } 時間複雜度：O(n × n!)，其中 n! 是排列的數量，n 是複製每個排列所需的時間。\n4. 全排列 II（Permutations II - 含重複元素） 問題描述：給定一個可包含重複數字的序列 nums，按任意順序回傳所有不重複的全排列。\n解題思路：\n在全排列的基礎上增加去重邏輯 先排序讓相同元素相鄰 使用剪枝條件避免產生重複的排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); // 排序是去重的關鍵 boolean[] used = new boolean[nums.length]; backtrack(result, new ArrayList\u0026lt;\u0026gt;(), nums, used); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] nums, boolean[] used) { // 達到目標長度，找到一個完整的排列 if (currentPath.size() == nums.length) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { // 跳過已使用的元素 if (used[i]) continue; // 去重關鍵：跳過重複元素 // 當前元素與前一個元素相同，且前一個元素未被使用 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !used[i - 1]) { continue; } // 做選擇 used[i] = true; currentPath.add(nums[i]); // Recursion探索 backtrack(result, currentPath, nums, used); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); used[i] = false; } } 去重原理：!used[i-1] 確保在同一層Recursion中，相同的元素只會被選擇一次，從而避免重複排列。\n5. 組合總和（Combination Sum - 可重複使用元素） 問題描述：給定一個無重複元素的陣列 candidates 和一個目標數 target，找出所有使元素和為 target 的組合。同一個數字可以被重複選擇。\n解題思路：\n每個元素都可以被無限次重複使用 使用 startIndex 避免產生重複組合（如 [2,3] 和 [3,2]） 當剩餘目標值為 0 時找到一個有效組合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(candidates); // 排序便於剪枝 backtrack(result, new ArrayList\u0026lt;\u0026gt;(), candidates, target, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] candidates, int remainingTarget, int startIndex) { // 剪枝：剩餘目標值小於 0，無效路徑 if (remainingTarget \u0026lt; 0) { return; } // 找到一個有效組合 if (remainingTarget == 0) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } for (int i = startIndex; i \u0026lt; candidates.length; i++) { // 剪枝優化：如果當前元素已經大於剩餘目標值，後面的元素也會更大 if (candidates[i] \u0026gt; remainingTarget) { break; } // 做選擇 currentPath.add(candidates[i]); // Recursion探索：注意這裡傳入 i 而不是 i+1，因為可以重複使用同一元素 backtrack(result, currentPath, candidates, remainingTarget - candidates[i], i); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); } } 關鍵點：\nRecursion時傳入 i 而非 i+1，允許重複使用當前元素 排序後可以進行剪枝優化，提早終止無效分支 6. 組合總和 II（Combination Sum II - 含重複元素但不可重複使用） 問題描述：給定一個陣列 candidates 和一個目標數 target，找出所有使元素和為 target 的組合。陣列中每個元素只能使用一次，但陣列中可能包含重複元素。\n解題思路：\n每個元素只能使用一次，需要跳過重複元素避免重複組合 排序後使用去重邏輯 Recursion時傳入 i+1 確保每個位置的元素只能使用一次 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(candidates); // 排序是去重的前提 backtrack(result, new ArrayList\u0026lt;\u0026gt;(), candidates, target, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] candidates, int remainingTarget, int startIndex) { // 剪枝：剩餘目標值小於 0 if (remainingTarget \u0026lt; 0) { return; } // 找到一個有效組合 if (remainingTarget == 0) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } for (int i = startIndex; i \u0026lt; candidates.length; i++) { // 跳過重複元素：避免在同一層Recursion中使用相同的元素 if (i \u0026gt; startIndex \u0026amp;\u0026amp; candidates[i] == candidates[i - 1]) { continue; // 跳過重複元素 } // 剪枝優化 if (candidates[i] \u0026gt; remainingTarget) { break; } // 做選擇 currentPath.add(candidates[i]); // Recursion探索：傳入 i+1 確保每個元素只使用一次 backtrack(result, currentPath, candidates, remainingTarget - candidates[i], i + 1); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); } } 與 Combination Sum 的差異：\nRecursion時傳入 i+1 而非 i，每個元素只能使用一次 增加去重邏輯處理陣列中的重複元素 7. 回文字串分割（Palindrome Partitioning） 問題描述：給定一個字串 s，將 s 分割成一些子字串，使得每個子字串都是回文字串。回傳所有可能的分割方案。\n解題思路：\n透過回溯法嘗試所有可能的分割點 對於每個分割點，檢查子字串是否為回文 只有當子字串是回文時，才繼續Recursion分割 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; partition(String s) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); backtrack(result, new ArrayList\u0026lt;\u0026gt;(), s, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; result, List\u0026lt;String\u0026gt; currentPath, String s, int startIndex) { // 達到字串結尾，找到一個完整的分割方案 if (startIndex == s.length()) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } // 嘗試所有可能的分割點 for (int endIndex = startIndex; endIndex \u0026lt; s.length(); endIndex++) { // 檢查當前子字串是否為回文 if (isPalindrome(s, startIndex, endIndex)) { // 做選擇：將回文子字串加入路徑 currentPath.add(s.substring(startIndex, endIndex + 1)); // Recursion探索：繼續分割剩餘部分 backtrack(result, currentPath, s, endIndex + 1); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); } } } /** * 檢查字串的指定範圍是否為回文 */ private boolean isPalindrome(String s, int left, int right) { while (left \u0026lt; right) { if (s.charAt(left) != s.charAt(right)) { return false; } left++; right--; } return true; } 優化技巧：可以預處理回文判斷結果，使用動態規劃建立回文查詢表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 預處理優化版本 private boolean[][] precomputePalindromes(String s) { int n = s.length(); boolean[][] isPalin = new boolean[n][n]; // 單個字元都是回文 for (int i = 0; i \u0026lt; n; i++) { isPalin[i][i] = true; } // 檢查長度為 2 的子字串 for (int i = 0; i \u0026lt; n - 1; i++) { isPalin[i][i + 1] = (s.charAt(i) == s.charAt(i + 1)); } // 檢查長度大於 2 的子字串 for (int len = 3; len \u0026lt;= n; len++) { for (int i = 0; i \u0026lt;= n - len; i++) { int j = i + len - 1; isPalin[i][j] = (s.charAt(i) == s.charAt(j)) \u0026amp;\u0026amp; isPalin[i + 1][j - 1]; } } return isPalin; } 最佳實踐與技巧 1. 剪枝優化 提早終止：當發現當前路徑不可能產生有效解時，立即返回 排序優化：對輸入進行排序，便於跳過重複元素和進行範圍剪枝 邊界檢查：在Recursion前檢查邊界條件，避免無效Recursion 2. 去重技巧 回溯問題中的去重通常有兩種情況：\n樹枝去重：避免在同一條路徑上重複使用同一個元素 樹層去重：避免在同一層Recursion中產生重複的選擇 1 2 3 4 5 // 樹層去重（適用於有重複元素的組合問題） if (i \u0026gt; startIndex \u0026amp;\u0026amp; nums[i] == nums[i-1]) continue; // 樹枝去重（適用於排列問題） if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1]) continue; 3. 效能優化 使用 boolean[] 取代 List.contains() 進行元素查找 預處理計算結果（如回文判斷表） 合理選擇資料結構（如使用 StringBuilder 處理字串） 常見錯誤與陷阱 忘記撤銷選擇：這是回溯演算法最常見的錯誤 重複解處理不當：沒有正確實現去重邏輯 邊界條件錯誤：Recursion終止條件設置不正確 索引使用錯誤：在組合和排列問題中混淆 i 和 i+1 的使用 總結 回溯演算法是解決組合、排列、分割等問題的重要工具。掌握以下要點：\n理解模板：Choose → Explore → Un-choose 三步驟 識別問題類型：子集、排列、組合、分割等不同類型有不同的處理方式 掌握去重技巧：樹層去重和樹枝去重的區別和應用 善用剪枝：透過剪枝大幅提升演算法效能 細心實作：注意邊界條件和索引使用 透過大量練習和理解這些經典題型，能夠幫助我們更好地掌握回溯演算法的精髓。\n","permalink":"https://xinqilin.github.io/post/algorithm/backtracking/","tags":["Algorithm","Backtracking","Recursion"],"title":"回溯演算法（Backtracking）完整指南"},{"content":"Rigidity, 難以變更 任何變更, 都需要去改其他的東西, 造成一個小小的需求就要去更改另個很大的東西\nFragility, 容易壞掉 任何變更都會導致其他有相依或無相依的東西超出想象的破壞, 改一個小東西, 結果其他重要的東西壞掉\nImmobility, 難以複用 系統中相依情況嚴重, 造成想要移出code 寫成 function 的成本 高於打掉重寫的成本\nViscosity, 難以正確修改 系統變更時, 因成本考量大多會以 治標不治本的方式改完需求,而非從源頭處修改\n","permalink":"https://xinqilin.github.io/post/architecture/badsmell/","tags":[],"title":"BadSmell"},{"content":"GitHub SSH Setting 1 2 3 4 5 6 7 8 9 10 11 12 cd ~/ mkdir .ssh ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; (是否要用預設檔名) enter \u0026gt;\u0026gt; (密碼) enter \u0026gt;\u0026gt; (密碼確認) enter cat .ssh/id_ed25519.pub \u0026gt;\u0026gt; 跑出公鑰 貼到 github 上 ssh -T git@github.com \u0026gt;\u0026gt; 測試連線 \u0026gt;\u0026gt; \u0026#34;Hi xinqilin! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access.\u0026#34; 重設 remote url =\u0026gt; https 改 ssh 1 2 git remote rm origin git remote add origin [url] 應用程式要用的 token setting -\u0026gt; developer setting -\u0026gt; personal access token -\u0026gt; generate new token\nGitHub 教學 ","permalink":"https://xinqilin.github.io/post/tools/github-ssh/","tags":[],"title":"Github Ssh"},{"content":"概述 在現代開發流程中，使用 Docker 部署資料庫已成為主流。將 MySQL 運行在 Docker 容器中，可以帶來許多好處：環境隔離、快速部署、版本控制、以及方便的遷移。這篇文章將引導您如何在 Docker 中設定和管理 MySQL 容器。\n啟動 MySQL 容器 使用 docker run 指令可以快速啟動一個 MySQL 容器。以下是一個常用的範例，包含了密碼設定、埠映射和字元集設定。\n1 2 3 4 5 6 7 8 9 docker run \\ --name mysql-server \\ -e MYSQL_ROOT_PASSWORD=your_strong_password \\ -p 3306:3306 \\ -d \\ mysql/mysql-server \\ --character-set-server=utf8mb4 \\ --collation-server=utf8mb4_unicode_ci \\ --skip-character-set-client-handshake 指令參數說明 --name mysql-server: 為容器指定一個易於識別的名稱，這裡命名為 mysql-server。 -e MYSQL_ROOT_PASSWORD=your_strong_password: 設定 MySQL root 使用者的密碼。請務必將 your_strong_password 替換為您自己的強密碼。 -p 3306:3306: 將主機的 3306 埠映射到容器的 3306 埠。這樣您就可以從主機透過 3306 埠連接到容器內的 MySQL 服務。 -d: 以背景模式 (detached mode) 運行容器，讓容器在背景執行。 mysql/mysql-server: 指定要使用的 Docker 映像檔。mysql/mysql-server 是 MySQL 官方提供的映像檔。 --character-set-server=utf8mb4: 設定 MySQL 伺服器的預設字元集為 utf8mb4，以支援更廣泛的字元，包括表情符號。 --collation-server=utf8mb4_unicode_ci: 設定伺服器的預設排序規則為 utf8mb4_unicode_ci，這是一種不區分大小寫和重音的排序規則。 --skip-character-set-client-handshake: 禁用客戶端字元集握手。這有助於確保客戶端和伺服器之間的字元集一致性，避免亂碼問題。 字元集設定的等效配置 上述字元集相關的 docker run 參數，在 MySQL 的配置檔 (my.cnf) 中，等效於以下設定：\n1 2 3 4 5 6 7 8 9 [client] default-character-set=utf8mb4 [mysql] default-character-set=utf8mb4 [mysqld] collation-server = utf8mb4_unicode_ci character-set-server = utf8mb4 資料持久化 (Data Persistence) 對於資料庫容器，資料持久化是至關重要的。如果沒有將資料儲存到主機上，一旦容器被移除，所有資料都將丟失。Docker 提供了兩種主要方式來實現資料持久化：綁定掛載 (Bind Mounts) 和 具名儲存卷 (Named Volumes)。\n使用具名儲存卷 (推薦) 具名儲存卷由 Docker 管理，是持久化資料的最佳方式。\n1 2 3 4 5 6 7 8 9 10 docker run \\ --name mysql-server \\ -e MYSQL_ROOT_PASSWORD=your_strong_password \\ -p 3306:3306 \\ -d \\ -v mysql_data:/var/lib/mysql \\ mysql/mysql-server \\ --character-set-server=utf8mb4 \\ --collation-server=utf8mb4_unicode_ci \\ --skip-character-set-client-handshake -v mysql_data:/var/lib/mysql: 這裡 mysql_data 是一個具名儲存卷。Docker 會自動創建並管理這個儲存卷，將容器內 /var/lib/mysql (MySQL 資料預設儲存路徑) 的資料持久化到這個儲存卷中。 您可以透過 docker volume ls 查看所有具名儲存卷，並透過 docker volume inspect mysql_data 查看其詳細資訊。\n使用綁定掛載 綁定掛載允許您將主機上的任意目錄直接掛載到容器中。\n1 2 3 4 5 6 7 8 9 10 docker run \\ --name mysql-server \\ -e MYSQL_ROOT_PASSWORD=your_strong_password \\ -p 3306:3306 \\ -d \\ -v /path/to/your/mysql_data:/var/lib/mysql \\ mysql/mysql-server \\ --character-set-server=utf8mb4 \\ --collation-server=utf8mb4_unicode_ci \\ --skip-character-set-client-handshake -v /path/to/your/mysql_data:/var/lib/mysql: 將主機上的 /path/to/your/mysql_data 目錄掛載到容器內的 /var/lib/mysql。請將 /path/to/your/mysql_data 替換為您主機上的實際路徑。 連接到 MySQL 容器 一旦 MySQL 容器運行起來，您有多種方式可以連接到它。\n從主機連接 如果您的主機上安裝了 MySQL 客戶端，可以直接透過 localhost 和映射的埠連接：\n1 mysql -h 127.0.0.1 -P 3306 -u root -p 然後輸入您在 docker run 指令中設定的 MYSQL_ROOT_PASSWORD。\n進入容器內部連接 您可以使用 docker exec 指令進入運行中的容器，然後在容器內部使用 MySQL 客戶端：\n1 2 3 4 5 # 進入容器的 bash shell docker exec -it mysql-server /bin/bash # 在容器內部執行 MySQL 客戶端 mysql -u root -p 然後輸入密碼。\n最佳實踐與考量 密碼安全：在生產環境中，請勿將密碼直接寫在 docker run 指令中。考慮使用 Docker Secrets 或環境變數檔案 (.env) 來管理敏感資訊。 資源限制：對於生產環境，建議為 MySQL 容器設定 CPU 和記憶體限制，以避免其佔用過多主機資源。 日誌管理：監控 MySQL 容器的日誌 (docker logs mysql-server) 對於故障排除非常重要。 Docker Compose：對於多服務應用程式，強烈建議使用 Docker Compose 來定義和管理 MySQL 服務，這會讓整個應用程式的部署和管理更加便捷。 透過 Docker 容器化部署 MySQL，您可以更高效、更靈活地管理您的資料庫環境。\n","permalink":"https://xinqilin.github.io/post/devops/docker-mysql/","tags":["Docker","MySQL","DevOps","Database","Containerization"],"title":"Docker MySQL：容器化部署與設定"},{"content":"Basic u: All Users +: add permission x: execute chmod u+x *.sh\nHomebrew /usr/bin/ruby -e \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026quot; brew install cask brew install wget\nSDKMAN curl -s \u0026quot;https://get.sdkman.io\u0026quot; | bash source \u0026quot;$HOME/.sdkman/bin/sdkman-init.sh\u0026quot;\nOPENJDK /Library/Java/JavaVirtualMachines/ 下面 /usr/libexec/java_home --verbose\nremove\n1 2 cd /Library/Java/JavaVirtualMachines/ sudo rm -rf amazon-corretto-11.jdk MAVEN \u0026amp; GRADLE 1 2 3 4 5 6 7 8 9 10 sdk list java sdk current java sdk list java sdk list gradle sdk install gradle \u0026#39;version\u0026#39; sdk list maven sdk list java history| grep sdk sdk list maven sdk install maven \u0026#39;version\u0026#39; NVM curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash\nCheatSheet Fig brew install --cask fig\nleave end of file to change userName 1 2 3 4 5 prompt_context() { if [[ \u0026#34;$USER\u0026#34; != \u0026#34;$DEFAULT_USER\u0026#34; || -n \u0026#34;$SSH_CLIENT\u0026#34; ]]; then prompt_segment black default \u0026#34;%(!.%{%F{yellow}%}.)Bill\u0026#34; fi } zsh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 # Fig pre block. Keep at the top of this file. [[ -f \u0026#34;$HOME/.fig/shell/zshrc.pre.zsh\u0026#34; ]] \u0026amp;\u0026amp; builtin source \u0026#34;$HOME/.fig/shell/zshrc.pre.zsh\u0026#34; # Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc. # Initialization code that may require console input (password prompts, [y/n] # confirmations, etc.) must go above this block; everything else may go below. if [[ -r \u0026#34;${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh\u0026#34; ]]; then source \u0026#34;${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh\u0026#34; fi # 懶人指令 alias hist=\u0026#39;history\u0026#39; alias d=\u0026#39;docker\u0026#39; alias gs=\u0026#39;git status\u0026#39; alias g=\u0026#39;git\u0026#39; # JDK # JAVA_HOME=/Library/Java/JavaVirtualMachines/amazon-corretto-11.jdk/Contents/Home JAVA_HOME=/Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home # JAVA_HOME=/Library/Java/JavaVirtualMachines/graalvm-ce-lts-java11-20.3.4/Contents/Home # JAVA_HOME=/Library/Java/JavaVirtualMachines/graalvm-ce-java17-22.1.0/Contents/Home PATH=$JAVA_HOME/bin:$PATH:. CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:. export JAVA_HOME export PATH export CLASSPATH #THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!! export SDKMAN_DIR=\u0026#34;$HOME/.sdkman\u0026#34; [[ -s \u0026#34;$HOME/.sdkman/bin/sdkman-init.sh\u0026#34; ]] \u0026amp;\u0026amp; source \u0026#34;$HOME/.sdkman/bin/sdkman-init.sh\u0026#34; # homebrew # x86_64 version brew path # 這邊會把舊版本取為 brow (o for old) export PATH=/opt/homebrew/bin:$PATH alias brow=\u0026#39;arch --x86_64 /usr/local/Homebrew/bin/brew\u0026#39; # nvm export NVM_DIR=\u0026#34;$([ -z \u0026#34;${XDG_CONFIG_HOME-}\u0026#34; ] \u0026amp;\u0026amp; printf %s \u0026#34;${HOME}/.nvm\u0026#34; || printf %s \u0026#34;${XDG_CONFIG_HOME}/nvm\u0026#34;)\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm # If you come from bash you might have to change your $PATH. # export PATH=$HOME/bin:/usr/local/bin:$PATH # Path to your oh-my-zsh installation. export ZSH=\u0026#34;$HOME/.oh-my-zsh\u0026#34; # Set name of the theme to load --- if set to \u0026#34;random\u0026#34;, it will # load a random theme each time oh-my-zsh is loaded, in which case, # to know which specific one was loaded, run: echo $RANDOM_THEME # See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes ZSH_THEME=\u0026#34;agnoster\u0026#34; # ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; # Set list of themes to pick from when loading at random # Setting this variable when ZSH_THEME=random will cause zsh to load # a theme from this variable instead of looking in $ZSH/themes/ # If set to an empty array, this variable will have no effect. # ZSH_THEME_RANDOM_CANDIDATES=( \u0026#34;robbyrussell\u0026#34; \u0026#34;agnoster\u0026#34; ) # Uncomment the following line to use case-sensitive completion. # CASE_SENSITIVE=\u0026#34;true\u0026#34; # Uncomment the following line to use hyphen-insensitive completion. # Case-sensitive completion must be off. _ and - will be interchangeable. # HYPHEN_INSENSITIVE=\u0026#34;true\u0026#34; # Uncomment one of the following lines to change the auto-update behavior # zstyle \u0026#39;:omz:update\u0026#39; mode disabled # disable automatic updates # zstyle \u0026#39;:omz:update\u0026#39; mode auto # update automatically without asking # zstyle \u0026#39;:omz:update\u0026#39; mode reminder # just remind me to update when it\u0026#39;s time # Uncomment the following line to change how often to auto-update (in days). # zstyle \u0026#39;:omz:update\u0026#39; frequency 13 # Uncomment the following line if pasting URLs and other text is messed up. # DISABLE_MAGIC_FUNCTIONS=\u0026#34;true\u0026#34; # Uncomment the following line to disable colors in ls. # DISABLE_LS_COLORS=\u0026#34;true\u0026#34; # Uncomment the following line to disable auto-setting terminal title. # DISABLE_AUTO_TITLE=\u0026#34;true\u0026#34; # Uncomment the following line to enable command auto-correction. # ENABLE_CORRECTION=\u0026#34;true\u0026#34; # Uncomment the following line to display red dots whilst waiting for completion. # You can also set it to another string to have that shown instead of the default red dots. # e.g. COMPLETION_WAITING_DOTS=\u0026#34;%F{yellow}waiting...%f\u0026#34; # Caution: this setting can cause issues with multiline prompts in zsh \u0026lt; 5.7.1 (see #5765) # COMPLETION_WAITING_DOTS=\u0026#34;true\u0026#34; # Uncomment the following line if you want to disable marking untracked files # under VCS as dirty. This makes repository status check for large repositories # much, much faster. # DISABLE_UNTRACKED_FILES_DIRTY=\u0026#34;true\u0026#34; # Uncomment the following line if you want to change the command execution time # stamp shown in the history command output. # You can set one of the optional three formats: # \u0026#34;mm/dd/yyyy\u0026#34;|\u0026#34;dd.mm.yyyy\u0026#34;|\u0026#34;yyyy-mm-dd\u0026#34; # or set a custom format using the strftime function format specifications, # see \u0026#39;man strftime\u0026#39; for details. # HIST_STAMPS=\u0026#34;mm/dd/yyyy\u0026#34; # Would you like to use another custom folder than $ZSH/custom? # ZSH_CUSTOM=/path/to/new-custom-folder # Which plugins would you like to load? # Standard plugins can be found in $ZSH/plugins/ # Custom plugins may be added to $ZSH_CUSTOM/plugins/ # Example format: plugins=(rails git textmate ruby lighthouse) # Add wisely, as too many plugins slow down shell startup. plugins=(git) source $ZSH/oh-my-zsh.sh # User configuration # export MANPATH=\u0026#34;/usr/local/man:$MANPATH\u0026#34; # You may need to manually set your language environment # export LANG=en_US.UTF-8 # Preferred editor for local and remote sessions # if [[ -n $SSH_CONNECTION ]]; then # export EDITOR=\u0026#39;vim\u0026#39; # else # export EDITOR=\u0026#39;mvim\u0026#39; # fi # Compilation flags # export ARCHFLAGS=\u0026#34;-arch x86_64\u0026#34; # Set personal aliases, overriding those provided by oh-my-zsh libs, # plugins, and themes. Aliases can be placed here, though oh-my-zsh # users are encouraged to define aliases within the ZSH_CUSTOM folder. # For a full list of active aliases, run `alias`. # # Example aliases # alias zshconfig=\u0026#34;mate ~/.zshrc\u0026#34; # alias ohmyzsh=\u0026#34;mate ~/.oh-my-zsh\u0026#34; code () { VSCODE_CWD=\u0026#34;$PWD\u0026#34; open -n -b \u0026#34;com.microsoft.VSCode\u0026#34; --args $* ;} plugins=( git zsh-syntax-highlighting zsh-autosuggestions ) # To customize prompt, run `p10k configure` or edit ~/.p10k.zsh. [[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh # 這行控制 userName prompt_context() { if [[ \u0026#34;$USER\u0026#34; != \u0026#34;$DEFAULT_USER\u0026#34; || -n \u0026#34;$SSH_CLIENT\u0026#34; ]]; then prompt_segment black default \u0026#34;%(!.%{%F{yellow}%}.)Bill\u0026#34; fi } # Fig post block. Keep at the bottom of this file. [[ -f \u0026#34;$HOME/.fig/shell/zshrc.post.zsh\u0026#34; ]] \u0026amp;\u0026amp; builtin source \u0026#34;$HOME/.fig/shell/zshrc.post.zsh\u0026#34; ","permalink":"https://xinqilin.github.io/post/tools/env/","tags":[],"title":"Env"},{"content":"概述 拓撲排序（Topological Sort）是對**有向無環圖（DAG, Directed Acyclic Graph）**進行排序的演算法。排序結果是一個線性序列，使得對於圖中任意有向邊 (u, v)，在排序結果中 u 都出現在 v 之前。\n基本概念 應用場景 課程排課：某些課程有先修課程的要求 編譯依賴：程式模組間的編譯順序 任務調度：有依賴關係的任務執行順序 Makefile 建構：檔案間的依賴關係 前提條件 圖必須是有向無環圖（DAG） 如果圖中存在環，則無法進行拓撲排序 演算法實作 方法一：Kahn 演算法（BFS 基礎） 基本思路 計算所有節點的入度 將入度為 0 的節點加入佇列 不斷從佇列中取出節點，並減少其相鄰節點的入度 如果相鄰節點的入度變為 0，則加入佇列 重複直到佇列為空 實作代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public class TopologicalSort { public List\u0026lt;Integer\u0026gt; topologicalSort(int numNodes, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; edges) { // 建立鄰接表和入度陣列 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] indegree = new int[numNodes]; for (int i = 0; i \u0026lt; numNodes; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } // 建構圖並計算入度 for (List\u0026lt;Integer\u0026gt; edge : edges) { int from = edge.get(0); int to = edge.get(1); graph.get(from).add(to); indegree[to]++; } // 將入度為 0 的節點加入佇列 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numNodes; i++) { if (indegree[i] == 0) { queue.offer(i); } } List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // BFS 處理 while (!queue.isEmpty()) { int node = queue.poll(); result.add(node); // 減少相鄰節點的入度 for (int neighbor : graph.get(node)) { indegree[neighbor]--; if (indegree[neighbor] == 0) { queue.offer(neighbor); } } } // 檢查是否存在環 if (result.size() != numNodes) { return new ArrayList\u0026lt;\u0026gt;(); // 存在環，無法拓撲排序 } return result; } } 方法二：DFS 基礎 基本思路 對每個未訪問的節點進行 DFS 在 DFS 回溯時將節點加入結果 反轉結果得到拓撲排序 實作代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 public class TopologicalSortDFS { private static final int WHITE = 0; // 未訪問 private static final int GRAY = 1; // 正在訪問 private static final int BLACK = 2; // 已完成 public List\u0026lt;Integer\u0026gt; topologicalSort(int numNodes, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; edges) { // 建立鄰接表 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numNodes; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (List\u0026lt;Integer\u0026gt; edge : edges) { graph.get(edge.get(0)).add(edge.get(1)); } int[] color = new int[numNodes]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 對每個未訪問的節點進行 DFS for (int i = 0; i \u0026lt; numNodes; i++) { if (color[i] == WHITE) { if (!dfs(graph, i, color, stack)) { return new ArrayList\u0026lt;\u0026gt;(); // 存在環 } } } // 反轉結果 List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); while (!stack.isEmpty()) { result.add(stack.pop()); } return result; } private boolean dfs(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph, int node, int[] color, Stack\u0026lt;Integer\u0026gt; stack) { color[node] = GRAY; // 標記為正在訪問 for (int neighbor : graph.get(node)) { if (color[neighbor] == GRAY) { return false; // 發現後向邊，存在環 } if (color[neighbor] == WHITE \u0026amp;\u0026amp; !dfs(graph, neighbor, color, stack)) { return false; } } color[node] = BLACK; // 標記為已完成 stack.push(node); // 後序遍歷順序 return true; } } 實際應用題型 1. 課程安排（LeetCode 207 \u0026amp; 210） 問題 207：判斷是否可以完成所有課程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public boolean canFinish(int numCourses, int[][] prerequisites) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] indegree = new int[numCourses]; // 初始化圖 for (int i = 0; i \u0026lt; numCourses; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } // 建構圖 for (int[] prereq : prerequisites) { graph.get(prereq[1]).add(prereq[0]); indegree[prereq[0]]++; } // Kahn 演算法 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } int completedCourses = 0; while (!queue.isEmpty()) { int course = queue.poll(); completedCourses++; for (int nextCourse : graph.get(course)) { indegree[nextCourse]--; if (indegree[nextCourse] == 0) { queue.offer(nextCourse); } } } return completedCourses == numCourses; } 問題 210：返回課程安排的順序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public int[] findOrder(int numCourses, int[][] prerequisites) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] indegree = new int[numCourses]; // 建構圖（同上） for (int i = 0; i \u0026lt; numCourses; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] prereq : prerequisites) { graph.get(prereq[1]).add(prereq[0]); indegree[prereq[0]]++; } Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } int[] result = new int[numCourses]; int index = 0; while (!queue.isEmpty()) { int course = queue.poll(); result[index++] = course; for (int nextCourse : graph.get(course)) { indegree[nextCourse]--; if (indegree[nextCourse] == 0) { queue.offer(nextCourse); } } } return index == numCourses ? result : new int[0]; } 2. 所有可能的菜譜（LeetCode 2115） 問題描述：給定可製作的菜譜、所需原料以及現有原料，找出所有可能製作的菜譜。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Solution { private static final int NOT_VISITED = 0; private static final int VISITING = 1; private static final int VISITED = 2; public List\u0026lt;String\u0026gt; findAllRecipes(String[] recipes, List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; ingredients, String[] supplies) { Map\u0026lt;String, Integer\u0026gt; status = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; prereqs = new HashMap\u0026lt;\u0026gt;(); // 初始化食譜和其所需原料 for (int i = 0; i \u0026lt; recipes.length; i++) { status.put(recipes[i], NOT_VISITED); prereqs.put(recipes[i], ingredients.get(i)); } // 將現有原料標記為已訪問 for (String supply : supplies) { status.put(supply, VISITED); } List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // 對每個食譜進行 DFS for (String recipe : recipes) { dfs(recipe, prereqs, status, result); } return result; } private boolean dfs(String item, Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; prereqs, Map\u0026lt;String, Integer\u0026gt; status, List\u0026lt;String\u0026gt; result) { if (!status.containsKey(item)) { return false; // 不存在此原料或食譜 } if (status.get(item) == VISITING) { return false; // 發現環，無法製作 } if (status.get(item) == VISITED) { return true; // 已經可以製作 } // 標記為正在訪問 status.put(item, VISITING); // 檢查所有前置條件 if (prereqs.containsKey(item)) { for (String ingredient : prereqs.get(item)) { if (!dfs(ingredient, prereqs, status, result)) { return false; } } } // 標記為已完成 status.put(item, VISITED); result.add(item); return true; } } 複雜度分析 演算法 時間複雜度 空間複雜度 優點 缺點 Kahn (BFS) O(V + E) O(V) 實作簡單，易於理解 需要額外的入度陣列 DFS O(V + E) O(V) 可以檢測環，記憶體使用較少 實作稍複雜 其中 V 是節點數，E 是邊數。\n實作技巧 1. 環的檢測 1 2 3 4 5 6 7 8 9 10 // Kahn 演算法：如果處理的節點數不等於總節點數，則存在環 if (processedNodes != totalNodes) { // 存在環 } // DFS：使用三色標記法檢測後向邊 if (color[neighbor] == GRAY) { // 發現後向邊，存在環 return false; } 2. 多個拓撲排序解 如果需要找出所有可能的拓撲排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public void findAllTopologicalSorts(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph, int[] indegree, List\u0026lt;Integer\u0026gt; current, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; allResults) { Queue\u0026lt;Integer\u0026gt; available = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; indegree.length; i++) { if (indegree[i] == 0) { available.offer(i); } } if (available.isEmpty()) { if (current.size() == indegree.length) { allResults.add(new ArrayList\u0026lt;\u0026gt;(current)); } return; } // 嘗試所有可能的下一個節點 for (int node : available) { // 選擇 current.add(node); int[] newIndegree = indegree.clone(); newIndegree[node] = -1; // 標記為已使用 for (int neighbor : graph.get(node)) { newIndegree[neighbor]--; } // 遞歸 findAllTopologicalSorts(graph, newIndegree, current, allResults); // 撤銷選擇 current.remove(current.size() - 1); } } 總結 拓撲排序是處理有依賴關係問題的重要演算法。掌握要點：\n適用條件：只能用於有向無環圖 兩種方法：Kahn 演算法（BFS）和 DFS 方法 環的檢測：兩種方法都能檢測圖中是否存在環 實際應用：課程安排、任務調度、編譯依賴等 選擇演算法時：\nKahn 演算法：邏輯直觀，適合初學者 DFS 方法：更靈活，能提供更多信息（如完成時間） 參考資料 LeetCode 207. Course Schedule LeetCode 210. Course Schedule II LeetCode 2115. Find All Possible Recipes from Given Supplies 演算法導論 - 圖的拓撲排序 ","permalink":"https://xinqilin.github.io/post/algorithm/topologicalsort/","tags":["Algorithm","Graph","TopologicalSort","DFS","BFS","Java"],"title":"拓撲排序（Topological Sort）演算法詳解"},{"content":"概述 Reactive Programming（響應式程式設計）是一種基於資料流和變化傳播的程式設計模式。在 Java 生態系統中，Project Reactor 是實現響應式程式設計的核心函式庫，而 Spring WebFlux 則建立在其之上，提供非阻塞式的 Web 應用程式開發能力。\n核心概念 什麼是 Reactive Programming？ 響應式程式設計的核心特徵：\n非阻塞（Non-blocking）：執行緒不會被 I/O 操作阻塞 事件驅動（Event-driven）：基於事件流處理資料 背壓支援（Backpressure）：自動處理生產者和消費者之間的速度差異 彈性（Resilient）：具備錯誤處理和恢復能力 響應性（Responsive）：快速回應使用者請求 Reactive Streams 規範 Reactive Streams 定義了四個核心介面：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public interface Publisher\u0026lt;T\u0026gt; { void subscribe(Subscriber\u0026lt;? super T\u0026gt; s); } public interface Subscriber\u0026lt;T\u0026gt; { void onSubscribe(Subscription s); void onNext(T t); void onError(Throwable t); void onComplete(); } public interface Subscription { void request(long n); void cancel(); } public interface Processor\u0026lt;T, R\u0026gt; extends Subscriber\u0026lt;T\u0026gt;, Publisher\u0026lt;R\u0026gt; { } Project Reactor 基礎 Mono 與 Flux Project Reactor 提供兩個核心類型：\nMono：發出 0 或 1 個元素的響應式流 Flux：發出 0 到 N 個元素的響應式流 創建響應式流 Mono 創建方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 創建包含單一值的 Mono Mono\u0026lt;String\u0026gt; mono1 = Mono.just(\u0026#34;Hello Reactive\u0026#34;); // 創建空的 Mono Mono\u0026lt;String\u0026gt; empty = Mono.empty(); // 從 Optional 創建 Mono\u0026lt;String\u0026gt; mono2 = Mono.justOrEmpty(Optional.of(\u0026#34;Optional Value\u0026#34;)); // 延遲創建 Mono\u0026lt;String\u0026gt; lazy = Mono.fromSupplier(() -\u0026gt; { // 複雜的計算邏輯 return \u0026#34;Computed Value\u0026#34;; }); // 從 Callable 創建 Mono\u0026lt;String\u0026gt; callable = Mono.fromCallable(() -\u0026gt; { Thread.sleep(1000); // 模擬耗時操作 return \u0026#34;Delayed Value\u0026#34;; }); // 錯誤 Mono Mono\u0026lt;String\u0026gt; error = Mono.error(new RuntimeException(\u0026#34;Something went wrong\u0026#34;)); Flux 創建方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 從可變參數創建 Flux\u0026lt;String\u0026gt; flux1 = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;); // 從集合創建 List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Cherry\u0026#34;); Flux\u0026lt;String\u0026gt; flux2 = Flux.fromIterable(list); // 創建數字範圍 Flux\u0026lt;Integer\u0026gt; range = Flux.range(1, 10); // 1 到 10 // 定時發射 Flux\u0026lt;Long\u0026gt; interval = Flux.interval(Duration.ofSeconds(1)); // 每秒發射一個遞增數字 // 從陣列創建 String[] array = {\u0026#34;X\u0026#34;, \u0026#34;Y\u0026#34;, \u0026#34;Z\u0026#34;}; Flux\u0026lt;String\u0026gt; flux3 = Flux.fromArray(array); // 從 Stream 創建 Flux\u0026lt;String\u0026gt; flux4 = Flux.fromStream(Stream.of(\u0026#34;Stream1\u0026#34;, \u0026#34;Stream2\u0026#34;)); 訂閱與消費 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 基本訂閱 Flux\u0026lt;Integer\u0026gt; numbers = Flux.range(1, 5); // 只處理數據 numbers.subscribe(System.out::println); // 處理數據和錯誤 numbers.subscribe( data -\u0026gt; System.out.println(\u0026#34;Data: \u0026#34; + data), error -\u0026gt; System.err.println(\u0026#34;Error: \u0026#34; + error) ); // 完整的訂閱處理 numbers.subscribe( data -\u0026gt; System.out.println(\u0026#34;Next: \u0026#34; + data), // onNext error -\u0026gt; System.err.println(\u0026#34;Error: \u0026#34; + error), // onError () -\u0026gt; System.out.println(\u0026#34;Completed!\u0026#34;) // onComplete ); // 使用自訂 Subscriber numbers.subscribe(new BaseSubscriber\u0026lt;Integer\u0026gt;() { @Override protected void hookOnSubscribe(Subscription subscription) { System.out.println(\u0026#34;Subscribed\u0026#34;); request(1); // 請求第一個元素 } @Override protected void hookOnNext(Integer value) { System.out.println(\u0026#34;Value: \u0026#34; + value); if (value \u0026lt; 3) { request(1); // 繼續請求下一個 } else { cancel(); // 取消訂閱 } } }); 核心操作符詳解 轉換操作符 map - 元素轉換 1 2 3 4 5 6 7 8 9 Flux\u0026lt;String\u0026gt; names = Flux.just(\u0026#34;alice\u0026#34;, \u0026#34;bob\u0026#34;, \u0026#34;charlie\u0026#34;); // 轉換為大寫 Flux\u0026lt;String\u0026gt; upperNames = names.map(String::toUpperCase); upperNames.subscribe(System.out::println); // ALICE, BOB, CHARLIE // 轉換為長度 Flux\u0026lt;Integer\u0026gt; lengths = names.map(String::length); lengths.subscribe(System.out::println); // 5, 3, 7 flatMap - 扁平化處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Flux\u0026lt;String\u0026gt; sentences = Flux.just(\u0026#34;Hello World\u0026#34;, \u0026#34;Reactive Programming\u0026#34;); // 將每個句子拆分為單詞 Flux\u0026lt;String\u0026gt; words = sentences.flatMap(sentence -\u0026gt; Flux.fromArray(sentence.split(\u0026#34; \u0026#34;)) ); words.subscribe(System.out::println); // Hello, World, Reactive, Programming // 非同步處理 Flux\u0026lt;String\u0026gt; urls = Flux.just(\u0026#34;url1\u0026#34;, \u0026#34;url2\u0026#34;, \u0026#34;url3\u0026#34;); Flux\u0026lt;String\u0026gt; responses = urls.flatMap(url -\u0026gt; Mono.fromCallable(() -\u0026gt; { // 模擬 HTTP 請求 Thread.sleep(100); return \u0026#34;Response from \u0026#34; + url; }).subscribeOn(Schedulers.boundedElastic()) ); concatMap - 順序處理 1 2 3 4 5 // 與 flatMap 不同，concatMap 保持順序 Flux\u0026lt;String\u0026gt; ordered = urls.concatMap(url -\u0026gt; Mono.fromCallable(() -\u0026gt; \u0026#34;Response from \u0026#34; + url) .subscribeOn(Schedulers.boundedElastic()) ); 過濾操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Flux\u0026lt;Integer\u0026gt; numbers = Flux.range(1, 10); // 過濾偶數 Flux\u0026lt;Integer\u0026gt; evenNumbers = numbers.filter(n -\u0026gt; n % 2 == 0); // 取前 3 個元素 Flux\u0026lt;Integer\u0026gt; first3 = numbers.take(3); // 跳過前 5 個元素 Flux\u0026lt;Integer\u0026gt; skip5 = numbers.skip(5); // 去重 Flux\u0026lt;String\u0026gt; duplicates = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;B\u0026#34;); Flux\u0026lt;String\u0026gt; distinct = duplicates.distinct(); // 取不重複元素直到遇到重複 Flux\u0026lt;String\u0026gt; distinctUntilChanged = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .distinctUntilChanged(); 組合操作符 merge - 合併多個流 1 2 3 4 5 6 7 8 9 Flux\u0026lt;String\u0026gt; flux1 = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;).delayElements(Duration.ofMillis(100)); Flux\u0026lt;String\u0026gt; flux2 = Flux.just(\u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;).delayElements(Duration.ofMillis(150)); // 合併（順序不保證） Flux\u0026lt;String\u0026gt; merged = Flux.merge(flux1, flux2); merged.subscribe(System.out::println); // 可能輸出: A, C, B, D // 使用 mergeWith Flux\u0026lt;String\u0026gt; merged2 = flux1.mergeWith(flux2); concat - 連接流 1 2 3 4 5 6 // 連接（保持順序） Flux\u0026lt;String\u0026gt; concatenated = Flux.concat(flux1, flux2); concatenated.subscribe(System.out::println); // 輸出: A, B, C, D // 使用 concatWith Flux\u0026lt;String\u0026gt; concatenated2 = flux1.concatWith(flux2); zip - 配對元素 1 2 3 4 5 6 7 8 9 10 11 Flux\u0026lt;String\u0026gt; names = Flux.just(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;); Flux\u0026lt;Integer\u0026gt; ages = Flux.just(25, 30, 35); // 配對元素 Flux\u0026lt;String\u0026gt; people = Flux.zip(names, ages, (name, age) -\u0026gt; name + \u0026#34; is \u0026#34; + age + \u0026#34; years old\u0026#34; ); people.subscribe(System.out::println); // Alice is 25 years old // Bob is 30 years old // Charlie is 35 years old 錯誤處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Flux\u0026lt;String\u0026gt; source = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .map(s -\u0026gt; { if (\u0026#34;B\u0026#34;.equals(s)) { throw new RuntimeException(\u0026#34;Error on B\u0026#34;); } return s; }); // 提供預設值 Flux\u0026lt;String\u0026gt; withDefault = source.onErrorReturn(\u0026#34;DEFAULT\u0026#34;); // 繼續其他流 Flux\u0026lt;String\u0026gt; fallback = source.onErrorResume(error -\u0026gt; Flux.just(\u0026#34;FALLBACK1\u0026#34;, \u0026#34;FALLBACK2\u0026#34;) ); // 重試 Flux\u0026lt;String\u0026gt; withRetry = source.retry(3); // 重試且延遲 Flux\u0026lt;String\u0026gt; withRetryDelay = source.retryWhen( Retry.backoff(3, Duration.ofSeconds(1)) ); // 捕獲錯誤並繼續 Flux\u0026lt;String\u0026gt; continueOnError = source.onErrorContinue((error, item) -\u0026gt; { System.err.println(\u0026#34;Error on item \u0026#34; + item + \u0026#34;: \u0026#34; + error.getMessage()); }); 背壓（Backpressure）處理 背壓是響應式程式設計中的重要概念，用於處理生產者速度超過消費者處理能力的情況：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 背壓策略示例 Flux\u0026lt;Integer\u0026gt; fastProducer = Flux.range(1, 1000) .delayElements(Duration.ofMillis(1)); // 消費者處理較慢 fastProducer .onBackpressureBuffer(10) // 緩衝區大小為 10 .subscribe(new BaseSubscriber\u0026lt;Integer\u0026gt;() { @Override protected void hookOnSubscribe(Subscription subscription) { request(1); } @Override protected void hookOnNext(Integer value) { try { Thread.sleep(100); // 模擬慢處理 System.out.println(\u0026#34;Processed: \u0026#34; + value); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } request(1); } }); // 其他背壓策略 Flux\u0026lt;Integer\u0026gt; dropped = fastProducer.onBackpressureDrop(); Flux\u0026lt;Integer\u0026gt; latest = fastProducer.onBackpressureLatest(); Flux\u0026lt;Integer\u0026gt; error = fastProducer.onBackpressureError(); 排程器（Scheduler） Reactor 提供多種排程器來控制執行上下文：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 不同類型的排程器 Scheduler single = Schedulers.single(); // 單執行緒 Scheduler parallel = Schedulers.parallel(); // 並行處理（CPU 密集） Scheduler boundedElastic = Schedulers.boundedElastic(); // 彈性執行緒池（I/O 密集） Scheduler immediate = Schedulers.immediate(); // 當前執行緒 // 使用排程器 Flux\u0026lt;String\u0026gt; source = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;); // 在指定排程器上發布 Flux\u0026lt;String\u0026gt; published = source.publishOn(Schedulers.parallel()); // 在指定排程器上訂閱 Flux\u0026lt;String\u0026gt; subscribed = source.subscribeOn(Schedulers.boundedElastic()); // 組合使用 source .subscribeOn(Schedulers.boundedElastic()) // 訂閱在彈性執行緒池 .map(s -\u0026gt; s.toLowerCase()) // 轉換操作 .publishOn(Schedulers.parallel()) // 後續操作在並行排程器 .map(s -\u0026gt; s.toUpperCase()) .subscribe(System.out::println); Spring WebFlux 實戰 依賴配置 1 2 3 4 5 6 7 8 9 10 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-webflux\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-r2dbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 響應式 REST Controller 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { private final UserService userService; public UserController(UserService userService) { this.userService = userService; } @GetMapping public Flux\u0026lt;User\u0026gt; getAllUsers() { return userService.findAll(); } @GetMapping(\u0026#34;/{id}\u0026#34;) public Mono\u0026lt;ResponseEntity\u0026lt;User\u0026gt;\u0026gt; getUserById(@PathVariable String id) { return userService.findById(id) .map(user -\u0026gt; ResponseEntity.ok(user)) .defaultIfEmpty(ResponseEntity.notFound().build()); } @PostMapping public Mono\u0026lt;User\u0026gt; createUser(@RequestBody User user) { return userService.save(user); } @PutMapping(\u0026#34;/{id}\u0026#34;) public Mono\u0026lt;ResponseEntity\u0026lt;User\u0026gt;\u0026gt; updateUser(@PathVariable String id, @RequestBody User user) { return userService.update(id, user) .map(updatedUser -\u0026gt; ResponseEntity.ok(updatedUser)) .defaultIfEmpty(ResponseEntity.notFound().build()); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) public Mono\u0026lt;ResponseEntity\u0026lt;Void\u0026gt;\u0026gt; deleteUser(@PathVariable String id) { return userService.deleteById(id) .then(Mono.just(ResponseEntity.noContent().\u0026lt;Void\u0026gt;build())) .defaultIfEmpty(ResponseEntity.notFound().build()); } // 串流端點 @GetMapping(value = \u0026#34;/stream\u0026#34;, produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux\u0026lt;User\u0026gt; getUserStream() { return userService.findAll() .delayElements(Duration.ofSeconds(1)); // 每秒發送一個用戶 } } 響應式 Service 層 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @Service public class UserService { private final UserRepository userRepository; private final WebClient webClient; public UserService(UserRepository userRepository, WebClient.Builder webClientBuilder) { this.userRepository = userRepository; this.webClient = webClientBuilder.baseUrl(\u0026#34;https://api.external.com\u0026#34;).build(); } public Flux\u0026lt;User\u0026gt; findAll() { return userRepository.findAll(); } public Mono\u0026lt;User\u0026gt; findById(String id) { return userRepository.findById(id); } public Mono\u0026lt;User\u0026gt; save(User user) { return userRepository.save(user); } public Mono\u0026lt;User\u0026gt; update(String id, User user) { return userRepository.findById(id) .flatMap(existingUser -\u0026gt; { existingUser.setName(user.getName()); existingUser.setEmail(user.getEmail()); return userRepository.save(existingUser); }); } public Mono\u0026lt;Void\u0026gt; deleteById(String id) { return userRepository.deleteById(id); } // 組合多個非同步操作 public Mono\u0026lt;UserProfile\u0026gt; getUserProfile(String userId) { Mono\u0026lt;User\u0026gt; userMono = findById(userId); Mono\u0026lt;List\u0026lt;Order\u0026gt;\u0026gt; ordersMono = getOrdersByUserId(userId); Mono\u0026lt;UserPreferences\u0026gt; preferencesMono = getUserPreferences(userId); return Mono.zip(userMono, ordersMono, preferencesMono) .map(tuple -\u0026gt; new UserProfile( tuple.getT1(), // User tuple.getT2(), // Orders tuple.getT3() // Preferences )); } // 外部 API 呼叫 private Mono\u0026lt;List\u0026lt;Order\u0026gt;\u0026gt; getOrdersByUserId(String userId) { return webClient.get() .uri(\u0026#34;/orders?userId={userId}\u0026#34;, userId) .retrieve() .bodyToFlux(Order.class) .collectList() .timeout(Duration.ofSeconds(5)) // 5 秒逾時 .onErrorReturn(Collections.emptyList()); // 錯誤時返回空列表 } private Mono\u0026lt;UserPreferences\u0026gt; getUserPreferences(String userId) { return webClient.get() .uri(\u0026#34;/preferences/{userId}\u0026#34;, userId) .retrieve() .bodyToMono(UserPreferences.class) .onErrorReturn(new UserPreferences()); // 預設偏好設定 } } 響應式資料庫存取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // R2DBC Repository @Repository public interface UserRepository extends ReactiveCrudRepository\u0026lt;User, String\u0026gt; { Flux\u0026lt;User\u0026gt; findByNameContaining(String name); Flux\u0026lt;User\u0026gt; findByEmailDomain(String domain); @Query(\u0026#34;SELECT * FROM users WHERE created_at \u0026gt; :date\u0026#34;) Flux\u0026lt;User\u0026gt; findUsersCreatedAfter(LocalDateTime date); @Modifying @Query(\u0026#34;UPDATE users SET last_login = :loginTime WHERE id = :userId\u0026#34;) Mono\u0026lt;Integer\u0026gt; updateLastLogin(String userId, LocalDateTime loginTime); } // 自訂 Repository 實作 @Component public class CustomUserRepository { private final DatabaseClient databaseClient; public CustomUserRepository(DatabaseClient databaseClient) { this.databaseClient = databaseClient; } public Flux\u0026lt;User\u0026gt; findUsersByComplexCriteria(UserSearchCriteria criteria) { return databaseClient.sql(\u0026#34;\u0026#34;\u0026#34; SELECT * FROM users WHERE (:name IS NULL OR name LIKE :name) AND (:email IS NULL OR email = :email) AND (:minAge IS NULL OR age \u0026gt;= :minAge) ORDER BY created_at DESC \u0026#34;\u0026#34;\u0026#34;) .bind(\u0026#34;name\u0026#34;, criteria.getName() != null ? \u0026#34;%\u0026#34; + criteria.getName() + \u0026#34;%\u0026#34; : null) .bind(\u0026#34;email\u0026#34;, criteria.getEmail()) .bind(\u0026#34;minAge\u0026#34;, criteria.getMinAge()) .map((row, metadata) -\u0026gt; User.builder() .id(row.get(\u0026#34;id\u0026#34;, String.class)) .name(row.get(\u0026#34;name\u0026#34;, String.class)) .email(row.get(\u0026#34;email\u0026#34;, String.class)) .age(row.get(\u0026#34;age\u0026#34;, Integer.class)) .createdAt(row.get(\u0026#34;created_at\u0026#34;, LocalDateTime.class)) .build()) .all(); } } WebClient 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @Component public class ExternalApiClient { private final WebClient webClient; public ExternalApiClient(WebClient.Builder webClientBuilder) { this.webClient = webClientBuilder .baseUrl(\u0026#34;https://jsonplaceholder.typicode.com\u0026#34;) .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .build(); } // GET 請求 public Mono\u0026lt;Post\u0026gt; getPost(Long id) { return webClient.get() .uri(\u0026#34;/posts/{id}\u0026#34;, id) .retrieve() .onStatus(HttpStatus::is4xxClientError, response -\u0026gt; Mono.error(new NotFoundException(\u0026#34;Post not found\u0026#34;))) .onStatus(HttpStatus::is5xxServerError, response -\u0026gt; Mono.error(new ServiceException(\u0026#34;Server error\u0026#34;))) .bodyToMono(Post.class) .timeout(Duration.ofSeconds(10)) .retry(3); } // POST 請求 public Mono\u0026lt;Post\u0026gt; createPost(Post post) { return webClient.post() .uri(\u0026#34;/posts\u0026#34;) .bodyValue(post) .retrieve() .bodyToMono(Post.class); } // 批量請求 public Flux\u0026lt;Post\u0026gt; getAllPosts() { return webClient.get() .uri(\u0026#34;/posts\u0026#34;) .retrieve() .bodyToFlux(Post.class) .onBackpressureBuffer(100); // 緩衝處理 } // 並行請求 public Mono\u0026lt;List\u0026lt;PostWithComments\u0026gt;\u0026gt; getPostsWithComments(List\u0026lt;Long\u0026gt; postIds) { return Flux.fromIterable(postIds) .flatMap(this::getPostWithComments, 5) // 最多 5 個並行請求 .collectList(); } private Mono\u0026lt;PostWithComments\u0026gt; getPostWithComments(Long postId) { Mono\u0026lt;Post\u0026gt; postMono = getPost(postId); Mono\u0026lt;List\u0026lt;Comment\u0026gt;\u0026gt; commentsMono = getCommentsByPostId(postId); return Mono.zip(postMono, commentsMono, PostWithComments::new); } private Mono\u0026lt;List\u0026lt;Comment\u0026gt;\u0026gt; getCommentsByPostId(Long postId) { return webClient.get() .uri(\u0026#34;/posts/{postId}/comments\u0026#34;, postId) .retrieve() .bodyToFlux(Comment.class) .collectList(); } } 測試響應式程式碼 測試配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 @ExtendWith(MockitoExtension.class) class UserServiceTest { @Mock private UserRepository userRepository; @Mock private WebClient webClient; @Mock private WebClient.RequestHeadersUriSpec requestHeadersUriSpec; @Mock private WebClient.ResponseSpec responseSpec; @InjectMocks private UserService userService; @Test void testFindById() { // Given String userId = \u0026#34;123\u0026#34;; User expectedUser = new User(userId, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); when(userRepository.findById(userId)).thenReturn(Mono.just(expectedUser)); // When Mono\u0026lt;User\u0026gt; result = userService.findById(userId); // Then StepVerifier.create(result) .expectNext(expectedUser) .verifyComplete(); verify(userRepository).findById(userId); } @Test void testFindByIdNotFound() { // Given String userId = \u0026#34;999\u0026#34;; when(userRepository.findById(userId)).thenReturn(Mono.empty()); // When Mono\u0026lt;User\u0026gt; result = userService.findById(userId); // Then StepVerifier.create(result) .verifyComplete(); // 期望空結果 } @Test void testGetAllUsers() { // Given List\u0026lt;User\u0026gt; users = Arrays.asList( new User(\u0026#34;1\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;), new User(\u0026#34;2\u0026#34;, \u0026#34;Jane\u0026#34;, \u0026#34;jane@example.com\u0026#34;) ); when(userRepository.findAll()).thenReturn(Flux.fromIterable(users)); // When Flux\u0026lt;User\u0026gt; result = userService.findAll(); // Then StepVerifier.create(result) .expectNext(users.get(0)) .expectNext(users.get(1)) .verifyComplete(); } @Test void testSaveUser() { // Given User userToSave = new User(null, \u0026#34;New User\u0026#34;, \u0026#34;new@example.com\u0026#34;); User savedUser = new User(\u0026#34;123\u0026#34;, \u0026#34;New User\u0026#34;, \u0026#34;new@example.com\u0026#34;); when(userRepository.save(userToSave)).thenReturn(Mono.just(savedUser)); // When Mono\u0026lt;User\u0026gt; result = userService.save(userToSave); // Then StepVerifier.create(result) .expectNext(savedUser) .verifyComplete(); } @Test void testErrorHandling() { // Given String userId = \u0026#34;123\u0026#34;; when(userRepository.findById(userId)) .thenReturn(Mono.error(new RuntimeException(\u0026#34;Database error\u0026#34;))); // When Mono\u0026lt;User\u0026gt; result = userService.findById(userId); // Then StepVerifier.create(result) .expectError(RuntimeException.class) .verify(); } } 整合測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) class UserControllerIntegrationTest { @Autowired private WebTestClient webTestClient; @MockBean private UserService userService; @Test void testGetAllUsers() { // Given List\u0026lt;User\u0026gt; users = Arrays.asList( new User(\u0026#34;1\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;), new User(\u0026#34;2\u0026#34;, \u0026#34;Jane\u0026#34;, \u0026#34;jane@example.com\u0026#34;) ); when(userService.findAll()).thenReturn(Flux.fromIterable(users)); // When \u0026amp; Then webTestClient.get() .uri(\u0026#34;/api/users\u0026#34;) .exchange() .expectStatus().isOk() .expectBodyList(User.class) .hasSize(2) .contains(users.toArray(new User[0])); } @Test void testGetUserById() { // Given String userId = \u0026#34;123\u0026#34;; User user = new User(userId, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); when(userService.findById(userId)).thenReturn(Mono.just(user)); // When \u0026amp; Then webTestClient.get() .uri(\u0026#34;/api/users/{id}\u0026#34;, userId) .exchange() .expectStatus().isOk() .expectBody(User.class) .isEqualTo(user); } @Test void testGetUserByIdNotFound() { // Given String userId = \u0026#34;999\u0026#34;; when(userService.findById(userId)).thenReturn(Mono.empty()); // When \u0026amp; Then webTestClient.get() .uri(\u0026#34;/api/users/{id}\u0026#34;, userId) .exchange() .expectStatus().isNotFound(); } @Test void testCreateUser() { // Given User userToCreate = new User(null, \u0026#34;New User\u0026#34;, \u0026#34;new@example.com\u0026#34;); User createdUser = new User(\u0026#34;123\u0026#34;, \u0026#34;New User\u0026#34;, \u0026#34;new@example.com\u0026#34;); when(userService.save(any(User.class))).thenReturn(Mono.just(createdUser)); // When \u0026amp; Then webTestClient.post() .uri(\u0026#34;/api/users\u0026#34;) .bodyValue(userToCreate) .exchange() .expectStatus().isOk() .expectBody(User.class) .isEqualTo(createdUser); } } 效能優化與最佳實踐 1. 適當的背壓策略 1 2 3 4 5 6 7 8 9 // 根據情況選擇合適的背壓策略 public Flux\u0026lt;ProcessedData\u0026gt; processLargeDataset(Flux\u0026lt;RawData\u0026gt; input) { return input .onBackpressureBuffer(1000) // 適度緩衝 .flatMap(this::processData, 10) // 限制並行度 .onErrorContinue((error, item) -\u0026gt; { log.warn(\u0026#34;處理項目 {} 時發生錯誤: {}\u0026#34;, item, error.getMessage()); }); } 2. 合理使用排程器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Service public class OptimizedService { // CPU 密集型操作使用 parallel() public Mono\u0026lt;String\u0026gt; cpuIntensiveTask(String input) { return Mono.fromCallable(() -\u0026gt; { // 複雜計算 return performComplexCalculation(input); }).subscribeOn(Schedulers.parallel()); } // I/O 操作使用 boundedElastic() public Mono\u0026lt;String\u0026gt; ioTask(String filename) { return Mono.fromCallable(() -\u0026gt; { // 檔案讀取 return readFromFile(filename); }).subscribeOn(Schedulers.boundedElastic()); } } 3. 資源管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 使用 using() 確保資源正確釋放 public Mono\u0026lt;String\u0026gt; processFileWithProperCleanup(String filename) { return Mono.using( () -\u0026gt; Files.newBufferedReader(Paths.get(filename)), // 資源供應商 reader -\u0026gt; Mono.fromCallable(() -\u0026gt; { // 使用資源 return reader.lines().collect(Collectors.joining(\u0026#34;\\n\u0026#34;)); }).subscribeOn(Schedulers.boundedElastic()), reader -\u0026gt; { // 清理資源 try { reader.close(); } catch (IOException e) { log.warn(\u0026#34;關閉檔案時發生錯誤\u0026#34;, e); } } ); } 4. 快取策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Service public class CachedUserService { private final Cache\u0026lt;String, User\u0026gt; userCache = Caffeine.newBuilder() .maximumSize(1000) .expireAfterWrite(Duration.ofMinutes(10)) .build(); public Mono\u0026lt;User\u0026gt; getUserWithCache(String userId) { User cachedUser = userCache.getIfPresent(userId); if (cachedUser != null) { return Mono.just(cachedUser); } return userRepository.findById(userId) .doOnNext(user -\u0026gt; userCache.put(userId, user)) .cache(Duration.ofMinutes(5)); // Reactor 層級快取 } } 監控與除錯 1. 日誌記錄 1 2 3 4 5 6 7 8 public Flux\u0026lt;User\u0026gt; processUsers() { return userRepository.findAll() .doOnSubscribe(subscription -\u0026gt; log.info(\u0026#34;開始處理用戶\u0026#34;)) .doOnNext(user -\u0026gt; log.debug(\u0026#34;處理用戶: {}\u0026#34;, user.getId())) .doOnError(error -\u0026gt; log.error(\u0026#34;處理過程中發生錯誤\u0026#34;, error)) .doOnComplete(() -\u0026gt; log.info(\u0026#34;用戶處理完成\u0026#34;)) .doFinally(signalType -\u0026gt; log.info(\u0026#34;處理結束，信號類型: {}\u0026#34;, signalType)); } 2. 度量收集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Component public class MetricsService { private final MeterRegistry meterRegistry; private final Counter userProcessedCounter; private final Timer userProcessingTimer; public MetricsService(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; this.userProcessedCounter = Counter.builder(\u0026#34;users.processed\u0026#34;) .description(\u0026#34;處理的用戶數量\u0026#34;) .register(meterRegistry); this.userProcessingTimer = Timer.builder(\u0026#34;users.processing.time\u0026#34;) .description(\u0026#34;用戶處理時間\u0026#34;) .register(meterRegistry); } public Mono\u0026lt;User\u0026gt; processUserWithMetrics(User user) { return Mono.fromCallable(() -\u0026gt; { // 處理邏輯 return processUser(user); }) .doOnNext(u -\u0026gt; userProcessedCounter.increment()) .doOnSuccess(u -\u0026gt; userProcessingTimer.recordCallable(() -\u0026gt; { // 計時邏輯 return u; })) .subscribeOn(Schedulers.boundedElastic()); } } 總結 Reactive Programming 為 Java 開發者提供了處理非同步、非阻塞程式設計的強大工具。透過 Project Reactor 和 Spring WebFlux，我們可以：\n核心優勢 高效能：非阻塞 I/O 提升系統吞吐量 可擴展性：更好地利用系統資源 彈性：內建錯誤處理和恢復機制 組合性：豐富的操作符支援複雜的資料流處理 最佳實踐要點 適當場景：I/O 密集型應用程式最適合 操作符選擇：理解不同操作符的特性和適用場景 錯誤處理：設計完善的錯誤處理策略 測試：使用 StepVerifier 進行完整測試 監控：建立適當的日誌和度量機制 響應式程式設計雖然學習曲線較陡，但掌握後能顯著提升應用程式的效能和可維護性，特別適合現代微服務架構和雲端環境。\n參考資料 Project Reactor 官方文檔 Spring WebFlux 參考指南 Reactive Streams 規範 R2DBC 響應式資料庫存取 Reactor 3 Reference Guide ","permalink":"https://xinqilin.github.io/post/backend/reactivejava/","tags":["Java","Spring","WebFlux","Reactor","Reactive","Async","Mono","Flux"],"title":"Reactive Programming 完整指南：Spring WebFlux 與 Project Reactor"},{"content":"#721 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Input: accounts = [ [\u0026#34;John\u0026#34;,\u0026#34;johnsmith@mail.com\u0026#34;,\u0026#34;john_newyork@mail.com\u0026#34;], [\u0026#34;John\u0026#34;,\u0026#34;johnsmith@mail.com\u0026#34;,\u0026#34;john00@mail.com\u0026#34;], [\u0026#34;Mary\u0026#34;,\u0026#34;mary@mail.com\u0026#34;], [\u0026#34;John\u0026#34;,\u0026#34;johnnybravo@mail.com\u0026#34;] ] Output: [ [\u0026#34;John\u0026#34;,\u0026#34;john00@mail.com\u0026#34;,\u0026#34;john_newyork@mail.com\u0026#34;,\u0026#34;johnsmith@mail.com\u0026#34;], [\u0026#34;Mary\u0026#34;,\u0026#34;mary@mail.com\u0026#34;], [\u0026#34;John\u0026#34;,\u0026#34;johnnybravo@mail.com\u0026#34;] ] Explanation: The first and second John\u0026#39;s are the same person as they have the common email \u0026#34;johnsmith@mail.com\u0026#34;. The third John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [[\u0026#39;Mary\u0026#39;, \u0026#39;mary@mail.com\u0026#39;], [\u0026#39;John\u0026#39;, \u0026#39;johnnybravo@mail.com\u0026#39;], [\u0026#39;John\u0026#39;, \u0026#39;john00@mail.com\u0026#39;, \u0026#39;john_newyork@mail.com\u0026#39;, \u0026#39;johnsmith@mail.com\u0026#39;]] would still be accepted. Sol: Graph + DFS ref: click me!\n1 2 3 4 5 6 7 Use these edges to build some components. Common email addresses are like the intersections that connect each single component for each account. Because each component represents a merged account, do DFS search for each components and add into a list. Before add the name into this list, sort the emails. Then add name string into it. Examples: Assume we have three accounts, we connect them like this in order to use DFS. {Name, 1, 2, 3} =\u0026gt; Name -- 1 -- 2 -- 3 {Name, 2, 4, 5} =\u0026gt; Name -- 2 -- 4 -- 5 (The same graph node 2 appears) {Name, 6, 7, 8} =\u0026gt; Name -- 6 -- 7 -- 8 (Where numbers represent email addresses). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accountsMerge(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accounts) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if(accounts==null || accounts.size()==0) return result; Map\u0026lt;String, String\u0026gt; names = new HashMap\u0026lt;String, String\u0026gt;(); //email - username Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt;(); //email - neighbors Set\u0026lt;String\u0026gt; emails = new HashSet\u0026lt;String\u0026gt;(); for(List\u0026lt;String\u0026gt; list : accounts){ String name = list.get(0); for(int i=1; i\u0026lt;list.size(); i++){ String email = list.get(i); emails.add( email ); names.put( email, name ); map.putIfAbsent( email, new HashSet\u0026lt;String\u0026gt;() ); if(i==1) continue; //build the \u0026#34;edge\u0026#34; between two adjacent email-nodes map.get( list.get(i-1) ).add( email ); map.get( email ).add( list.get(i-1) ); } } Set\u0026lt;String\u0026gt; visited = new HashSet\u0026lt;String\u0026gt;(); for(String s : emails) if( !visited.contains(s) ){ visited.add(s); List\u0026lt;String\u0026gt; buffer = new ArrayList\u0026lt;String\u0026gt;(); buffer.add(s); helper(s, map, visited, buffer); Collections.sort(buffer); buffer.add(0, names.get(s)); result.add(buffer); } return result; } private void helper(String s, Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; map, Set\u0026lt;String\u0026gt; visited, List\u0026lt;String\u0026gt; buffer){ for(String node : map.get(s)) if( !visited.contains(node) ){ visited.add(node); buffer.add(node); helper(node, map, visited, buffer); } } } BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accountsMerge(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accounts) { HashMap\u0026lt;String,String\u0026gt; emailName = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; graph = new HashMap\u0026lt;\u0026gt;(); for(List\u0026lt;String\u0026gt; account: accounts){ String name = account.get(0); graph.putIfAbsent(account.get(1), new LinkedList\u0026lt;\u0026gt;()); emailName.put(account.get(1), name); for(int i = 2; i \u0026lt; account.size(); i++){ emailName.put(account.get(i), name); graph.putIfAbsent(account.get(i), new LinkedList\u0026lt;\u0026gt;()); graph.get(account.get(i)).add(account.get(1)); graph.get(account.get(1)).add(account.get(i)); } } List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); HashSet\u0026lt;String\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); for(String email: graph.keySet()){ if(visited.contains(email)) continue; visited.add(email); String name = emailName.get(email); List\u0026lt;String\u0026gt; emails = new LinkedList\u0026lt;\u0026gt;(); Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(email); while(!queue.isEmpty()){ String cur = queue.poll(); emails.add(cur); for(String next: graph.get(cur)){ if(!visited.contains(next)){ queue.offer(next); visited.add(next); } } } Collections.sort(emails); emails.add(0,name); res.add(emails); } return res; } ","permalink":"https://xinqilin.github.io/post/algorithm/graphaccountmerge/","tags":["Algorithm"],"title":"GraphAccountMerge"},{"content":"概述 二元樹遍歷是資料結構與演算法中的基本概念，主要有三種遍歷方式：前序遍歷（PreOrder）、中序遍歷（InOrder）、後序遍歷（PostOrder）。每種遍歷方式都有其特定的應用場景和優勢。\n基本概念 考慮以下二元樹結構：\n1 2 3 4 5 4 / \\ 2 6 / \\ / \\ 1 3 5 7 三種遍歷方式的順序 前序遍歷（PreOrder）：中 → 左 → 右\n遍歷順序：4 → 2 → 1 → 3 → 6 → 5 → 7 中序遍歷（InOrder）：左 → 中 → 右\n遍歷順序：1 → 2 → 3 → 4 → 5 → 6 → 7 對於二元搜尋樹，中序遍歷可得到有序序列 後序遍歷（PostOrder）：左 → 右 → 中\n遍歷順序：1 → 3 → 2 → 5 → 7 → 6 → 4 遍歷實作 1. 中序遍歷（InOrder Traversal） 中序遍歷在二元搜尋樹中特別有用，因為它會按升序訪問所有節點。\n遞歸實作 1 2 3 4 5 6 7 public void inorderTraversal(TreeNode root) { if (root == null) return; inorderTraversal(root.left); // 遍歷左子樹 System.out.print(root.val + \u0026#34; \u0026#34;); // 處理根節點 inorderTraversal(root.right); // 遍歷右子樹 } 迭代實作（使用堆疊） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode current = root; while (current != null || !stack.isEmpty()) { // 將所有左子節點推入堆疊 while (current != null) { stack.push(current); current = current.left; } // 處理堆疊頂部節點 current = stack.pop(); result.add(current.val); // 移動到右子樹 current = current.right; } return result; } 2. 前序遍歷（PreOrder Traversal） 前序遍歷適用於複製樹結構或建立表達式樹等場景。\n遞歸實作 1 2 3 4 5 6 7 public void preorderTraversal(TreeNode root) { if (root == null) return; System.out.print(root.val + \u0026#34; \u0026#34;); // 處理根節點 preorderTraversal(root.left); // 遍歷左子樹 preorderTraversal(root.right); // 遍歷右子樹 } 迭代實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return result; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode current = stack.pop(); result.add(current.val); // 注意：先推入右子節點，再推入左子節點 // 這樣確保左子節點先被處理 if (current.right != null) { stack.push(current.right); } if (current.left != null) { stack.push(current.left); } } return result; } 3. 後序遍歷（PostOrder Traversal） 後序遍歷適用於計算樹的大小、刪除節點或計算表達式值等場景。\n遞歸實作 1 2 3 4 5 6 7 public void postorderTraversal(TreeNode root) { if (root == null) return; postorderTraversal(root.left); // 遍歷左子樹 postorderTraversal(root.right); // 遍歷右子樹 System.out.print(root.val + \u0026#34; \u0026#34;); // 處理根節點 } 迭代實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return result; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode lastVisited = null; TreeNode current = root; while (current != null || !stack.isEmpty()) { if (current != null) { stack.push(current); current = current.left; } else { TreeNode peekNode = stack.peek(); // 如果右子節點存在且未被訪問過 if (peekNode.right != null \u0026amp;\u0026amp; lastVisited != peekNode.right) { current = peekNode.right; } else { result.add(peekNode.val); lastVisited = stack.pop(); } } } return result; } 實際應用：從遍歷序列重建二元樹 1. 從中序與後序遍歷重建二元樹 LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class Solution { public TreeNode buildTree(int[] inorder, int[] postorder) { if (inorder == null || inorder.length == 0 || postorder == null || postorder.length == 0) { return null; } return helper(postorder, postorder.length - 1, inorder, 0, inorder.length - 1); } private TreeNode helper(int[] postorder, int postIndex, int[] inorder, int inStart, int inEnd) { if (inStart \u0026gt; inEnd || postIndex \u0026lt; 0) { return null; } // 後序遍歷的最後一個元素是根節點 TreeNode root = new TreeNode(postorder[postIndex]); // 在中序遍歷中找到根節點的位置 int rootIndex = 0; for (int i = inStart; i \u0026lt;= inEnd; i++) { if (inorder[i] == root.val) { rootIndex = i; break; } } // 遞歸建構左右子樹 // 注意：先建構右子樹，因為後序遍歷是左-右-根 root.right = helper(postorder, postIndex - 1, inorder, rootIndex + 1, inEnd); root.left = helper(postorder, postIndex - (inEnd - rootIndex + 1), inorder, inStart, rootIndex - 1); return root; } } 2. 從前序與中序遍歷重建二元樹 LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { return helper(preorder, inorder, 0, 0, inorder.length - 1); } private TreeNode helper(int[] preorder, int[] inorder, int preStart, int inStart, int inEnd) { if (preStart \u0026gt; preorder.length - 1 || inStart \u0026gt; inEnd) { return null; } // 前序遍歷的第一個元素是根節點 TreeNode root = new TreeNode(preorder[preStart]); // 在中序遍歷中找到根節點的位置 int rootIndex = 0; for (int i = inStart; i \u0026lt;= inEnd; i++) { if (inorder[i] == preorder[preStart]) { rootIndex = i; break; } } // 遞歸建構左右子樹 root.left = helper(preorder, inorder, preStart + 1, inStart, rootIndex - 1); root.right = helper(preorder, inorder, preStart + rootIndex - inStart + 1, rootIndex + 1, inEnd); return root; } } 時間與空間複雜度 遍歷方式 時間複雜度 空間複雜度（遞歸） 空間複雜度（迭代） 前序遍歷 O(n) O(h) O(h) 中序遍歷 O(n) O(h) O(h) 後序遍歷 O(n) O(h) O(h) 其中 n 是節點數量，h 是樹的高度（最壞情況下 h = n，最佳情況下 h = log n）。\n應用場景總結 前序遍歷：複製樹、序列化樹結構、建立表達式樹 中序遍歷：二元搜尋樹的有序輸出、驗證二元搜尋樹 後序遍歷：計算樹的大小、刪除樹、計算表達式值、釋放記憶體 參考資料 LeetCode 94. Binary Tree Inorder Traversal LeetCode 144. Binary Tree Preorder Traversal LeetCode 145. Binary Tree Postorder Traversal 演算法導論 - 二元樹的基本操作 ","permalink":"https://xinqilin.github.io/post/algorithm/treetraversal/","tags":["Algorithm","Tree","遞歸","Java"],"title":"二元樹遍歷（Binary Tree Traversal）完整指南"},{"content":"Java TreeMap 完整實作指南 簡介 TreeMap 是 Java 集合框架中實現有序映射的核心類別，基於紅黑樹（Red-Black Tree）數據結構實現。它提供了 O(log n) 的時間複雜度進行搜索、插入和刪除操作，並保證鍵的有序性。本文將深入探討 TreeMap 的內部實現、各種方法使用、效能特性以及在企業級開發中的最佳實踐。\nTreeMap 架構與繼承關係 類別繼承結構 1 2 3 4 5 6 7 Map\u0026lt;K,V\u0026gt; ↑ SortedMap\u0026lt;K,V\u0026gt; ↑ NavigableMap\u0026lt;K,V\u0026gt; ↑ TreeMap\u0026lt;K,V\u0026gt; 核心介面關係 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 基本映射介面 public interface Map\u0026lt;K,V\u0026gt; { V put(K key, V value); V get(Object key); V remove(Object key); boolean containsKey(Object key); Set\u0026lt;K\u0026gt; keySet(); Collection\u0026lt;V\u0026gt; values(); Set\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; entrySet(); } // 有序映射介面 public interface SortedMap\u0026lt;K,V\u0026gt; extends Map\u0026lt;K,V\u0026gt; { Comparator\u0026lt;? super K\u0026gt; comparator(); SortedMap\u0026lt;K,V\u0026gt; subMap(K fromKey, K toKey); SortedMap\u0026lt;K,V\u0026gt; headMap(K toKey); SortedMap\u0026lt;K,V\u0026gt; tailMap(K fromKey); K firstKey(); K lastKey(); } // 可導航映射介面 public interface NavigableMap\u0026lt;K,V\u0026gt; extends SortedMap\u0026lt;K,V\u0026gt; { Map.Entry\u0026lt;K,V\u0026gt; lowerEntry(K key); K lowerKey(K key); Map.Entry\u0026lt;K,V\u0026gt; floorEntry(K key); K floorKey(K key); Map.Entry\u0026lt;K,V\u0026gt; ceilingEntry(K key); K ceilingKey(K key); Map.Entry\u0026lt;K,V\u0026gt; higherEntry(K key); K higherKey(K key); Map.Entry\u0026lt;K,V\u0026gt; firstEntry(); Map.Entry\u0026lt;K,V\u0026gt; lastEntry(); Map.Entry\u0026lt;K,V\u0026gt; pollFirstEntry(); Map.Entry\u0026lt;K,V\u0026gt; pollLastEntry(); NavigableMap\u0026lt;K,V\u0026gt; descendingMap(); NavigableSet\u0026lt;K\u0026gt; navigableKeySet(); NavigableSet\u0026lt;K\u0026gt; descendingKeySet(); } TreeMap 核心特性 1. 紅黑樹實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // TreeMap 內部節點結構 static final class Entry\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { K key; V value; Entry\u0026lt;K,V\u0026gt; left; Entry\u0026lt;K,V\u0026gt; right; Entry\u0026lt;K,V\u0026gt; parent; boolean color = BLACK; Entry(K key, V value, Entry\u0026lt;K,V\u0026gt; parent) { this.key = key; this.value = value; this.parent = parent; } } // 紅黑樹顏色常量 private static final boolean RED = false; private static final boolean BLACK = true; // 根節點和大小 private transient Entry\u0026lt;K,V\u0026gt; root; private transient int size = 0; private transient int modCount = 0; // 比較器 private final Comparator\u0026lt;? super K\u0026gt; comparator; 2. 自然排序與自定義比較器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 自然排序 TreeMap TreeMap\u0026lt;String, Integer\u0026gt; naturalOrder = new TreeMap\u0026lt;\u0026gt;(); naturalOrder.put(\u0026#34;Charlie\u0026#34;, 3); naturalOrder.put(\u0026#34;Alice\u0026#34;, 1); naturalOrder.put(\u0026#34;Bob\u0026#34;, 2); // 結果：{Alice=1, Bob=2, Charlie=3} // 自定義比較器 TreeMap\u0026lt;String, Integer\u0026gt; customOrder = new TreeMap\u0026lt;\u0026gt;( (s1, s2) -\u0026gt; s2.compareTo(s1) // 降序 ); customOrder.put(\u0026#34;Charlie\u0026#34;, 3); customOrder.put(\u0026#34;Alice\u0026#34;, 1); customOrder.put(\u0026#34;Bob\u0026#34;, 2); // 結果：{Charlie=3, Bob=2, Alice=1} // 複雜對象比較器 TreeMap\u0026lt;Student, String\u0026gt; studentMap = new TreeMap\u0026lt;\u0026gt;( Comparator.comparing(Student::getGrade) .thenComparing(Student::getName) ); SortedMap 介面詳解 基本方法實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class TreeMapSortedExample { public static void main(String[] args) { TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); // 添加元素 treeMap.put(5, \u0026#34;Five\u0026#34;); treeMap.put(2, \u0026#34;Two\u0026#34;); treeMap.put(8, \u0026#34;Eight\u0026#34;); treeMap.put(1, \u0026#34;One\u0026#34;); treeMap.put(9, \u0026#34;Nine\u0026#34;); // 基本排序方法 demonstrateSortedMapMethods(treeMap); } private static void demonstrateSortedMapMethods(TreeMap\u0026lt;Integer, String\u0026gt; map) { System.out.println(\u0026#34;Original map: \u0026#34; + map); // 獲取比較器 Comparator\u0026lt;? super Integer\u0026gt; comparator = map.comparator(); System.out.println(\u0026#34;Comparator: \u0026#34; + comparator); // null (natural ordering) // 第一個和最後一個鍵 System.out.println(\u0026#34;First key: \u0026#34; + map.firstKey()); // 1 System.out.println(\u0026#34;Last key: \u0026#34; + map.lastKey()); // 9 // 子映射（含頭不含尾） SortedMap\u0026lt;Integer, String\u0026gt; subMap = map.subMap(2, 8); System.out.println(\u0026#34;SubMap [2, 8): \u0026#34; + subMap); // {2=Two, 5=Five} // 頭部映射（不包含指定鍵） SortedMap\u0026lt;Integer, String\u0026gt; headMap = map.headMap(5); System.out.println(\u0026#34;HeadMap (\u0026lt; 5): \u0026#34; + headMap); // {1=One, 2=Two} // 尾部映射（包含指定鍵） SortedMap\u0026lt;Integer, String\u0026gt; tailMap = map.tailMap(5); System.out.println(\u0026#34;TailMap (\u0026gt;= 5): \u0026#34; + tailMap); // {5=Five, 8=Eight, 9=Nine} // 鍵集合、值集合、條目集合 System.out.println(\u0026#34;Keys: \u0026#34; + map.keySet()); System.out.println(\u0026#34;Values: \u0026#34; + map.values()); System.out.println(\u0026#34;Entries: \u0026#34; + map.entrySet()); } } NavigableMap 介面詳解 導航方法實現 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 public class TreeMapNavigableExample { public static void main(String[] args) { TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); // 添加測試數據 treeMap.put(1, \u0026#34;One\u0026#34;); treeMap.put(3, \u0026#34;Three\u0026#34;); treeMap.put(5, \u0026#34;Five\u0026#34;); treeMap.put(7, \u0026#34;Seven\u0026#34;); treeMap.put(9, \u0026#34;Nine\u0026#34;); demonstrateNavigableMethods(treeMap); } private static void demonstrateNavigableMethods(TreeMap\u0026lt;Integer, String\u0026gt; map) { System.out.println(\u0026#34;Original map: \u0026#34; + map); // Lower 方法：返回嚴格小於指定鍵的最大鍵 Map.Entry\u0026lt;Integer, String\u0026gt; lowerEntry = map.lowerEntry(5); System.out.println(\u0026#34;Lower entry (\u0026lt; 5): \u0026#34; + lowerEntry); // 3=Three Integer lowerKey = map.lowerKey(5); System.out.println(\u0026#34;Lower key (\u0026lt; 5): \u0026#34; + lowerKey); // 3 // Floor 方法：返回小於或等於指定鍵的最大鍵 Map.Entry\u0026lt;Integer, String\u0026gt; floorEntry = map.floorEntry(4); System.out.println(\u0026#34;Floor entry (\u0026lt;= 4): \u0026#34; + floorEntry); // 3=Three Map.Entry\u0026lt;Integer, String\u0026gt; floorEntry2 = map.floorEntry(5); System.out.println(\u0026#34;Floor entry (\u0026lt;= 5): \u0026#34; + floorEntry2); // 5=Five // Ceiling 方法：返回大於或等於指定鍵的最小鍵 Map.Entry\u0026lt;Integer, String\u0026gt; ceilingEntry = map.ceilingEntry(4); System.out.println(\u0026#34;Ceiling entry (\u0026gt;= 4): \u0026#34; + ceilingEntry); // 5=Five Map.Entry\u0026lt;Integer, String\u0026gt; ceilingEntry2 = map.ceilingEntry(5); System.out.println(\u0026#34;Ceiling entry (\u0026gt;= 5): \u0026#34; + ceilingEntry2); // 5=Five // Higher 方法：返回嚴格大於指定鍵的最小鍵 Map.Entry\u0026lt;Integer, String\u0026gt; higherEntry = map.higherEntry(5); System.out.println(\u0026#34;Higher entry (\u0026gt; 5): \u0026#34; + higherEntry); // 7=Seven // 首尾條目 Map.Entry\u0026lt;Integer, String\u0026gt; firstEntry = map.firstEntry(); Map.Entry\u0026lt;Integer, String\u0026gt; lastEntry = map.lastEntry(); System.out.println(\u0026#34;First entry: \u0026#34; + firstEntry); // 1=One System.out.println(\u0026#34;Last entry: \u0026#34; + lastEntry); // 9=Nine // 彈出首尾條目（會刪除元素） TreeMap\u0026lt;Integer, String\u0026gt; copyMap = new TreeMap\u0026lt;\u0026gt;(map); Map.Entry\u0026lt;Integer, String\u0026gt; pollFirst = copyMap.pollFirstEntry(); Map.Entry\u0026lt;Integer, String\u0026gt; pollLast = copyMap.pollLastEntry(); System.out.println(\u0026#34;Poll first: \u0026#34; + pollFirst); // 1=One System.out.println(\u0026#34;Poll last: \u0026#34; + pollLast); // 9=Nine System.out.println(\u0026#34;After polling: \u0026#34; + copyMap); // {3=Three, 5=Five, 7=Seven} // 降序視圖 NavigableMap\u0026lt;Integer, String\u0026gt; descendingMap = map.descendingMap(); System.out.println(\u0026#34;Descending map: \u0026#34; + descendingMap); // 導航鍵集合 NavigableSet\u0026lt;Integer\u0026gt; navigableKeySet = map.navigableKeySet(); NavigableSet\u0026lt;Integer\u0026gt; descendingKeySet = map.descendingKeySet(); System.out.println(\u0026#34;Navigable key set: \u0026#34; + navigableKeySet); System.out.println(\u0026#34;Descending key set: \u0026#34; + descendingKeySet); // 範圍視圖 NavigableMap\u0026lt;Integer, String\u0026gt; rangeMap = map.subMap(3, true, 7, false); System.out.println(\u0026#34;Range [3, 7): \u0026#34; + rangeMap); // {3=Three, 5=Five} NavigableMap\u0026lt;Integer, String\u0026gt; headMap = map.headMap(5, true); System.out.println(\u0026#34;Head map (\u0026lt;= 5): \u0026#34; + headMap); // {1=One, 3=Three, 5=Five} NavigableMap\u0026lt;Integer, String\u0026gt; tailMap = map.tailMap(5, false); System.out.println(\u0026#34;Tail map (\u0026gt; 5): \u0026#34; + tailMap); // {7=Seven, 9=Nine} } } 企業級應用實例 1. 時間序列數據管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 public class TimeSeriesDataManager { private final TreeMap\u0026lt;LocalDateTime, Double\u0026gt; timeSeriesData; public TimeSeriesDataManager() { this.timeSeriesData = new TreeMap\u0026lt;\u0026gt;(); } // 添加數據點 public void addDataPoint(LocalDateTime timestamp, Double value) { timeSeriesData.put(timestamp, value); } // 獲取指定時間範圍的數據 public NavigableMap\u0026lt;LocalDateTime, Double\u0026gt; getDataInRange( LocalDateTime startTime, LocalDateTime endTime) { return timeSeriesData.subMap(startTime, true, endTime, true); } // 獲取最新數據 public Map.Entry\u0026lt;LocalDateTime, Double\u0026gt; getLatestData() { return timeSeriesData.lastEntry(); } // 獲取指定時間之前的最新數據 public Map.Entry\u0026lt;LocalDateTime, Double\u0026gt; getLatestDataBefore(LocalDateTime time) { return timeSeriesData.lowerEntry(time); } // 獲取指定時間之後的最早數據 public Map.Entry\u0026lt;LocalDateTime, Double\u0026gt; getEarliestDataAfter(LocalDateTime time) { return timeSeriesData.higherEntry(time); } // 計算時間範圍內的平均值 public double getAverageInRange(LocalDateTime startTime, LocalDateTime endTime) { NavigableMap\u0026lt;LocalDateTime, Double\u0026gt; rangeData = getDataInRange(startTime, endTime); return rangeData.values().stream() .mapToDouble(Double::doubleValue) .average() .orElse(0.0); } // 清理舊數據 public void cleanupOldData(LocalDateTime cutoffTime) { timeSeriesData.headMap(cutoffTime, false).clear(); } // 獲取數據統計信息 public DataStatistics getStatistics() { if (timeSeriesData.isEmpty()) { return new DataStatistics(); } DoubleSummaryStatistics stats = timeSeriesData.values().stream() .mapToDouble(Double::doubleValue) .summaryStatistics(); return new DataStatistics( timeSeriesData.firstKey(), timeSeriesData.lastKey(), stats.getCount(), stats.getMin(), stats.getMax(), stats.getAverage() ); } public static class DataStatistics { private final LocalDateTime earliestTime; private final LocalDateTime latestTime; private final long count; private final double min; private final double max; private final double average; public DataStatistics() { this(null, null, 0, 0, 0, 0); } public DataStatistics(LocalDateTime earliestTime, LocalDateTime latestTime, long count, double min, double max, double average) { this.earliestTime = earliestTime; this.latestTime = latestTime; this.count = count; this.min = min; this.max = max; this.average = average; } // Getters public LocalDateTime getEarliestTime() { return earliestTime; } public LocalDateTime getLatestTime() { return latestTime; } public long getCount() { return count; } public double getMin() { return min; } public double getMax() { return max; } public double getAverage() { return average; } } } 2. 範圍查詢系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 public class RangeQuerySystem\u0026lt;T extends Comparable\u0026lt;T\u0026gt;, V\u0026gt; { private final TreeMap\u0026lt;T, V\u0026gt; dataMap; private final ReentrantReadWriteLock lock; private final ReadLock readLock; private final WriteLock writeLock; public RangeQuerySystem() { this.dataMap = new TreeMap\u0026lt;\u0026gt;(); this.lock = new ReentrantReadWriteLock(); this.readLock = lock.readLock(); this.writeLock = lock.writeLock(); } // 線程安全的插入操作 public void put(T key, V value) { writeLock.lock(); try { dataMap.put(key, value); } finally { writeLock.unlock(); } } // 線程安全的獲取操作 public V get(T key) { readLock.lock(); try { return dataMap.get(key); } finally { readLock.unlock(); } } // 範圍查詢 public List\u0026lt;Map.Entry\u0026lt;T, V\u0026gt;\u0026gt; rangeQuery(T start, T end) { readLock.lock(); try { return new ArrayList\u0026lt;\u0026gt;(dataMap.subMap(start, true, end, true).entrySet()); } finally { readLock.unlock(); } } // 前綴查詢 public List\u0026lt;Map.Entry\u0026lt;T, V\u0026gt;\u0026gt; prefixQuery(T prefix) { readLock.lock(); try { NavigableMap\u0026lt;T, V\u0026gt; tailMap = dataMap.tailMap(prefix, true); List\u0026lt;Map.Entry\u0026lt;T, V\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;T, V\u0026gt; entry : tailMap.entrySet()) { if (entry.getKey().toString().startsWith(prefix.toString())) { result.add(entry); } else { break; } } return result; } finally { readLock.unlock(); } } // 獲取最接近的值 public Map.Entry\u0026lt;T, V\u0026gt; getClosest(T target) { readLock.lock(); try { Map.Entry\u0026lt;T, V\u0026gt; floor = dataMap.floorEntry(target); Map.Entry\u0026lt;T, V\u0026gt; ceiling = dataMap.ceilingEntry(target); if (floor == null) return ceiling; if (ceiling == null) return floor; // 比較距離 if (target.compareTo(floor.getKey()) \u0026lt;= ceiling.getKey().compareTo(target)) { return floor; } else { return ceiling; } } finally { readLock.unlock(); } } // 批量插入 public void putAll(Map\u0026lt;T, V\u0026gt; map) { writeLock.lock(); try { dataMap.putAll(map); } finally { writeLock.unlock(); } } // 條件刪除 public int removeIf(Predicate\u0026lt;Map.Entry\u0026lt;T, V\u0026gt;\u0026gt; condition) { writeLock.lock(); try { List\u0026lt;T\u0026gt; keysToRemove = dataMap.entrySet().stream() .filter(condition) .map(Map.Entry::getKey) .collect(Collectors.toList()); keysToRemove.forEach(dataMap::remove); return keysToRemove.size(); } finally { writeLock.unlock(); } } // 獲取統計信息 public RangeStatistics getStatistics() { readLock.lock(); try { return new RangeStatistics( dataMap.size(), dataMap.isEmpty() ? null : dataMap.firstKey(), dataMap.isEmpty() ? null : dataMap.lastKey() ); } finally { readLock.unlock(); } } public static class RangeStatistics { private final int size; private final Object minKey; private final Object maxKey; public RangeStatistics(int size, Object minKey, Object maxKey) { this.size = size; this.minKey = minKey; this.maxKey = maxKey; } // Getters public int getSize() { return size; } public Object getMinKey() { return minKey; } public Object getMaxKey() { return maxKey; } } } 3. 優先級任務調度器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 public class PriorityTaskScheduler { private final TreeMap\u0026lt;Priority, Queue\u0026lt;Task\u0026gt;\u0026gt; taskQueues; private final ExecutorService executor; private final ScheduledExecutorService scheduler; private final AtomicBoolean running; public PriorityTaskScheduler(int threadPoolSize) { this.taskQueues = new TreeMap\u0026lt;\u0026gt;(); this.executor = Executors.newFixedThreadPool(threadPoolSize); this.scheduler = Executors.newScheduledThreadPool(2); this.running = new AtomicBoolean(true); // 初始化優先級隊列 for (Priority priority : Priority.values()) { taskQueues.put(priority, new ConcurrentLinkedQueue\u0026lt;\u0026gt;()); } // 啟動任務調度 startTaskScheduling(); } // 提交任務 public void submitTask(Task task) { if (!running.get()) { throw new IllegalStateException(\u0026#34;Scheduler is shutdown\u0026#34;); } taskQueues.get(task.getPriority()).offer(task); } // 提交延遲任務 public void submitDelayedTask(Task task, long delay, TimeUnit unit) { scheduler.schedule(() -\u0026gt; submitTask(task), delay, unit); } // 提交週期性任務 public void submitPeriodicTask(Task task, long initialDelay, long period, TimeUnit unit) { scheduler.scheduleAtFixedRate(() -\u0026gt; { if (running.get()) { submitTask(task); } }, initialDelay, period, unit); } // 啟動任務調度 private void startTaskScheduling() { scheduler.scheduleAtFixedRate(this::processNextTask, 0, 10, TimeUnit.MILLISECONDS); } // 處理下一個任務 private void processNextTask() { if (!running.get()) { return; } // 從最高優先級開始查找任務 NavigableMap\u0026lt;Priority, Queue\u0026lt;Task\u0026gt;\u0026gt; descendingMap = taskQueues.descendingMap(); for (Map.Entry\u0026lt;Priority, Queue\u0026lt;Task\u0026gt;\u0026gt; entry : descendingMap.entrySet()) { Queue\u0026lt;Task\u0026gt; queue = entry.getValue(); Task task = queue.poll(); if (task != null) { executor.submit(new TaskRunner(task)); return; } } } // 獲取隊列統計信息 public QueueStatistics getQueueStatistics() { Map\u0026lt;Priority, Integer\u0026gt; queueSizes = new EnumMap\u0026lt;\u0026gt;(Priority.class); int totalTasks = 0; for (Map.Entry\u0026lt;Priority, Queue\u0026lt;Task\u0026gt;\u0026gt; entry : taskQueues.entrySet()) { int size = entry.getValue().size(); queueSizes.put(entry.getKey(), size); totalTasks += size; } return new QueueStatistics(queueSizes, totalTasks); } // 清空指定優先級的任務 public int clearTasks(Priority priority) { Queue\u0026lt;Task\u0026gt; queue = taskQueues.get(priority); int size = queue.size(); queue.clear(); return size; } // 關閉調度器 public void shutdown() { running.set(false); executor.shutdown(); scheduler.shutdown(); try { if (!executor.awaitTermination(30, TimeUnit.SECONDS)) { executor.shutdownNow(); } if (!scheduler.awaitTermination(30, TimeUnit.SECONDS)) { scheduler.shutdownNow(); } } catch (InterruptedException e) { executor.shutdownNow(); scheduler.shutdownNow(); Thread.currentThread().interrupt(); } } // 優先級枚舉 public enum Priority { LOW(1), NORMAL(2), HIGH(3), CRITICAL(4); private final int value; Priority(int value) { this.value = value; } public int getValue() { return value; } } // 任務介面 public interface Task { void execute(); Priority getPriority(); String getName(); } // 任務運行器 private static class TaskRunner implements Runnable { private final Task task; public TaskRunner(Task task) { this.task = task; } @Override public void run() { try { task.execute(); } catch (Exception e) { System.err.println(\u0026#34;Task execution failed: \u0026#34; + task.getName()); e.printStackTrace(); } } } // 隊列統計信息 public static class QueueStatistics { private final Map\u0026lt;Priority, Integer\u0026gt; queueSizes; private final int totalTasks; public QueueStatistics(Map\u0026lt;Priority, Integer\u0026gt; queueSizes, int totalTasks) { this.queueSizes = queueSizes; this.totalTasks = totalTasks; } public Map\u0026lt;Priority, Integer\u0026gt; getQueueSizes() { return queueSizes; } public int getTotalTasks() { return totalTasks; } } } 效能分析與優化 1. 時間複雜度分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 public class TreeMapPerformanceAnalysis { public static void main(String[] args) { performanceComparison(); memoryAnalysis(); concurrencyTest(); } // 效能比較 private static void performanceComparison() { int[] sizes = {1000, 10000, 100000, 1000000}; for (int size : sizes) { System.out.println(\u0026#34;Size: \u0026#34; + size); // TreeMap 測試 long startTime = System.nanoTime(); TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; size; i++) { treeMap.put(i, \u0026#34;value\u0026#34; + i); } long treeMapInsertTime = System.nanoTime() - startTime; // 搜索測試 startTime = System.nanoTime(); for (int i = 0; i \u0026lt; 1000; i++) { treeMap.get(i * size / 1000); } long treeMapSearchTime = System.nanoTime() - startTime; // HashMap 比較 startTime = System.nanoTime(); HashMap\u0026lt;Integer, String\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; size; i++) { hashMap.put(i, \u0026#34;value\u0026#34; + i); } long hashMapInsertTime = System.nanoTime() - startTime; startTime = System.nanoTime(); for (int i = 0; i \u0026lt; 1000; i++) { hashMap.get(i * size / 1000); } long hashMapSearchTime = System.nanoTime() - startTime; System.out.printf(\u0026#34;TreeMap - Insert: %d ns, Search: %d ns\\n\u0026#34;, treeMapInsertTime, treeMapSearchTime); System.out.printf(\u0026#34;HashMap - Insert: %d ns, Search: %d ns\\n\\n\u0026#34;, hashMapInsertTime, hashMapSearchTime); } } // 記憶體分析 private static void memoryAnalysis() { Runtime runtime = Runtime.getRuntime(); runtime.gc(); long beforeMemory = runtime.totalMemory() - runtime.freeMemory(); TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100000; i++) { treeMap.put(i, \u0026#34;value\u0026#34; + i); } long afterMemory = runtime.totalMemory() - runtime.freeMemory(); System.out.println(\u0026#34;TreeMap memory usage: \u0026#34; + (afterMemory - beforeMemory) + \u0026#34; bytes\u0026#34;); // 對比 HashMap runtime.gc(); beforeMemory = runtime.totalMemory() - runtime.freeMemory(); HashMap\u0026lt;Integer, String\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100000; i++) { hashMap.put(i, \u0026#34;value\u0026#34; + i); } afterMemory = runtime.totalMemory() - runtime.freeMemory(); System.out.println(\u0026#34;HashMap memory usage: \u0026#34; + (afterMemory - beforeMemory) + \u0026#34; bytes\u0026#34;); } // 並發測試 private static void concurrencyTest() { TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); ConcurrentSkipListMap\u0026lt;Integer, String\u0026gt; concurrentMap = new ConcurrentSkipListMap\u0026lt;\u0026gt;(); // 填充初始數據 for (int i = 0; i \u0026lt; 10000; i++) { treeMap.put(i, \u0026#34;value\u0026#34; + i); concurrentMap.put(i, \u0026#34;value\u0026#34; + i); } // 並發讀取測試 int threadCount = 4; ExecutorService executor = Executors.newFixedThreadPool(threadCount); System.out.println(\u0026#34;Concurrent read test:\u0026#34;); // TreeMap 同步讀取 long startTime = System.nanoTime(); CountDownLatch latch = new CountDownLatch(threadCount); for (int i = 0; i \u0026lt; threadCount; i++) { executor.submit(() -\u0026gt; { try { for (int j = 0; j \u0026lt; 10000; j++) { synchronized (treeMap) { treeMap.get(j); } } } finally { latch.countDown(); } }); } try { latch.await(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } long treeMapTime = System.nanoTime() - startTime; System.out.println(\u0026#34;TreeMap (synchronized): \u0026#34; + treeMapTime + \u0026#34; ns\u0026#34;); // ConcurrentSkipListMap 測試 startTime = System.nanoTime(); latch = new CountDownLatch(threadCount); for (int i = 0; i \u0026lt; threadCount; i++) { executor.submit(() -\u0026gt; { try { for (int j = 0; j \u0026lt; 10000; j++) { concurrentMap.get(j); } } finally { latch.countDown(); } }); } try { latch.await(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } long concurrentMapTime = System.nanoTime() - startTime; System.out.println(\u0026#34;ConcurrentSkipListMap: \u0026#34; + concurrentMapTime + \u0026#34; ns\u0026#34;); executor.shutdown(); } } 2. 最佳化建議 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 public class TreeMapOptimizationTips { // 1. 使用適當的比較器 public static void comparatorOptimization() { // 避免在比較器中進行複雜計算 TreeMap\u0026lt;String, Integer\u0026gt; badExample = new TreeMap\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { // 壞例子：每次比較都進行昂貴的計算 return expensiveCalculation(s1) - expensiveCalculation(s2); }); // 好例子：預先計算或使用緩存 Map\u0026lt;String, Integer\u0026gt; cache = new ConcurrentHashMap\u0026lt;\u0026gt;(); TreeMap\u0026lt;String, Integer\u0026gt; goodExample = new TreeMap\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { int val1 = cache.computeIfAbsent(s1, TreeMapOptimizationTips::expensiveCalculation); int val2 = cache.computeIfAbsent(s2, TreeMapOptimizationTips::expensiveCalculation); return val1 - val2; }); } // 2. 批量操作優化 public static void batchOperationOptimization() { TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); // 批量插入比單個插入效率更高 Map\u0026lt;Integer, String\u0026gt; batchData = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 1000; i++) { batchData.put(i, \u0026#34;value\u0026#34; + i); } treeMap.putAll(batchData); // 使用子映射進行批量操作 NavigableMap\u0026lt;Integer, String\u0026gt; subMap = treeMap.subMap(100, true, 200, false); subMap.clear(); // 比逐個刪除效率更高 } // 3. 記憶體優化 public static void memoryOptimization() { // 使用原始類型包裝器時注意自動裝箱 TreeMap\u0026lt;Integer, Integer\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); // 避免不必要的對象創建 for (int i = 0; i \u0026lt; 1000; i++) { map.put(i, i * 2); // 會創建 Integer 對象 } // 考慮使用專門的原始類型集合庫（如 Eclipse Collections） // 或者使用 TIntIntMap 等原始類型映射 } // 4. 並發優化 public static void concurrencyOptimization() { TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); // 使用 ConcurrentSkipListMap 替代同步的 TreeMap ConcurrentSkipListMap\u0026lt;Integer, String\u0026gt; concurrentMap = new ConcurrentSkipListMap\u0026lt;\u0026gt;(); // 或者使用讀寫鎖 ReadWriteLock lock = new ReentrantReadWriteLock(); ReadLock readLock = lock.readLock(); WriteLock writeLock = lock.writeLock(); // 讀操作 readLock.lock(); try { treeMap.get(1); } finally { readLock.unlock(); } // 寫操作 writeLock.lock(); try { treeMap.put(1, \u0026#34;value\u0026#34;); } finally { writeLock.unlock(); } } private static int expensiveCalculation(String s) { // 模擬昂貴的計算 return s.hashCode() * 31; } } 實際應用場景 1. LeetCode 問題解決 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 public class TreeMapLeetCodeSolutions { // LeetCode 2055: 蠟燭之間的盤子 public int[] platesBetweenCandles(String s, int[][] queries) { TreeMap\u0026lt;Integer, Integer\u0026gt; candlePositions = new TreeMap\u0026lt;\u0026gt;(); // 記錄蠟燭位置 for (int i = 0; i \u0026lt; s.length(); i++) { if (s.charAt(i) == \u0026#39;|\u0026#39;) { candlePositions.put(i, i); } } int[] result = new int[queries.length]; for (int i = 0; i \u0026lt; queries.length; i++) { int left = queries[i][0]; int right = queries[i][1]; // 找到範圍內的第一個和最後一個蠟燭 Integer firstCandle = candlePositions.ceilingKey(left); Integer lastCandle = candlePositions.floorKey(right); if (firstCandle != null \u0026amp;\u0026amp; lastCandle != null \u0026amp;\u0026amp; firstCandle \u0026lt;= lastCandle) { // 計算蠟燭之間的盤子數量 int totalLength = lastCandle - firstCandle + 1; int candleCount = candlePositions.subMap(firstCandle, true, lastCandle, true).size(); result[i] = totalLength - candleCount; } else { result[i] = 0; } } return result; } // LeetCode 220: 存在重複元素 III public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) { TreeMap\u0026lt;Integer, Integer\u0026gt; window = new TreeMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { int num = nums[i]; // 查找是否存在差值小於等於 t 的數字 Integer floor = window.floorKey(num); Integer ceiling = window.ceilingKey(num); if ((floor != null \u0026amp;\u0026amp; (long) num - floor \u0026lt;= t) || (ceiling != null \u0026amp;\u0026amp; (long) ceiling - num \u0026lt;= t)) { return true; } // 添加當前數字到窗口 window.put(num, window.getOrDefault(num, 0) + 1); // 維護窗口大小 if (i \u0026gt;= k) { int oldNum = nums[i - k]; window.put(oldNum, window.get(oldNum) - 1); if (window.get(oldNum) == 0) { window.remove(oldNum); } } } return false; } // LeetCode 732: 我的日程安排表 III static class MyCalendarThree { private TreeMap\u0026lt;Integer, Integer\u0026gt; timeline; public MyCalendarThree() { timeline = new TreeMap\u0026lt;\u0026gt;(); } public int book(int start, int end) { timeline.put(start, timeline.getOrDefault(start, 0) + 1); timeline.put(end, timeline.getOrDefault(end, 0) - 1); int activeEvents = 0; int maxEvents = 0; for (int count : timeline.values()) { activeEvents += count; maxEvents = Math.max(maxEvents, activeEvents); } return maxEvents; } } } 2. 分佈式系統中的應用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 public class DistributedSystemApplications { // 一致性哈希環 public static class ConsistentHashRing { private final TreeMap\u0026lt;Long, String\u0026gt; ring; private final int virtualNodes; public ConsistentHashRing(int virtualNodes) { this.ring = new TreeMap\u0026lt;\u0026gt;(); this.virtualNodes = virtualNodes; } public void addNode(String node) { for (int i = 0; i \u0026lt; virtualNodes; i++) { long hash = hash(node + \u0026#34;:\u0026#34; + i); ring.put(hash, node); } } public void removeNode(String node) { for (int i = 0; i \u0026lt; virtualNodes; i++) { long hash = hash(node + \u0026#34;:\u0026#34; + i); ring.remove(hash); } } public String getNode(String key) { if (ring.isEmpty()) { return null; } long hash = hash(key); Map.Entry\u0026lt;Long, String\u0026gt; entry = ring.ceilingEntry(hash); if (entry == null) { entry = ring.firstEntry(); } return entry.getValue(); } private long hash(String key) { return key.hashCode() \u0026amp; 0xFFFFFFFFL; } } // 負載平衡器 public static class LoadBalancer { private final TreeMap\u0026lt;Integer, List\u0026lt;String\u0026gt;\u0026gt; weightedServers; private final AtomicInteger currentWeight; public LoadBalancer() { this.weightedServers = new TreeMap\u0026lt;\u0026gt;(); this.currentWeight = new AtomicInteger(0); } public void addServer(String server, int weight) { weightedServers.computeIfAbsent(weight, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(server); } public String selectServer() { if (weightedServers.isEmpty()) { return null; } // 加權輪詢算法 int totalWeight = weightedServers.lastKey(); int current = currentWeight.updateAndGet(w -\u0026gt; (w + 1) % totalWeight); for (Map.Entry\u0026lt;Integer, List\u0026lt;String\u0026gt;\u0026gt; entry : weightedServers.descendingMap().entrySet()) { if (current \u0026lt; entry.getKey()) { List\u0026lt;String\u0026gt; servers = entry.getValue(); return servers.get(current % servers.size()); } } return null; } } } 最佳實踐與建議 1. 選擇適當的比較策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 public class TreeMapBestPractices { // 1. 自然排序 vs 自定義比較器 public static void comparatorChoice() { // 對於實現 Comparable 的類型，使用自然排序 TreeMap\u0026lt;String, Integer\u0026gt; naturalOrder = new TreeMap\u0026lt;\u0026gt;(); // 對於需要自定義排序的情況，使用比較器 TreeMap\u0026lt;String, Integer\u0026gt; customOrder = new TreeMap\u0026lt;\u0026gt;(String.CASE_INSENSITIVE_ORDER); // 複雜對象的多字段排序 TreeMap\u0026lt;Person, String\u0026gt; personMap = new TreeMap\u0026lt;\u0026gt;( Comparator.comparing(Person::getAge) .thenComparing(Person::getName) ); } // 2. 空值處理 public static void nullHandling() { // TreeMap 不允許 null 鍵 TreeMap\u0026lt;String, Integer\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); // map.put(null, 1); // 會拋出 NullPointerException // 但允許 null 值 map.put(\u0026#34;key\u0026#34;, null); // 如果需要支持 null 鍵，使用自定義比較器 TreeMap\u0026lt;String, Integer\u0026gt; nullSafeMap = new TreeMap\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { if (s1 == null \u0026amp;\u0026amp; s2 == null) return 0; if (s1 == null) return -1; if (s2 == null) return 1; return s1.compareTo(s2); }); } // 3. 線程安全處理 public static void threadSafety() { TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); // 方法1：使用 Collections.synchronizedMap Map\u0026lt;Integer, String\u0026gt; syncMap = Collections.synchronizedMap(treeMap); // 方法2：使用 ConcurrentSkipListMap ConcurrentSkipListMap\u0026lt;Integer, String\u0026gt; concurrentMap = new ConcurrentSkipListMap\u0026lt;\u0026gt;(); // 方法3：使用讀寫鎖 ReadWriteLock lock = new ReentrantReadWriteLock(); // 在讀寫操作時使用相應的鎖 } // 4. 效能考慮 public static void performanceConsiderations() { // 預先指定初始容量（TreeMap 沒有初始容量概念，但可以批量插入） Map\u0026lt;Integer, String\u0026gt; initialData = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 1000; i++) { initialData.put(i, \u0026#34;value\u0026#34; + i); } TreeMap\u0026lt;Integer, String\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(initialData); // 避免頻繁的範圍查詢操作 NavigableMap\u0026lt;Integer, String\u0026gt; subMap = treeMap.subMap(100, true, 200, false); // 對 subMap 的操作會影響原始 map } static class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } } } 2. 常見錯誤避免 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 public class TreeMapCommonMistakes { // 錯誤1：在迭代過程中修改 TreeMap public static void avoidConcurrentModification() { TreeMap\u0026lt;Integer, String\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 10; i++) { map.put(i, \u0026#34;value\u0026#34; + i); } // 錯誤的做法 // for (Integer key : map.keySet()) { // if (key % 2 == 0) { // map.remove(key); // ConcurrentModificationException // } // } // 正確的做法1：使用迭代器 Iterator\u0026lt;Integer\u0026gt; iterator = map.keySet().iterator(); while (iterator.hasNext()) { if (iterator.next() % 2 == 0) { iterator.remove(); } } // 正確的做法2：收集要刪除的鍵 List\u0026lt;Integer\u0026gt; keysToRemove = map.keySet().stream() .filter(key -\u0026gt; key % 2 == 0) .collect(Collectors.toList()); keysToRemove.forEach(map::remove); } // 錯誤2：比較器不一致 public static void avoidInconsistentComparator() { // 錯誤：比較器與 equals 不一致 TreeMap\u0026lt;String, Integer\u0026gt; badMap = new TreeMap\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { return s1.length() - s2.length(); // 只比較長度 }); badMap.put(\u0026#34;abc\u0026#34;, 1); badMap.put(\u0026#34;def\u0026#34;, 2); // 會覆蓋 \u0026#34;abc\u0026#34;，因為長度相同 // 正確：確保比較器一致性 TreeMap\u0026lt;String, Integer\u0026gt; goodMap = new TreeMap\u0026lt;\u0026gt;((s1, s2) -\u0026gt; { int lengthCompare = s1.length() - s2.length(); if (lengthCompare != 0) { return lengthCompare; } return s1.compareTo(s2); // 長度相同時比較內容 }); } // 錯誤3：誤用子映射 public static void avoidSubMapMisuse() { TreeMap\u0026lt;Integer, String\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 10; i++) { map.put(i, \u0026#34;value\u0026#34; + i); } // 錯誤：認為子映射是獨立的 NavigableMap\u0026lt;Integer, String\u0026gt; subMap = map.subMap(2, true, 8, false); subMap.clear(); // 這會影響原始 map // 正確：如果需要獨立的副本 NavigableMap\u0026lt;Integer, String\u0026gt; independentCopy = new TreeMap\u0026lt;\u0026gt;(subMap); } } 總結 TreeMap 是 Java 集合框架中功能強大的有序映射實現，基於紅黑樹提供了 O(log n) 的高效操作。通過本文的深入分析，我們了解了：\n核心特性：基於紅黑樹的有序存儲，支持自然排序和自定義比較器 介面層次：從 Map 到 SortedMap 再到 NavigableMap 的完整功能 實用方法：豐富的範圍查詢、導航操作和視圖方法 企業應用：時間序列數據、範圍查詢、任務調度等實際場景 效能優化：比較器優化、批量操作、並發處理等最佳實踐 常見陷阱：並發修改、比較器一致性、子映射使用等需要注意的問題 正確使用 TreeMap 可以在需要有序映射的場景中提供高效、可靠的解決方案，是 Java 開發者必須掌握的重要工具之一。\n","permalink":"https://xinqilin.github.io/post/backend/treemap/","tags":["Java","TreeMap","NavigableMap","Red-Black Tree","Data Structure","Sorting","SortedMap","Binary Search Tree","Performance","Algorithms","Collections","Enterprise","Best Practices","Thread Safety","Concurrency"],"title":"Java TreeMap 完整實作指南：紅黑樹有序映射與 NavigableMap 介面詳解"},{"content":"概述 QueryDSL 是一個強大的 Java 查詢框架，提供類型安全的 SQL 查詢建構功能。它通過代碼生成技術創建查詢類型，在編譯時期就能發現查詢錯誤，大幅提升開發效率和代碼質量。本文將深入介紹 QueryDSL 的各種用法和最佳實踐。\n核心優勢 類型安全：編譯時檢查，避免執行期錯誤 IDE 支援：完整的自動完成和重構功能 統一 API：支援 JPA、SQL、MongoDB 等多種數據源 動態查詢：靈活的條件組合和查詢建構 效能優化：生成高效的 SQL 查詢 支援的技術棧 JPA/Hibernate：最常用的 ORM 整合 Spring Data JPA：與 Spring 生態完美整合 SQL 數據庫：MySQL、PostgreSQL、Oracle 等 NoSQL 數據庫：MongoDB、Lucene 等 環境配置與設定 1. Maven 依賴配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 \u0026lt;properties\u0026gt; \u0026lt;querydsl.version\u0026gt;5.0.0\u0026lt;/querydsl.version\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- Spring Boot Starter Data JPA --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- QueryDSL JPA --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.querydsl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;querydsl-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${querydsl.version}\u0026lt;/version\u0026gt; \u0026lt;classifier\u0026gt;jakarta\u0026lt;/classifier\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- QueryDSL APT (Annotation Processing Tool) --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.querydsl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;querydsl-apt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${querydsl.version}\u0026lt;/version\u0026gt; \u0026lt;classifier\u0026gt;jakarta\u0026lt;/classifier\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Database Driver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Validation --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- Maven Compiler Plugin --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.11.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;17\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;17\u0026lt;/target\u0026gt; \u0026lt;annotationProcessorPaths\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;com.querydsl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;querydsl-apt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${querydsl.version}\u0026lt;/version\u0026gt; \u0026lt;classifier\u0026gt;jakarta\u0026lt;/classifier\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;jakarta.persistence\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jakarta.persistence-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;jakarta.annotation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jakarta.annotation-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.1\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;/annotationProcessorPaths\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- Generate Sources Plugin --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.codehaus.mojo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;build-helper-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.0\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;generate-sources\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;add-source\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;sources\u0026gt; \u0026lt;source\u0026gt;target/generated-sources/annotations\u0026lt;/source\u0026gt; \u0026lt;/sources\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 2. Gradle 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 plugins { id \u0026#39;org.springframework.boot\u0026#39; version \u0026#39;3.1.0\u0026#39; id \u0026#39;io.spring.dependency-management\u0026#39; version \u0026#39;1.1.0\u0026#39; id \u0026#39;java\u0026#39; } dependencies { implementation \u0026#39;org.springframework.boot:spring-boot-starter-data-jpa\u0026#39; implementation \u0026#39;org.springframework.boot:spring-boot-starter-web\u0026#39; implementation \u0026#39;org.springframework.boot:spring-boot-starter-validation\u0026#39; // QueryDSL implementation \u0026#39;com.querydsl:querydsl-jpa:5.0.0:jakarta\u0026#39; annotationProcessor \u0026#39;com.querydsl:querydsl-apt:5.0.0:jakarta\u0026#39; annotationProcessor \u0026#39;jakarta.persistence:jakarta.persistence-api\u0026#39; annotationProcessor \u0026#39;jakarta.annotation:jakarta.annotation-api\u0026#39; runtimeOnly \u0026#39;mysql:mysql-connector-java\u0026#39; testImplementation \u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39; } // QueryDSL 配置 def queryDslDir = \u0026#34;$buildDir/generated/querydsl\u0026#34; querydsl { jpa = true querydslSourcesDir = queryDslDir } sourceSets { main.java.srcDir queryDslDir } configurations { querydsl.extendsFrom compileClasspath } compileQuerydsl { options.annotationProcessorPath = configurations.querydsl } 3. Spring Boot 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.example.querydsl.config; import com.querydsl.jpa.impl.JPAQueryFactory; import jakarta.persistence.EntityManager; import jakarta.persistence.PersistenceContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class QueryDSLConfig { @PersistenceContext private EntityManager entityManager; @Bean public JPAQueryFactory jpaQueryFactory() { return new JPAQueryFactory(entityManager); } } 實體類定義與 Q 類生成 1. 實體類定義 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 package com.example.querydsl.entity; import jakarta.persistence.*; import jakarta.validation.constraints.NotBlank; import jakarta.validation.constraints.Email; import org.hibernate.annotations.CreationTimestamp; import org.hibernate.annotations.UpdateTimestamp; import java.time.LocalDateTime; import java.util.Set; @Entity @Table(name = \u0026#34;users\u0026#34;, indexes = { @Index(name = \u0026#34;idx_username\u0026#34;, columnList = \u0026#34;username\u0026#34;), @Index(name = \u0026#34;idx_email\u0026#34;, columnList = \u0026#34;email\u0026#34;), @Index(name = \u0026#34;idx_department_id\u0026#34;, columnList = \u0026#34;department_id\u0026#34;), @Index(name = \u0026#34;idx_status\u0026#34;, columnList = \u0026#34;status\u0026#34;) }) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotBlank @Column(unique = true, nullable = false, length = 50) private String username; @NotBlank @Email @Column(unique = true, nullable = false, length = 100) private String email; @Column(name = \u0026#34;first_name\u0026#34;, length = 50) private String firstName; @Column(name = \u0026#34;last_name\u0026#34;, length = 50) private String lastName; @Column(nullable = false) private Integer age; @Column(length = 20) private String phone; @Enumerated(EnumType.STRING) @Column(nullable = false) private UserStatus status = UserStatus.ACTIVE; @Column(precision = 10, scale = 2) private Double salary; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;department_id\u0026#34;) private Department department; @OneToMany(mappedBy = \u0026#34;user\u0026#34;, cascade = CascadeType.ALL, fetch = FetchType.LAZY) private Set\u0026lt;UserRole\u0026gt; userRoles; @OneToMany(mappedBy = \u0026#34;assignee\u0026#34;, fetch = FetchType.LAZY) private Set\u0026lt;Project\u0026gt; assignedProjects; @CreationTimestamp @Column(name = \u0026#34;created_at\u0026#34;, nullable = false, updatable = false) private LocalDateTime createdAt; @UpdateTimestamp @Column(name = \u0026#34;updated_at\u0026#34;, nullable = false) private LocalDateTime updatedAt; // 建構子、getter、setter 和 toString 方法 public User() {} public User(String username, String email, String firstName, String lastName, Integer age) { this.username = username; this.email = email; this.firstName = firstName; this.lastName = lastName; this.age = age; } // 完整的 getter 和 setter 方法 public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } public UserStatus getStatus() { return status; } public void setStatus(UserStatus status) { this.status = status; } public Double getSalary() { return salary; } public void setSalary(Double salary) { this.salary = salary; } public Department getDepartment() { return department; } public void setDepartment(Department department) { this.department = department; } public Set\u0026lt;UserRole\u0026gt; getUserRoles() { return userRoles; } public void setUserRoles(Set\u0026lt;UserRole\u0026gt; userRoles) { this.userRoles = userRoles; } public Set\u0026lt;Project\u0026gt; getAssignedProjects() { return assignedProjects; } public void setAssignedProjects(Set\u0026lt;Project\u0026gt; assignedProjects) { this.assignedProjects = assignedProjects; } public LocalDateTime getCreatedAt() { return createdAt; } public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; } public LocalDateTime getUpdatedAt() { return updatedAt; } public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; } } // 枚舉類型 enum UserStatus { ACTIVE, INACTIVE, SUSPENDED, DELETED } 2. 相關實體類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 // Department 實體 @Entity @Table(name = \u0026#34;departments\u0026#34;) public class Department { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotBlank @Column(unique = true, nullable = false, length = 100) private String name; @Column(length = 500) private String description; @Column(name = \u0026#34;budget\u0026#34;, precision = 15, scale = 2) private Double budget; @OneToMany(mappedBy = \u0026#34;department\u0026#34;, fetch = FetchType.LAZY) private Set\u0026lt;User\u0026gt; employees; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;manager_id\u0026#34;) private User manager; @CreationTimestamp @Column(name = \u0026#34;created_at\u0026#34;, nullable = false, updatable = false) private LocalDateTime createdAt; // 建構子、getter、setter 方法 public Department() {} public Department(String name, String description, Double budget) { this.name = name; this.description = description; this.budget = budget; } // getter 和 setter 方法省略... } // Project 實體 @Entity @Table(name = \u0026#34;projects\u0026#34;) public class Project { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotBlank @Column(nullable = false, length = 200) private String title; @Column(length = 1000) private String description; @Column(name = \u0026#34;start_date\u0026#34;) private LocalDateTime startDate; @Column(name = \u0026#34;end_date\u0026#34;) private LocalDateTime endDate; @Enumerated(EnumType.STRING) @Column(nullable = false) private ProjectStatus status = ProjectStatus.PLANNING; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;assignee_id\u0026#34;) private User assignee; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;department_id\u0026#34;) private Department department; // getter 和 setter 方法省略... } enum ProjectStatus { PLANNING, IN_PROGRESS, COMPLETED, CANCELLED, ON_HOLD } // UserRole 實體（多對多關聯表） @Entity @Table(name = \u0026#34;user_roles\u0026#34;) public class UserRole { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;user_id\u0026#34;, nullable = false) private User user; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;role_id\u0026#34;, nullable = false) private Role role; @CreationTimestamp @Column(name = \u0026#34;assigned_at\u0026#34;, nullable = false, updatable = false) private LocalDateTime assignedAt; // getter 和 setter 方法省略... } @Entity @Table(name = \u0026#34;roles\u0026#34;) public class Role { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotBlank @Column(unique = true, nullable = false, length = 50) private String name; @Column(length = 200) private String description; @OneToMany(mappedBy = \u0026#34;role\u0026#34;, fetch = FetchType.LAZY) private Set\u0026lt;UserRole\u0026gt; userRoles; // getter 和 setter 方法省略... } 3. Q 類生成 執行以下命令生成 Q 類：\n1 2 3 4 5 # Maven 項目 mvn clean compile # Gradle 項目 ./gradlew compileQuerydsl 生成的 Q 類將位於 target/generated-sources/annotations (Maven) 或 build/generated/querydsl (Gradle) 目錄中。\n基礎查詢操作 1. Repository 介面定義 1 2 3 4 5 6 7 8 9 10 11 12 package com.example.querydsl.repository; import com.example.querydsl.entity.User; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.querydsl.QuerydslPredicateExecutor; import org.springframework.stereotype.Repository; @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt;, QuerydslPredicateExecutor\u0026lt;User\u0026gt; { // 基本的 CRUD 操作由 JpaRepository 提供 // QuerydslPredicateExecutor 提供 QueryDSL 查詢支援 } 2. Service 層實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 package com.example.querydsl.service; import com.example.querydsl.entity.*; import com.example.querydsl.repository.UserRepository; import com.querydsl.core.BooleanBuilder; import com.querydsl.core.types.OrderSpecifier; import com.querydsl.core.types.Predicate; import com.querydsl.core.types.Projections; import com.querydsl.core.types.dsl.BooleanExpression; import com.querydsl.jpa.impl.JPAQueryFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import java.time.LocalDateTime; import java.util.List; import java.util.Optional; @Service @Transactional(readOnly = true) public class UserService { @Autowired private JPAQueryFactory queryFactory; @Autowired private UserRepository userRepository; // Q 類實例 private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; private final QProject qProject = QProject.project; private final QUserRole qUserRole = QUserRole.userRole; private final QRole qRole = QRole.role; /** * 基礎查詢：根據用戶名查找用戶 */ public Optional\u0026lt;User\u0026gt; findByUsername(String username) { User user = queryFactory.selectFrom(qUser) .where(qUser.username.eq(username)) .fetchOne(); return Optional.ofNullable(user); } /** * 條件查詢：根據多個條件查找用戶 */ public List\u0026lt;User\u0026gt; findUsersByConditions(String username, String email, Integer minAge, Integer maxAge, UserStatus status) { BooleanBuilder builder = new BooleanBuilder(); if (username != null \u0026amp;\u0026amp; !username.trim().isEmpty()) { builder.and(qUser.username.containsIgnoreCase(username)); } if (email != null \u0026amp;\u0026amp; !email.trim().isEmpty()) { builder.and(qUser.email.containsIgnoreCase(email)); } if (minAge != null) { builder.and(qUser.age.goe(minAge)); } if (maxAge != null) { builder.and(qUser.age.loe(maxAge)); } if (status != null) { builder.and(qUser.status.eq(status)); } return queryFactory.selectFrom(qUser) .where(builder) .orderBy(qUser.createdAt.desc()) .fetch(); } /** * 分頁查詢：使用 Spring Data 的分頁支援 */ public Page\u0026lt;User\u0026gt; findUsersWithPagination(String keyword, UserStatus status, Pageable pageable) { BooleanBuilder builder = new BooleanBuilder(); if (keyword != null \u0026amp;\u0026amp; !keyword.trim().isEmpty()) { BooleanExpression keywordCondition = qUser.username.containsIgnoreCase(keyword) .or(qUser.firstName.containsIgnoreCase(keyword)) .or(qUser.lastName.containsIgnoreCase(keyword)) .or(qUser.email.containsIgnoreCase(keyword)); builder.and(keywordCondition); } if (status != null) { builder.and(qUser.status.eq(status)); } return userRepository.findAll(builder, pageable); } } 高級查詢功能 1. Join 查詢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 /** * Join 查詢範例 */ @Service @Transactional(readOnly = true) public class AdvancedQueryService { @Autowired private JPAQueryFactory queryFactory; private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; private final QProject qProject = QProject.project; private final QUserRole qUserRole = QUserRole.userRole; private final QRole qRole = QRole.role; /** * Inner Join：查詢用戶及其部門資訊 */ public List\u0026lt;User\u0026gt; findUsersWithDepartment() { return queryFactory.selectFrom(qUser) .innerJoin(qUser.department, qDepartment).fetchJoin() .where(qDepartment.name.isNotNull()) .orderBy(qDepartment.name.asc(), qUser.username.asc()) .fetch(); } /** * Left Join：查詢所有用戶（包含沒有部門的用戶） */ public List\u0026lt;User\u0026gt; findAllUsersWithOptionalDepartment() { return queryFactory.selectFrom(qUser) .leftJoin(qUser.department, qDepartment).fetchJoin() .orderBy(qUser.username.asc()) .fetch(); } /** * 複雜 Join：查詢用戶、部門和專案資訊 */ public List\u0026lt;User\u0026gt; findUsersWithDepartmentAndProjects() { return queryFactory.selectFrom(qUser) .leftJoin(qUser.department, qDepartment).fetchJoin() .leftJoin(qUser.assignedProjects, qProject).fetchJoin() .where(qUser.status.eq(UserStatus.ACTIVE)) .orderBy(qDepartment.name.asc(), qUser.username.asc()) .fetch(); } /** * 條件 Join：根據部門預算查詢用戶 */ public List\u0026lt;User\u0026gt; findUsersByDepartmentBudget(Double minBudget) { return queryFactory.selectFrom(qUser) .innerJoin(qUser.department, qDepartment) .where(qDepartment.budget.goe(minBudget)) .orderBy(qDepartment.budget.desc(), qUser.username.asc()) .fetch(); } /** * 多層 Join：查詢用戶角色資訊 */ public List\u0026lt;User\u0026gt; findUsersWithRoles(String roleName) { return queryFactory.selectFrom(qUser) .innerJoin(qUser.userRoles, qUserRole) .innerJoin(qUserRole.role, qRole) .where(qRole.name.eq(roleName)) .orderBy(qUser.username.asc()) .fetch(); } } 2. 子查詢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 /** * 子查詢範例 */ public class SubQueryService { @Autowired private JPAQueryFactory queryFactory; private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; private final QProject qProject = QProject.project; /** * EXISTS 子查詢：查詢有專案的用戶 */ public List\u0026lt;User\u0026gt; findUsersWithProjects() { QProject subProject = new QProject(\u0026#34;subProject\u0026#34;); return queryFactory.selectFrom(qUser) .where(JPAExpressions.selectOne() .from(subProject) .where(subProject.assignee.eq(qUser)) .exists()) .orderBy(qUser.username.asc()) .fetch(); } /** * NOT EXISTS 子查詢：查詢沒有專案的用戶 */ public List\u0026lt;User\u0026gt; findUsersWithoutProjects() { QProject subProject = new QProject(\u0026#34;subProject\u0026#34;); return queryFactory.selectFrom(qUser) .where(JPAExpressions.selectOne() .from(subProject) .where(subProject.assignee.eq(qUser)) .notExists()) .orderBy(qUser.username.asc()) .fetch(); } /** * IN 子查詢：查詢特定部門的用戶 */ public List\u0026lt;User\u0026gt; findUsersByDepartmentNames(List\u0026lt;String\u0026gt; departmentNames) { QDepartment subDepartment = new QDepartment(\u0026#34;subDepartment\u0026#34;); return queryFactory.selectFrom(qUser) .where(qUser.department.id.in( JPAExpressions.select(subDepartment.id) .from(subDepartment) .where(subDepartment.name.in(departmentNames)) )) .orderBy(qUser.username.asc()) .fetch(); } /** * 比較子查詢：查詢薪資高於平均薪資的用戶 */ public List\u0026lt;User\u0026gt; findUsersWithAboveAverageSalary() { QUser subUser = new QUser(\u0026#34;subUser\u0026#34;); return queryFactory.selectFrom(qUser) .where(qUser.salary.gt( JPAExpressions.select(subUser.salary.avg()) .from(subUser) .where(subUser.salary.isNotNull()) )) .orderBy(qUser.salary.desc()) .fetch(); } /** * 相關子查詢：查詢部門內薪資最高的用戶 */ public List\u0026lt;User\u0026gt; findTopSalaryUsersByDepartment() { QUser subUser = new QUser(\u0026#34;subUser\u0026#34;); return queryFactory.selectFrom(qUser) .where(qUser.salary.eq( JPAExpressions.select(subUser.salary.max()) .from(subUser) .where(subUser.department.eq(qUser.department) .and(subUser.salary.isNotNull())) )) .orderBy(qUser.department.name.asc(), qUser.username.asc()) .fetch(); } } 3. 聚合查詢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 /** * 聚合查詢範例 */ public class AggregationService { @Autowired private JPAQueryFactory queryFactory; private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; private final QProject qProject = QProject.project; /** * 基礎聚合：統計用戶數量 */ public Long countActiveUsers() { return queryFactory.select(qUser.count()) .from(qUser) .where(qUser.status.eq(UserStatus.ACTIVE)) .fetchOne(); } /** * GROUP BY：按部門統計用戶數量 */ public List\u0026lt;DepartmentUserCount\u0026gt; countUsersByDepartment() { return queryFactory.select(Projections.constructor(DepartmentUserCount.class, qDepartment.id, qDepartment.name, qUser.count())) .from(qUser) .innerJoin(qUser.department, qDepartment) .where(qUser.status.eq(UserStatus.ACTIVE)) .groupBy(qDepartment.id, qDepartment.name) .orderBy(qUser.count().desc()) .fetch(); } /** * HAVING：查詢用戶數量大於指定數量的部門 */ public List\u0026lt;DepartmentUserCount\u0026gt; findDepartmentsWithMinUsers(Long minUserCount) { return queryFactory.select(Projections.constructor(DepartmentUserCount.class, qDepartment.id, qDepartment.name, qUser.count())) .from(qUser) .innerJoin(qUser.department, qDepartment) .where(qUser.status.eq(UserStatus.ACTIVE)) .groupBy(qDepartment.id, qDepartment.name) .having(qUser.count().goe(minUserCount)) .orderBy(qUser.count().desc()) .fetch(); } /** * 多欄位聚合：部門薪資統計 */ public List\u0026lt;DepartmentSalaryStats\u0026gt; calculateDepartmentSalaryStats() { return queryFactory.select(Projections.constructor(DepartmentSalaryStats.class, qDepartment.id, qDepartment.name, qUser.salary.sum(), qUser.salary.avg(), qUser.salary.min(), qUser.salary.max(), qUser.count())) .from(qUser) .innerJoin(qUser.department, qDepartment) .where(qUser.status.eq(UserStatus.ACTIVE) .and(qUser.salary.isNotNull())) .groupBy(qDepartment.id, qDepartment.name) .orderBy(qUser.salary.avg().desc()) .fetch(); } /** * 時間聚合：按月統計用戶註冊數量 */ public List\u0026lt;MonthlyUserRegistration\u0026gt; getUserRegistrationByMonth(int year) { return queryFactory.select(Projections.constructor(MonthlyUserRegistration.class, qUser.createdAt.month(), qUser.count())) .from(qUser) .where(qUser.createdAt.year().eq(year)) .groupBy(qUser.createdAt.month()) .orderBy(qUser.createdAt.month().asc()) .fetch(); } // DTO 類別定義 public static class DepartmentUserCount { private Long departmentId; private String departmentName; private Long userCount; public DepartmentUserCount(Long departmentId, String departmentName, Long userCount) { this.departmentId = departmentId; this.departmentName = departmentName; this.userCount = userCount; } // getter 和 setter 方法省略... } public static class DepartmentSalaryStats { private Long departmentId; private String departmentName; private Double totalSalary; private Double averageSalary; private Double minSalary; private Double maxSalary; private Long employeeCount; public DepartmentSalaryStats(Long departmentId, String departmentName, Double totalSalary, Double averageSalary, Double minSalary, Double maxSalary, Long employeeCount) { this.departmentId = departmentId; this.departmentName = departmentName; this.totalSalary = totalSalary; this.averageSalary = averageSalary; this.minSalary = minSalary; this.maxSalary = maxSalary; this.employeeCount = employeeCount; } // getter 和 setter 方法省略... } public static class MonthlyUserRegistration { private Integer month; private Long registrationCount; public MonthlyUserRegistration(Integer month, Long registrationCount) { this.month = month; this.registrationCount = registrationCount; } // getter 和 setter 方法省略... } } 動態查詢建構 1. Predicate 建構器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 /** * 動態查詢建構器 */ @Component public class UserPredicateBuilder { private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; /** * 建構用戶查詢條件 */ public BooleanBuilder buildUserPredicate(UserSearchCriteria criteria) { BooleanBuilder builder = new BooleanBuilder(); // 基本欄位條件 addStringCondition(builder, qUser.username, criteria.getUsername(), StringMatchType.CONTAINS); addStringCondition(builder, qUser.email, criteria.getEmail(), StringMatchType.CONTAINS); addStringCondition(builder, qUser.firstName, criteria.getFirstName(), StringMatchType.CONTAINS); addStringCondition(builder, qUser.lastName, criteria.getLastName(), StringMatchType.CONTAINS); addStringCondition(builder, qUser.phone, criteria.getPhone(), StringMatchType.EXACT); // 數值範圍條件 addRangeCondition(builder, qUser.age, criteria.getMinAge(), criteria.getMaxAge()); addRangeCondition(builder, qUser.salary, criteria.getMinSalary(), criteria.getMaxSalary()); // 枚舉條件 addEnumCondition(builder, qUser.status, criteria.getStatuses()); // 日期範圍條件 addDateRangeCondition(builder, qUser.createdAt, criteria.getCreatedAfter(), criteria.getCreatedBefore()); addDateRangeCondition(builder, qUser.updatedAt, criteria.getUpdatedAfter(), criteria.getUpdatedBefore()); // 關聯條件 addDepartmentConditions(builder, criteria); return builder; } /** * 字串條件處理 */ private void addStringCondition(BooleanBuilder builder, StringPath path, String value, StringMatchType matchType) { if (value != null \u0026amp;\u0026amp; !value.trim().isEmpty()) { switch (matchType) { case EXACT: builder.and(path.eq(value)); break; case CONTAINS: builder.and(path.containsIgnoreCase(value.trim())); break; case STARTS_WITH: builder.and(path.startsWithIgnoreCase(value.trim())); break; case ENDS_WITH: builder.and(path.endsWithIgnoreCase(value.trim())); break; } } } /** * 數值範圍條件處理 */ private \u0026lt;T extends Number \u0026amp; Comparable\u0026lt;T\u0026gt;\u0026gt; void addRangeCondition( BooleanBuilder builder, NumberPath\u0026lt;T\u0026gt; path, T minValue, T maxValue) { if (minValue != null) { builder.and(path.goe(minValue)); } if (maxValue != null) { builder.and(path.loe(maxValue)); } } /** * 枚舉條件處理 */ private \u0026lt;T extends Enum\u0026lt;T\u0026gt;\u0026gt; void addEnumCondition( BooleanBuilder builder, EnumPath\u0026lt;T\u0026gt; path, List\u0026lt;T\u0026gt; values) { if (values != null \u0026amp;\u0026amp; !values.isEmpty()) { builder.and(path.in(values)); } } /** * 日期範圍條件處理 */ private void addDateRangeCondition(BooleanBuilder builder, DateTimePath\u0026lt;LocalDateTime\u0026gt; path, LocalDateTime after, LocalDateTime before) { if (after != null) { builder.and(path.goe(after)); } if (before != null) { builder.and(path.loe(before)); } } /** * 部門相關條件處理 */ private void addDepartmentConditions(BooleanBuilder builder, UserSearchCriteria criteria) { if (criteria.getDepartmentIds() != null \u0026amp;\u0026amp; !criteria.getDepartmentIds().isEmpty()) { builder.and(qUser.department.id.in(criteria.getDepartmentIds())); } if (criteria.getDepartmentName() != null \u0026amp;\u0026amp; !criteria.getDepartmentName().trim().isEmpty()) { builder.and(qUser.department.name.containsIgnoreCase(criteria.getDepartmentName().trim())); } if (criteria.getMinDepartmentBudget() != null) { builder.and(qUser.department.budget.goe(criteria.getMinDepartmentBudget())); } if (criteria.getMaxDepartmentBudget() != null) { builder.and(qUser.department.budget.loe(criteria.getMaxDepartmentBudget())); } } /** * 字串匹配類型枚舉 */ public enum StringMatchType { EXACT, CONTAINS, STARTS_WITH, ENDS_WITH } } /** * 用戶搜尋條件 DTO */ public class UserSearchCriteria { private String username; private String email; private String firstName; private String lastName; private String phone; private Integer minAge; private Integer maxAge; private Double minSalary; private Double maxSalary; private List\u0026lt;UserStatus\u0026gt; statuses; private LocalDateTime createdAfter; private LocalDateTime createdBefore; private LocalDateTime updatedAfter; private LocalDateTime updatedBefore; private List\u0026lt;Long\u0026gt; departmentIds; private String departmentName; private Double minDepartmentBudget; private Double maxDepartmentBudget; // 建構子、getter 和 setter 方法省略... } 2. 查詢規格建構器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 /** * 查詢規格建構器 */ @Component public class QuerySpecificationBuilder { private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; private final QProject qProject = QProject.project; /** * 建構複雜查詢規格 */ public JPAQuery\u0026lt;User\u0026gt; buildComplexUserQuery(JPAQueryFactory queryFactory, ComplexSearchCriteria criteria) { JPAQuery\u0026lt;User\u0026gt; query = queryFactory.selectFrom(qUser); // 添加 Join addJoins(query, criteria); // 添加 Where 條件 addWhereConditions(query, criteria); // 添加排序 addOrderBy(query, criteria); return query; } /** * 添加 Join 條件 */ private void addJoins(JPAQuery\u0026lt;User\u0026gt; query, ComplexSearchCriteria criteria) { if (criteria.isIncludeDepartment() || criteria.hasDepartmentConditions()) { query.leftJoin(qUser.department, qDepartment); if (criteria.isFetchDepartment()) { query.fetchJoin(); } } if (criteria.isIncludeProjects() || criteria.hasProjectConditions()) { query.leftJoin(qUser.assignedProjects, qProject); if (criteria.isFetchProjects()) { query.fetchJoin(); } } } /** * 添加 Where 條件 */ private void addWhereConditions(JPAQuery\u0026lt;User\u0026gt; query, ComplexSearchCriteria criteria) { BooleanBuilder builder = new BooleanBuilder(); // 用戶基本條件 addUserConditions(builder, criteria); // 部門條件 addDepartmentConditions(builder, criteria); // 專案條件 addProjectConditions(builder, criteria); // 自訂條件 addCustomConditions(builder, criteria); if (builder.hasValue()) { query.where(builder); } } /** * 添加排序條件 */ private void addOrderBy(JPAQuery\u0026lt;User\u0026gt; query, ComplexSearchCriteria criteria) { List\u0026lt;OrderSpecifier\u0026lt;?\u0026gt;\u0026gt; orderSpecifiers = new ArrayList\u0026lt;\u0026gt;(); if (criteria.getSortFields() != null \u0026amp;\u0026amp; !criteria.getSortFields().isEmpty()) { for (SortField sortField : criteria.getSortFields()) { OrderSpecifier\u0026lt;?\u0026gt; orderSpecifier = createOrderSpecifier(sortField); if (orderSpecifier != null) { orderSpecifiers.add(orderSpecifier); } } } // 預設排序 if (orderSpecifiers.isEmpty()) { orderSpecifiers.add(qUser.createdAt.desc()); } query.orderBy(orderSpecifiers.toArray(new OrderSpecifier[0])); } /** * 創建排序規格 */ private OrderSpecifier\u0026lt;?\u0026gt; createOrderSpecifier(SortField sortField) { boolean isAsc = sortField.getDirection() == SortDirection.ASC; switch (sortField.getField()) { case \u0026#34;username\u0026#34;: return isAsc ? qUser.username.asc() : qUser.username.desc(); case \u0026#34;email\u0026#34;: return isAsc ? qUser.email.asc() : qUser.email.desc(); case \u0026#34;age\u0026#34;: return isAsc ? qUser.age.asc() : qUser.age.desc(); case \u0026#34;salary\u0026#34;: return isAsc ? qUser.salary.asc() : qUser.salary.desc(); case \u0026#34;createdAt\u0026#34;: return isAsc ? qUser.createdAt.asc() : qUser.createdAt.desc(); case \u0026#34;departmentName\u0026#34;: return isAsc ? qDepartment.name.asc() : qDepartment.name.desc(); default: return null; } } // 輔助方法省略... } 更新和刪除操作 1. 批量更新 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /** * 更新和刪除操作服務 */ @Service @Transactional public class UserUpdateService { @Autowired private JPAQueryFactory queryFactory; private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; /** * 批量更新用戶狀態 */ public long updateUserStatus(List\u0026lt;Long\u0026gt; userIds, UserStatus newStatus) { return queryFactory.update(qUser) .set(qUser.status, newStatus) .set(qUser.updatedAt, LocalDateTime.now()) .where(qUser.id.in(userIds)) .execute(); } /** * 批量更新用戶薪資 */ public long updateSalaryByDepartment(Long departmentId, Double salaryIncrease) { return queryFactory.update(qUser) .set(qUser.salary, qUser.salary.add(salaryIncrease)) .set(qUser.updatedAt, LocalDateTime.now()) .where(qUser.department.id.eq(departmentId) .and(qUser.status.eq(UserStatus.ACTIVE)) .and(qUser.salary.isNotNull())) .execute(); } /** * 條件式更新：根據年齡調整薪資 */ public long adjustSalaryByAge() { // 為年齡大於 30 的員工增加 10% 薪資 return queryFactory.update(qUser) .set(qUser.salary, qUser.salary.multiply(1.1)) .set(qUser.updatedAt, LocalDateTime.now()) .where(qUser.age.gt(30) .and(qUser.status.eq(UserStatus.ACTIVE)) .and(qUser.salary.isNotNull())) .execute(); } /** * Join 更新：根據部門預算更新員工狀態 */ public long updateStatusByDepartmentBudget(Double minBudget, UserStatus newStatus) { return queryFactory.update(qUser) .set(qUser.status, newStatus) .set(qUser.updatedAt, LocalDateTime.now()) .where(qUser.department.budget.lt(minBudget)) .execute(); } } 2. 批量刪除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /** * 刪除操作服務 */ @Service @Transactional public class UserDeleteService { @Autowired private JPAQueryFactory queryFactory; private final QUser qUser = QUser.user; /** * 軟刪除：標記為已刪除狀態 */ public long softDeleteUsers(List\u0026lt;Long\u0026gt; userIds) { return queryFactory.update(qUser) .set(qUser.status, UserStatus.DELETED) .set(qUser.updatedAt, LocalDateTime.now()) .where(qUser.id.in(userIds)) .execute(); } /** * 硬刪除：物理刪除記錄 */ public long hardDeleteInactiveUsers(LocalDateTime before) { return queryFactory.delete(qUser) .where(qUser.status.eq(UserStatus.DELETED) .and(qUser.updatedAt.before(before))) .execute(); } /** * 條件刪除：刪除特定條件的用戶 */ public long deleteUsersByCondition(UserStatus status, Integer maxAge) { BooleanBuilder builder = new BooleanBuilder(); if (status != null) { builder.and(qUser.status.eq(status)); } if (maxAge != null) { builder.and(qUser.age.loe(maxAge)); } return queryFactory.delete(qUser) .where(builder) .execute(); } /** * 清理孤立記錄：刪除沒有部門的用戶 */ public long deleteUsersWithoutDepartment() { return queryFactory.delete(qUser) .where(qUser.department.isNull() .and(qUser.status.eq(UserStatus.INACTIVE))) .execute(); } } 效能優化技巧 1. 查詢優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 /** * 效能優化服務 */ @Service @Transactional(readOnly = true) public class QueryOptimizationService { @Autowired private JPAQueryFactory queryFactory; private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; /** * 使用投影減少資料傳輸 */ public List\u0026lt;UserSummaryDTO\u0026gt; getUserSummaries() { return queryFactory.select(Projections.constructor(UserSummaryDTO.class, qUser.id, qUser.username, qUser.email, qUser.status, qDepartment.name)) .from(qUser) .leftJoin(qUser.department, qDepartment) .where(qUser.status.eq(UserStatus.ACTIVE)) .orderBy(qUser.username.asc()) .fetch(); } /** * 使用 Fetch Join 避免 N+1 問題 */ public List\u0026lt;User\u0026gt; getUsersWithDepartmentOptimized() { return queryFactory.selectFrom(qUser) .leftJoin(qUser.department, qDepartment).fetchJoin() .where(qUser.status.eq(UserStatus.ACTIVE)) .orderBy(qUser.username.asc()) .fetch(); } /** * 分頁查詢優化 */ public Page\u0026lt;User\u0026gt; getUsersWithOptimizedPaging(Pageable pageable) { // 先查詢總數 Long total = queryFactory.select(qUser.count()) .from(qUser) .where(qUser.status.eq(UserStatus.ACTIVE)) .fetchOne(); // 如果總數為 0，直接返回空頁面 if (total == 0) { return new PageImpl\u0026lt;\u0026gt;(Collections.emptyList(), pageable, 0); } // 查詢分頁資料 List\u0026lt;User\u0026gt; users = queryFactory.selectFrom(qUser) .where(qUser.status.eq(UserStatus.ACTIVE)) .orderBy(qUser.username.asc()) .offset(pageable.getOffset()) .limit(pageable.getPageSize()) .fetch(); return new PageImpl\u0026lt;\u0026gt;(users, pageable, total); } /** * 使用索引提示優化查詢 */ public List\u0026lt;User\u0026gt; findUsersByIndexedFields(String username, String email) { BooleanBuilder builder = new BooleanBuilder(); // 優先使用有索引的欄位 if (username != null \u0026amp;\u0026amp; !username.trim().isEmpty()) { builder.and(qUser.username.eq(username)); // username 有唯一索引 } else if (email != null \u0026amp;\u0026amp; !email.trim().isEmpty()) { builder.and(qUser.email.eq(email)); // email 有唯一索引 } return queryFactory.selectFrom(qUser) .where(builder) .fetch(); } /** * 批量查詢優化 */ public Map\u0026lt;Long, User\u0026gt; getUsersByIdsOptimized(List\u0026lt;Long\u0026gt; userIds) { if (userIds.isEmpty()) { return Collections.emptyMap(); } List\u0026lt;User\u0026gt; users = queryFactory.selectFrom(qUser) .where(qUser.id.in(userIds)) .fetch(); return users.stream() .collect(Collectors.toMap(User::getId, Function.identity())); } } /** * 用戶摘要 DTO */ public class UserSummaryDTO { private Long id; private String username; private String email; private UserStatus status; private String departmentName; public UserSummaryDTO(Long id, String username, String email, UserStatus status, String departmentName) { this.id = id; this.username = username; this.email = email; this.status = status; this.departmentName = departmentName; } // getter 和 setter 方法省略... } 2. 快取策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 /** * 快取優化服務 */ @Service @Transactional(readOnly = true) public class CachedQueryService { @Autowired private JPAQueryFactory queryFactory; @Autowired private CacheManager cacheManager; private final QUser qUser = QUser.user; private final QDepartment qDepartment = QDepartment.department; /** * 快取用戶基本資訊 */ @Cacheable(value = \u0026#34;userCache\u0026#34;, key = \u0026#34;#userId\u0026#34;) public Optional\u0026lt;User\u0026gt; getCachedUser(Long userId) { User user = queryFactory.selectFrom(qUser) .where(qUser.id.eq(userId)) .fetchOne(); return Optional.ofNullable(user); } /** * 快取部門用戶列表 */ @Cacheable(value = \u0026#34;departmentUsersCache\u0026#34;, key = \u0026#34;#departmentId\u0026#34;) public List\u0026lt;User\u0026gt; getCachedDepartmentUsers(Long departmentId) { return queryFactory.selectFrom(qUser) .where(qUser.department.id.eq(departmentId) .and(qUser.status.eq(UserStatus.ACTIVE))) .orderBy(qUser.username.asc()) .fetch(); } /** * 快取用戶統計資訊 */ @Cacheable(value = \u0026#34;userStatsCache\u0026#34;, key = \u0026#34;\u0026#39;userStats\u0026#39;\u0026#34;) public UserStatistics getCachedUserStatistics() { Long totalUsers = queryFactory.select(qUser.count()) .from(qUser) .fetchOne(); Long activeUsers = queryFactory.select(qUser.count()) .from(qUser) .where(qUser.status.eq(UserStatus.ACTIVE)) .fetchOne(); Double averageSalary = queryFactory.select(qUser.salary.avg()) .from(qUser) .where(qUser.salary.isNotNull() .and(qUser.status.eq(UserStatus.ACTIVE))) .fetchOne(); return new UserStatistics(totalUsers, activeUsers, averageSalary); } /** * 更新時清除快取 */ @CacheEvict(value = {\u0026#34;userCache\u0026#34;, \u0026#34;departmentUsersCache\u0026#34;, \u0026#34;userStatsCache\u0026#34;}, allEntries = true) public void evictAllCaches() { // 清除所有相關快取 } /** * 清除特定用戶快取 */ @CacheEvict(value = \u0026#34;userCache\u0026#34;, key = \u0026#34;#userId\u0026#34;) public void evictUserCache(Long userId) { // 清除特定用戶快取 } } 測試策略 1. 單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 /** * QueryDSL 單元測試 */ @DataJpaTest @TestPropertySource(locations = \u0026#34;classpath:application-test.properties\u0026#34;) class QueryDSLServiceTest { @Autowired private TestEntityManager entityManager; @Autowired private UserRepository userRepository; private JPAQueryFactory queryFactory; private UserService userService; @BeforeEach void setUp() { queryFactory = new JPAQueryFactory(entityManager.getEntityManager()); userService = new UserService(); ReflectionTestUtils.setField(userService, \u0026#34;queryFactory\u0026#34;, queryFactory); ReflectionTestUtils.setField(userService, \u0026#34;userRepository\u0026#34;, userRepository); } @Test @DisplayName(\u0026#34;根據用戶名查找用戶\u0026#34;) void testFindByUsername() { // Given User user = new User(\u0026#34;testuser\u0026#34;, \u0026#34;test@example.com\u0026#34;, \u0026#34;Test\u0026#34;, \u0026#34;User\u0026#34;, 25); user.setStatus(UserStatus.ACTIVE); entityManager.persistAndFlush(user); // When Optional\u0026lt;User\u0026gt; result = userService.findByUsername(\u0026#34;testuser\u0026#34;); // Then assertThat(result).isPresent(); assertThat(result.get().getUsername()).isEqualTo(\u0026#34;testuser\u0026#34;); assertThat(result.get().getEmail()).isEqualTo(\u0026#34;test@example.com\u0026#34;); } @Test @DisplayName(\u0026#34;多條件查詢用戶\u0026#34;) void testFindUsersByConditions() { // Given Department department = new Department(\u0026#34;IT\u0026#34;, \u0026#34;Information Technology\u0026#34;, 100000.0); entityManager.persistAndFlush(department); User user1 = new User(\u0026#34;john\u0026#34;, \u0026#34;john@example.com\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;, 30); user1.setStatus(UserStatus.ACTIVE); user1.setDepartment(department); User user2 = new User(\u0026#34;jane\u0026#34;, \u0026#34;jane@example.com\u0026#34;, \u0026#34;Jane\u0026#34;, \u0026#34;Smith\u0026#34;, 25); user2.setStatus(UserStatus.INACTIVE); user2.setDepartment(department); entityManager.persistAndFlush(user1); entityManager.persistAndFlush(user2); // When List\u0026lt;User\u0026gt; activeUsers = userService.findUsersByConditions( null, null, 20, 35, UserStatus.ACTIVE); // Then assertThat(activeUsers).hasSize(1); assertThat(activeUsers.get(0).getUsername()).isEqualTo(\u0026#34;john\u0026#34;); } @Test @DisplayName(\u0026#34;測試 Join 查詢\u0026#34;) void testJoinQuery() { // Given Department department = new Department(\u0026#34;HR\u0026#34;, \u0026#34;Human Resources\u0026#34;, 80000.0); entityManager.persistAndFlush(department); User user = new User(\u0026#34;hr_user\u0026#34;, \u0026#34;hr@example.com\u0026#34;, \u0026#34;HR\u0026#34;, \u0026#34;Manager\u0026#34;, 35); user.setStatus(UserStatus.ACTIVE); user.setDepartment(department); entityManager.persistAndFlush(user); // When QUser qUser = QUser.user; QDepartment qDepartment = QDepartment.department; List\u0026lt;User\u0026gt; users = queryFactory.selectFrom(qUser) .innerJoin(qUser.department, qDepartment).fetchJoin() .where(qDepartment.name.eq(\u0026#34;HR\u0026#34;)) .fetch(); // Then assertThat(users).hasSize(1); assertThat(users.get(0).getDepartment().getName()).isEqualTo(\u0026#34;HR\u0026#34;); } @Test @DisplayName(\u0026#34;測試聚合查詢\u0026#34;) void testAggregationQuery() { // Given Department department = new Department(\u0026#34;Sales\u0026#34;, \u0026#34;Sales Department\u0026#34;, 120000.0); entityManager.persistAndFlush(department); User user1 = new User(\u0026#34;sales1\u0026#34;, \u0026#34;sales1@example.com\u0026#34;, \u0026#34;Sales\u0026#34;, \u0026#34;Rep1\u0026#34;, 28); user1.setStatus(UserStatus.ACTIVE); user1.setDepartment(department); user1.setSalary(50000.0); User user2 = new User(\u0026#34;sales2\u0026#34;, \u0026#34;sales2@example.com\u0026#34;, \u0026#34;Sales\u0026#34;, \u0026#34;Rep2\u0026#34;, 32); user2.setStatus(UserStatus.ACTIVE); user2.setDepartment(department); user2.setSalary(60000.0); entityManager.persistAndFlush(user1); entityManager.persistAndFlush(user2); // When QUser qUser = QUser.user; QDepartment qDepartment = QDepartment.department; Tuple result = queryFactory.select( qDepartment.name, qUser.count(), qUser.salary.avg()) .from(qUser) .innerJoin(qUser.department, qDepartment) .where(qDepartment.name.eq(\u0026#34;Sales\u0026#34;)) .groupBy(qDepartment.name) .fetchOne(); // Then assertThat(result).isNotNull(); assertThat(result.get(qDepartment.name)).isEqualTo(\u0026#34;Sales\u0026#34;); assertThat(result.get(qUser.count())).isEqualTo(2L); assertThat(result.get(qUser.salary.avg())).isEqualTo(55000.0); } } 2. 整合測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /** * QueryDSL 整合測試 */ @SpringBootTest @Transactional @TestPropertySource(locations = \u0026#34;classpath:application-integration-test.properties\u0026#34;) class QueryDSLIntegrationTest { @Autowired private UserService userService; @Autowired private UserRepository userRepository; @Autowired private DepartmentRepository departmentRepository; @Test @DisplayName(\u0026#34;完整的用戶管理流程測試\u0026#34;) void testCompleteUserManagementFlow() { // 1. 創建部門 Department department = new Department(\u0026#34;Engineering\u0026#34;, \u0026#34;Software Engineering\u0026#34;, 200000.0); department = departmentRepository.save(department); // 2. 創建用戶 User user1 = new User(\u0026#34;engineer1\u0026#34;, \u0026#34;eng1@example.com\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Engineer\u0026#34;, 30); user1.setStatus(UserStatus.ACTIVE); user1.setSalary(80000.0); user1.setDepartment(department); User user2 = new User(\u0026#34;engineer2\u0026#34;, \u0026#34;eng2@example.com\u0026#34;, \u0026#34;Jane\u0026#34;, \u0026#34;Developer\u0026#34;, 28); user2.setStatus(UserStatus.ACTIVE); user2.setSalary(75000.0); user2.setDepartment(department); userRepository.saveAll(Arrays.asList(user1, user2)); // 3. 測試查詢 List\u0026lt;User\u0026gt; engineers = userService.findUsersByConditions( null, null, 25, 35, UserStatus.ACTIVE); assertThat(engineers).hasSize(2); // 4. 測試更新 UserUpdateService updateService = new UserUpdateService(); // 設定 queryFactory... long updatedCount = updateService.updateSalaryByDepartment( department.getId(), 5000.0); assertThat(updatedCount).isEqualTo(2); // 5. 驗證更新結果 List\u0026lt;User\u0026gt; updatedUsers = userRepository.findAll(); assertThat(updatedUsers.stream() .mapToDouble(User::getSalary) .average() .orElse(0.0)) .isEqualTo(82500.0); // (85000 + 80000) / 2 } } 最佳實踐與建議 1. 查詢優化建議 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 /** * QueryDSL 最佳實踐指南 */ @Component public class QueryDSLBestPractices { /** * 1. 使用適當的 Fetch 策略 */ public void demonstrateFetchStrategies() { // ✅ 推薦：使用 fetchJoin 避免 N+1 問題 List\u0026lt;User\u0026gt; usersWithDepartment = queryFactory.selectFrom(qUser) .leftJoin(qUser.department, qDepartment).fetchJoin() .fetch(); // ❌ 避免：不使用 fetchJoin 會導致 N+1 問題 List\u0026lt;User\u0026gt; users = queryFactory.selectFrom(qUser).fetch(); // 後續存取 user.getDepartment() 會觸發額外查詢 } /** * 2. 使用投影減少記憶體使用 */ public void demonstrateProjections() { // ✅ 推薦：只選擇需要的欄位 List\u0026lt;UserSummaryDTO\u0026gt; summaries = queryFactory .select(Projections.constructor(UserSummaryDTO.class, qUser.id, qUser.username, qUser.email)) .from(qUser) .fetch(); // ❌ 避免：選擇整個實體但只使用部分欄位 List\u0026lt;User\u0026gt; allUsers = queryFactory.selectFrom(qUser).fetch(); } /** * 3. 合理使用索引 */ public void demonstrateIndexUsage() { // ✅ 推薦：查詢條件使用有索引的欄位 List\u0026lt;User\u0026gt; usersByUsername = queryFactory.selectFrom(qUser) .where(qUser.username.eq(\u0026#34;john\u0026#34;)) // username 有索引 .fetch(); // ❌ 避免：在沒有索引的欄位上使用 LIKE 查詢 List\u0026lt;User\u0026gt; usersByDescription = queryFactory.selectFrom(qUser) .where(qUser.email.contains(\u0026#34;@gmail\u0026#34;)) // 可能效能較差 .fetch(); } /** * 4. 批量操作優化 */ public void demonstrateBatchOperations() { // ✅ 推薦：使用批量更新 long updated = queryFactory.update(qUser) .set(qUser.status, UserStatus.ACTIVE) .where(qUser.id.in(Arrays.asList(1L, 2L, 3L))) .execute(); // ❌ 避免：迴圈中進行單個更新 for (Long id : Arrays.asList(1L, 2L, 3L)) { queryFactory.update(qUser) .set(qUser.status, UserStatus.ACTIVE) .where(qUser.id.eq(id)) .execute(); // 多次資料庫往返 } } /** * 5. 分頁查詢優化 */ public void demonstratePaginationOptimization() { // ✅ 推薦：先查總數，再查分頁資料 Long total = queryFactory.select(qUser.count()) .from(qUser) .where(qUser.status.eq(UserStatus.ACTIVE)) .fetchOne(); if (total \u0026gt; 0) { List\u0026lt;User\u0026gt; users = queryFactory.selectFrom(qUser) .where(qUser.status.eq(UserStatus.ACTIVE)) .offset(0) .limit(20) .fetch(); } // ❌ 避免：使用複雜的子查詢進行分頁 } } 2. 錯誤處理與除錯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 /** * QueryDSL 錯誤處理指南 */ @Component public class QueryDSLErrorHandling { private static final Logger logger = LoggerFactory.getLogger(QueryDSLErrorHandling.class); /** * 安全的查詢執行 */ public Optional\u0026lt;User\u0026gt; safeQueryExecution(Long userId) { try { User user = queryFactory.selectFrom(qUser) .where(qUser.id.eq(userId)) .fetchOne(); return Optional.ofNullable(user); } catch (DataAccessException e) { logger.error(\u0026#34;Database error while fetching user with id: {}\u0026#34;, userId, e); return Optional.empty(); } catch (Exception e) { logger.error(\u0026#34;Unexpected error while fetching user with id: {}\u0026#34;, userId, e); throw new ServiceException(\u0026#34;Failed to fetch user\u0026#34;, e); } } /** * 查詢除錯輔助方法 */ public void debugQuery() { // 開啟 SQL 日誌記錄 JPAQuery\u0026lt;User\u0026gt; query = queryFactory.selectFrom(qUser) .where(qUser.status.eq(UserStatus.ACTIVE)); // 印出生成的 SQL logger.debug(\u0026#34;Generated SQL: {}\u0026#34;, query.toString()); // 執行查詢 List\u0026lt;User\u0026gt; results = query.fetch(); logger.debug(\u0026#34;Query returned {} results\u0026#34;, results.size()); } /** * 驗證查詢參數 */ public List\u0026lt;User\u0026gt; validateAndQuery(UserSearchCriteria criteria) { // 參數驗證 if (criteria == null) { throw new IllegalArgumentException(\u0026#34;Search criteria cannot be null\u0026#34;); } BooleanBuilder builder = new BooleanBuilder(); // 安全的字串處理 if (criteria.getUsername() != null) { String cleanUsername = criteria.getUsername().trim(); if (!cleanUsername.isEmpty()) { builder.and(qUser.username.containsIgnoreCase(cleanUsername)); } } // 數值範圍驗證 if (criteria.getMinAge() != null \u0026amp;\u0026amp; criteria.getMaxAge() != null) { if (criteria.getMinAge() \u0026gt; criteria.getMaxAge()) { throw new IllegalArgumentException(\u0026#34;Min age cannot be greater than max age\u0026#34;); } } return queryFactory.selectFrom(qUser) .where(builder) .fetch(); } } 總結 QueryDSL 是一個功能強大的類型安全查詢框架，為 Java 開發者提供了高效的動態查詢解決方案：\n主要優勢 類型安全：編譯時檢查，減少執行期錯誤 IDE 友好：完整的自動完成和重構支援 統一 API：支援多種資料源的一致查詢介面 效能優化：生成高效的 SQL 查詢語句 動態查詢：靈活的條件組合和查詢建構 適用場景 複雜動態查詢：多條件組合查詢 報表系統：複雜的聚合和統計查詢 搜尋功能：靈活的搜尋條件組合 資料分析：大量的資料處理和分析 API 開發：RESTful API 的查詢參數處理 最佳實踐要點 效能優化：合理使用 Fetch Join 和投影 索引利用：查詢條件對應適當的資料庫索引 批量操作：使用批量更新和刪除操作 錯誤處理：完善的異常處理和日誌記錄 測試覆蓋：充分的單元測試和整合測試 通過掌握 QueryDSL 的使用技巧和最佳實踐，可以大幅提升 Java 應用程式的查詢效率和開發體驗，建構出高效能、可維護的資料存取層。\n","permalink":"https://xinqilin.github.io/post/backend/querydsl/","tags":["QueryDSL","JPA","Spring Data","Database","Query Builder","Type Safety","Criteria API","Dynamic Query","Performance"],"title":"QueryDSL 完整實戰指南：類型安全的動態查詢解決方案"},{"content":"Kotlin lateinit 完整實作指南 簡介 在 Kotlin 開發中，lateinit 關鍵字提供了一種延遲初始化屬性的優雅方式，特別適用於依賴注入、Android 開發和 Spring Boot 應用。本文將深入探討 lateinit 的工作原理、使用場景、與 lazy 的比較，以及在企業級開發中的最佳實踐。\nlateinit 基本概念 核心特性 lateinit 是 Kotlin 提供的延遲初始化修飾符，允許開發者聲明非空屬性而不需要立即初始化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class UserService { // 延遲初始化，避免空值檢查 lateinit var userRepository: UserRepository lateinit var cacheManager: CacheManager fun initializeServices() { userRepository = UserRepositoryImpl() cacheManager = RedisCacheManager() } fun findUser(id: Long): User { // 直接使用，無需空值檢查 return userRepository.findById(id) ?: throw UserNotFoundException(id) } } 語法規則與限制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class PropertyRules { // ✅ 正確：var 屬性 lateinit var validProperty: String // ❌ 錯誤：lateinit 不能用於 val // lateinit val invalidProperty: String // 編譯錯誤 // ❌ 錯誤：原始類型不支援 // lateinit var invalidInt: Int // 編譯錯誤 // ❌ 錯誤：可空類型不支援 // lateinit var invalidNullable: String? // 編譯錯誤 // ✅ 正確：自定義類別 lateinit var database: Database // ✅ 正確：介面類型 lateinit var service: ServiceInterface } lateinit 詳細機制 內部實現原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Kotlin 編譯後的 Java 等效代碼 public class UserService { private String name; public final String getName() { String var1 = this.name; if (var1 == null) { Intrinsics.throwUninitializedPropertyAccessException(\u0026#34;name\u0026#34;); } return var1; } public final void setName(String value) { Intrinsics.checkNotNullParameter(value, \u0026#34;value\u0026#34;); this.name = value; } } 初始化檢查機制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class InitializationChecker { lateinit var database: Database lateinit var config: AppConfig fun checkInitialization() { // 檢查是否已初始化 if (::database.isInitialized) { println(\u0026#34;Database is ready\u0026#34;) } else { println(\u0026#34;Database not initialized\u0026#34;) } // 安全初始化模式 if (!::config.isInitialized) { config = loadDefaultConfig() } } fun safeAccess(): String { return if (::database.isInitialized) { database.getConnectionInfo() } else { \u0026#34;Database not available\u0026#34; } } } 企業級應用場景 1. Spring Boot 依賴注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @Service class UserManagementService { @Autowired lateinit var userRepository: UserRepository @Autowired lateinit var emailService: EmailService @Autowired lateinit var auditService: AuditService @Value(\u0026#34;\\${app.user.max-login-attempts}\u0026#34;) lateinit var maxLoginAttempts: String @PostConstruct fun validateDependencies() { require(::userRepository.isInitialized) { \u0026#34;UserRepository not injected\u0026#34; } require(::emailService.isInitialized) { \u0026#34;EmailService not injected\u0026#34; } require(::auditService.isInitialized) { \u0026#34;AuditService not injected\u0026#34; } logger.info(\u0026#34;All dependencies initialized successfully\u0026#34;) } fun createUser(userData: UserCreateRequest): User { val user = User( email = userData.email, username = userData.username, hashedPassword = hashPassword(userData.password) ) val savedUser = userRepository.save(user) // 發送歡迎郵件 emailService.sendWelcomeEmail(savedUser) // 記錄審計日誌 auditService.logUserCreation(savedUser) return savedUser } companion object { private val logger = LoggerFactory.getLogger(UserManagementService::class.java) } } 2. Android 開發中的應用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class MainActivity : AppCompatActivity() { // View 元件延遲初始化 lateinit var recyclerView: RecyclerView lateinit var adapter: UserAdapter lateinit var viewModel: UserViewModel // 網路元件 lateinit var apiService: ApiService lateinit var networkManager: NetworkManager override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initializeViews() initializeNetwork() initializeViewModel() setupObservers() } private fun initializeViews() { recyclerView = findViewById(R.id.recyclerView) adapter = UserAdapter { user -\u0026gt; onUserClicked(user) } recyclerView.adapter = adapter recyclerView.layoutManager = LinearLayoutManager(this) } private fun initializeNetwork() { apiService = RetrofitBuilder.createApiService() networkManager = NetworkManager(this) } private fun initializeViewModel() { viewModel = ViewModelProvider(this)[UserViewModel::class.java] } private fun setupObservers() { // 確保所有元件都已初始化 require(::viewModel.isInitialized) { \u0026#34;ViewModel not initialized\u0026#34; } require(::adapter.isInitialized) { \u0026#34;Adapter not initialized\u0026#34; } viewModel.users.observe(this) { users -\u0026gt; adapter.submitList(users) } viewModel.loading.observe(this) { isLoading -\u0026gt; // 處理載入狀態 } } private fun onUserClicked(user: User) { if (::networkManager.isInitialized \u0026amp;\u0026amp; networkManager.isConnected()) { // 處理用戶點擊事件 viewModel.loadUserDetails(user.id) } else { showNoNetworkError() } } } 3. 配置管理系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @Component class ConfigurationManager { @Value(\u0026#34;\\${database.url}\u0026#34;) lateinit var databaseUrl: String @Value(\u0026#34;\\${database.username}\u0026#34;) lateinit var databaseUsername: String @Value(\u0026#34;\\${redis.host}\u0026#34;) lateinit var redisHost: String @Value(\u0026#34;\\${jwt.secret}\u0026#34;) lateinit var jwtSecret: String lateinit var databaseConfig: DatabaseConfig lateinit var redisConfig: RedisConfig lateinit var securityConfig: SecurityConfig @PostConstruct fun initializeConfigurations() { validateRequiredProperties() buildConfigurations() logConfigurationStatus() } private fun validateRequiredProperties() { val errors = mutableListOf\u0026lt;String\u0026gt;() if (!::databaseUrl.isInitialized || databaseUrl.isBlank()) { errors.add(\u0026#34;Database URL not configured\u0026#34;) } if (!::databaseUsername.isInitialized || databaseUsername.isBlank()) { errors.add(\u0026#34;Database username not configured\u0026#34;) } if (!::redisHost.isInitialized || redisHost.isBlank()) { errors.add(\u0026#34;Redis host not configured\u0026#34;) } if (!::jwtSecret.isInitialized || jwtSecret.isBlank()) { errors.add(\u0026#34;JWT secret not configured\u0026#34;) } if (errors.isNotEmpty()) { throw ConfigurationException(\u0026#34;Configuration errors: ${errors.joinToString(\u0026#34;, \u0026#34;)}\u0026#34;) } } private fun buildConfigurations() { databaseConfig = DatabaseConfig( url = databaseUrl, username = databaseUsername, maxPoolSize = 20, connectionTimeout = Duration.ofSeconds(30) ) redisConfig = RedisConfig( host = redisHost, port = 6379, timeout = Duration.ofSeconds(10) ) securityConfig = SecurityConfig( jwtSecret = jwtSecret, tokenExpiration = Duration.ofHours(24), refreshTokenExpiration = Duration.ofDays(7) ) } private fun logConfigurationStatus() { logger.info(\u0026#34;Configuration initialized successfully:\u0026#34;) logger.info(\u0026#34;- Database: ${databaseConfig.url}\u0026#34;) logger.info(\u0026#34;- Redis: ${redisConfig.host}:${redisConfig.port}\u0026#34;) logger.info(\u0026#34;- Security: JWT configured with ${securityConfig.tokenExpiration} expiration\u0026#34;) } fun getDatabaseConfig(): DatabaseConfig { require(::databaseConfig.isInitialized) { \u0026#34;Database configuration not initialized\u0026#34; } return databaseConfig } fun getRedisConfig(): RedisConfig { require(::redisConfig.isInitialized) { \u0026#34;Redis configuration not initialized\u0026#34; } return redisConfig } fun getSecurityConfig(): SecurityConfig { require(::securityConfig.isInitialized) { \u0026#34;Security configuration not initialized\u0026#34; } return securityConfig } companion object { private val logger = LoggerFactory.getLogger(ConfigurationManager::class.java) } } lateinit vs lazy 詳細比較 特性對比表 特性 lateinit lazy 初始化時機 手動控制 首次訪問時 線程安全 否 是（預設） 可變性 var（可重新賦值） val（不可變） 初始化檢查 ::property.isInitialized 無需檢查 記憶體開銷 低 略高（Lazy包裝） 適用場景 依賴注入、外部初始化 延遲計算、高開銷操作 使用場景比較 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class ComparisonExample { // lateinit：適合依賴注入 @Autowired lateinit var repository: UserRepository // lazy：適合計算密集型初始化 private val expensiveResource: DatabaseConnection by lazy { createDatabaseConnection() // 僅在首次使用時執行 } // lateinit：可重新賦值 lateinit var currentUser: User fun switchUser(newUser: User) { currentUser = newUser // 可以重新賦值 } // lazy：線程安全的單例初始化 private val singleton: ServiceManager by lazy(LazyThreadSafetyMode.SYNCHRONIZED) { ServiceManager.create() } // lateinit：手動控制初始化時機 lateinit var testDatabase: TestDatabase @BeforeEach fun setupTest() { testDatabase = createTestDatabase() } @AfterEach fun cleanupTest() { if (::testDatabase.isInitialized) { testDatabase.cleanup() } } } 進階使用模式 1. 條件初始化模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class ConditionalInitialization { lateinit var primaryDatabase: Database lateinit var secondaryDatabase: Database fun initializeDatabases(config: DatabaseConfig) { // 主資料庫總是初始化 primaryDatabase = createDatabase(config.primary) // 次要資料庫僅在啟用時初始化 if (config.enableSecondary) { secondaryDatabase = createDatabase(config.secondary) } } fun executeQuery(query: String): QueryResult { val result = primaryDatabase.execute(query) // 安全地使用次要資料庫 if (::secondaryDatabase.isInitialized) { secondaryDatabase.logQuery(query, result) } return result } } 2. 初始化鏈模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class InitializationChain { lateinit var configService: ConfigService lateinit var databaseService: DatabaseService lateinit var cacheService: CacheService lateinit var businessService: BusinessService fun initializeAll() { initializeConfig() initializeDatabase() initializeCache() initializeBusiness() validateInitialization() } private fun initializeConfig() { configService = ConfigService() logger.info(\u0026#34;Config service initialized\u0026#34;) } private fun initializeDatabase() { require(::configService.isInitialized) { \u0026#34;Config service must be initialized first\u0026#34; } databaseService = DatabaseService(configService.getDatabaseConfig()) logger.info(\u0026#34;Database service initialized\u0026#34;) } private fun initializeCache() { require(::configService.isInitialized) { \u0026#34;Config service must be initialized first\u0026#34; } cacheService = CacheService(configService.getCacheConfig()) logger.info(\u0026#34;Cache service initialized\u0026#34;) } private fun initializeBusiness() { require(::databaseService.isInitialized) { \u0026#34;Database service must be initialized first\u0026#34; } require(::cacheService.isInitialized) { \u0026#34;Cache service must be initialized first\u0026#34; } businessService = BusinessService(databaseService, cacheService) logger.info(\u0026#34;Business service initialized\u0026#34;) } private fun validateInitialization() { val errors = mutableListOf\u0026lt;String\u0026gt;() if (!::configService.isInitialized) errors.add(\u0026#34;ConfigService\u0026#34;) if (!::databaseService.isInitialized) errors.add(\u0026#34;DatabaseService\u0026#34;) if (!::cacheService.isInitialized) errors.add(\u0026#34;CacheService\u0026#34;) if (!::businessService.isInitialized) errors.add(\u0026#34;BusinessService\u0026#34;) if (errors.isNotEmpty()) { throw InitializationException(\u0026#34;未初始化的服務: ${errors.joinToString(\u0026#34;, \u0026#34;)}\u0026#34;) } logger.info(\u0026#34;所有服務初始化完成\u0026#34;) } companion object { private val logger = LoggerFactory.getLogger(InitializationChain::class.java) } } 3. 資源管理模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class ResourceManager : AutoCloseable { lateinit var connectionPool: ConnectionPool lateinit var cacheManager: CacheManager lateinit var fileManager: FileManager private val initializedResources = mutableSetOf\u0026lt;String\u0026gt;() fun initializeConnectionPool(config: ConnectionConfig) { connectionPool = ConnectionPool.create(config) initializedResources.add(\u0026#34;connectionPool\u0026#34;) logger.info(\u0026#34;Connection pool initialized with ${config.maxConnections} connections\u0026#34;) } fun initializeCacheManager(config: CacheConfig) { cacheManager = CacheManager.create(config) initializedResources.add(\u0026#34;cacheManager\u0026#34;) logger.info(\u0026#34;Cache manager initialized with ${config.maxSize} max size\u0026#34;) } fun initializeFileManager(config: FileConfig) { fileManager = FileManager.create(config) initializedResources.add(\u0026#34;fileManager\u0026#34;) logger.info(\u0026#34;File manager initialized with root: ${config.rootPath}\u0026#34;) } fun getResourceStatus(): Map\u0026lt;String, Boolean\u0026gt; { return mapOf( \u0026#34;connectionPool\u0026#34; to ::connectionPool.isInitialized, \u0026#34;cacheManager\u0026#34; to ::cacheManager.isInitialized, \u0026#34;fileManager\u0026#34; to ::fileManager.isInitialized ) } override fun close() { logger.info(\u0026#34;開始關閉資源管理器\u0026#34;) // 按相反順序關閉資源 if (::fileManager.isInitialized) { try { fileManager.close() logger.info(\u0026#34;File manager closed\u0026#34;) } catch (e: Exception) { logger.error(\u0026#34;Error closing file manager\u0026#34;, e) } } if (::cacheManager.isInitialized) { try { cacheManager.close() logger.info(\u0026#34;Cache manager closed\u0026#34;) } catch (e: Exception) { logger.error(\u0026#34;Error closing cache manager\u0026#34;, e) } } if (::connectionPool.isInitialized) { try { connectionPool.close() logger.info(\u0026#34;Connection pool closed\u0026#34;) } catch (e: Exception) { logger.error(\u0026#34;Error closing connection pool\u0026#34;, e) } } initializedResources.clear() logger.info(\u0026#34;資源管理器關閉完成\u0026#34;) } companion object { private val logger = LoggerFactory.getLogger(ResourceManager::class.java) } } 測試策略 1. 單元測試模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class UserServiceTest { @Mock lateinit var userRepository: UserRepository @Mock lateinit var emailService: EmailService @InjectMocks lateinit var userService: UserService @BeforeEach fun setup() { MockitoAnnotations.openMocks(this) // 驗證依賴注入是否成功 assertTrue(::userRepository.isInitialized, \u0026#34;UserRepository should be initialized\u0026#34;) assertTrue(::emailService.isInitialized, \u0026#34;EmailService should be initialized\u0026#34;) assertTrue(::userService.isInitialized, \u0026#34;UserService should be initialized\u0026#34;) } @Test fun `should create user successfully`() { // Given val userData = UserCreateRequest( email = \u0026#34;test@example.com\u0026#34;, username = \u0026#34;testuser\u0026#34; ) val expectedUser = User(1L, \u0026#34;test@example.com\u0026#34;, \u0026#34;testuser\u0026#34;) `when`(userRepository.save(any())).thenReturn(expectedUser) doNothing().`when`(emailService).sendWelcomeEmail(any()) // When val result = userService.createUser(userData) // Then assertEquals(expectedUser, result) verify(userRepository).save(any()) verify(emailService).sendWelcomeEmail(expectedUser) } @Test fun `should handle uninitialized dependencies gracefully`() { // 測試未初始化的情況 val service = UserService() assertFalse(service::userRepository.isInitialized) assertFalse(service::emailService.isInitialized) assertThrows\u0026lt;UninitializedPropertyAccessException\u0026gt; { service.createUser(UserCreateRequest(\u0026#34;test@example.com\u0026#34;, \u0026#34;test\u0026#34;)) } } } 2. 整合測試模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @SpringBootTest @TestPropertySource(properties = [ \u0026#34;spring.datasource.url=jdbc:h2:mem:testdb\u0026#34;, \u0026#34;spring.jpa.hibernate.ddl-auto=create-drop\u0026#34; ]) class UserServiceIntegrationTest { @Autowired lateinit var userService: UserService @Autowired lateinit var userRepository: UserRepository @TestConfiguration class TestConfig { @Bean @Primary fun mockEmailService(): EmailService = mockk(relaxed = true) } @Test fun `should initialize all dependencies in Spring context`() { // 驗證 Spring 上下文中的依賴注入 assertTrue(userService::userRepository.isInitialized) assertTrue(userService::emailService.isInitialized) // 執行實際的業務邏輯測試 val userData = UserCreateRequest(\u0026#34;integration@test.com\u0026#34;, \u0026#34;integrationuser\u0026#34;) val result = userService.createUser(userData) assertNotNull(result.id) assertEquals(\u0026#34;integration@test.com\u0026#34;, result.email) assertEquals(\u0026#34;integrationuser\u0026#34;, result.username) // 驗證資料實際儲存 val savedUser = userRepository.findById(result.id!!) assertTrue(savedUser.isPresent) assertEquals(result.email, savedUser.get().email) } } 效能優化與最佳實踐 1. 記憶體管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class MemoryOptimizedService { // 大型物件使用 lateinit 延遲初始化 lateinit var largeDataSet: LargeDataSet lateinit var heavyProcessor: HeavyProcessor // 小型配置物件可以直接初始化 private val config = ServiceConfig() fun initializeHeavyResources() { if (!::largeDataSet.isInitialized) { largeDataSet = LargeDataSet.loadFromDatabase() logger.info(\u0026#34;Large dataset loaded: ${largeDataSet.size} records\u0026#34;) } if (!::heavyProcessor.isInitialized) { heavyProcessor = HeavyProcessor(largeDataSet) logger.info(\u0026#34;Heavy processor initialized\u0026#34;) } } fun processDataIfReady(input: String): String? { return if (::heavyProcessor.isInitialized) { heavyProcessor.process(input) } else { logger.warn(\u0026#34;Heavy processor not initialized, skipping processing\u0026#34;) null } } // 清理資源 fun cleanup() { if (::heavyProcessor.isInitialized) { heavyProcessor.cleanup() } if (::largeDataSet.isInitialized) { largeDataSet.cleanup() } } companion object { private val logger = LoggerFactory.getLogger(MemoryOptimizedService::class.java) } } 2. 線程安全考量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class ThreadSafeService { @Volatile lateinit var sharedResource: SharedResource private val initializationLock = ReentrantLock() private val condition = initializationLock.newCondition() fun initializeSharedResource(config: ResourceConfig) { initializationLock.withLock { if (!::sharedResource.isInitialized) { sharedResource = SharedResource.create(config) condition.signalAll() // 通知等待的線程 logger.info(\u0026#34;Shared resource initialized\u0026#34;) } } } fun accessSharedResource(): String { // 等待初始化完成 initializationLock.withLock { while (!::sharedResource.isInitialized) { condition.await(5, TimeUnit.SECONDS) if (!::sharedResource.isInitialized) { throw TimeoutException(\u0026#34;Shared resource initialization timeout\u0026#34;) } } } return sharedResource.getData() } fun isResourceReady(): Boolean { return ::sharedResource.isInitialized } companion object { private val logger = LoggerFactory.getLogger(ThreadSafeService::class.java) } } 常見陷阱與錯誤處理 1. 常見錯誤模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class CommonMistakes { lateinit var service: SomeService // ❌ 錯誤：在初始化前訪問 fun badExample1() { service.doSomething() // UninitializedPropertyAccessException } // ❌ 錯誤：忘記檢查初始化狀態 fun badExample2() { val result = service.getData() // 可能未初始化 return result } // ✅ 正確：檢查後訪問 fun goodExample1() { if (::service.isInitialized) { service.doSomething() } else { logger.warn(\u0026#34;Service not initialized\u0026#34;) } } // ✅ 正確：防禦性初始化 fun goodExample2(): String { if (!::service.isInitialized) { service = SomeService.createDefault() } return service.getData() } } 2. 錯誤處理策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ErrorHandlingService { lateinit var primaryService: PrimaryService lateinit var backupService: BackupService fun processRequest(request: Request): Response { return try { // 嘗試使用主要服務 if (::primaryService.isInitialized) { primaryService.process(request) } else { throw ServiceNotInitializedException(\u0026#34;Primary service not available\u0026#34;) } } catch (e: ServiceNotInitializedException) { logger.warn(\u0026#34;Primary service unavailable, falling back to backup\u0026#34;, e) // 備援服務處理 if (::backupService.isInitialized) { backupService.process(request) } else { throw ServiceUnavailableException(\u0026#34;No services available\u0026#34;) } } catch (e: Exception) { logger.error(\u0026#34;Unexpected error processing request\u0026#34;, e) throw ProcessingException(\u0026#34;Failed to process request\u0026#34;, e) } } fun healthCheck(): HealthStatus { val status = HealthStatus() status.primaryServiceAvailable = ::primaryService.isInitialized status.backupServiceAvailable = ::backupService.isInitialized status.overallStatus = when { status.primaryServiceAvailable -\u0026gt; HealthStatus.Status.HEALTHY status.backupServiceAvailable -\u0026gt; HealthStatus.Status.DEGRADED else -\u0026gt; HealthStatus.Status.UNHEALTHY } return status } companion object { private val logger = LoggerFactory.getLogger(ErrorHandlingService::class.java) } } 企業級最佳實踐 1. 初始化驗證框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @Component class InitializationValidator { fun validateObject(obj: Any): ValidationResult { val result = ValidationResult() val clazz = obj::class // 使用反射檢查所有 lateinit 屬性 clazz.memberProperties .filterIsInstance\u0026lt;KMutableProperty1\u0026lt;Any, Any\u0026gt;\u0026gt;() .filter { it.isLateinit } .forEach { property -\u0026gt; try { if (!property.isInitialized(obj)) { result.addError(\u0026#34;Property \u0026#39;${property.name}\u0026#39; is not initialized\u0026#34;) } else { result.addSuccess(\u0026#34;Property \u0026#39;${property.name}\u0026#39; is initialized\u0026#34;) } } catch (e: Exception) { result.addError(\u0026#34;Error checking property \u0026#39;${property.name}\u0026#39;: ${e.message}\u0026#34;) } } return result } @EventListener fun onApplicationReady(event: ApplicationReadyEvent) { logger.info(\u0026#34;開始驗證應用程式初始化狀態\u0026#34;) val context = event.applicationContext val beanNames = context.beanDefinitionNames var totalBeans = 0 var validatedBeans = 0 var errorCount = 0 beanNames.forEach { beanName -\u0026gt; try { val bean = context.getBean(beanName) totalBeans++ val result = validateObject(bean) if (result.hasErrors()) { logger.warn(\u0026#34;Bean \u0026#39;$beanName\u0026#39; has initialization issues: ${result.getErrors()}\u0026#34;) errorCount += result.getErrorCount() } else { validatedBeans++ } } catch (e: Exception) { logger.debug(\u0026#34;Skipped validation for bean \u0026#39;$beanName\u0026#39;: ${e.message}\u0026#34;) } } logger.info(\u0026#34;初始化驗證完成: $validatedBeans/$totalBeans beans validated, $errorCount errors found\u0026#34;) } companion object { private val logger = LoggerFactory.getLogger(InitializationValidator::class.java) } } data class ValidationResult( private val errors: MutableList\u0026lt;String\u0026gt; = mutableListOf(), private val successes: MutableList\u0026lt;String\u0026gt; = mutableListOf() ) { fun addError(error: String) = errors.add(error) fun addSuccess(success: String) = successes.add(success) fun hasErrors() = errors.isNotEmpty() fun getErrors() = errors.toList() fun getSuccesses() = successes.toList() fun getErrorCount() = errors.size } 2. 監控與診斷 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @Component class LateinitMonitor { private val meterRegistry: MeterRegistry = Metrics.globalRegistry private val initializationTimer = Timer.builder(\u0026#34;lateinit.initialization.time\u0026#34;) .description(\u0026#34;Time taken to initialize lateinit properties\u0026#34;) .register(meterRegistry) fun \u0026lt;T\u0026gt; monitorInitialization( propertyName: String, initializer: () -\u0026gt; T ): T { return Timer.Sample.start(meterRegistry).use { sample -\u0026gt; try { val result = initializer() // 記錄成功的初始化 Counter.builder(\u0026#34;lateinit.initialization.success\u0026#34;) .tag(\u0026#34;property\u0026#34;, propertyName) .register(meterRegistry) .increment() sample.stop(initializationTimer.withTag(\u0026#34;property\u0026#34;, propertyName)) logger.info(\u0026#34;Successfully initialized property: $propertyName\u0026#34;) result } catch (e: Exception) { // 記錄失敗的初始化 Counter.builder(\u0026#34;lateinit.initialization.failure\u0026#34;) .tag(\u0026#34;property\u0026#34;, propertyName) .tag(\u0026#34;error\u0026#34;, e.javaClass.simpleName) .register(meterRegistry) .increment() logger.error(\u0026#34;Failed to initialize property: $propertyName\u0026#34;, e) throw e } } } @Scheduled(fixedRate = 60000) // 每分鐘檢查一次 fun reportInitializationStatus() { val successCount = meterRegistry.counter(\u0026#34;lateinit.initialization.success\u0026#34;).count() val failureCount = meterRegistry.counter(\u0026#34;lateinit.initialization.failure\u0026#34;).count() val totalCount = successCount + failureCount if (totalCount \u0026gt; 0) { val successRate = (successCount / totalCount) * 100 logger.info(\u0026#34;Lateinit initialization statistics - Success rate: ${\u0026#34;%.2f\u0026#34;.format(successRate)}% ($successCount/$totalCount)\u0026#34;) } } companion object { private val logger = LoggerFactory.getLogger(LateinitMonitor::class.java) } } 效能基準測試 初始化效能比較 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) @State(Scope.Benchmark) class LateinitPerformanceBenchmark { // 測試類別 class LateinitExample { lateinit var service: ExpensiveService fun initializeService() { service = ExpensiveService() } } class LazyExample { private val service: ExpensiveService by lazy { ExpensiveService() } fun getService(): ExpensiveService = service } class EagerExample { private val service: ExpensiveService = ExpensiveService() fun getService(): ExpensiveService = service } @Benchmark fun lateinitInitialization(): ExpensiveService { val example = LateinitExample() example.initializeService() return example.service } @Benchmark fun lazyInitialization(): ExpensiveService { val example = LazyExample() return example.getService() } @Benchmark fun eagerInitialization(): ExpensiveService { val example = EagerExample() return example.getService() } @Benchmark fun lateinitAccessAfterInit(): String { val example = LateinitExample() example.initializeService() return example.service.getData() // 訪問已初始化的屬性 } @Benchmark fun lazyAccess(): String { val example = LazyExample() example.getService() // 首次訪問，觸發初始化 return example.getService().getData() // 再次訪問，使用快取值 } } 總結 lateinit 是 Kotlin 中強大的延遲初始化機制，特別適用於：\n依賴注入場景：Spring Boot、Android 等框架的依賴注入 外部初始化：需要在物件創建後由外部代碼初始化的屬性 測試場景：Mock 物件和測試設置 條件初始化：根據運行時條件決定是否初始化的屬性 關鍵最佳實踐 總是檢查初始化狀態：使用 ::property.isInitialized 進行安全檢查 提供錯誤處理：妥善處理 UninitializedPropertyAccessException 文檔化初始化需求：清楚說明何時和如何初始化屬性 考慮線程安全：在多線程環境中使用適當的同步機制 監控和診斷：在生產環境中監控初始化狀態和效能 選擇 lateinit 還是 lazy 取決於具體需求：使用 lateinit 進行手動控制的延遲初始化，使用 lazy 進行自動的懶加載。正確使用這些機制可以顯著改善應用程式的效能和記憶體使用效率。\n","permalink":"https://xinqilin.github.io/post/backend/lateinit/","tags":["Kotlin","lateinit","lazy","Property Initialization","Android","Spring Boot","Dependency Injection","Performance","Memory Management","Best Practices","Enterprise","Thread Safety","Reflection","Testing"],"title":"Kotlin lateinit 完整實作指南：延遲初始化與企業級開發最佳實踐"},{"content":"概述 cURL（Client URL）是一個功能強大的命令行工具和函式庫，用於傳輸各種網路協定的資料。它支援 HTTP、HTTPS、FTP、SFTP、TELNET 等多種協定，是開發者進行 API 測試、網路除錯和自動化腳本的必備工具。\n核心特徵 多協定支援：HTTP/HTTPS、FTP、SFTP、SMTP、POP3 等 豐富的選項：支援各種 HTTP 方法、標頭、認證方式 跨平台：適用於 Linux、macOS、Windows 等系統 腳本友好：輸出格式化，適合自動化處理 安全性：支援 SSL/TLS、各種認證機制 基本語法 1 curl [選項] [URL] 簡單範例 1 2 3 4 5 6 7 8 9 10 11 # 基本 GET 請求 curl https://httpbin.org/get # 查看 HTTP 響應標頭 curl -I https://google.com # 下載檔案 curl -o filename.html https://example.com # 靜默模式 curl -s https://api.github.com/users/octocat 核心選項詳解 基本操作選項 1 2 3 4 5 6 7 8 9 10 11 12 13 # 輸出控制 -o, --output \u0026lt;file\u0026gt; # 將輸出寫入檔案 -O, --remote-name # 使用遠程檔案名稱儲存 -s, --silent # 靜默模式，不顯示進度 -S, --show-error # 顯示錯誤訊息 -v, --verbose # 詳細輸出模式 -w, --write-out \u0026lt;format\u0026gt; # 自訂輸出格式 # 基本範例 curl -o index.html https://example.com curl -O https://example.com/file.zip curl -s https://api.example.com/data curl -v https://httpbin.org/get HTTP 方法選項 1 2 3 4 5 6 7 8 9 10 11 # 請求方法 -X, --request \u0026lt;method\u0026gt; # 指定 HTTP 方法 -G, --get # 強制使用 GET 方法 -I, --head # 只獲取 HTTP 標頭 (HEAD 方法) # 範例 curl -X POST https://httpbin.org/post curl -X PUT https://httpbin.org/put curl -X DELETE https://httpbin.org/delete curl -X PATCH https://httpbin.org/patch curl -I https://httpbin.org/headers 資料傳送選項 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 資料傳送 -d, --data \u0026lt;data\u0026gt; # 發送 POST 資料 -d @filename # 從檔案讀取資料 -F, --form \u0026lt;name=content\u0026gt; # 表單資料 (multipart/form-data) -T, --upload-file \u0026lt;file\u0026gt; # 上傳檔案 # JSON 資料範例 curl -X POST https://httpbin.org/post \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 30}\u0026#39; # 表單資料範例 curl -X POST https://httpbin.org/post \\ -F \u0026#34;name=John\u0026#34; \\ -F \u0026#34;file=@upload.txt\u0026#34; # 從檔案讀取資料 curl -X POST https://httpbin.org/post \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d @data.json HTTP 標頭選項 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 標頭設定 -H, --header \u0026lt;header\u0026gt; # 添加自訂標頭 -A, --user-agent \u0026lt;agent\u0026gt; # 設定 User-Agent -e, --referer \u0026lt;URL\u0026gt; # 設定 Referer -i, --include # 在輸出中包含響應標頭 # 範例 curl -H \u0026#34;Authorization: Bearer token123\u0026#34; https://api.example.com curl -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;Accept: application/json\u0026#34; \\ https://api.example.com curl -A \u0026#34;MyApp/1.0\u0026#34; https://httpbin.org/user-agent curl -e \u0026#34;https://google.com\u0026#34; https://httpbin.org/headers curl -i https://httpbin.org/get HTTP 方法應用 GET 請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 基本 GET 請求 curl https://jsonplaceholder.typicode.com/posts # 帶查詢參數的 GET curl \u0026#34;https://jsonplaceholder.typicode.com/posts?userId=1\u0026#34; # 使用 -G 和 -d 構建查詢字串 curl -G -d \u0026#34;userId=1\u0026#34; -d \u0026#34;id=1\u0026#34; https://jsonplaceholder.typicode.com/posts # 帶認證的 GET curl -H \u0026#34;Authorization: Bearer your-token\u0026#34; https://api.example.com/user # 自訂 User-Agent curl -A \u0026#34;Mozilla/5.0 (Custom Agent)\u0026#34; https://httpbin.org/user-agent POST 請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # JSON 資料 POST curl -X POST https://jsonplaceholder.typicode.com/posts \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;title\u0026#34;: \u0026#34;New Post\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;This is the content\u0026#34;, \u0026#34;userId\u0026#34;: 1 }\u0026#39; # 表單資料 POST curl -X POST https://httpbin.org/post \\ -d \u0026#34;username=john\u0026#34; \\ -d \u0026#34;password=secret\u0026#34; # 檔案上傳 POST curl -X POST https://httpbin.org/post \\ -F \u0026#34;file=@document.pdf\u0026#34; \\ -F \u0026#34;description=Important document\u0026#34; # URL 編碼資料 curl -X POST https://httpbin.org/post \\ -H \u0026#34;Content-Type: application/x-www-form-urlencoded\u0026#34; \\ -d \u0026#34;name=John%20Doe\u0026amp;email=john%40example.com\u0026#34; PUT 和 PATCH 請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # PUT 更新資源 curl -X PUT https://jsonplaceholder.typicode.com/posts/1 \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;Updated Title\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Updated content\u0026#34;, \u0026#34;userId\u0026#34;: 1 }\u0026#39; # PATCH 部分更新 curl -X PATCH https://jsonplaceholder.typicode.com/posts/1 \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;title\u0026#34;: \u0026#34;Partially Updated Title\u0026#34;}\u0026#39; # 檔案替換上傳 curl -X PUT https://api.example.com/files/document.pdf \\ -T document.pdf \\ -H \u0026#34;Authorization: Bearer token\u0026#34; DELETE 請求 1 2 3 4 5 6 7 8 9 10 11 # 基本 DELETE curl -X DELETE https://jsonplaceholder.typicode.com/posts/1 # 帶認證的 DELETE curl -X DELETE https://api.example.com/users/123 \\ -H \u0026#34;Authorization: Bearer your-token\u0026#34; # 帶確認資料的 DELETE curl -X DELETE https://api.example.com/dangerous-action \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;confirm\u0026#34;: true, \u0026#34;reason\u0026#34;: \u0026#34;No longer needed\u0026#34;}\u0026#39; 認證與安全 基本認證 1 2 3 4 5 6 7 8 9 # HTTP Basic Authentication curl -u username:password https://httpbin.org/basic-auth/username/password # 從提示輸入密碼 curl -u username https://httpbin.org/basic-auth/username/password # 使用 Base64 編碼 curl -H \u0026#34;Authorization: Basic $(echo -n username:password | base64)\u0026#34; \\ https://httpbin.org/basic-auth/username/password Bearer Token 認證 1 2 3 4 5 6 7 8 9 # JWT Token curl -H \u0026#34;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\u0026#34; \\ https://api.example.com/protected # API Key in Header curl -H \u0026#34;X-API-Key: your-api-key\u0026#34; https://api.example.com/data # API Key in Query curl \u0026#34;https://api.example.com/data?api_key=your-api-key\u0026#34; OAuth 2.0 1 2 3 4 5 6 7 8 9 10 # 獲取存取令牌 curl -X POST https://oauth.example.com/token \\ -H \u0026#34;Content-Type: application/x-www-form-urlencoded\u0026#34; \\ -d \u0026#34;grant_type=client_credentials\u0026#34; \\ -d \u0026#34;client_id=your-client-id\u0026#34; \\ -d \u0026#34;client_secret=your-client-secret\u0026#34; # 使用存取令牌 curl -H \u0026#34;Authorization: Bearer access-token\u0026#34; \\ https://api.example.com/protected-resource SSL/TLS 選項 1 2 3 4 5 6 7 8 9 10 # SSL 相關選項 -k, --insecure # 允許不安全的 SSL 連接 --cert \u0026lt;certificate\u0026gt; # 客戶端證書 --key \u0026lt;private-key\u0026gt; # 私鑰檔案 --cacert \u0026lt;CA-certificate\u0026gt; # CA 證書檔案 # 範例 curl -k https://self-signed.example.com curl --cert client.crt --key client.key https://secure.example.com curl --cacert ca-bundle.crt https://secure.example.com Cookie 處理 Cookie 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 發送 Cookie curl -b \u0026#34;session=abc123; user=john\u0026#34; https://httpbin.org/cookies # 從檔案讀取 Cookie curl -b cookies.txt https://httpbin.org/cookies # 儲存 Cookie 到檔案 curl -c cookies.txt https://httpbin.org/cookies/set/session/abc123 # 同時讀取和儲存 Cookie curl -b cookies.txt -c cookies.txt https://example.com/login # Cookie Jar 格式 curl -b cookie-jar.txt -c cookie-jar.txt https://example.com 會話管理 1 2 3 4 5 6 7 8 9 # 登入並保持會話 curl -c session.txt -d \u0026#34;username=john\u0026amp;password=secret\u0026#34; \\ https://example.com/login # 使用會話訪問受保護頁面 curl -b session.txt https://example.com/dashboard # 登出並清除會話 curl -b session.txt -c /dev/null https://example.com/logout 檔案傳輸 檔案下載 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 基本下載 curl -O https://example.com/file.zip # 自訂檔案名 curl -o myfile.zip https://example.com/file.zip # 斷點續傳 curl -C - -O https://example.com/largefile.zip # 限制下載速度 curl --limit-rate 100k -O https://example.com/file.zip # 下載多個檔案 curl -O https://example.com/file1.zip -O https://example.com/file2.zip # 使用範圍下載 curl -r 0-1023 https://example.com/file.txt # 下載前 1024 位元組 檔案上傳 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # FTP 上傳 curl -T localfile.txt ftp://ftp.example.com/remote/ # HTTP PUT 上傳 curl -T document.pdf https://api.example.com/upload # 表單檔案上傳 curl -F \u0026#34;file=@document.pdf\u0026#34; -F \u0026#34;title=My Document\u0026#34; \\ https://example.com/upload # 多檔案上傳 curl -F \u0026#34;file1=@doc1.pdf\u0026#34; -F \u0026#34;file2=@doc2.pdf\u0026#34; \\ https://example.com/upload # 帶進度條的上傳 curl -# -T largefile.zip https://api.example.com/upload 進階功能 輸出格式化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 自訂輸出格式 curl -w \u0026#34;Status: %{http_code}\\nTime: %{time_total}s\\nSize: %{size_download} bytes\\n\u0026#34; \\ -o /dev/null -s https://example.com # 常用格式變數 %{http_code} # HTTP 狀態碼 %{time_total} # 總耗時 %{time_connect} # 連接時間 %{time_starttransfer} # 開始傳輸時間 %{size_download} # 下載大小 %{size_upload} # 上傳大小 %{speed_download} # 下載速度 %{speed_upload} # 上傳速度 # 效能測試範例 curl -w \u0026#34;@curl-format.txt\u0026#34; -o /dev/null -s https://example.com 建立 curl-format.txt 檔案：\n1 2 3 4 5 6 7 8 time_namelookup: %{time_namelookup}s\\n time_connect: %{time_connect}s\\n time_appconnect: %{time_appconnect}s\\n time_pretransfer: %{time_pretransfer}s\\n time_redirect: %{time_redirect}s\\n time_starttransfer: %{time_starttransfer}s\\n ----------\\n time_total: %{time_total}s\\n 重定向處理 1 2 3 4 5 6 7 8 9 10 11 # 跟隨重定向 curl -L https://bit.ly/shortened-url # 限制重定向次數 curl -L --max-redirs 5 https://example.com # 顯示重定向過程 curl -L -v https://bit.ly/shortened-url # 不跟隨重定向（預設） curl https://bit.ly/shortened-url 代理設定 1 2 3 4 5 6 7 8 9 10 11 12 13 # HTTP 代理 curl --proxy http://proxy.example.com:8080 https://httpbin.org/ip # SOCKS 代理 curl --socks5 localhost:1080 https://httpbin.org/ip # 代理認證 curl --proxy-user username:password \\ --proxy http://proxy.example.com:8080 \\ https://httpbin.org/ip # 排除代理 curl --noproxy localhost,127.0.0.1 https://localhost:8080/api 並行請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 背景執行 curl https://api1.example.com \u0026amp; curl https://api2.example.com \u0026amp; curl https://api3.example.com \u0026amp; wait # 使用 xargs 並行 echo -e \u0026#34;https://api1.example.com\\nhttps://api2.example.com\u0026#34; | \\ xargs -n 1 -P 2 curl -s # 循環請求 for i in {1..5}; do curl -s \u0026#34;https://api.example.com/data/$i\u0026#34; \u0026amp; done wait API 測試實戰 REST API 測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 使用者管理 API 測試 BASE_URL=\u0026#34;https://jsonplaceholder.typicode.com\u0026#34; # 1. 獲取所有使用者 curl -s \u0026#34;$BASE_URL/users\u0026#34; | jq \u0026#39;.[0:3]\u0026#39; # 2. 獲取特定使用者 curl -s \u0026#34;$BASE_URL/users/1\u0026#34; | jq \u0026#39;.\u0026#39; # 3. 創建新使用者 curl -X POST \u0026#34;$BASE_URL/users\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;johndoe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34; }\u0026#39; | jq \u0026#39;.\u0026#39; # 4. 更新使用者 curl -X PUT \u0026#34;$BASE_URL/users/1\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Jane Doe\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;janedoe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;jane@example.com\u0026#34; }\u0026#39; | jq \u0026#39;.\u0026#39; # 5. 刪除使用者 curl -X DELETE \u0026#34;$BASE_URL/users/1\u0026#34; -w \u0026#34;Status: %{http_code}\\n\u0026#34; API 效能測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 響應時間測試 test_api_performance() { local url=\u0026#34;$1\u0026#34; local requests=\u0026#34;$2\u0026#34; echo \u0026#34;Testing $url with $requests requests...\u0026#34; for i in $(seq 1 $requests); do curl -w \u0026#34;%{time_total}\\n\u0026#34; -o /dev/null -s \u0026#34;$url\u0026#34; done | awk \u0026#39;{sum+=$1; count++} END {print \u0026#34;Average:\u0026#34;, sum/count \u0026#34;s\u0026#34;}\u0026#39; } test_api_performance \u0026#34;https://httpbin.org/delay/1\u0026#34; 5 # 並發測試 concurrent_test() { local url=\u0026#34;$1\u0026#34; local concurrent=\u0026#34;$2\u0026#34; local total=\u0026#34;$3\u0026#34; echo \u0026#34;Concurrent test: $concurrent parallel requests, $total total\u0026#34; seq 1 $total | xargs -n 1 -P $concurrent -I {} \\ curl -w \u0026#34;Request {}: %{time_total}s\\n\u0026#34; -o /dev/null -s \u0026#34;$url\u0026#34; } concurrent_test \u0026#34;https://httpbin.org/delay/1\u0026#34; 3 10 API 健康檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #!/bin/bash # api_health_check.sh check_api_health() { local name=\u0026#34;$1\u0026#34; local url=\u0026#34;$2\u0026#34; local expected_status=\u0026#34;$3\u0026#34; echo -n \u0026#34;Checking $name... \u0026#34; response=$(curl -s -w \u0026#34;HTTPSTATUS:%{http_code}\u0026#34; \u0026#34;$url\u0026#34;) http_code=$(echo \u0026#34;$response\u0026#34; | tr -d \u0026#39;\\n\u0026#39; | sed -E \u0026#39;s/.*HTTPSTATUS:([0-9]{3})$/\\1/\u0026#39;) body=$(echo \u0026#34;$response\u0026#34; | sed -E \u0026#39;s/HTTPSTATUS:[0-9]{3}$//\u0026#39;) if [ \u0026#34;$http_code\u0026#34; -eq \u0026#34;$expected_status\u0026#34; ]; then echo \u0026#34;✓ OK (HTTP $http_code)\u0026#34; return 0 else echo \u0026#34;✗ FAIL (HTTP $http_code)\u0026#34; echo \u0026#34;Response: $body\u0026#34; return 1 fi } # 健康檢查 check_api_health \u0026#34;Main API\u0026#34; \u0026#34;https://api.example.com/health\u0026#34; 200 check_api_health \u0026#34;User Service\u0026#34; \u0026#34;https://api.example.com/users/1\u0026#34; 200 check_api_health \u0026#34;Auth Service\u0026#34; \u0026#34;https://api.example.com/auth/status\u0026#34; 200 除錯與監控 詳細除錯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 詳細模式 curl -v https://httpbin.org/get # 追蹤 ASCII 格式 curl --trace-ascii debug.txt https://httpbin.org/get # 追蹤二進位格式 curl --trace debug.bin https://httpbin.org/get # 只顯示標頭 curl -I https://httpbin.org/get # 顯示請求和響應標頭 curl -D headers.txt https://httpbin.org/get 網路診斷 1 2 3 4 5 6 7 8 9 10 11 12 13 # DNS 解析時間 curl -w \u0026#34;DNS lookup: %{time_namelookup}s\\n\u0026#34; -o /dev/null -s https://example.com # 連接時間分析 curl -w \u0026#34;Connect: %{time_connect}s, Start transfer: %{time_starttransfer}s, Total: %{time_total}s\\n\u0026#34; \\ -o /dev/null -s https://example.com # 檢查 SSL 證書 curl -vI https://example.com 2\u0026gt;\u0026amp;1 | grep -E \u0026#34;(SSL|TLS|certificate)\u0026#34; # 測試不同 HTTP 版本 curl --http1.1 -I https://example.com curl --http2 -I https://example.com 錯誤處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 基本錯誤處理 if curl -s --fail https://api.example.com/data; then echo \u0026#34;Request successful\u0026#34; else echo \u0026#34;Request failed with exit code $?\u0026#34; fi # 詳細錯誤資訊 curl -s -w \u0026#34;Status: %{http_code}, Exit: %{exitcode}\\n\u0026#34; \\ https://httpbin.org/status/404 # 重試機制 retry_curl() { local url=\u0026#34;$1\u0026#34; local max_attempts=3 local attempt=1 while [ $attempt -le $max_attempts ]; do echo \u0026#34;Attempt $attempt of $max_attempts...\u0026#34; if curl -s --fail \u0026#34;$url\u0026#34;; then echo \u0026#34;Success on attempt $attempt\u0026#34; return 0 fi echo \u0026#34;Failed attempt $attempt\u0026#34; ((attempt++)) sleep 2 done echo \u0026#34;All attempts failed\u0026#34; return 1 } retry_curl \u0026#34;https://unstable-api.example.com\u0026#34; 實用腳本範例 1. API 批次測試腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #!/bin/bash # api_batch_test.sh API_BASE=\u0026#34;https://jsonplaceholder.typicode.com\u0026#34; AUTH_TOKEN=\u0026#34;your-auth-token\u0026#34; # 測試配置 declare -A TESTS=( [\u0026#34;GET /users\u0026#34;]=\u0026#34;$API_BASE/users\u0026#34; [\u0026#34;GET /posts\u0026#34;]=\u0026#34;$API_BASE/posts\u0026#34; [\u0026#34;GET /user/1\u0026#34;]=\u0026#34;$API_BASE/users/1\u0026#34; [\u0026#34;POST /posts\u0026#34;]=\u0026#34;$API_BASE/posts\u0026#34; ) # 執行測試 run_tests() { echo \u0026#34;Starting API batch tests...\u0026#34; echo \u0026#34;==========================\u0026#34; local passed=0 local failed=0 for test_name in \u0026#34;${!TESTS[@]}\u0026#34;; do local url=\u0026#34;${TESTS[$test_name]}\u0026#34; echo -n \u0026#34;Testing $test_name... \u0026#34; if [[ \u0026#34;$test_name\u0026#34; == \u0026#34;POST\u0026#34;* ]]; then # POST 測試 response=$(curl -s -w \u0026#34;HTTPSTATUS:%{http_code}\u0026#34; \\ -X POST \u0026#34;$url\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;Authorization: Bearer $AUTH_TOKEN\u0026#34; \\ -d \u0026#39;{\u0026#34;title\u0026#34;:\u0026#34;Test\u0026#34;,\u0026#34;body\u0026#34;:\u0026#34;Test content\u0026#34;,\u0026#34;userId\u0026#34;:1}\u0026#39;) else # GET 測試 response=$(curl -s -w \u0026#34;HTTPSTATUS:%{http_code}\u0026#34; \\ -H \u0026#34;Authorization: Bearer $AUTH_TOKEN\u0026#34; \\ \u0026#34;$url\u0026#34;) fi http_code=$(echo \u0026#34;$response\u0026#34; | tr -d \u0026#39;\\n\u0026#39; | sed -E \u0026#39;s/.*HTTPSTATUS:([0-9]{3})$/\\1/\u0026#39;) if [[ \u0026#34;$http_code\u0026#34; -ge 200 \u0026amp;\u0026amp; \u0026#34;$http_code\u0026#34; -lt 300 ]]; then echo \u0026#34;✓ PASS (HTTP $http_code)\u0026#34; ((passed++)) else echo \u0026#34;✗ FAIL (HTTP $http_code)\u0026#34; ((failed++)) fi done echo \u0026#34;==========================\u0026#34; echo \u0026#34;Results: $passed passed, $failed failed\u0026#34; } run_tests 2. 檔案同步腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #!/bin/bash # file_sync.sh LOCAL_DIR=\u0026#34;./local_files\u0026#34; REMOTE_BASE=\u0026#34;https://api.example.com/files\u0026#34; AUTH_TOKEN=\u0026#34;your-token\u0026#34; sync_files() { echo \u0026#34;Starting file synchronization...\u0026#34; # 獲取遠程檔案列表 remote_files=$(curl -s -H \u0026#34;Authorization: Bearer $AUTH_TOKEN\u0026#34; \\ \u0026#34;$REMOTE_BASE\u0026#34; | jq -r \u0026#39;.[].filename\u0026#39;) for file in $remote_files; do local_file=\u0026#34;$LOCAL_DIR/$file\u0026#34; remote_url=\u0026#34;$REMOTE_BASE/$file\u0026#34; echo -n \u0026#34;Checking $file... \u0026#34; if [ -f \u0026#34;$local_file\u0026#34; ]; then # 比較檔案雜湊 local_hash=$(sha256sum \u0026#34;$local_file\u0026#34; | cut -d\u0026#39; \u0026#39; -f1) remote_hash=$(curl -s -I -H \u0026#34;Authorization: Bearer $AUTH_TOKEN\u0026#34; \\ \u0026#34;$remote_url\u0026#34; | grep -i \u0026#34;x-file-hash\u0026#34; | cut -d\u0026#39; \u0026#39; -f2 | tr -d \u0026#39;\\r\u0026#39;) if [ \u0026#34;$local_hash\u0026#34; = \u0026#34;$remote_hash\u0026#34; ]; then echo \u0026#34;✓ Up to date\u0026#34; continue fi fi # 下載檔案 echo \u0026#34;⬇ Downloading...\u0026#34; curl -s -H \u0026#34;Authorization: Bearer $AUTH_TOKEN\u0026#34; \\ -o \u0026#34;$local_file\u0026#34; \u0026#34;$remote_url\u0026#34; if [ $? -eq 0 ]; then echo \u0026#34;✓ Downloaded successfully\u0026#34; else echo \u0026#34;✗ Download failed\u0026#34; fi done } mkdir -p \u0026#34;$LOCAL_DIR\u0026#34; sync_files 3. 網站監控腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #!/bin/bash # website_monitor.sh SITES=( \u0026#34;https://example.com\u0026#34; \u0026#34;https://api.example.com/health\u0026#34; \u0026#34;https://cdn.example.com\u0026#34; ) TIMEOUT=10 LOG_FILE=\u0026#34;/var/log/website_monitor.log\u0026#34; log_message() { echo \u0026#34;$(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;) - $1\u0026#34; | tee -a \u0026#34;$LOG_FILE\u0026#34; } check_site() { local url=\u0026#34;$1\u0026#34; local name=$(echo \u0026#34;$url\u0026#34; | sed \u0026#39;s|https\\?://||\u0026#39; | sed \u0026#39;s|/.*||\u0026#39;) response=$(curl -s -w \u0026#34;HTTPSTATUS:%{http_code};TIME:%{time_total}\u0026#34; \\ --max-time \u0026#34;$TIMEOUT\u0026#34; \u0026#34;$url\u0026#34;) if [ $? -eq 0 ]; then http_code=$(echo \u0026#34;$response\u0026#34; | grep -o \u0026#34;HTTPSTATUS:[0-9]*\u0026#34; | cut -d: -f2) time_total=$(echo \u0026#34;$response\u0026#34; | grep -o \u0026#34;TIME:[0-9.]*\u0026#34; | cut -d: -f2) if [ \u0026#34;$http_code\u0026#34; = \u0026#34;200\u0026#34; ]; then log_message \u0026#34;✓ $name - OK (${time_total}s)\u0026#34; else log_message \u0026#34;⚠ $name - HTTP $http_code (${time_total}s)\u0026#34; fi else log_message \u0026#34;✗ $name - TIMEOUT or ERROR\u0026#34; fi } log_message \u0026#34;Starting website monitoring...\u0026#34; for site in \u0026#34;${SITES[@]}\u0026#34;; do check_site \u0026#34;$site\u0026#34; done log_message \u0026#34;Monitoring completed\u0026#34; 效能最佳化 連接重用 1 2 3 4 5 6 7 8 9 10 # HTTP/1.1 Keep-Alive curl --keepalive-time 30 https://api.example.com/endpoint1 curl --keepalive-time 30 https://api.example.com/endpoint2 # HTTP/2 多路復用 curl --http2 https://example.com/resource1 curl --http2 https://example.com/resource2 # 連接池配置 curl --max-time 30 --connect-timeout 10 https://api.example.com 快取與壓縮 1 2 3 4 5 6 7 8 9 10 # 啟用壓縮 curl -H \u0026#34;Accept-Encoding: gzip, deflate\u0026#34; https://example.com # 條件請求 curl -H \u0026#34;If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT\u0026#34; \\ https://example.com/data # ETag 支援 curl -H \u0026#34;If-None-Match: \\\u0026#34;33a64df551425fcc55e4d42a148795d9f25f89d4\\\u0026#34;\u0026#34; \\ https://example.com/resource 批次優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 並行下載 urls=( \u0026#34;https://api.example.com/data1\u0026#34; \u0026#34;https://api.example.com/data2\u0026#34; \u0026#34;https://api.example.com/data3\u0026#34; ) for url in \u0026#34;${urls[@]}\u0026#34;; do curl -s \u0026#34;$url\u0026#34; \u0026gt; \u0026#34;$(basename \u0026#34;$url\u0026#34;).json\u0026#34; \u0026amp; done wait # 限制並行數 printf \u0026#34;%s\\n\u0026#34; \u0026#34;${urls[@]}\u0026#34; | xargs -n 1 -P 3 -I {} \\ sh -c \u0026#39;curl -s \u0026#34;{}\u0026#34; \u0026gt; \u0026#34;$(basename \u0026#34;{}\u0026#34;).json\u0026#34;\u0026#39; 常見問題與解決方案 SSL/TLS 問題 1 2 3 4 5 6 7 8 9 # 證書驗證問題 curl -k https://self-signed.example.com # 跳過驗證（不推薦） curl --cacert /path/to/ca-bundle.crt https://example.com # 指定 CA # 檢查證書資訊 curl -vI https://example.com 2\u0026gt;\u0026amp;1 | grep -A 10 \u0026#34;Server certificate\u0026#34; # 測試 SSL 配置 curl --tlsv1.2 --ciphers HIGH https://example.com 編碼問題 1 2 3 4 5 6 7 8 # UTF-8 編碼 curl -H \u0026#34;Accept-Charset: utf-8\u0026#34; https://example.com # URL 編碼 curl \u0026#34;https://example.com/search?q=$(echo \u0026#39;中文查詢\u0026#39; | curl -Gso /dev/null -w %{url_effective} --data-urlencode @- | cut -c3-)\u0026#34; # 處理特殊字元 curl -G -d \u0026#34;query=hello world\u0026#34; https://example.com/search 超時與重試 1 2 3 4 5 6 7 8 9 # 超時設定 curl --connect-timeout 10 --max-time 30 https://slow-api.example.com # 自動重試 curl --retry 3 --retry-delay 5 https://unstable-api.example.com # 指數退避 curl --retry 3 --retry-delay 1 --retry-max-time 60 \\ https://api.example.com 總結 核心優勢 多功能性：支援多種協定和操作方式 靈活性：豐富的選項和配置能力 可程式性：適合自動化和腳本處理 跨平台：在各種系統上表現一致 效能：高效的網路通訊和傳輸 最佳實踐 安全第一：正確處理認證和 SSL 驗證 錯誤處理：實作適當的重試和錯誤恢復機制 效能優化：使用連接重用和並行處理 日誌記錄：保留詳細的請求和響應日誌 測試自動化：將 API 測試整合到 CI/CD 流程 常用模式記憶 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # API 測試基本模式 curl -X POST https://api.example.com/resource \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;Authorization: Bearer token\u0026#34; \\ -d \u0026#39;{\u0026#34;key\u0026#34;: \u0026#34;value\u0026#34;}\u0026#39; # 檔案操作模式 curl -O https://example.com/file.zip # 下載 curl -T file.txt https://api.example.com/upload # 上傳 # 除錯模式 curl -v -I https://example.com # 詳細標頭 curl -w \u0026#34;%{http_code}\\n\u0026#34; https://example.com # 狀態碼 # 效能測試模式 curl -w \u0026#34;@curl-format.txt\u0026#34; -o /dev/null -s https://example.com cURL 是現代開發者工具箱中不可或缺的利器，掌握其核心功能和進階技巧，能夠大幅提升 API 開發、測試和維護的效率。記住：實務中最重要的是理解 HTTP 協定基礎，並善用 cURL 的豐富選項來解決實際問題。\n參考資料 cURL 官方文檔 cURL Tutorial HTTP/1.1 規範 REST API 設計指南 JSON API 規範 ","permalink":"https://xinqilin.github.io/post/tools/curl/","tags":["cURL","HTTP","API","REST","Web Development","Command Line","Network"],"title":"cURL 完整指南：HTTP 客戶端工具與 API 測試利器"},{"content":"概述 在現代應用程式開發中，一個專案往往由多個服務組成，例如前端、後端 API、資料庫、快取等。這些服務各自運行在不同的容器中，而 Docker Compose 正是為了解決這種多容器應用程式的定義與管理而生。\nDocker Compose 允許您使用一個 YAML 檔案 (docker-compose.yml) 來定義應用程式的所有服務、網路和儲存卷，然後透過單一指令啟動、停止或管理整個應用程式堆疊。這極大地簡化了開發、測試和部署的流程。\n常用 Docker Compose 指令 以下是 Docker Compose 的一些常用指令，用於管理您的多容器應用程式：\n指令 說明 範例 docker-compose --version 顯示 Docker Compose 的版本資訊。 docker-compose --version docker-compose -h 顯示 Docker Compose 的幫助訊息。 docker-compose -h docker-compose up 啟動並建立所有服務的容器。如果容器已存在，則會重新建立。 docker-compose up docker-compose up -d 在背景模式 (detached mode) 啟動並建立所有服務的容器。 docker-compose up -d docker-compose down 停止並移除所有服務的容器、網路和預設儲存卷。 docker-compose down docker-compose exec \u0026lt;service_name\u0026gt; \u0026lt;command\u0026gt; 在指定服務的容器中執行指令。 docker-compose exec microService /bin/bash docker-compose ps 列出所有服務的容器狀態。 docker-compose ps docker-compose top 顯示服務容器的運行進程。 docker-compose top docker-compose logs \u0026lt;service_name\u0026gt; 顯示指定服務容器的日誌輸出。 docker-compose logs microService docker-compose config 驗證 docker-compose.yml 檔案的語法是否正確，並顯示解析後的配置。 docker-compose config docker-compose config -q 靜默模式驗證配置，只在有錯誤時輸出訊息。 docker-compose config -q docker-compose restart \u0026lt;service_name\u0026gt; 重新啟動指定服務的容器。若未指定服務，則重新啟動所有服務。 docker-compose restart microService docker-compose start \u0026lt;service_name\u0026gt; 啟動指定服務的容器。若未指定服務，則啟動所有已停止的服務。 docker-compose start microService docker-compose stop \u0026lt;service_name\u0026gt; 停止指定服務的容器。若未指定服務，則停止所有運行中的服務。 docker-compose stop microService 常用組合指令 1 2 # 驗證配置後，停止並重新啟動所有服務 docker-compose config -q \u0026amp;\u0026amp; docker-compose down \u0026amp;\u0026amp; docker-compose up -d docker-compose.yml 檔案結構詳解 docker-compose.yml 是 Docker Compose 的核心配置檔案，它使用 YAML 語法來定義應用程式的服務。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 # 指定 Docker Compose 檔案格式的版本，建議使用最新穩定版 (目前為 \u0026#39;3.x\u0026#39;) version: \u0026#34;3.8\u0026#34; # 建議使用 3.8 或更高版本，以支援更多功能 # 定義應用程式中的所有服務 (即容器) services: # 自訂服務名稱，例如 \u0026#39;microService\u0026#39;、\u0026#39;web\u0026#39;、\u0026#39;db\u0026#39; 等 microService: # 指定服務所使用的 Docker 映像檔 image: my_image:1.0 # 定義容器的名稱，方便識別和管理 container_name: ms_01 # 埠映射：將主機埠映射到容器埠 (HOST_PORT:CONTAINER_PORT) ports: - \u0026#34;8081:8080\u0026#34; # 將主機的 8081 埠映射到容器的 8080 埠 # 儲存卷映射：將主機路徑映射到容器路徑 (HOST_PATH:CONTAINER_PATH) volumes: - /Users/bill/microService:/app # 將主機的 /Users/bill/microService 目錄映射到容器的 /app 目錄 # 指定服務所連接的網路 networks: - my_network # 連接到名為 \u0026#39;my_network\u0026#39; 的網路 # 定義服務的啟動順序依賴關係 # 注意：depends_on 只保證服務啟動順序，不保證服務內部應用程式完全就緒 # 可搭配 https://github.com/vishnubob/wait-for-it 或其他健康檢查機制確保服務可用 depends_on: - redis # microService 服務會在 redis 服務啟動後才啟動 - mysql # microService 服務會在 mysql 服務啟動後才啟動 # 範例：等同於 `docker run -d -p 8081:8080 -v /Users/bill/microService:/app --network my_network` redis: image: redis:6.0.8 # 使用 Redis 6.0.8 映像檔 ports: - \u0026#34;6379:6379\u0026#34; # 映射 Redis 預設埠 volumes: # 映射 Redis 配置檔，讓容器使用自訂配置 - /app/redis/redis.conf:/etc/redis/redis.conf # 映射 Redis 資料目錄，實現資料持久化 - /app/redis/data:/data networks: - my_network # 覆寫容器的預設啟動指令，讓 Redis 使用指定的配置檔啟動 command: redis-server /etc/redis/redis.conf mysql: image: mysql:5.7 # 使用 MySQL 5.7 映像檔 # 設定 MySQL 容器的環境變數 environment: MYSQL_ROOT_PASSWORD: \u0026#39;123456\u0026#39; # 設定 root 使用者的密碼 MYSQL_ALLOW_EMPTY_PASSWORD: \u0026#39;no\u0026#39; # 不允許 root 密碼為空 MYSQL_DATABASE: \u0026#39;my_test_db\u0026#39; # 建立一個名為 \u0026#39;my_test_db\u0026#39; 的資料庫 MYSQL_USER: \u0026#39;bill\u0026#39; # 建立一個名為 \u0026#39;bill\u0026#39; 的使用者 MYSQL_PASSWORD: \u0026#39;user_pwd\u0026#39; # 設定 \u0026#39;bill\u0026#39; 使用者的密碼 ports: - \u0026#34;3306:3306\u0026#34; # 映射 MySQL 預設埠 volumes: # 映射 MySQL 資料目錄，實現資料持久化 - /app/mysql/db:/var/lib/mysql # 映射 MySQL 配置檔 - /app/mysql/conf/my.cnf:/etc/my.cnf # 映射初始化腳本目錄，容器啟動時會執行此目錄下的 .sh 或 .sql 腳本 - /app/mysql/init:/docker-entrypoint-initdb.d networks: - my_network # 解決 MySQL 8.0 之後預設認證插件導致外部客戶端無法連接的問題 command: --default-authentication-plugin=mysql_native_password # 定義應用程式使用的網路 networks: my_network: # 自訂網路名稱，所有服務將在此網路中互相通訊 # 定義應用程式使用的儲存卷 (可選，如果服務中直接使用匿名卷或綁定掛載則不需要在此定義) # volumes: # my_data: # 自訂儲存卷名稱 ","permalink":"https://xinqilin.github.io/post/devops/docker-compose/","tags":["Docker","Docker Compose","DevOps","Containerization","Microservices","YAML"],"title":"Docker Compose 完整指南：多容器應用程式的定義與執行"},{"content":"概述 Docker 網路是容器化應用程式的基石，它決定了容器如何與外部世界通訊，以及容器之間如何互相連接。理解 Docker 的網路模式對於建構穩健、可擴展的容器化應用程式至關重要。本文將詳細介紹 Docker 提供的幾種主要網路模式及其應用場景。\nDocker 網路模式 Docker 提供了多種網路驅動程式，每種驅動程式都提供不同的網路功能。最常用的包括 bridge、host、none 和 container。\n1. Bridge (橋接模式) 說明：這是 Docker 的預設網路模式。當您不指定網路模式時，Docker 會自動為容器分配一個 IP 位址，並將其連接到一個名為 docker0 的虛擬橋接器上。每個容器都會獲得一個獨立的網路堆疊。 工作原理： Docker 會在主機上建立一個名為 docker0 的虛擬橋接器。 每個容器都會建立一對虛擬乙太網卡 (veth pair)，其中一端連接到容器內的 eth0，另一端連接到 docker0 橋接器。 容器可以透過 docker0 橋接器與同一橋接器上的其他容器通訊，也可以透過主機的網路介面與外部網路通訊。 優點：提供良好的隔離性，容器間預設不直接暴露埠。 缺點：容器需要透過埠映射才能從外部訪問。 2. Host (主機模式) 說明：在主機模式下，容器不會有自己的獨立網路堆疊，而是直接使用主機的網路堆疊。這意味著容器會直接使用主機的 IP 位址和埠。 工作原理：容器內的應用程式會直接綁定到主機的網路介面和埠上。 優點：網路效能最佳，因為沒有額外的網路層。 缺點： 容器不再與主機隔離，容器內應用程式使用的埠不能與主機上已佔用的埠衝突。 安全性較低，因為容器直接暴露在主機網路中。 使用方式：--network host 3. None (無網路模式) 說明：在無網路模式下，容器會建立一個獨立的網路堆疊，但不會對其進行任何網路配置。容器將沒有網路介面，無法與外部通訊。 工作原理：容器只包含一個 lo (loopback) 介面。 優點：適用於只需要計算資源而不需要網路連接的特殊場景，或者需要手動配置網路的進階情況。 缺點：容器無法進行任何網路通訊，除非手動配置。 使用方式：--network none 4. Container (容器模式) 說明：在容器模式下，新建立的容器不會有自己的網路堆疊，而是與另一個已存在的容器共享其網路堆疊。這意味著兩個容器會共享同一個 IP 位址和埠空間。 工作原理：兩個容器共享同一個網路命名空間。 優點：適用於需要緊密協同工作的應用程式，例如主應用程式容器和一個代理或日誌收集容器。 缺點：兩個容器會共享埠，可能導致埠衝突。 使用方式：--network container:\u0026lt;name_or_id\u0026gt; 常用 Docker 網路指令 指令 說明 範例 docker network ls 列出所有 Docker 網路。 docker network ls docker network prune 刪除所有未使用的網路。 docker network prune docker network inspect \u0026lt;network_name_or_id\u0026gt; 顯示指定網路的詳細資訊，包括連接到該網路的容器。 docker network inspect bridge docker inspect \u0026lt;container_id\u0026gt; 顯示指定容器的詳細資訊，包括其網路配置。 docker inspect \u0026lt;container_id\u0026gt; 自訂網路 (User-defined Bridge Networks) 雖然 Docker 預設的 bridge 網路 (docker0) 已經足夠應付許多情況，但強烈建議您建立自訂橋接網路 (User-defined Bridge Networks)。自訂網路提供了更好的隔離性、內建的 DNS 解析和更靈活的配置。\n優點 內建 DNS 解析：在自訂網路中，容器可以透過服務名稱（而不是 IP 位址）互相通訊，因為 Docker 會為自訂網路提供內建的 DNS 解析服務。這使得容器的 IP 位址變化不再是問題。 更好的隔離性：自訂網路中的容器預設只能與同一網路中的其他容器通訊，提供了更好的安全性。 可移植性：在 Docker Compose 中，自訂網路是預設行為，這使得多容器應用程式的定義更加簡潔和可移植。 建立自訂網路 1 2 # 建立一個名為 \u0026#39;my_network\u0026#39; 的自訂橋接網路 docker network create my_network 將容器連接到自訂網路 在啟動容器時，使用 --network 參數指定自訂網路名稱：\n1 2 3 4 5 # 啟動第一個 Tomcat 容器，連接到 \u0026#39;my_network\u0026#39; docker run -d -p 8080:8080 --network my_network --name tomcat_1 tomcat # 啟動第二個 Tomcat 容器，連接到 \u0026#39;my_network\u0026#39; docker run -d -p 8081:8080 --network my_network --name tomcat_2 tomcat 現在，tomcat_1 和 tomcat_2 容器都在 my_network 中，它們可以透過彼此的容器名稱（tomcat_1 和 tomcat_2）互相通訊，例如：\n1 2 3 4 5 # 進入 tomcat_1 容器內部 docker exec -it tomcat_1 bash # 在 tomcat_1 容器內部 ping tomcat_2 ping tomcat_2 容器模式的限制與自訂網路的優勢 您原先的範例中，嘗試讓兩個 Tomcat 容器共享網路，但由於埠衝突而失敗：\n1 2 3 4 # 坑 （下面起不起來因兩台 tomcat 都用 8080 映射出去） # 借用 tomcat_1 網路 docker run -d -p 8080:8080 --name tomcat_1 tomcat docker run -d -p 8081:8080 --network container:tomcat_1 --name tomcat_2 tomcat # 會失敗，因為 tomcat_2 試圖使用 tomcat_1 的 8080 埠 這是因為在 container 模式下，兩個容器共享同一個網路命名空間，包括埠空間。如果 tomcat_1 已經佔用了 8080 埠，那麼 tomcat_2 就無法再使用這個埠。\n相比之下，使用自訂網路則沒有這個問題。每個容器在自訂網路中仍然擁有自己的獨立網路堆疊和埠空間，只是它們可以透過網路名稱互相發現和通訊。這使得自訂網路成為多容器應用程式之間通訊的更優雅和健壯的解決方案。\n透過理解和善用 Docker 網路模式，您可以更有效地設計和管理您的容器化應用程式。\n","permalink":"https://xinqilin.github.io/post/devops/docker-network/","tags":["Docker","Network","DevOps","Containerization","Bridge","Host"],"title":"Docker 網路模式詳解：容器間通訊與外部連接"},{"content":"概述 在自動化測試和網路爬蟲等場景中，經常需要將應用程式與瀏覽器自動化工具 (如 Selenium) 打包到同一個 Docker 容器中。此外，為了支援不同的運行環境（例如 ARM64 或 x86_64 架構，以及 Firefox 或 Chrome 瀏覽器），我們需要一個靈活的建構流程。\n本文將深入解析一個多階段 Dockerfile，它展示了如何：\n建構一個包含 Node.js 應用程式的基礎映像檔。 利用這個基礎映像檔，為不同的 CPU 架構和瀏覽器環境建立多個最終的 Selenium 應用程式映像檔。 透過一個通用的 entrypoint.sh 腳本，在容器啟動時自動判斷環境並執行對應的測試。 Dockerfile 詳解 這個 Dockerfile 採用了多階段建構 (Multi-stage Builds) 的方式，以確保最終映像檔的輕量化和模組化。\n第一階段：應用程式建構 (build 階段) 這個階段負責準備 Node.js 環境並打包應用程式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 FROM ubuntu:22.04 AS build # 設定環境變數 ENV NVM_DIR /opt/nvm # NVM (Node Version Manager) 的安裝目錄 ENV NODE_VERSION v16.13.2 # 指定要安裝的 Node.js 版本 ENV APP_DIR /app # 應用程式的工作目錄 # 建立必要的目錄 RUN [ -d $APP_DIR ] || mkdir -p $APP_DIR RUN [ -d $NVM_DIR ] || mkdir -p $NVM_DIR # 更新套件列表並安裝 curl (用於下載 NVM) RUN apt-get update \u0026amp;\u0026amp; apt-get install curl -y # 安裝 NVM 和指定版本的 Node.js # 從 GitHub 下載 NVM 安裝腳本 RUN curl -o $NVM_DIR/install.sh https://raw.githubusercontent.com/nvm-sh/nvm/master/install.sh # 執行 NVM 安裝腳本 RUN /bin/bash $NVM_DIR/install.sh # 設定 PATH 環境變數，將 Node.js 可執行檔加入路徑 ENV PATH $NVM_DIR/versions/node/$NODE_VERSION/bin:$PATH # 複製應用程式檔案 COPY test /app/test # 複製 \u0026#39;test\u0026#39; 目錄 COPY *.js /app/ # 複製所有 .js 檔案 COPY *.json /app/ # 複製所有 .json 檔案 COPY *.sh /app/ # 複製所有 .sh 腳本 RUN chmod 0755 /app/*.sh # 為腳本添加執行權限 # 設定工作目錄並安裝 Node.js 依賴 WORKDIR $APP_DIR RUN npm install 第二階段：Selenium 瀏覽器映像檔建構 (多個 FROM 階段) 這個 Dockerfile 為不同的 CPU 架構 (ARM64, x86_64) 和瀏覽器 (Firefox, Chrome) 定義了多個最終映像檔。每個階段都從一個預先建構好的 Selenium 映像檔開始，並將第一階段建構好的應用程式複製進來。\nARM64 架構 - Firefox 瀏覽器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 FROM seleniarm/standalone-firefox:latest AS arm64-firefox # 設定終端機和語言環境變數 ENV TERM=\u0026#34;xterm-color\u0026#34; ENV LANG=\u0026#39;en_US.UTF-8\u0026#39; ENV LANGUAGE=\u0026#39;en_US.UTF-8\u0026#39; # 重新設定 NVM 和應用程式目錄 (因為是新的 FROM 階段) ENV NVM_DIR /opt/nvm ENV NODE_VERSION v16.13.2 ENV APP_DIR /app # 建立目錄並調整權限 (使用 sudo 和 chown 是因為基礎映像檔可能以非 root 用戶運行) RUN [ -d $APP_DIR ] || (sudo mkdir -p $APP_DIR \u0026amp;\u0026amp; sudo chown `whoami`:`id -g -n` $APP_DIR) RUN [ -d $NVM_DIR ] || (sudo mkdir -p $NVM_DIR \u0026amp;\u0026amp; sudo chown `whoami`:`id -g -n` $NVM_DIR) # 從 \u0026#39;build\u0026#39; 階段複製 NVM 安裝腳本並執行 COPY --from=build $NVM_DIR/install.sh $NVM_DIR RUN /bin/bash $NVM_DIR/install.sh # 設定 PATH 環境變數 ENV PATH $NVM_DIR/versions/node/$NODE_VERSION/bin:$PATH # 從 \u0026#39;build\u0026#39; 階段複製應用程式檔案 COPY --from=build $APP_DIR $APP_DIR # 調整應用程式目錄的擁有者為 \u0026#39;seluser\u0026#39; (Selenium 映像檔的預設用戶) RUN chown seluser:seluser $APP_DIR # 設定工作目錄 WORKDIR $APP_DIR # 定義容器啟動時執行的命令 (將由 entrypoint.sh 腳本處理) CMD [ \u0026#34;/app/entrypoint.sh\u0026#34; ] ARM64 架構 - Chrome 瀏覽器 1 2 3 FROM seleniarm/standalone-chromium:latest AS arm64-chrome # ... (與 arm64-firefox 階段類似的環境變數、目錄建立、NVM 安裝、應用程式複製和權限調整) ... CMD [ \u0026#34;/app/entrypoint.sh\u0026#34; ] x86_64 架構 - Firefox 瀏覽器 1 2 3 FROM selenium/standalone-firefox:latest AS x86_64-firefox # ... (與 arm64-firefox 階段類似的環境變數、目錄建立、NVM 安裝、應用程式複製和權限調整) ... CMD [ \u0026#34;/app/entrypoint.sh\u0026#34; ] x86_64 架構 - Chrome 瀏覽器 1 2 3 FROM selenium/standalone-chrome:latest AS x86_64-chrome # ... (與 arm64-firefox 階段類似的環境變數、目錄建立、NVM 安裝、應用程式複製和權限調整) ... CMD [ \u0026#34;/app/entrypoint.sh\u0026#34; ] entrypoint.sh 腳本詳解 這個腳本是容器啟動時執行的入口點，它負責根據運行環境動態判斷要執行的 npm 腳本，並確保 Selenium 服務已啟動。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #!/bin/bash # 根據容器中存在的瀏覽器可執行檔來設定 SCRIPTS 變數 # 如果找到 firefox，則 SCRIPTS 為 \u0026#34;docker-firefox\u0026#34; [ -f /usr/bin/firefox ] \u0026amp;\u0026amp; export SCRIPTS=\u0026#34;docker-firefox\u0026#34; # 如果找到 chromium-browser 或 google-chrome，則 SCRIPTS 為 \u0026#34;docker-chrome\u0026#34; [ -f /usr/bin/chromium-browser ] \u0026amp;\u0026amp; export SCRIPTS=\u0026#34;docker-chrome\u0026#34; [ -f /usr/bin/google-chrome ] \u0026amp;\u0026amp; export SCRIPTS=\u0026#34;docker-chrome\u0026#34; # 判斷 CPU 架構 (uname -m 會回傳機器硬體名稱) uu=`uname -m` echo \u0026#39;uname -m:\u0026#39; $uu if [ \u0026#34;$uu\u0026#34; = \u0026#34;arm64\u0026#34; ] || [ \u0026#34;$uu\u0026#34; = \u0026#34;aarch64\u0026#34; ];then # 如果是 ARM64 架構，則在 SCRIPTS 後面加上 \u0026#34;-arm64\u0026#34; export SCRIPTS=\u0026#34;$SCRIPTS-arm64\u0026#34; fi # 啟動 Selenium 服務的入口點腳本 (通常由基礎映像檔提供) # 將標準輸出和標準錯誤重定向到 /dev/null，使其在背景靜默運行 /opt/bin/entry_point.sh \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; # 等待 Selenium 服務啟動 (檢查 localhost:4444 是否可訪問) for number in {1..120} # 最多等待 120 秒 do if curl -s http://localhost:4444; then # -s 靜默模式，不顯示進度或錯誤 break # 如果成功訪問，則跳出迴圈 fi echo \u0026#34;Waiting selenium service,\u0026#34; $number # 顯示等待訊息 sleep 1 # 每秒檢查一次 done # 再次檢查 Selenium 服務是否成功啟動，如果沒有則退出並報錯 if ! curl -s http://localhost:4444; then echo \u0026#34;Selenium service failed to start.\u0026#34; exit 1 fi # 進入應用程式目錄 cd /app # 執行對應的 npm 腳本 echo \u0026#34;npm run $SCRIPTS\u0026#34; npm run $SCRIPTS 最佳實踐與考量 多階段建構：此 Dockerfile 充分利用了多階段建構的優勢，將建構環境與運行環境分離，顯著減小了最終映像檔的大小，並提高了安全性。 跨平台支援：透過為不同 CPU 架構和瀏覽器建立獨立的階段，實現了單一 Dockerfile 支援多種運行環境的能力。 權限管理：在複製應用程式檔案後，使用 chown 調整檔案擁有者，確保應用程式以非 root 用戶運行，這是一個重要的安全實踐。 健壯的啟動腳本：entrypoint.sh 腳本包含了等待外部服務 (Selenium) 啟動的邏輯，這使得容器的啟動更加健壯和可靠。 環境變數：合理使用 ENV 指令來管理版本號和路徑，提高了 Dockerfile 的可維護性。 透過這個詳細的 Dockerfile 和啟動腳本，您可以高效地建構和部署跨平台的 Selenium 自動化測試應用程式。\n","permalink":"https://xinqilin.github.io/post/devops/dockerfile-docker_in_docker/","tags":["Docker","Dockerfile","Multi-stage Build","Selenium","Node.js","DevOps","Cross-platform"],"title":"多階段 Dockerfile：建構跨平台 Selenium 應用程式映像檔"},{"content":"概述 Dockerfile 是一個包含一系列指令的文字檔案，Docker 引擎會讀取這些指令，並自動建構出 Docker 映像檔 (Image)。它定義了映像檔的內容、運行環境以及啟動時執行的指令。理解 Dockerfile 是掌握 Docker 容器化技術的關鍵一步。\nDockerfile 核心指令詳解 1. 基礎指令 FROM：指定基礎映像檔。Dockerfile 的第一條指令必須是 FROM。\n語法：FROM \u0026lt;image\u0026gt;[:\u0026lt;tag\u0026gt;] 範例：FROM ubuntu:18.04 (使用 Ubuntu 18.04 作為基礎映像檔) 注意：如果未指定 tag，預設為 latest。建議明確指定版本，以確保建構的可重複性。 MAINTAINER：指定映像檔的維護者資訊。\n語法：MAINTAINER \u0026lt;name\u0026gt; [email] 範例：MAINTAINER Bill.Lin \u0026lt;zzx123bill@gmail.com\u0026gt; 注意：此指令已過時，建議使用 LABEL 指令來替代，例如 LABEL maintainer=\u0026quot;Bill.Lin \u0026lt;zzx123bill@gmail.com\u0026gt;\u0026quot;。 2. 執行指令 RUN：在建構映像檔時執行命令。每個 RUN 指令都會在映像檔中建立一個新的層 (layer)。\n語法： RUN \u0026lt;command\u0026gt; (shell 模式，預設使用 /bin/sh -c 執行) RUN [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;] (exec 模式，直接執行可執行檔) 範例 (shell 模式)： 1 2 RUN apt-get update -y \\ \u0026amp;\u0026amp; apt-get install nginx -y 注意：使用 \u0026amp;\u0026amp; 將多個命令串聯起來，可以減少映像檔層數，優化映像檔大小。 範例 (exec 模式)： 1 2 RUN [\u0026#34;./test.php\u0026#34;, \u0026#34;dev\u0026#34;, \u0026#34;offline\u0026#34;] # 等同於在容器內執行 `./test.php dev offline` CMD：設定容器啟動時預設執行的命令。如果 docker run 命令後帶有參數，CMD 的命令會被覆蓋。一個 Dockerfile 中只能有一個 CMD，多個 CMD 只有最後一個生效。\n語法： CMD [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;] (exec 模式，推薦) CMD [\u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;] (作為 ENTRYPOINT 的預設參數) CMD command param1 param2 (shell 模式) 範例：CMD [\u0026quot;nginx\u0026quot;, \u0026quot;-g\u0026quot;, \u0026quot;daemon off;\u0026quot;] (啟動 Nginx 並保持在前台運行) 注意：CMD 會被 docker run \u0026lt;image\u0026gt; \u0026lt;command\u0026gt; 中的 \u0026lt;command\u0026gt; 覆蓋。 ENTRYPOINT：設定容器啟動時執行的命令。ENTRYPOINT 不會被 docker run 後的參數覆蓋，而是將這些參數作為 ENTRYPOINT 命令的參數。\n語法：ENTRYPOINT [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;] (exec 模式，推薦) 範例：ENTRYPOINT [\u0026quot;docker-entrypoint.sh\u0026quot;] CMD 與 ENTRYPOINT 組合使用： 當 ENTRYPOINT 和 CMD 都使用 exec 模式時，CMD 的內容會作為 ENTRYPOINT 的參數。 1 2 3 4 FROM nginx ENTRYPOINT [\u0026#34;nginx\u0026#34;, \u0026#34;-c\u0026#34;] CMD [\u0026#34;/etc/nginx/nginx.conf\u0026#34;] # 容器啟動時實際執行：nginx -c /etc/nginx/nginx.conf 這種組合常用於設定固定的啟動命令，同時允許使用者透過 CMD 或 docker run 參數來提供預設或自訂的參數。 3. 環境設定 WORKDIR：設定工作目錄。後續的 RUN, CMD, ENTRYPOINT, COPY, ADD 指令都會在這個目錄下執行。\n語法：WORKDIR /path/to/workdir 範例： 1 2 WORKDIR /app COPY . /app # 將建構上下文中的檔案複製到容器的 /app 目錄 USER：指定運行容器時的用戶或用戶組。\n語法：USER \u0026lt;user\u0026gt;[:\u0026lt;group\u0026gt;] 範例：USER nobody (以非 root 用戶運行，提高安全性) 注意：預設為 root。在生產環境中，建議使用非 root 用戶運行應用程式。 VOLUME：建立一個掛載點，將容器內的路徑標記為外部掛載點，用於持久化資料或共享資料。\n語法：VOLUME [\u0026quot;/data\u0026quot;] 範例：VOLUME /var/lib/mysql (將 MySQL 資料目錄標記為儲存卷) ARG：定義建構時的變數。這些變數只在 docker build 過程中有效，不會保留在最終的映像檔中。\n語法：ARG \u0026lt;name\u0026gt;[=\u0026lt;default value\u0026gt;] 範例： 1 2 ARG VERSION=1.0 FROM myapp:${VERSION} 使用：docker build --build-arg VERSION=2.0 . ENV：設定環境變數。這些變數會保留在最終的映像檔中，並在容器運行時可用。\n語法：ENV \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; ... 範例： 1 2 ENV MY_PATH /usr/local WORKDIR $MY_PATH # WORKDIR 可以使用 ENV 定義的變數 EXPOSE：聲明容器運行時監聽的埠。這只是一個文件說明，並不會實際發布埠。要發布埠，需要在 docker run 或 docker-compose.yml 中使用 -p 或 ports。\n語法：EXPOSE \u0026lt;port\u0026gt; [\u0026lt;port\u0026gt;...] 範例：EXPOSE 8080 (聲明容器會監聽 8080 埠) 4. 檔案操作 COPY：將建構上下文中的檔案或目錄複製到映像檔中。\n語法：COPY \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt; 範例：COPY ./target/mms.war /app/mms.war (將主機 target 目錄下的 mms.war 複製到容器的 /app 目錄) 注意：COPY 只能複製本地建構上下文中的檔案。 ADD：與 COPY 類似，但 ADD 具有額外的功能：\n如果 \u0026lt;src\u0026gt; 是一個壓縮檔 (如 .tar, .gz, .zip)，它會自動解壓縮到 \u0026lt;dest\u0026gt;。 如果 \u0026lt;src\u0026gt; 是一個 URL，它會從該 URL 下載檔案。 語法：ADD \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt; 範例：ADD https://example.com/app.tar.gz /app/ 注意：由於 ADD 的自動解壓縮和 URL 下載功能可能導致不確定性，通常建議優先使用 COPY，除非您明確需要 ADD 的特殊功能。 Docker Build 流程 使用 docker build 命令來建構 Docker 映像檔。\n語法：docker build [OPTIONS] PATH | URL | - 範例：docker build -t my-app:1.0 . -t my-app:1.0：為映像檔指定名稱和標籤。 .：指定建構上下文的路徑。Docker 會將此路徑下的所有檔案發送到 Docker Daemon，作為建構過程的上下文。 範例：Java Spring Boot 應用程式的多階段建構 多階段建構 (Multi-stage Builds) 允許您在一個 Dockerfile 中使用多個 FROM 指令。每個 FROM 指令都可以使用不同的基礎映像檔，並且每個階段都可以獨立地建構。最終的映像檔只包含您需要的最終產物，大大減少了映像檔的大小。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # --- 第一階段：建構應用程式 --- # 使用一個包含 Java 開發工具包 (JDK) 的映像檔來編譯和打包應用程式 FROM openjdk:11-jdk-slim AS build # 設定工作目錄 WORKDIR /app # 將 Maven 的設定檔複製到容器中 (如果有的話) # COPY settings.xml /root/.m2/ # 將專案的 pom.xml 複製到容器中，並下載依賴，利用 Docker 層快取 COPY pom.xml . RUN mvn dependency:go-offline # 將所有原始碼複製到容器中 COPY src ./src # 編譯並打包應用程式，生成 JAR 檔案 RUN mvn clean package -DskipTests # --- 第二階段：運行應用程式 --- # 使用一個輕量級的 Java 運行環境 (JRE) 映像檔來運行應用程式 FROM openjdk:11-jre-slim # 設定環境變數，指定應用程式的 JAR 檔案路徑 ENV APP_HOME=/app # 設定工作目錄 WORKDIR $APP_HOME # 從第一階段複製編譯好的 JAR 檔案 COPY --from=build /app/target/*.jar app.jar # 暴露應用程式監聽的埠 EXPOSE 8080 # 定義容器啟動時執行的命令 ENTRYPOINT [\u0026#34;java\u0026#34;, \u0026#34;-jar\u0026#34;, \u0026#34;app.jar\u0026#34;] 這個範例展示了如何使用多階段建構來：\n在第一個階段 (build) 中編譯 Java 應用程式，生成一個 JAR 檔案。 在第二個階段中，只複製最終的 JAR 檔案到一個更小的 JRE 基礎映像檔中。 這樣可以避免將編譯工具、原始碼等不必要的內容包含在最終的運行映像檔中，從而顯著減小映像檔大小，提高安全性和部署效率。\n透過熟練掌握 Dockerfile 的各項指令和最佳實踐，您可以更有效地建構和管理您的 Docker 映像檔。\n","permalink":"https://xinqilin.github.io/post/devops/dockerfile-basic/","tags":["Docker","Dockerfile","DevOps","Containerization","Image Build"],"title":"Dockerfile 基礎：建構 Docker 映像檔的核心指令"},{"content":"Instance Level Dependency 依賴 Association 關聯 Aggregation 聚合 Composition 組合 Class Level Implementation 實作 Inheritance 繼承 Dependency 1 2 3 4 虛線，箭頭指向 被使用者 A ---\u0026gt; B Association 1 2 3 4 實線，箭頭指向 被擁有者 ， 可在箭頭上增加 1-many 1-1 關西 A -\u0026gt; B Aggregation 1 2 3 4 5 6 7 8 空心菱形屁股箭頭，箭頭指向 整體 A \u0026lt;\u0026gt;-\u0026gt; B \u0026lt;\u0026gt;-\u0026gt; C 要有A 必須要有B，C Composition 1 2 實心菱形屁股箭頭，箭頭指向 整體 to be continued\u0026hellip;.\n","permalink":"https://xinqilin.github.io/post/architecture/uml/","tags":[],"title":"UML"},{"content":"概述 Spring Framework 的核心特性之一是依賴注入（Dependency Injection, DI），它實現了控制反轉（Inversion of Control, IoC）的設計模式。正確使用依賴注入不僅能提升程式碼的可測試性和可維護性，還能降低組件間的耦合度。本文將深入探討 Spring 中各種依賴注入方式，並重點說明最佳實踐。\n為什麼不建議使用 @Autowired Field Injection？ 當你在 IntelliJ IDEA 中使用 @Autowired 進行欄位注入時，會看到這樣的警告：\n1 2 3 4 Field injection is not recommended Inspection info: Spring Team recommends: \u0026#34;Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies\u0026#34;. 這個警告背後有深刻的技術理由，讓我們逐一分析。\nSpring 依賴注入的三種方式 1. Field Injection（不建議） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Service public class OrderService { @Autowired private PaymentService paymentService; // ❌ 不建議 @Autowired private InventoryService inventoryService; // ❌ 不建議 @Autowired private EmailService emailService; // ❌ 不建議 public void processOrder(Order order) { paymentService.processPayment(order); inventoryService.updateStock(order); emailService.sendConfirmation(order); } } Field Injection 的問題：\n問題 1：違反單一職責原則 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Service public class UserService { @Autowired private UserRepository userRepository; @Autowired private EmailService emailService; @Autowired private SmsService smsService; @Autowired private AuditService auditService; @Autowired private CacheService cacheService; @Autowired private ValidationService validationService; @Autowired private SecurityService securityService; @Autowired private LoggingService loggingService; @Autowired private MetricsService metricsService; @Autowired private ConfigurationService configurationService; // ... 還有更多依賴 // 當你看到這麼多依賴時，應該重新思考這個類別的職責 } 問題 2：無法進行單元測試 1 2 3 4 5 6 7 8 9 10 11 public class OrderServiceTest { @Test public void testProcessOrder() { // ❌ 無法輕易創建 OrderService 實例進行測試 OrderService orderService = new OrderService(); // PaymentService 為 null! Order order = new Order(); orderService.processOrder(order); // NullPointerException! } } 問題 3：隱藏的依賴關係 1 2 3 4 // 從這個建構子看不出這個類別需要什麼依賴 public class OrderService { // 依賴隱藏在類別內部，外部無法得知 } 問題 4：循環依賴不易發現 1 2 3 4 5 6 7 8 9 10 11 @Service public class ServiceA { @Autowired private ServiceB serviceB; // 循環依賴在運行時才會發現 } @Service public class ServiceB { @Autowired private ServiceA serviceA; // 循環依賴在運行時才會發現 } 2. Setter Injection（條件性建議） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Service public class OrderService { private PaymentService paymentService; private EmailService emailService; @Autowired public void setPaymentService(PaymentService paymentService) { this.paymentService = paymentService; } @Autowired public void setEmailService(EmailService emailService) { this.emailService = emailService; } public void processOrder(Order order) { if (paymentService != null) { paymentService.processPayment(order); } if (emailService != null) { emailService.sendConfirmation(order); } } } Setter Injection 適用場景：\n可選依賴（Optional Dependencies） 循環依賴的暫時解決方案 需要在運行時重新配置依賴 3. Constructor Injection（強烈建議） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Service public class OrderService { private final PaymentService paymentService; private final InventoryService inventoryService; private final EmailService emailService; // ✅ 推薦：Constructor Injection public OrderService(PaymentService paymentService, InventoryService inventoryService, EmailService emailService) { this.paymentService = Objects.requireNonNull(paymentService, \u0026#34;PaymentService cannot be null\u0026#34;); this.inventoryService = Objects.requireNonNull(inventoryService, \u0026#34;InventoryService cannot be null\u0026#34;); this.emailService = Objects.requireNonNull(emailService, \u0026#34;EmailService cannot be null\u0026#34;); } public void processOrder(Order order) { paymentService.processPayment(order); inventoryService.updateStock(order); emailService.sendConfirmation(order); } } Constructor Injection 的優勢 1. 不可變性（Immutability） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Service public class OrderService { // ✅ final 關鍵字確保依賴不會被修改 private final PaymentService paymentService; private final InventoryService inventoryService; public OrderService(PaymentService paymentService, InventoryService inventoryService) { this.paymentService = paymentService; this.inventoryService = inventoryService; } // 無法意外修改依賴關係 } 2. 強制依賴檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Service public class OrderService { private final PaymentService paymentService; public OrderService(PaymentService paymentService) { // ✅ 在物件創建時就確保依賴存在 this.paymentService = Objects.requireNonNull(paymentService, \u0026#34;PaymentService is required for OrderService\u0026#34;); } public void processOrder(Order order) { // ✅ 保證 paymentService 不為 null paymentService.processPayment(order); } } 3. 易於單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @ExtendWith(MockitoExtension.class) class OrderServiceTest { @Mock private PaymentService paymentService; @Mock private InventoryService inventoryService; @Mock private EmailService emailService; private OrderService orderService; @BeforeEach void setUp() { // ✅ 易於創建測試實例 orderService = new OrderService(paymentService, inventoryService, emailService); } @Test void testProcessOrder() { // Given Order order = new Order(); when(paymentService.processPayment(order)).thenReturn(true); // When orderService.processOrder(order); // Then verify(paymentService).processPayment(order); verify(inventoryService).updateStock(order); verify(emailService).sendConfirmation(order); } } 4. 明確的依賴關係 1 2 3 4 5 6 7 8 9 10 11 // ✅ 從建構子就能清楚看到所有依賴 public class OrderService { public OrderService(PaymentService paymentService, InventoryService inventoryService, EmailService emailService, AuditService auditService) { // 如果建構子參數太多，說明這個類別承擔了太多職責 // 這是一個程式碼異味（Code Smell），提醒我們重構 } } 使用 Lombok 簡化 Constructor Injection 基本用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Service @RequiredArgsConstructor // ✅ Lombok 自動生成建構子 public class OrderService { private final PaymentService paymentService; private final InventoryService inventoryService; private final EmailService emailService; // Lombok 自動生成： // public OrderService(PaymentService paymentService, // InventoryService inventoryService, // EmailService emailService) { // this.paymentService = paymentService; // this.inventoryService = inventoryService; // this.emailService = emailService; // } public void processOrder(Order order) { paymentService.processPayment(order); inventoryService.updateStock(order); emailService.sendConfirmation(order); } } 混合必要和可選依賴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Service @RequiredArgsConstructor public class NotificationService { // 必要依賴（final） private final EmailService emailService; private final SmsService smsService; // 可選依賴（non-final） private PushNotificationService pushService; private SlackService slackService; @Autowired(required = false) public void setPushNotificationService(PushNotificationService pushService) { this.pushService = pushService; } @Autowired(required = false) public void setSlackService(SlackService slackService) { this.slackService = slackService; } public void sendNotification(String message, User user) { // 必要服務 emailService.send(message, user.getEmail()); smsService.send(message, user.getPhone()); // 可選服務 if (pushService != null) { pushService.send(message, user.getDeviceToken()); } if (slackService != null) { slackService.send(message, user.getSlackChannel()); } } } 進階依賴注入技巧 1. 條件性依賴注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Configuration public class ServiceConfiguration { @Bean @ConditionalOnProperty(name = \u0026#34;payment.provider\u0026#34;, havingValue = \u0026#34;stripe\u0026#34;) public PaymentService stripePaymentService() { return new StripePaymentService(); } @Bean @ConditionalOnProperty(name = \u0026#34;payment.provider\u0026#34;, havingValue = \u0026#34;paypal\u0026#34;) public PaymentService paypalPaymentService() { return new PaypalPaymentService(); } @Bean @ConditionalOnMissingBean(PaymentService.class) public PaymentService defaultPaymentService() { return new DefaultPaymentService(); } } 2. 集合注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Service @RequiredArgsConstructor public class NotificationService { // ✅ 注入所有 NotificationProvider 實作 private final List\u0026lt;NotificationProvider\u0026gt; providers; public void sendNotification(String message, User user) { providers.forEach(provider -\u0026gt; { try { provider.send(message, user); } catch (Exception e) { log.warn(\u0026#34;Failed to send notification via {}: {}\u0026#34;, provider.getClass().getSimpleName(), e.getMessage()); } }); } } // 不同的通知提供者 @Component public class EmailNotificationProvider implements NotificationProvider { public void send(String message, User user) { // 發送郵件 } } @Component public class SmsNotificationProvider implements NotificationProvider { public void send(String message, User user) { // 發送簡訊 } } 3. 限定符注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 使用 @Qualifier 區分相同類型的 Bean @Service @RequiredArgsConstructor public class OrderService { @Qualifier(\u0026#34;primary\u0026#34;) private final PaymentService primaryPaymentService; @Qualifier(\u0026#34;backup\u0026#34;) private final PaymentService backupPaymentService; public void processPayment(Order order) { try { primaryPaymentService.processPayment(order); } catch (PaymentException e) { log.warn(\u0026#34;Primary payment failed, trying backup: {}\u0026#34;, e.getMessage()); backupPaymentService.processPayment(order); } } } @Configuration public class PaymentConfiguration { @Bean @Qualifier(\u0026#34;primary\u0026#34;) public PaymentService primaryPaymentService() { return new StripePaymentService(); } @Bean @Qualifier(\u0026#34;backup\u0026#34;) public PaymentService backupPaymentService() { return new PaypalPaymentService(); } } 4. Profile 相關注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Configuration public class DatabaseConfiguration { @Bean @Profile(\u0026#34;dev\u0026#34;) public DataSource devDataSource() { return new H2DataSource(); } @Bean @Profile(\u0026#34;prod\u0026#34;) public DataSource prodDataSource() { return new MySQLDataSource(); } @Bean @Profile(\u0026#34;test\u0026#34;) public DataSource testDataSource() { return new TestContainerDataSource(); } } 常見陷阱與解決方案 1. 循環依賴問題 問題示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class OrderService { private final CustomerService customerService; public OrderService(CustomerService customerService) { this.customerService = customerService; } } @Service public class CustomerService { private final OrderService orderService; // ❌ 循環依賴 public CustomerService(OrderService orderService) { this.orderService = orderService; } } 解決方案 1：重新設計架構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // ✅ 引入共享服務，避免循環依賴 @Service @RequiredArgsConstructor public class OrderService { private final CustomerRepository customerRepository; private final OrderRepository orderRepository; private final OrderValidationService validationService; } @Service @RequiredArgsConstructor public class CustomerService { private final CustomerRepository customerRepository; private final OrderRepository orderRepository; } @Service @RequiredArgsConstructor public class OrderValidationService { private final CustomerRepository customerRepository; private final PaymentService paymentService; } 解決方案 2：使用事件驅動架構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Service @RequiredArgsConstructor public class OrderService { private final ApplicationEventPublisher eventPublisher; private final OrderRepository orderRepository; public void createOrder(Order order) { order = orderRepository.save(order); // ✅ 發布事件而非直接調用 eventPublisher.publishEvent(new OrderCreatedEvent(order)); } } @Service @RequiredArgsConstructor @EventListener public class CustomerService { private final CustomerRepository customerRepository; @EventListener public void handleOrderCreated(OrderCreatedEvent event) { // 處理訂單創建事件 updateCustomerOrderCount(event.getOrder().getCustomerId()); } } 2. 建構子參數過多 問題識別： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class UserService { // ❌ 建構子參數過多，違反 SRP 原則 public UserService(UserRepository userRepository, EmailService emailService, SmsService smsService, AuditService auditService, CacheService cacheService, ValidationService validationService, SecurityService securityService, NotificationService notificationService, PaymentService paymentService, ReportService reportService) { // 太多依賴！ } } 解決方案：拆分服務 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // ✅ 拆分為多個專門的服務 @Service @RequiredArgsConstructor public class UserService { private final UserRepository userRepository; private final UserValidationService validationService; private final UserSecurityService securityService; } @Service @RequiredArgsConstructor public class UserNotificationService { private final EmailService emailService; private final SmsService smsService; private final NotificationService notificationService; } @Service @RequiredArgsConstructor public class UserBillingService { private final PaymentService paymentService; private final BillingRepository billingRepository; } 3. 可選依賴處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Service @RequiredArgsConstructor public class UserService { private final UserRepository userRepository; private final EmailService emailService; // ✅ 可選依賴使用 Optional private final Optional\u0026lt;SmsService\u0026gt; smsService; public void createUser(User user) { user = userRepository.save(user); // 必要服務 emailService.sendWelcomeEmail(user); // 可選服務 smsService.ifPresent(service -\u0026gt; service.sendWelcomeSms(user.getPhone()) ); } } @Configuration public class ServiceConfiguration { @Bean @ConditionalOnProperty(name = \u0026#34;sms.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public SmsService smsService() { return new TwilioSmsService(); } } 效能考量 1. 延遲初始化 1 2 3 4 5 6 7 8 9 10 11 12 @Service @Lazy // ✅ 延遲初始化，減少啟動時間 @RequiredArgsConstructor public class ReportService { private final DataAnalysisService dataAnalysisService; private final ChartGenerationService chartService; public Report generateReport(String type) { // 只有在實際使用時才會初始化 return dataAnalysisService.analyze(type); } } 2. 原型 Bean 的注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Service @RequiredArgsConstructor public class OrderProcessorService { private final ApplicationContext applicationContext; public void processOrder(Order order) { // ✅ 每次都創建新的處理器實例 OrderProcessor processor = applicationContext.getBean(OrderProcessor.class); processor.process(order); } } @Component @Scope(\u0026#34;prototype\u0026#34;) // 原型範圍 public class OrderProcessor { public void process(Order order) { // 處理邏輯 } } 3. Provider 模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Service @RequiredArgsConstructor public class OrderService { // ✅ 使用 Provider 延遲獲取 Bean private final Provider\u0026lt;ExpensiveService\u0026gt; expensiveServiceProvider; public void processSpecialOrder(Order order) { if (order.isSpecial()) { // 只有在需要時才獲取昂貴的服務 ExpensiveService service = expensiveServiceProvider.get(); service.processSpecialOrder(order); } } } 測試最佳實踐 1. 使用 Constructor Injection 的測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @ExtendWith(MockitoExtension.class) class OrderServiceTest { @Mock private PaymentService paymentService; @Mock private InventoryService inventoryService; @Mock private EmailService emailService; private OrderService orderService; @BeforeEach void setUp() { // ✅ 清晰的測試設置 orderService = new OrderService(paymentService, inventoryService, emailService); } @Test void shouldProcessOrderSuccessfully() { // Given Order order = TestDataBuilder.createOrder(); when(paymentService.processPayment(order)).thenReturn(PaymentResult.success()); // When OrderResult result = orderService.processOrder(order); // Then assertThat(result.isSuccessful()).isTrue(); verify(paymentService).processPayment(order); verify(inventoryService).updateStock(order); verify(emailService).sendConfirmation(order); } @Test void shouldHandlePaymentFailure() { // Given Order order = TestDataBuilder.createOrder(); when(paymentService.processPayment(order)) .thenThrow(new PaymentException(\u0026#34;Payment failed\u0026#34;)); // When \u0026amp; Then assertThatThrownBy(() -\u0026gt; orderService.processOrder(order)) .isInstanceOf(OrderProcessingException.class) .hasMessageContaining(\u0026#34;Payment failed\u0026#34;); verify(inventoryService, never()).updateStock(order); verify(emailService, never()).sendConfirmation(order); } } 2. Integration Testing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @SpringBootTest @TestPropertySource(properties = { \u0026#34;spring.datasource.url=jdbc:h2:mem:testdb\u0026#34;, \u0026#34;payment.provider=mock\u0026#34; }) class OrderServiceIntegrationTest { @Autowired private OrderService orderService; @MockBean // ✅ Spring Boot 的 Mock 支援 private EmailService emailService; @Test void shouldProcessOrderEndToEnd() { // Given Order order = TestDataBuilder.createOrder(); // When OrderResult result = orderService.processOrder(order); // Then assertThat(result.isSuccessful()).isTrue(); verify(emailService).sendConfirmation(order); } } Spring Boot 中的依賴注入 1. 自動配置與依賴注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @SpringBootApplication public class ECommerceApplication { public static void main(String[] args) { SpringApplication.run(ECommerceApplication.class, args); } } // ✅ Spring Boot 自動配置 + Constructor Injection @RestController @RequiredArgsConstructor @RequestMapping(\u0026#34;/api/orders\u0026#34;) public class OrderController { private final OrderService orderService; private final OrderMapper orderMapper; @PostMapping public ResponseEntity\u0026lt;OrderDto\u0026gt; createOrder(@RequestBody CreateOrderRequest request) { Order order = orderMapper.toEntity(request); Order savedOrder = orderService.createOrder(order); OrderDto dto = orderMapper.toDto(savedOrder); return ResponseEntity.ok(dto); } } 2. Configuration Properties 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @ConfigurationProperties(prefix = \u0026#34;app.order\u0026#34;) @ConstructorBinding // ✅ 不可變配置類 @RequiredArgsConstructor @Getter public class OrderProperties { private final Duration timeout; private final int maxRetries; private final boolean enableNotifications; private final PaymentConfig payment; @RequiredArgsConstructor @Getter public static class PaymentConfig { private final String provider; private final Duration timeout; private final boolean enableRetry; } } // 使用配置 @Service @RequiredArgsConstructor public class OrderService { private final OrderProperties properties; private final PaymentService paymentService; public void processOrder(Order order) { try { paymentService.processPayment(order, properties.getPayment().getTimeout()); } catch (PaymentException e) { if (properties.getPayment().isEnableRetry()) { retryPayment(order); } } } } 監控與偵錯 1. Bean 依賴關係檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Component @RequiredArgsConstructor public class DependencyHealthIndicator implements HealthIndicator { private final List\u0026lt;HealthCheckable\u0026gt; healthCheckableServices; @Override public Health health() { Health.Builder builder = Health.up(); for (HealthCheckable service : healthCheckableServices) { try { service.checkHealth(); builder.withDetail(service.getClass().getSimpleName(), \u0026#34;UP\u0026#34;); } catch (Exception e) { builder.withDetail(service.getClass().getSimpleName(), \u0026#34;DOWN: \u0026#34; + e.getMessage()); builder.down(); } } return builder.build(); } } 2. 依賴注入除錯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @EventListener @Component @Slf4j public class ApplicationStartupListener { @EventListener public void handleContextRefresh(ContextRefreshedEvent event) { ApplicationContext context = event.getApplicationContext(); log.info(\u0026#34;=== Spring Context Loaded ===\u0026#34;); log.info(\u0026#34;Total beans: {}\u0026#34;, context.getBeanDefinitionCount()); // 列出所有 Bean String[] beanNames = context.getBeanDefinitionNames(); for (String beanName : beanNames) { Object bean = context.getBean(beanName); log.debug(\u0026#34;Bean: {} -\u0026gt; {}\u0026#34;, beanName, bean.getClass().getName()); } } } 總結 依賴注入方式比較 注入方式 推薦度 優點 缺點 適用場景 Constructor ⭐⭐⭐⭐⭐ 不可變、強制檢查、易測試 建構子可能變長 預設選擇 Setter ⭐⭐⭐ 靈活、支援可選依賴 可變、晚期檢查 可選依賴、循環依賴 Field ⭐ 簡潔 難測試、隱藏依賴、可變 避免使用 最佳實踐總結 優先使用 Constructor Injection：確保依賴的不可變性和強制檢查 使用 Lombok @RequiredArgsConstructor：減少模板程式碼 限制建構子參數數量：超過 5 個參數考慮重構 使用 final 關鍵字：確保依賴不會被意外修改 適當使用 @Qualifier：區分相同類型的 Bean 考慮可選依賴：使用 Optional 或 Setter Injection 避免循環依賴：重新設計架構或使用事件驅動 編寫完整的測試：利用 Constructor Injection 的可測試性 遷移策略 如果你的專案目前大量使用 Field Injection，可以採用漸進式遷移：\n新程式碼：立即採用 Constructor Injection 現有程式碼：在修改時逐步重構 關鍵服務：優先重構核心業務邏輯 工具支援：使用 IDE 的自動重構功能 正確的依賴注入不僅是技術最佳實踐，更是建立可維護、可測試、高品質軟體的基礎。\n參考資料 Spring Framework Reference Documentation Spring Boot Reference Guide Effective Java by Joshua Bloch Clean Code by Robert Martin Spring in Action by Craig Walls ","permalink":"https://xinqilin.github.io/post/backend/@autowired/","tags":["Java","Spring","DI","IoC","Autowired","Constructor","Best-Practices"],"title":"Spring 依賴注入完整指南：@Autowired 與最佳實踐"},{"content":"概述 SOLID 是物件導向程式設計和軟體架構設計中五個核心設計原則的縮寫，由 Robert C. Martin（Uncle Bob）在 21 世紀初期提出。這些原則旨在讓軟體設計更加容易理解、靈活且可維護。\nSOLID 原則不僅適用於物件導向程式設計，也是現代軟體架構的基石，從微服務設計到 Clean Architecture 都深受其影響。\nSOLID 原則概覽 首字母 英文原則名稱 中文名稱 核心概念 S Single Responsibility Principle 單一職責原則 一個類別應該只有一個改變的理由 O Open/Closed Principle 開閉原則 對擴展開放，對修改封閉 L Liskov Substitution Principle 里氏替換原則 子類別應該能完全替換父類別 I Interface Segregation Principle 介面隔離原則 客戶端不應該依賴它不需要的介面 D Dependency Inversion Principle 依賴反轉原則 依賴於抽象而非具體實作 1. Single Responsibility Principle (SRP) - 單一職責原則 定義 一個類別應該只有一個引起它變化的原因\n核心概念 高內聚性：類別內部的方法和屬性應該為同一個目標服務 低耦合性：減少類別之間的依賴關係 明確責任：每個類別都應該有明確且單一的職責 違反 SRP 的範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // ❌ 違反 SRP：一個類別承擔多種職責 public class User { private String name; private String email; // 用戶資料驗證職責 public boolean validateEmail(String email) { return email.contains(\u0026#34;@\u0026#34;) \u0026amp;\u0026amp; email.contains(\u0026#34;.\u0026#34;); } // 用戶持久化職責 public void saveToDatabase() { // 資料庫存儲邏輯 System.out.println(\u0026#34;儲存用戶到資料庫\u0026#34;); } // 用戶通知職責 public void sendWelcomeEmail() { // 郵件發送邏輯 System.out.println(\u0026#34;發送歡迎郵件\u0026#34;); } // 用戶報表職責 public String generateUserReport() { return \u0026#34;用戶報表: \u0026#34; + name + \u0026#34; - \u0026#34; + email; } } 遵循 SRP 的重構範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 // ✅ 遵循 SRP：職責分離 // 1. 用戶實體類別（僅負責用戶資料） public class User { private String name; private String email; public User(String name, String email) { this.name = name; this.email = email; } // Getter and Setter methods public String getName() { return name; } public String getEmail() { return email; } public void setName(String name) { this.name = name; } public void setEmail(String email) { this.email = email; } } // 2. 用戶驗證服務（僅負責驗證邏輯） @Service public class UserValidator { public boolean validateEmail(String email) { return email != null \u0026amp;\u0026amp; email.contains(\u0026#34;@\u0026#34;) \u0026amp;\u0026amp; email.contains(\u0026#34;.\u0026#34;) \u0026amp;\u0026amp; email.length() \u0026gt; 5; } public boolean validateName(String name) { return name != null \u0026amp;\u0026amp; name.trim().length() \u0026gt; 0 \u0026amp;\u0026amp; name.length() \u0026lt;= 50; } public ValidationResult validateUser(User user) { ValidationResult result = new ValidationResult(); if (!validateName(user.getName())) { result.addError(\u0026#34;用戶名格式無效\u0026#34;); } if (!validateEmail(user.getEmail())) { result.addError(\u0026#34;郵箱格式無效\u0026#34;); } return result; } } // 3. 用戶持久化服務（僅負責資料存取） @Repository public class UserRepository { public void save(User user) { // 資料庫存儲邏輯 System.out.println(\u0026#34;儲存用戶到資料庫: \u0026#34; + user.getName()); } public User findByEmail(String email) { // 查詢邏輯 return new User(\u0026#34;找到的用戶\u0026#34;, email); } public List\u0026lt;User\u0026gt; findAll() { // 查詢所有用戶 return Arrays.asList(new User(\u0026#34;用戶1\u0026#34;, \u0026#34;user1@example.com\u0026#34;)); } } // 4. 用戶通知服務（僅負責通知邏輯） @Service public class UserNotificationService { public void sendWelcomeEmail(User user) { System.out.println(\u0026#34;發送歡迎郵件給: \u0026#34; + user.getEmail()); } public void sendPasswordResetEmail(User user) { System.out.println(\u0026#34;發送密碼重設郵件給: \u0026#34; + user.getEmail()); } public void sendAccountActivationEmail(User user) { System.out.println(\u0026#34;發送帳戶啟用郵件給: \u0026#34; + user.getEmail()); } } // 5. 用戶報表服務（僅負責報表生成） @Service public class UserReportService { public String generateUserReport(User user) { return String.format(\u0026#34;用戶報表\\n姓名: %s\\n郵箱: %s\\n生成時間: %s\u0026#34;, user.getName(), user.getEmail(), LocalDateTime.now()); } public String generateUsersListReport(List\u0026lt;User\u0026gt; users) { StringBuilder report = new StringBuilder(\u0026#34;用戶列表報表\\n\u0026#34;); users.forEach(user -\u0026gt; report.append(String.format(\u0026#34;- %s (%s)\\n\u0026#34;, user.getName(), user.getEmail())) ); return report.toString(); } } // 6. 用戶服務協調器（組合各種服務） @Service public class UserService { private final UserValidator userValidator; private final UserRepository userRepository; private final UserNotificationService notificationService; public UserService(UserValidator userValidator, UserRepository userRepository, UserNotificationService notificationService) { this.userValidator = userValidator; this.userRepository = userRepository; this.notificationService = notificationService; } public Result\u0026lt;User\u0026gt; createUser(String name, String email) { User user = new User(name, email); // 驗證用戶資料 ValidationResult validation = userValidator.validateUser(user); if (!validation.isValid()) { return Result.failure(\u0026#34;驗證失敗: \u0026#34; + validation.getErrors()); } // 儲存用戶 userRepository.save(user); // 發送歡迎郵件 notificationService.sendWelcomeEmail(user); return Result.success(user); } } SRP 的好處 降低複雜度：每個類別的責任明確，易於理解 提高可讀性：程式碼結構清晰，功能劃分明確 增強可維護性：修改某個功能時，只需要關注特定的類別 提升可測試性：職責單一的類別更容易進行單元測試 促進重用性：功能獨立的類別可以在不同場景中重複使用 2. Open/Closed Principle (OCP) - 開閉原則 定義 軟體實體（類別、模組、函數等）應該對擴展開放，對修改封閉\n核心概念 對擴展開放：可以透過新增程式碼來擴展功能 對修改封閉：不應該修改現有的程式碼 策略模式：透過抽象介面實現不同的實作策略 違反 OCP 的範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // ❌ 違反 OCP：每次新增形狀都需要修改計算器類別 public class AreaCalculator { public double calculateArea(Object shape) { if (shape instanceof Rectangle) { Rectangle rectangle = (Rectangle) shape; return rectangle.getWidth() * rectangle.getHeight(); } else if (shape instanceof Circle) { Circle circle = (Circle) shape; return Math.PI * circle.getRadius() * circle.getRadius(); } else if (shape instanceof Triangle) { // 新增三角形需要修改此方法 Triangle triangle = (Triangle) shape; return 0.5 * triangle.getBase() * triangle.getHeight(); } // 每次新增新形狀都需要修改這裡 throw new IllegalArgumentException(\u0026#34;不支援的形狀類型\u0026#34;); } } 遵循 OCP 的重構範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 // ✅ 遵循 OCP：定義抽象介面 public interface Shape { double calculateArea(); String getShapeType(); } // 具體實作 - 矩形 public class Rectangle implements Shape { private double width; private double height; public Rectangle(double width, double height) { this.width = width; this.height = height; } @Override public double calculateArea() { return width * height; } @Override public String getShapeType() { return \u0026#34;矩形\u0026#34;; } // Getter methods public double getWidth() { return width; } public double getHeight() { return height; } } // 具體實作 - 圓形 public class Circle implements Shape { private double radius; public Circle(double radius) { this.radius = radius; } @Override public double calculateArea() { return Math.PI * radius * radius; } @Override public String getShapeType() { return \u0026#34;圓形\u0026#34;; } public double getRadius() { return radius; } } // 具體實作 - 三角形（新增時無需修改現有程式碼） public class Triangle implements Shape { private double base; private double height; public Triangle(double base, double height) { this.base = base; this.height = height; } @Override public double calculateArea() { return 0.5 * base * height; } @Override public String getShapeType() { return \u0026#34;三角形\u0026#34;; } public double getBase() { return base; } public double getHeight() { return height; } } // 新增多邊形（無需修改現有程式碼） public class Polygon implements Shape { private List\u0026lt;Point\u0026gt; vertices; public Polygon(List\u0026lt;Point\u0026gt; vertices) { this.vertices = vertices; } @Override public double calculateArea() { // 使用鞋帶公式計算多邊形面積 double area = 0; int n = vertices.size(); for (int i = 0; i \u0026lt; n; i++) { int j = (i + 1) % n; area += vertices.get(i).getX() * vertices.get(j).getY(); area -= vertices.get(j).getX() * vertices.get(i).getY(); } return Math.abs(area) / 2.0; } @Override public String getShapeType() { return \u0026#34;多邊形\u0026#34;; } } // 面積計算器（無需修改，支援所有 Shape 實作） @Service public class AreaCalculator { public double calculateArea(Shape shape) { return shape.calculateArea(); } public List\u0026lt;AreaReport\u0026gt; calculateMultipleAreas(List\u0026lt;Shape\u0026gt; shapes) { return shapes.stream() .map(shape -\u0026gt; new AreaReport( shape.getShapeType(), shape.calculateArea() )) .collect(Collectors.toList()); } public double calculateTotalArea(List\u0026lt;Shape\u0026gt; shapes) { return shapes.stream() .mapToDouble(Shape::calculateArea) .sum(); } } // 形狀工廠（支援擴展新形狀） @Component public class ShapeFactory { public Shape createRectangle(double width, double height) { return new Rectangle(width, height); } public Shape createCircle(double radius) { return new Circle(radius); } public Shape createTriangle(double base, double height) { return new Triangle(base, height); } public Shape createPolygon(List\u0026lt;Point\u0026gt; vertices) { return new Polygon(vertices); } } // 使用範例 @RestController @RequestMapping(\u0026#34;/shapes\u0026#34;) public class ShapeController { private final AreaCalculator areaCalculator; private final ShapeFactory shapeFactory; public ShapeController(AreaCalculator areaCalculator, ShapeFactory shapeFactory) { this.areaCalculator = areaCalculator; this.shapeFactory = shapeFactory; } @PostMapping(\u0026#34;/rectangle/area\u0026#34;) public AreaResponse calculateRectangleArea(@RequestBody RectangleRequest request) { Shape rectangle = shapeFactory.createRectangle(request.getWidth(), request.getHeight()); double area = areaCalculator.calculateArea(rectangle); return new AreaResponse(rectangle.getShapeType(), area); } @PostMapping(\u0026#34;/circle/area\u0026#34;) public AreaResponse calculateCircleArea(@RequestBody CircleRequest request) { Shape circle = shapeFactory.createCircle(request.getRadius()); double area = areaCalculator.calculateArea(circle); return new AreaResponse(circle.getShapeType(), area); } } 進階應用：策略模式與工廠模式結合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 // 折扣策略介面 public interface DiscountStrategy { double calculateDiscount(double originalPrice); String getStrategyName(); } // 具體折扣策略 @Component(\u0026#34;regular\u0026#34;) public class RegularCustomerDiscount implements DiscountStrategy { @Override public double calculateDiscount(double originalPrice) { return originalPrice * 0.05; // 5% 折扣 } @Override public String getStrategyName() { return \u0026#34;一般客戶折扣\u0026#34;; } } @Component(\u0026#34;vip\u0026#34;) public class VipCustomerDiscount implements DiscountStrategy { @Override public double calculateDiscount(double originalPrice) { return originalPrice * 0.15; // 15% 折扣 } @Override public String getStrategyName() { return \u0026#34;VIP 客戶折扣\u0026#34;; } } @Component(\u0026#34;premium\u0026#34;) public class PremiumCustomerDiscount implements DiscountStrategy { @Override public double calculateDiscount(double originalPrice) { return originalPrice * 0.25; // 25% 折扣 } @Override public String getStrategyName() { return \u0026#34;尊享客戶折扣\u0026#34;; } } // 折扣計算器（對修改封閉，對擴展開放） @Service public class DiscountCalculator { private final Map\u0026lt;String, DiscountStrategy\u0026gt; strategies; public DiscountCalculator(Map\u0026lt;String, DiscountStrategy\u0026gt; strategies) { this.strategies = strategies; } public DiscountResult calculateDiscount(String customerType, double originalPrice) { DiscountStrategy strategy = strategies.get(customerType); if (strategy == null) { throw new IllegalArgumentException(\u0026#34;不支援的客戶類型: \u0026#34; + customerType); } double discountAmount = strategy.calculateDiscount(originalPrice); double finalPrice = originalPrice - discountAmount; return new DiscountResult( strategy.getStrategyName(), originalPrice, discountAmount, finalPrice ); } } 3. Liskov Substitution Principle (LSP) - 里氏替換原則 定義 子類別必須能夠替換其父類別，而不會改變程式的正確性\n核心概念 行為相容性：子類別的行為應該與父類別一致 契約保持：子類別不能違反父類別建立的契約 強化前置條件：子類別不能強化前置條件 弱化後置條件：子類別不能弱化後置條件 違反 LSP 的範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 // ❌ 違反 LSP：正方形修改了矩形的行為契約 public class Rectangle { protected double width; protected double height; public Rectangle(double width, double height) { this.width = width; this.height = height; } public void setWidth(double width) { this.width = width; } public void setHeight(double height) { this.height = height; } public double getWidth() { return width; } public double getHeight() { return height; } public double getArea() { return width * height; } } // ❌ 正方形繼承矩形，但違反了里氏替換原則 public class Square extends Rectangle { public Square(double side) { super(side, side); } // 違反LSP：改變了父類別的行為契約 @Override public void setWidth(double width) { this.width = width; this.height = width; // 強制保持正方形性質 } @Override public void setHeight(double height) { this.width = height; // 強制保持正方形性質 this.height = height; } } // 測試程式碼展示問題 public class GeometryTest { public static void testRectangle(Rectangle rectangle) { rectangle.setWidth(4); rectangle.setHeight(5); // 期望面積是 20，但如果傳入 Square 物件，面積會是 25 double expectedArea = 20; double actualArea = rectangle.getArea(); System.out.println(\u0026#34;期望面積: \u0026#34; + expectedArea); System.out.println(\u0026#34;實際面積: \u0026#34; + actualArea); System.out.println(\u0026#34;測試結果: \u0026#34; + (expectedArea == actualArea ? \u0026#34;通過\u0026#34; : \u0026#34;失敗\u0026#34;)); } public static void main(String[] args) { Rectangle rectangle = new Rectangle(0, 0); testRectangle(rectangle); // 通過 Rectangle square = new Square(0); testRectangle(square); // 失敗！違反了 LSP } } 遵循 LSP 的重構範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 // ✅ 遵循 LSP：重新設計繼承階層 // 抽象基礎類別 public abstract class Shape { public abstract double getArea(); public abstract double getPerimeter(); public abstract String getShapeType(); // 模板方法 public String getShapeInfo() { return String.format(\u0026#34;%s - 面積: %.2f, 周長: %.2f\u0026#34;, getShapeType(), getArea(), getPerimeter()); } } // 矩形實作 public class Rectangle extends Shape { private double width; private double height; public Rectangle(double width, double height) { if (width \u0026lt;= 0 || height \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;長度和寬度必須大於 0\u0026#34;); } this.width = width; this.height = height; } @Override public double getArea() { return width * height; } @Override public double getPerimeter() { return 2 * (width + height); } @Override public String getShapeType() { return \u0026#34;矩形\u0026#34;; } // 只提供安全的修改方法 public Rectangle resize(double newWidth, double newHeight) { return new Rectangle(newWidth, newHeight); } public double getWidth() { return width; } public double getHeight() { return height; } } // 正方形實作（不繼承矩形） public class Square extends Shape { private double side; public Square(double side) { if (side \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;邊長必須大於 0\u0026#34;); } this.side = side; } @Override public double getArea() { return side * side; } @Override public double getPerimeter() { return 4 * side; } @Override public String getShapeType() { return \u0026#34;正方形\u0026#34;; } public Square resize(double newSide) { return new Square(newSide); } public double getSide() { return side; } } // 圓形實作 public class Circle extends Shape { private double radius; public Circle(double radius) { if (radius \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;半徑必須大於 0\u0026#34;); } this.radius = radius; } @Override public double getArea() { return Math.PI * radius * radius; } @Override public double getPerimeter() { return 2 * Math.PI * radius; } @Override public String getShapeType() { return \u0026#34;圓形\u0026#34;; } public Circle resize(double newRadius) { return new Circle(newRadius); } public double getRadius() { return radius; } } // 幾何計算器（可以安全地使用任何 Shape 子類別） @Service public class GeometryCalculator { // 可以安全地接受任何 Shape 子類別 public double calculateArea(Shape shape) { return shape.getArea(); } public double calculatePerimeter(Shape shape) { return shape.getPerimeter(); } public List\u0026lt;ShapeReport\u0026gt; generateShapeReports(List\u0026lt;Shape\u0026gt; shapes) { return shapes.stream() .map(shape -\u0026gt; new ShapeReport( shape.getShapeType(), shape.getArea(), shape.getPerimeter() )) .collect(Collectors.toList()); } public Shape findLargestShape(List\u0026lt;Shape\u0026gt; shapes) { return shapes.stream() .max(Comparator.comparing(Shape::getArea)) .orElseThrow(() -\u0026gt; new IllegalArgumentException(\u0026#34;形狀列表不能為空\u0026#34;)); } } // 測試證明 LSP 合規性 @Component public class GeometryTestService { private final GeometryCalculator calculator; public GeometryTestService(GeometryCalculator calculator) { this.calculator = calculator; } public void testShapePolymorphism() { List\u0026lt;Shape\u0026gt; shapes = Arrays.asList( new Rectangle(4, 5), // 面積: 20 new Square(4), // 面積: 16 new Circle(3) // 面積: ~28.27 ); // 所有形狀都可以安全地使用相同的方法 shapes.forEach(shape -\u0026gt; { System.out.println(shape.getShapeInfo()); }); // 找出最大面積的形狀 Shape largest = calculator.findLargestShape(shapes); System.out.println(\u0026#34;最大形狀: \u0026#34; + largest.getShapeInfo()); } } LSP 的進階應用：契約設計 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 // 定義清楚的契約 public abstract class Bird { protected String name; protected double weight; public Bird(String name, double weight) { this.name = name; this.weight = weight; } // 契約：所有鳥類都可以吃 public abstract void eat(String food); // 契約：所有鳥類都可以移動 public abstract void move(); public String getName() { return name; } public double getWeight() { return weight; } } // 可飛行的鳥類介面 public interface Flyable { void fly(); double getMaxFlightHeight(); } // 可游泳的鳥類介面 public interface Swimmable { void swim(); double getMaxDivingDepth(); } // 具體實作 - 老鷹（可飛行） public class Eagle extends Bird implements Flyable { public Eagle(String name, double weight) { super(name, weight); } @Override public void eat(String food) { System.out.println(name + \u0026#34; 正在吃 \u0026#34; + food); } @Override public void move() { fly(); // 老鷹主要透過飛行移動 } @Override public void fly() { System.out.println(name + \u0026#34; 正在高空飛翔\u0026#34;); } @Override public double getMaxFlightHeight() { return 3000; // 3000公尺 } } // 具體實作 - 企鵝（可游泳，不能飛行） public class Penguin extends Bird implements Swimmable { public Penguin(String name, double weight) { super(name, weight); } @Override public void eat(String food) { System.out.println(name + \u0026#34; 正在吃 \u0026#34; + food); } @Override public void move() { swim(); // 企鵝主要透過游泳移動 } @Override public void swim() { System.out.println(name + \u0026#34; 正在水中游泳\u0026#34;); } @Override public double getMaxDivingDepth() { return 200; // 200公尺 } } // 鳥類管理服務（完全遵循 LSP） @Service public class BirdManagementService { // 可以安全地處理任何 Bird 子類別 public void feedBird(Bird bird, String food) { bird.eat(food); } public void moveBird(Bird bird) { bird.move(); } // 專門處理可飛行的鳥類 public void makeFly(Flyable flyableBird) { flyableBird.fly(); System.out.println(\u0026#34;最大飛行高度: \u0026#34; + flyableBird.getMaxFlightHeight() + \u0026#34; 公尺\u0026#34;); } // 專門處理可游泳的鳥類 public void makeSwim(Swimmable swimmableBird) { swimmableBird.swim(); System.out.println(\u0026#34;最大潛水深度: \u0026#34; + swimmableBird.getMaxDivingDepth() + \u0026#34; 公尺\u0026#34;); } } 4. Interface Segregation Principle (ISP) - 介面隔離原則 定義 不應該強迫客戶端依賴它們不使用的介面方法\n核心概念 介面最小化：介面應該只包含客戶端需要的方法 職責分離：大介面應該拆分成多個小介面 依賴最小化：降低介面之間的耦合度 違反 ISP 的範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // ❌ 違反 ISP：萬能介面，強迫實作不需要的方法 public interface MediaPlayer { void playAudio(String audioFile); void playVideo(String videoFile); void displaySubtitles(String subtitleFile); void adjustVolume(int volume); void adjustBrightness(int brightness); void recordAudio(); void recordVideo(); void takeScreenshot(); void applyAudioFilter(String filter); void applyVideoFilter(String filter); } // ❌ 音頻播放器被迫實作不需要的視頻相關方法 public class AudioPlayer implements MediaPlayer { @Override public void playAudio(String audioFile) { System.out.println(\u0026#34;播放音頻: \u0026#34; + audioFile); } @Override public void adjustVolume(int volume) { System.out.println(\u0026#34;調整音量到: \u0026#34; + volume); } @Override public void applyAudioFilter(String filter) { System.out.println(\u0026#34;應用音頻濾鏡: \u0026#34; + filter); } // 被迫實作不需要的方法 @Override public void playVideo(String videoFile) { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援視頻播放\u0026#34;); } @Override public void displaySubtitles(String subtitleFile) { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援字幕\u0026#34;); } @Override public void adjustBrightness(int brightness) { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援亮度調整\u0026#34;); } @Override public void recordAudio() { throw new UnsupportedOperationException(\u0026#34;此音頻播放器不支援錄音\u0026#34;); } @Override public void recordVideo() { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援視頻錄製\u0026#34;); } @Override public void takeScreenshot() { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援截圖\u0026#34;); } @Override public void applyVideoFilter(String filter) { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援視頻濾鏡\u0026#34;); } } 遵循 ISP 的重構範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 // ✅ 遵循 ISP：將大介面拆分成多個職責明確的小介面 // 基礎播放介面 public interface Playable { void play(String file); void pause(); void stop(); void seek(long position); } // 音頻相關介面 public interface AudioPlayable extends Playable { void adjustVolume(int volume); int getVolume(); } // 視頻相關介面 public interface VideoPlayable extends Playable { void adjustBrightness(int brightness); void adjustContrast(int contrast); int getBrightness(); int getContrast(); } // 字幕支援介面 public interface SubtitleSupport { void loadSubtitles(String subtitleFile); void showSubtitles(boolean show); void adjustSubtitleSize(int size); } // 錄音介面 public interface AudioRecordable { void startAudioRecording(String outputFile); void stopAudioRecording(); boolean isRecording(); } // 錄影介面 public interface VideoRecordable { void startVideoRecording(String outputFile); void stopVideoRecording(); void takeScreenshot(String outputFile); } // 濾鏡支援介面 public interface AudioFilterSupport { void applyAudioFilter(AudioFilter filter); void removeAudioFilter(); List\u0026lt;AudioFilter\u0026gt; getAvailableAudioFilters(); } public interface VideoFilterSupport { void applyVideoFilter(VideoFilter filter); void removeVideoFilter(); List\u0026lt;VideoFilter\u0026gt; getAvailableVideoFilters(); } // 音頻播放器實作（只實作需要的介面） @Component public class SimpleAudioPlayer implements AudioPlayable, AudioFilterSupport { private int volume = 50; private boolean isPlaying = false; private AudioFilter currentFilter; @Override public void play(String file) { System.out.println(\u0026#34;播放音頻檔案: \u0026#34; + file); isPlaying = true; } @Override public void pause() { System.out.println(\u0026#34;暫停播放\u0026#34;); isPlaying = false; } @Override public void stop() { System.out.println(\u0026#34;停止播放\u0026#34;); isPlaying = false; } @Override public void seek(long position) { System.out.println(\u0026#34;跳轉到位置: \u0026#34; + position + \u0026#34; 秒\u0026#34;); } @Override public void adjustVolume(int volume) { this.volume = Math.max(0, Math.min(100, volume)); System.out.println(\u0026#34;音量調整為: \u0026#34; + this.volume); } @Override public int getVolume() { return volume; } @Override public void applyAudioFilter(AudioFilter filter) { this.currentFilter = filter; System.out.println(\u0026#34;應用音頻濾鏡: \u0026#34; + filter.getName()); } @Override public void removeAudioFilter() { this.currentFilter = null; System.out.println(\u0026#34;移除音頻濾鏡\u0026#34;); } @Override public List\u0026lt;AudioFilter\u0026gt; getAvailableAudioFilters() { return Arrays.asList( new AudioFilter(\u0026#34;回音\u0026#34;, \u0026#34;echo\u0026#34;), new AudioFilter(\u0026#34;降噪\u0026#34;, \u0026#34;noise_reduction\u0026#34;), new AudioFilter(\u0026#34;等化器\u0026#34;, \u0026#34;equalizer\u0026#34;) ); } } // 專業錄音機實作（實作錄音相關介面） @Component public class ProfessionalAudioRecorder implements AudioPlayable, AudioRecordable, AudioFilterSupport { private int volume = 50; private boolean isPlaying = false; private boolean isRecording = false; private String currentRecordingFile; // 實作播放功能 @Override public void play(String file) { if (!isRecording) { System.out.println(\u0026#34;播放音頻檔案: \u0026#34; + file); isPlaying = true; } else { System.out.println(\u0026#34;錄音中，無法播放\u0026#34;); } } @Override public void pause() { System.out.println(\u0026#34;暫停播放\u0026#34;); isPlaying = false; } @Override public void stop() { System.out.println(\u0026#34;停止播放\u0026#34;); isPlaying = false; } @Override public void seek(long position) { System.out.println(\u0026#34;跳轉到位置: \u0026#34; + position + \u0026#34; 秒\u0026#34;); } @Override public void adjustVolume(int volume) { this.volume = Math.max(0, Math.min(100, volume)); System.out.println(\u0026#34;音量調整為: \u0026#34; + this.volume); } @Override public int getVolume() { return volume; } // 實作錄音功能 @Override public void startAudioRecording(String outputFile) { if (!isPlaying) { this.currentRecordingFile = outputFile; this.isRecording = true; System.out.println(\u0026#34;開始錄音到: \u0026#34; + outputFile); } else { System.out.println(\u0026#34;播放中，無法錄音\u0026#34;); } } @Override public void stopAudioRecording() { if (isRecording) { this.isRecording = false; System.out.println(\u0026#34;錄音完成: \u0026#34; + currentRecordingFile); this.currentRecordingFile = null; } } @Override public boolean isRecording() { return isRecording; } // 實作濾鏡功能 @Override public void applyAudioFilter(AudioFilter filter) { System.out.println(\u0026#34;應用專業音頻濾鏡: \u0026#34; + filter.getName()); } @Override public void removeAudioFilter() { System.out.println(\u0026#34;移除音頻濾鏡\u0026#34;); } @Override public List\u0026lt;AudioFilter\u0026gt; getAvailableAudioFilters() { return Arrays.asList( new AudioFilter(\u0026#34;回音\u0026#34;, \u0026#34;echo\u0026#34;), new AudioFilter(\u0026#34;降噪\u0026#34;, \u0026#34;noise_reduction\u0026#34;), new AudioFilter(\u0026#34;等化器\u0026#34;, \u0026#34;equalizer\u0026#34;), new AudioFilter(\u0026#34;壓縮器\u0026#34;, \u0026#34;compressor\u0026#34;), new AudioFilter(\u0026#34;限制器\u0026#34;, \u0026#34;limiter\u0026#34;) ); } } // 視頻播放器實作（實作視頻相關介面） @Component public class VideoPlayer implements VideoPlayable, SubtitleSupport, VideoFilterSupport { private int brightness = 50; private int contrast = 50; private boolean subtitlesVisible = false; private String currentSubtitleFile; @Override public void play(String file) { System.out.println(\u0026#34;播放視頻檔案: \u0026#34; + file); } @Override public void pause() { System.out.println(\u0026#34;暫停視頻\u0026#34;); } @Override public void stop() { System.out.println(\u0026#34;停止視頻\u0026#34;); } @Override public void seek(long position) { System.out.println(\u0026#34;跳轉到視頻位置: \u0026#34; + position + \u0026#34; 秒\u0026#34;); } @Override public void adjustBrightness(int brightness) { this.brightness = Math.max(0, Math.min(100, brightness)); System.out.println(\u0026#34;亮度調整為: \u0026#34; + this.brightness); } @Override public void adjustContrast(int contrast) { this.contrast = Math.max(0, Math.min(100, contrast)); System.out.println(\u0026#34;對比度調整為: \u0026#34; + this.contrast); } @Override public int getBrightness() { return brightness; } @Override public int getContrast() { return contrast; } // 字幕支援 @Override public void loadSubtitles(String subtitleFile) { this.currentSubtitleFile = subtitleFile; System.out.println(\u0026#34;載入字幕檔案: \u0026#34; + subtitleFile); } @Override public void showSubtitles(boolean show) { this.subtitlesVisible = show; System.out.println(\u0026#34;字幕顯示: \u0026#34; + (show ? \u0026#34;開啟\u0026#34; : \u0026#34;關閉\u0026#34;)); } @Override public void adjustSubtitleSize(int size) { System.out.println(\u0026#34;字幕大小調整為: \u0026#34; + size); } // 視頻濾鏡支援 @Override public void applyVideoFilter(VideoFilter filter) { System.out.println(\u0026#34;應用視頻濾鏡: \u0026#34; + filter.getName()); } @Override public void removeVideoFilter() { System.out.println(\u0026#34;移除視頻濾鏡\u0026#34;); } @Override public List\u0026lt;VideoFilter\u0026gt; getAvailableVideoFilters() { return Arrays.asList( new VideoFilter(\u0026#34;模糊\u0026#34;, \u0026#34;blur\u0026#34;), new VideoFilter(\u0026#34;銳化\u0026#34;, \u0026#34;sharpen\u0026#34;), new VideoFilter(\u0026#34;色彩增強\u0026#34;, \u0026#34;color_enhance\u0026#34;) ); } } // 媒體管理服務（使用介面隔離的好處） @Service public class MediaManagementService { // 只處理播放功能 public void playMedia(Playable player, String file) { player.play(file); } // 只處理音頻播放 public void playAudioWithVolume(AudioPlayable audioPlayer, String file, int volume) { audioPlayer.adjustVolume(volume); audioPlayer.play(file); } // 只處理錄音功能 public void recordAudio(AudioRecordable recorder, String outputFile) { if (!recorder.isRecording()) { recorder.startAudioRecording(outputFile); } } // 只處理字幕功能 public void setupSubtitles(SubtitleSupport player, String subtitleFile) { player.loadSubtitles(subtitleFile); player.showSubtitles(true); } } 5. Dependency Inversion Principle (DIP) - 依賴反轉原則 定義 高層模組不應該依賴低層模組，兩者都應該依賴於抽象。抽象不應該依賴於細節，細節應該依賴於抽象。\n核心概念 依賴注入：透過外部注入依賴而非內部創建 控制反轉：將依賴關係的控制權交給外部容器 抽象依賴：依賴於介面而非具體實作 違反 DIP 的範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // ❌ 違反 DIP：高層模組直接依賴低層模組的具體實作 public class MySQLDatabase { public void save(String data) { System.out.println(\u0026#34;儲存資料到 MySQL: \u0026#34; + data); } public String load(String id) { return \u0026#34;從 MySQL 載入資料: \u0026#34; + id; } } public class EmailService { public void sendEmail(String to, String subject, String body) { System.out.println(\u0026#34;發送郵件到: \u0026#34; + to); System.out.println(\u0026#34;主題: \u0026#34; + subject); System.out.println(\u0026#34;內容: \u0026#34; + body); } } // ❌ UserService 直接依賴具體實作，難以測試和擴展 public class UserService { private MySQLDatabase database; // 直接依賴具體實作 private EmailService emailService; // 直接依賴具體實作 public UserService() { this.database = new MySQLDatabase(); // 在構造函數中創建依賴 this.emailService = new EmailService(); // 硬編碼依賴 } public void createUser(String username, String email) { // 驗證邏輯 if (username == null || username.trim().isEmpty()) { throw new IllegalArgumentException(\u0026#34;用戶名不能為空\u0026#34;); } // 儲存用戶（依賴具體的 MySQL 實作） String userData = \u0026#34;User: \u0026#34; + username + \u0026#34;, Email: \u0026#34; + email; database.save(userData); // 發送歡迎郵件（依賴具體的郵件服務實作） emailService.sendEmail(email, \u0026#34;歡迎\u0026#34;, \u0026#34;歡迎加入我們的平台！\u0026#34;); } public String getUser(String userId) { return database.load(userId); } } 遵循 DIP 的重構範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 // ✅ 遵循 DIP：定義抽象介面 // 資料庫抽象介面 public interface UserRepository { void save(User user); Optional\u0026lt;User\u0026gt; findById(String id); Optional\u0026lt;User\u0026gt; findByEmail(String email); List\u0026lt;User\u0026gt; findAll(); void delete(String id); } // 通知服務抽象介面 public interface NotificationService { void sendWelcomeNotification(User user); void sendPasswordResetNotification(User user, String resetToken); void sendAccountActivationNotification(User user, String activationToken); } // 用戶驗證抽象介面 public interface UserValidator { ValidationResult validate(User user); boolean isEmailUnique(String email); boolean isUsernameValid(String username); } // 具體實作 - MySQL 資料庫 @Repository public class MySQLUserRepository implements UserRepository { @Override public void save(User user) { System.out.println(\u0026#34;儲存用戶到 MySQL: \u0026#34; + user.getUsername()); // 實際的資料庫操作邏輯 } @Override public Optional\u0026lt;User\u0026gt; findById(String id) { System.out.println(\u0026#34;從 MySQL 查找用戶: \u0026#34; + id); // 實際的查詢邏輯 return Optional.of(new User(id, \u0026#34;user@example.com\u0026#34;)); } @Override public Optional\u0026lt;User\u0026gt; findByEmail(String email) { System.out.println(\u0026#34;從 MySQL 根據郵箱查找用戶: \u0026#34; + email); return Optional.empty(); } @Override public List\u0026lt;User\u0026gt; findAll() { System.out.println(\u0026#34;從 MySQL 查找所有用戶\u0026#34;); return Arrays.asList(new User(\u0026#34;1\u0026#34;, \u0026#34;user1@example.com\u0026#34;)); } @Override public void delete(String id) { System.out.println(\u0026#34;從 MySQL 刪除用戶: \u0026#34; + id); } } // 具體實作 - MongoDB 資料庫（可替換實作） @Repository @Profile(\u0026#34;mongodb\u0026#34;) public class MongoUserRepository implements UserRepository { @Override public void save(User user) { System.out.println(\u0026#34;儲存用戶到 MongoDB: \u0026#34; + user.getUsername()); } @Override public Optional\u0026lt;User\u0026gt; findById(String id) { System.out.println(\u0026#34;從 MongoDB 查找用戶: \u0026#34; + id); return Optional.of(new User(id, \u0026#34;user@example.com\u0026#34;)); } @Override public Optional\u0026lt;User\u0026gt; findByEmail(String email) { System.out.println(\u0026#34;從 MongoDB 根據郵箱查找用戶: \u0026#34; + email); return Optional.empty(); } @Override public List\u0026lt;User\u0026gt; findAll() { System.out.println(\u0026#34;從 MongoDB 查找所有用戶\u0026#34;); return Arrays.asList(new User(\u0026#34;1\u0026#34;, \u0026#34;user1@example.com\u0026#34;)); } @Override public void delete(String id) { System.out.println(\u0026#34;從 MongoDB 刪除用戶: \u0026#34; + id); } } // 具體實作 - 郵件通知服務 @Service public class EmailNotificationService implements NotificationService { @Override public void sendWelcomeNotification(User user) { System.out.println(\u0026#34;發送歡迎郵件到: \u0026#34; + user.getEmail()); // 實際的郵件發送邏輯 } @Override public void sendPasswordResetNotification(User user, String resetToken) { System.out.println(\u0026#34;發送密碼重設郵件到: \u0026#34; + user.getEmail()); System.out.println(\u0026#34;重設令牌: \u0026#34; + resetToken); } @Override public void sendAccountActivationNotification(User user, String activationToken) { System.out.println(\u0026#34;發送帳戶啟用郵件到: \u0026#34; + user.getEmail()); System.out.println(\u0026#34;啟用令牌: \u0026#34; + activationToken); } } // 具體實作 - SMS 通知服務（可替換實作） @Service @Profile(\u0026#34;sms\u0026#34;) public class SMSNotificationService implements NotificationService { @Override public void sendWelcomeNotification(User user) { System.out.println(\u0026#34;發送歡迎 SMS 到: \u0026#34; + user.getPhoneNumber()); } @Override public void sendPasswordResetNotification(User user, String resetToken) { System.out.println(\u0026#34;發送密碼重設 SMS 到: \u0026#34; + user.getPhoneNumber()); System.out.println(\u0026#34;重設代碼: \u0026#34; + resetToken); } @Override public void sendAccountActivationNotification(User user, String activationToken) { System.out.println(\u0026#34;發送帳戶啟用 SMS 到: \u0026#34; + user.getPhoneNumber()); System.out.println(\u0026#34;啟用代碼: \u0026#34; + activationToken); } } // 具體實作 - 用戶驗證器 @Component public class DefaultUserValidator implements UserValidator { private final UserRepository userRepository; public DefaultUserValidator(UserRepository userRepository) { this.userRepository = userRepository; } @Override public ValidationResult validate(User user) { ValidationResult result = new ValidationResult(); if (!isUsernameValid(user.getUsername())) { result.addError(\u0026#34;用戶名格式無效\u0026#34;); } if (!isEmailValid(user.getEmail())) { result.addError(\u0026#34;郵箱格式無效\u0026#34;); } if (!isEmailUnique(user.getEmail())) { result.addError(\u0026#34;郵箱已被使用\u0026#34;); } return result; } @Override public boolean isEmailUnique(String email) { return userRepository.findByEmail(email).isEmpty(); } @Override public boolean isUsernameValid(String username) { return username != null \u0026amp;\u0026amp; username.trim().length() \u0026gt;= 3 \u0026amp;\u0026amp; username.trim().length() \u0026lt;= 50 \u0026amp;\u0026amp; username.matches(\u0026#34;^[a-zA-Z0-9_]+$\u0026#34;); } private boolean isEmailValid(String email) { return email != null \u0026amp;\u0026amp; email.contains(\u0026#34;@\u0026#34;) \u0026amp;\u0026amp; email.contains(\u0026#34;.\u0026#34;) \u0026amp;\u0026amp; email.length() \u0026gt; 5; } } // 高層模組 - 用戶服務（依賴於抽象） @Service public class UserService { private final UserRepository userRepository; private final NotificationService notificationService; private final UserValidator userValidator; // 依賴注入：透過構造函數注入依賴 public UserService(UserRepository userRepository, NotificationService notificationService, UserValidator userValidator) { this.userRepository = userRepository; this.notificationService = notificationService; this.userValidator = userValidator; } public Result\u0026lt;User\u0026gt; createUser(String username, String email) { User user = new User(username, email); // 驗證用戶資料 ValidationResult validation = userValidator.validate(user); if (!validation.isValid()) { return Result.failure(\u0026#34;驗證失敗: \u0026#34; + validation.getErrors()); } try { // 儲存用戶 userRepository.save(user); // 發送通知 notificationService.sendWelcomeNotification(user); return Result.success(user); } catch (Exception e) { return Result.failure(\u0026#34;創建用戶失敗: \u0026#34; + e.getMessage()); } } public Result\u0026lt;User\u0026gt; getUserById(String id) { Optional\u0026lt;User\u0026gt; user = userRepository.findById(id); if (user.isPresent()) { return Result.success(user.get()); } else { return Result.failure(\u0026#34;用戶不存在\u0026#34;); } } public Result\u0026lt;Void\u0026gt; resetPassword(String email) { Optional\u0026lt;User\u0026gt; userOpt = userRepository.findByEmail(email); if (userOpt.isEmpty()) { return Result.failure(\u0026#34;用戶不存在\u0026#34;); } User user = userOpt.get(); String resetToken = generateResetToken(); // 儲存重設令牌（實際應該儲存到資料庫） // userRepository.saveResetToken(user.getId(), resetToken); // 發送重設通知 notificationService.sendPasswordResetNotification(user, resetToken); return Result.success(null); } private String generateResetToken() { return \u0026#34;RESET-\u0026#34; + UUID.randomUUID().toString(); } } // 配置類別（控制依賴注入） @Configuration public class UserServiceConfiguration { @Bean @ConditionalOnProperty(name = \u0026#34;database.type\u0026#34;, havingValue = \u0026#34;mysql\u0026#34;, matchIfMissing = true) public UserRepository mysqlUserRepository() { return new MySQLUserRepository(); } @Bean @ConditionalOnProperty(name = \u0026#34;database.type\u0026#34;, havingValue = \u0026#34;mongodb\u0026#34;) public UserRepository mongoUserRepository() { return new MongoUserRepository(); } @Bean @ConditionalOnProperty(name = \u0026#34;notification.type\u0026#34;, havingValue = \u0026#34;email\u0026#34;, matchIfMissing = true) public NotificationService emailNotificationService() { return new EmailNotificationService(); } @Bean @ConditionalOnProperty(name = \u0026#34;notification.type\u0026#34;, havingValue = \u0026#34;sms\u0026#34;) public NotificationService smsNotificationService() { return new SMSNotificationService(); } } DIP 的進階應用：工廠模式與策略模式結合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 // 報表生成策略介面 public interface ReportGenerator { String generateReport(List\u0026lt;User\u0026gt; users); String getReportFormat(); } // CSV 報表生成器 @Component(\u0026#34;csvReportGenerator\u0026#34;) public class CSVReportGenerator implements ReportGenerator { @Override public String generateReport(List\u0026lt;User\u0026gt; users) { StringBuilder csv = new StringBuilder(); csv.append(\u0026#34;用戶名,郵箱,創建時間\\n\u0026#34;); users.forEach(user -\u0026gt; csv.append(String.format(\u0026#34;%s,%s,%s\\n\u0026#34;, user.getUsername(), user.getEmail(), user.getCreatedAt())) ); return csv.toString(); } @Override public String getReportFormat() { return \u0026#34;CSV\u0026#34;; } } // JSON 報表生成器 @Component(\u0026#34;jsonReportGenerator\u0026#34;) public class JSONReportGenerator implements ReportGenerator { private final ObjectMapper objectMapper; public JSONReportGenerator(ObjectMapper objectMapper) { this.objectMapper = objectMapper; } @Override public String generateReport(List\u0026lt;User\u0026gt; users) { try { Map\u0026lt;String, Object\u0026gt; report = new HashMap\u0026lt;\u0026gt;(); report.put(\u0026#34;totalUsers\u0026#34;, users.size()); report.put(\u0026#34;generatedAt\u0026#34;, LocalDateTime.now()); report.put(\u0026#34;users\u0026#34;, users); return objectMapper.writeValueAsString(report); } catch (Exception e) { throw new RuntimeException(\u0026#34;JSON 報表生成失敗\u0026#34;, e); } } @Override public String getReportFormat() { return \u0026#34;JSON\u0026#34;; } } // 報表工廠 @Service public class ReportGeneratorFactory { private final Map\u0026lt;String, ReportGenerator\u0026gt; generators; public ReportGeneratorFactory(Map\u0026lt;String, ReportGenerator\u0026gt; generators) { this.generators = generators; } public ReportGenerator getGenerator(String format) { ReportGenerator generator = generators.get(format.toLowerCase() + \u0026#34;ReportGenerator\u0026#34;); if (generator == null) { throw new IllegalArgumentException(\u0026#34;不支援的報表格式: \u0026#34; + format); } return generator; } public List\u0026lt;String\u0026gt; getSupportedFormats() { return generators.values().stream() .map(ReportGenerator::getReportFormat) .collect(Collectors.toList()); } } // 報表服務（高層模組，依賴於抽象） @Service public class UserReportService { private final UserRepository userRepository; private final ReportGeneratorFactory reportGeneratorFactory; public UserReportService(UserRepository userRepository, ReportGeneratorFactory reportGeneratorFactory) { this.userRepository = userRepository; this.reportGeneratorFactory = reportGeneratorFactory; } public String generateUserReport(String format) { List\u0026lt;User\u0026gt; users = userRepository.findAll(); ReportGenerator generator = reportGeneratorFactory.getGenerator(format); return generator.generateReport(users); } public List\u0026lt;String\u0026gt; getSupportedReportFormats() { return reportGeneratorFactory.getSupportedFormats(); } } 總結 SOLID 原則是軟體設計的基石，它們相互補充，共同促進程式碼的品質：\n核心價值 可維護性：每個原則都有助於降低程式碼修改的複雜度 可擴展性：支援新功能的增加而不破壞現有功能 可測試性：依賴注入和介面隔離使單元測試更容易 可重用性：職責明確的類別可以在不同場景中重複使用 實踐建議 從小處開始：在新專案中逐步應用 SOLID 原則 重構現有程式碼：識別違反 SOLID 原則的程式碼並逐步改進 使用現代框架：Spring、依賴注入容器等工具有助於實踐 SOLID 原則 程式碼審查：在團隊中推廣 SOLID 原則的理解和應用 持續學習：SOLID 原則是軟體架構的基礎，需要在實踐中不斷深化理解 常見陷阱 過度設計：不要為了遵循原則而增加不必要的複雜性 教條主義：原則是指導而非絕對規則，需要根據具體情況靈活應用 忽略性能：在追求設計原則的同時要考慮性能影響 缺乏漸進性：不要試圖一次性重構整個系統，要採用漸進式改進 SOLID 原則不僅適用於物件導向程式設計，在微服務架構、函數式程式設計等現代軟體架構中同樣具有指導意義。掌握這些原則將顯著提升你的軟體設計能力。\n參考資料 Clean Code by Robert C. Martin Agile Software Development, Principles, Patterns, and Practices SOLID Principles of Object Oriented Design Spring Framework Documentation ","permalink":"https://xinqilin.github.io/post/architecture/solid/","tags":["SOLID","Design Principles","OOP","Software Architecture","Clean Code","Best Practices"],"title":"SOLID 設計原則完整指南：物件導向程式設計的五大核心原則"},{"content":"筆記 Vue 未整理 version 套件 vetur vue2 snippets webpack -\u0026gt; npm install webpack -g vue -\u0026gt; npm install -g @vue/cli-init chrome: vue plugin\n快速開始 vue init webpack \u0026lt;你的app名字\u0026gt;\nnpm run dev\nmain.js -\u0026gt; 路由 index.js 在 [router 內]\n1 2 3 4 5 6 7 8 9 10 export default new Router({ routes:[ { path: \u0026#39;/\u0026#39;, name: \u0026#39;HelloWorld\u0026#39;, component: HelloWorld } ] }) HelloWorld.vue 內容 在 [components內]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data(){ return name: \u0026#39;Bill\u0026#39; } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 跳頁\n1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;router-link to=\u0026#34;/HelloWorld\u0026#34;\u0026gt;go to hello world\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 單向綁定 1 2 3 4 v-text v-html v-bind:href=\u0026#34;link\u0026#34; vue instance 內的 method 的 data:{link} (v-bind:href 可縮寫:href) 雙向綁定 v-model\n綁定事件 1 2 3 4 5 6 7 8 9 10 v-on:click=\u0026#34;num++\u0026#34; = @click v-on 防止事件冒泡{ `.stop`: 阻止事件冒泡倒父層 `.prevent`: 阻止默認(預設) 事件發生 `.capture`: 阻止事件捕獲模式 `.self`: 只有自身觸發事件才執行 `.once`: 只執行一次 } 按鍵修飾符 v-on:keyup.13 1 2 3 4 5 6 7 8 9 10 11 12 13 13 是鍵碼 v-on 按鍵修飾符 懶人包{ `.enter` `.tab` `.delete` `.esc` `.space` `.up` `.down` `.left` `.right` } v-for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 v-for = \u0026#34;user in users\u0026#34; 或 v-for=\u0026#34;(user, index) in users\u0026#34; v-for = \u0026#34;(value, key, index) in users\u0026#34; {{value}} {{key}} {{index}} v-for 增加 :key = \u0026#34;\u0026#34; 可增加效率 最主要是是別惟一值 :key 是 v-bind縮寫 v-if 裡面都填boolean 整個標籤不見 v-show 裡面都填boolean 是用 display:none 常跟 v-if 一起用 v-else-if v-else 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // computed 計算屬性 // watch 監控屬性 // filter 過濾屬性 -\u0026gt; 使用 {{user.gender | genderFilter}} new Vue({ el: \u0026#34;#app\u0026#34;, data:{ a:100, b:200 }, computed: { total: function(){ return this.a+this.b } }, watch:{ a: function(newValue, oldValue){ alert(\u0026#34;new: \u0026#34;+newValue+\u0026#34; , old: \u0026#34;+oldValue) if(a\u0026gt;3){ this.msg = \u0026#34;太多\u0026#34; } } }, filters:{ genderFilter(val){ if(val == 1) return \u0026#34;male\u0026#34; else return \u0026#34;female\u0026#34; } } }) 組件:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;script\u0026gt; Global 組件: Vue.component(\u0026#34;counter\u0026#34;,{ template: `\u0026lt;button v-on:click = \u0026#34;count++\u0026#34;\u0026gt; {{count}}\u0026lt;/button\u0026gt;` data(){ return { count: 0 } } }); 區域組件: const buttonCounter = { template: `\u0026lt;button v-on:click = \u0026#34;count++\u0026#34;\u0026gt; {{count}}\u0026lt;/button\u0026gt;` data(){ return { count: 0 } } } 後 放入 vue instance components:{}中 components:{ \u0026#39;button-counter 名字\u0026#39;: buttonCounter } ``` \u0026lt;button-counter\u0026gt;\u0026lt;/button-counter\u0026gt; 使用 ``` \u0026lt;/script\u0026gt; lifeCycle 1 2 3 4 5 6 7 8 9 10 11 let app = new Vue(){ el: app, data: { }, beforeCreate: function(){ } // 放一些生命週期的東西 }; ","permalink":"https://xinqilin.github.io/post/frontend/vue-intro/","tags":[],"title":"Vue Intro"},{"content":"概述 JSON Web Token (JWT) 是一種開放標準 (RFC 7519)，定義了一種簡潔、自包含的方式，用於在各方之間安全地傳輸資訊。JWT 在現代 Web 應用程式中廣泛用於身份驗證和授權，特別適合分散式系統和微服務架構。\nJWT 核心特徵 無狀態性：伺服器不需要儲存 Session 資訊 可擴展性：適合分散式和微服務環境 跨域支援：支援跨網域請求 自包含：Token 包含所有必要的使用者資訊 數位簽名：確保 Token 的完整性和真實性 JWT 結構 JWT 由三部分組成，以點號（.）分隔：\n1 Header.Payload.Signature Header：包含 Token 類型和簽名演算法 Payload：包含聲明（Claims），即使用者資訊和其他資料 Signature：用於驗證 Token 是否被篡改 Spring Boot 整合實作 1. 依賴配置 Maven 依賴設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;jjwt.version\u0026gt;0.12.3\u0026lt;/jjwt.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!-- Spring Boot Starters --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- JWT Library (推薦使用最新版本) --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jjwt.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-impl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jjwt.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-jackson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jjwt.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Gradle 依賴設定 1 2 3 4 5 6 7 8 9 10 dependencies { implementation \u0026#39;org.springframework.boot:spring-boot-starter-web\u0026#39; implementation \u0026#39;org.springframework.boot:spring-boot-starter-security\u0026#39; implementation \u0026#39;org.springframework.boot:spring-boot-starter-data-jpa\u0026#39; implementation \u0026#39;org.springframework.boot:spring-boot-starter-validation\u0026#39; implementation \u0026#39;io.jsonwebtoken:jjwt-api:0.12.3\u0026#39; runtimeOnly \u0026#39;io.jsonwebtoken:jjwt-impl:0.12.3\u0026#39; runtimeOnly \u0026#39;io.jsonwebtoken:jjwt-jackson:0.12.3\u0026#39; } 2. 資料模型 認證請求 DTO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package com.example.jwt.dto; import jakarta.validation.constraints.NotBlank; import jakarta.validation.constraints.Size; public class AuthenticationRequest { @NotBlank(message = \u0026#34;使用者名稱不能為空\u0026#34;) @Size(min = 3, max = 50, message = \u0026#34;使用者名稱長度必須在3-50字符之間\u0026#34;) private String username; @NotBlank(message = \u0026#34;密碼不能為空\u0026#34;) @Size(min = 6, max = 100, message = \u0026#34;密碼長度必須在6-100字符之間\u0026#34;) private String password; // 建構子 public AuthenticationRequest() {} public AuthenticationRequest(String username, String password) { this.username = username; this.password = password; } // Getters and Setters public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } 認證回應 DTO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package com.example.jwt.dto; import com.fasterxml.jackson.annotation.JsonProperty; public class AuthenticationResponse { @JsonProperty(\u0026#34;access_token\u0026#34;) private final String accessToken; @JsonProperty(\u0026#34;token_type\u0026#34;) private final String tokenType = \u0026#34;Bearer\u0026#34;; @JsonProperty(\u0026#34;expires_in\u0026#34;) private final long expiresIn; @JsonProperty(\u0026#34;refresh_token\u0026#34;) private String refreshToken; public AuthenticationResponse(String accessToken, long expiresIn) { this.accessToken = accessToken; this.expiresIn = expiresIn; } public AuthenticationResponse(String accessToken, long expiresIn, String refreshToken) { this.accessToken = accessToken; this.expiresIn = expiresIn; this.refreshToken = refreshToken; } // Getters public String getAccessToken() { return accessToken; } public String getTokenType() { return tokenType; } public long getExpiresIn() { return expiresIn; } public String getRefreshToken() { return refreshToken; } } 使用者實體 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 package com.example.jwt.entity; import jakarta.persistence.*; import jakarta.validation.constraints.Email; import jakarta.validation.constraints.NotBlank; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.userdetails.UserDetails; import java.time.LocalDateTime; import java.util.*; import java.util.stream.Collectors; @Entity @Table(name = \u0026#34;users\u0026#34;) public class User implements UserDetails { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotBlank @Column(unique = true, nullable = false) private String username; @NotBlank @Email @Column(unique = true, nullable = false) private String email; @NotBlank @Column(nullable = false) private String password; @Column(name = \u0026#34;first_name\u0026#34;) private String firstName; @Column(name = \u0026#34;last_name\u0026#34;) private String lastName; @Column(name = \u0026#34;enabled\u0026#34;) private boolean enabled = true; @Column(name = \u0026#34;account_non_expired\u0026#34;) private boolean accountNonExpired = true; @Column(name = \u0026#34;credentials_non_expired\u0026#34;) private boolean credentialsNonExpired = true; @Column(name = \u0026#34;account_non_locked\u0026#34;) private boolean accountNonLocked = true; @Column(name = \u0026#34;created_at\u0026#34;) private LocalDateTime createdAt = LocalDateTime.now(); @Column(name = \u0026#34;updated_at\u0026#34;) private LocalDateTime updatedAt = LocalDateTime.now(); @ElementCollection(targetClass = Role.class, fetch = FetchType.EAGER) @Enumerated(EnumType.STRING) @CollectionTable(name = \u0026#34;user_roles\u0026#34;) private Set\u0026lt;Role\u0026gt; roles = new HashSet\u0026lt;\u0026gt;(); // 建構子 public User() {} public User(String username, String email, String password) { this.username = username; this.email = email; this.password = password; this.roles.add(Role.USER); } // UserDetails interface 實作 @Override public Collection\u0026lt;? extends GrantedAuthority\u0026gt; getAuthorities() { return roles.stream() .map(role -\u0026gt; new SimpleGrantedAuthority(\u0026#34;ROLE_\u0026#34; + role.name())) .collect(Collectors.toList()); } @Override public String getPassword() { return password; } @Override public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return accountNonExpired; } @Override public boolean isAccountNonLocked() { return accountNonLocked; } @Override public boolean isCredentialsNonExpired() { return credentialsNonExpired; } @Override public boolean isEnabled() { return enabled; } // Getters and Setters public Long getId() { return id; } public void setId(Long id) { this.id = id; } public void setUsername(String username) { this.username = username; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public void setPassword(String password) { this.password = password; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public Set\u0026lt;Role\u0026gt; getRoles() { return roles; } public void setRoles(Set\u0026lt;Role\u0026gt; roles) { this.roles = roles; } public LocalDateTime getCreatedAt() { return createdAt; } public LocalDateTime getUpdatedAt() { return updatedAt; } @PreUpdate public void preUpdate() { this.updatedAt = LocalDateTime.now(); } } enum Role { USER, ADMIN, MODERATOR } 3. JWT 工具類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 package com.example.jwt.util; import io.jsonwebtoken.*; import io.jsonwebtoken.io.Decoders; import io.jsonwebtoken.security.Keys; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Value; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.stereotype.Component; import javax.crypto.SecretKey; import java.util.Date; import java.util.HashMap; import java.util.Map; import java.util.function.Function; @Component public class JwtUtil { private static final Logger logger = LoggerFactory.getLogger(JwtUtil.class); @Value(\u0026#34;${jwt.secret}\u0026#34;) private String jwtSecret; @Value(\u0026#34;${jwt.expiration}\u0026#34;) private long jwtExpiration; @Value(\u0026#34;${jwt.refresh-expiration}\u0026#34;) private long refreshExpiration; /** * 從 Token 中提取使用者名稱 */ public String extractUsername(String token) { return extractClaim(token, Claims::getSubject); } /** * 從 Token 中提取過期時間 */ public Date extractExpiration(String token) { return extractClaim(token, Claims::getExpiration); } /** * 從 Token 中提取特定的聲明 */ public \u0026lt;T\u0026gt; T extractClaim(String token, Function\u0026lt;Claims, T\u0026gt; claimsResolver) { final Claims claims = extractAllClaims(token); return claimsResolver.apply(claims); } /** * 提取 Token 中的所有聲明 */ private Claims extractAllClaims(String token) { try { return Jwts.parser() .verifyWith(getSignInKey()) .build() .parseSignedClaims(token) .getPayload(); } catch (ExpiredJwtException e) { logger.warn(\u0026#34;JWT token 已過期: {}\u0026#34;, e.getMessage()); throw e; } catch (UnsupportedJwtException e) { logger.warn(\u0026#34;不支援的 JWT token: {}\u0026#34;, e.getMessage()); throw e; } catch (MalformedJwtException e) { logger.warn(\u0026#34;格式錯誤的 JWT token: {}\u0026#34;, e.getMessage()); throw e; } catch (IllegalArgumentException e) { logger.warn(\u0026#34;JWT claims string 為空: {}\u0026#34;, e.getMessage()); throw e; } } /** * 檢查 Token 是否過期 */ public boolean isTokenExpired(String token) { try { return extractExpiration(token).before(new Date()); } catch (ExpiredJwtException e) { return true; } } /** * 生成訪問 Token */ public String generateAccessToken(UserDetails userDetails) { Map\u0026lt;String, Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(\u0026#34;roles\u0026#34;, userDetails.getAuthorities()); return createToken(claims, userDetails.getUsername(), jwtExpiration); } /** * 生成刷新 Token */ public String generateRefreshToken(UserDetails userDetails) { return createToken(new HashMap\u0026lt;\u0026gt;(), userDetails.getUsername(), refreshExpiration); } /** * 創建 Token */ private String createToken(Map\u0026lt;String, Object\u0026gt; claims, String subject, long expiration) { Date now = new Date(); Date expiryDate = new Date(now.getTime() + expiration); return Jwts.builder() .claims(claims) .subject(subject) .issuedAt(now) .expiration(expiryDate) .signWith(getSignInKey()) .compact(); } /** * 驗證 Token */ public boolean validateToken(String token, UserDetails userDetails) { try { final String username = extractUsername(token); return (username.equals(userDetails.getUsername()) \u0026amp;\u0026amp; !isTokenExpired(token)); } catch (JwtException | IllegalArgumentException e) { logger.warn(\u0026#34;JWT token 驗證失敗: {}\u0026#34;, e.getMessage()); return false; } } /** * 驗證 Token 格式和簽名 */ public boolean validateToken(String token) { try { Jwts.parser() .verifyWith(getSignInKey()) .build() .parseSignedClaims(token); return true; } catch (JwtException | IllegalArgumentException e) { logger.warn(\u0026#34;JWT token 驗證失敗: {}\u0026#34;, e.getMessage()); return false; } } /** * 獲取簽名金鑰 */ private SecretKey getSignInKey() { byte[] keyBytes = Decoders.BASE64.decode(jwtSecret); return Keys.hmacShaKeyFor(keyBytes); } /** * 獲取 Token 的剩餘有效時間（毫秒） */ public long getExpirationTime() { return jwtExpiration; } /** * 檢查 Token 是否需要刷新（剩餘時間少於 30 分鐘） */ public boolean shouldRefreshToken(String token) { try { Date expiration = extractExpiration(token); Date now = new Date(); long timeLeft = expiration.getTime() - now.getTime(); return timeLeft \u0026lt; (30 * 60 * 1000); // 30 分鐘 } catch (Exception e) { return false; } } } 4. JWT 請求過濾器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 package com.example.jwt.filter; import com.example.jwt.service.CustomUserDetailsService; import com.example.jwt.util.JwtUtil; import jakarta.servlet.FilterChain; import jakarta.servlet.ServletException; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.web.authentication.WebAuthenticationDetailsSource; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import org.springframework.web.filter.OncePerRequestFilter; import java.io.IOException; @Component public class JwtAuthenticationFilter extends OncePerRequestFilter { private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class); private static final String BEARER_PREFIX = \u0026#34;Bearer \u0026#34;; private static final String AUTHORIZATION_HEADER = \u0026#34;Authorization\u0026#34;; @Autowired private JwtUtil jwtUtil; @Autowired private CustomUserDetailsService userDetailsService; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { try { String jwt = getJwtFromRequest(request); if (StringUtils.hasText(jwt) \u0026amp;\u0026amp; jwtUtil.validateToken(jwt)) { String username = jwtUtil.extractUsername(jwt); // 檢查 SecurityContext 中是否已有認證資訊 if (username != null \u0026amp;\u0026amp; SecurityContextHolder.getContext().getAuthentication() == null) { UserDetails userDetails = userDetailsService.loadUserByUsername(username); if (jwtUtil.validateToken(jwt, userDetails)) { UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken( userDetails, null, userDetails.getAuthorities()); authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); SecurityContextHolder.getContext().setAuthentication(authentication); logger.debug(\u0026#34;設定使用者 \u0026#39;{}\u0026#39; 的安全上下文\u0026#34;, username); } } } } catch (Exception e) { logger.error(\u0026#34;無法設定使用者認證: {}\u0026#34;, e.getMessage()); } filterChain.doFilter(request, response); } /** * 從請求中提取 JWT Token */ private String getJwtFromRequest(HttpServletRequest request) { String bearerToken = request.getHeader(AUTHORIZATION_HEADER); if (StringUtils.hasText(bearerToken) \u0026amp;\u0026amp; bearerToken.startsWith(BEARER_PREFIX)) { return bearerToken.substring(BEARER_PREFIX.length()); } return null; } @Override protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException { String path = request.getRequestURI(); // 排除不需要 JWT 驗證的路徑 return path.startsWith(\u0026#34;/api/auth/\u0026#34;) || path.startsWith(\u0026#34;/swagger-ui/\u0026#34;) || path.startsWith(\u0026#34;/v3/api-docs/\u0026#34;) || path.equals(\u0026#34;/health\u0026#34;) || path.equals(\u0026#34;/favicon.ico\u0026#34;); } } 5. Spring Security 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 package com.example.jwt.config; import com.example.jwt.filter.JwtAuthenticationFilter; import com.example.jwt.service.CustomUserDetailsService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.AuthenticationProvider; import org.springframework.security.authentication.dao.DaoAuthenticationProvider; import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration; import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.security.web.SecurityFilterChain; import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.CorsConfigurationSource; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import java.util.Arrays; @Configuration @EnableWebSecurity @EnableMethodSecurity(prePostEnabled = true) public class SecurityConfig { @Autowired private CustomUserDetailsService userDetailsService; @Autowired private JwtAuthenticationFilter jwtAuthenticationFilter; @Autowired private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint; @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(12); } @Bean public AuthenticationProvider authenticationProvider() { DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider(); authProvider.setUserDetailsService(userDetailsService); authProvider.setPasswordEncoder(passwordEncoder()); return authProvider; } @Bean public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception { return config.getAuthenticationManager(); } @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .csrf(AbstractHttpConfigurer::disable) .cors(cors -\u0026gt; cors.configurationSource(corsConfigurationSource())) .sessionManagement(session -\u0026gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) .authorizeHttpRequests(authz -\u0026gt; authz // 公開端點 .requestMatchers( \u0026#34;/api/auth/**\u0026#34;, \u0026#34;/swagger-ui/**\u0026#34;, \u0026#34;/v3/api-docs/**\u0026#34;, \u0026#34;/health\u0026#34;, \u0026#34;/favicon.ico\u0026#34; ).permitAll() // 管理員端點 .requestMatchers(\u0026#34;/api/admin/**\u0026#34;).hasRole(\u0026#34;ADMIN\u0026#34;) // 其他端點需要認證 .anyRequest().authenticated() ) .exceptionHandling(ex -\u0026gt; ex.authenticationEntryPoint(jwtAuthenticationEntryPoint)) .authenticationProvider(authenticationProvider()) .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class); return http.build(); } @Bean public CorsConfigurationSource corsConfigurationSource() { CorsConfiguration configuration = new CorsConfiguration(); configuration.setAllowedOriginPatterns(Arrays.asList(\u0026#34;*\u0026#34;)); configuration.setAllowedMethods(Arrays.asList(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;OPTIONS\u0026#34;)); configuration.setAllowedHeaders(Arrays.asList(\u0026#34;*\u0026#34;)); configuration.setAllowCredentials(true); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\u0026#34;/**\u0026#34;, configuration); return source; } } 6. 認證控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package com.example.jwt.controller; import com.example.jwt.dto.AuthenticationRequest; import com.example.jwt.dto.AuthenticationResponse; import com.example.jwt.service.AuthenticationService; import jakarta.validation.Valid; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; @RestController @RequestMapping(\u0026#34;/api/auth\u0026#34;) @CrossOrigin(origins = \u0026#34;*\u0026#34;, maxAge = 3600) public class AuthController { @Autowired private AuthenticationService authenticationService; /** * 使用者登入 */ @PostMapping(\u0026#34;/login\u0026#34;) public ResponseEntity\u0026lt;AuthenticationResponse\u0026gt; login( @Valid @RequestBody AuthenticationRequest request) { AuthenticationResponse response = authenticationService.authenticate(request); return ResponseEntity.ok(response); } /** * 刷新 Token */ @PostMapping(\u0026#34;/refresh\u0026#34;) public ResponseEntity\u0026lt;AuthenticationResponse\u0026gt; refreshToken( @RequestHeader(\u0026#34;Authorization\u0026#34;) String refreshToken) { AuthenticationResponse response = authenticationService.refreshToken(refreshToken); return ResponseEntity.ok(response); } /** * 登出（可選：加入黑名單機制） */ @PostMapping(\u0026#34;/logout\u0026#34;) public ResponseEntity\u0026lt;Void\u0026gt; logout(@RequestHeader(\u0026#34;Authorization\u0026#34;) String token) { authenticationService.logout(token); return ResponseEntity.ok().build(); } /** * 驗證 Token 有效性 */ @GetMapping(\u0026#34;/validate\u0026#34;) public ResponseEntity\u0026lt;Boolean\u0026gt; validateToken(@RequestHeader(\u0026#34;Authorization\u0026#34;) String token) { boolean isValid = authenticationService.validateToken(token); return ResponseEntity.ok(isValid); } } 7. 認證服務 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 package com.example.jwt.service; import com.example.jwt.dto.AuthenticationRequest; import com.example.jwt.dto.AuthenticationResponse; import com.example.jwt.util.JwtUtil; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.BadCredentialsException; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.Authentication; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.stereotype.Service; @Service public class AuthenticationService { @Autowired private AuthenticationManager authenticationManager; @Autowired private CustomUserDetailsService userDetailsService; @Autowired private JwtUtil jwtUtil; @Autowired private TokenBlacklistService tokenBlacklistService; /** * 認證使用者並生成 Token */ public AuthenticationResponse authenticate(AuthenticationRequest request) { try { // 驗證使用者憑證 Authentication authentication = authenticationManager.authenticate( new UsernamePasswordAuthenticationToken( request.getUsername(), request.getPassword() ) ); // 載入使用者詳細資訊 UserDetails userDetails = userDetailsService.loadUserByUsername(request.getUsername()); // 生成 Token String accessToken = jwtUtil.generateAccessToken(userDetails); String refreshToken = jwtUtil.generateRefreshToken(userDetails); return new AuthenticationResponse( accessToken, jwtUtil.getExpirationTime(), refreshToken ); } catch (BadCredentialsException e) { throw new BadCredentialsException(\u0026#34;使用者名稱或密碼錯誤\u0026#34;); } } /** * 刷新 Token */ public AuthenticationResponse refreshToken(String refreshToken) { // 移除 Bearer 前綴 String token = refreshToken.startsWith(\u0026#34;Bearer \u0026#34;) ? refreshToken.substring(7) : refreshToken; if (!jwtUtil.validateToken(token)) { throw new RuntimeException(\u0026#34;無效的刷新 Token\u0026#34;); } String username = jwtUtil.extractUsername(token); UserDetails userDetails = userDetailsService.loadUserByUsername(username); String newAccessToken = jwtUtil.generateAccessToken(userDetails); return new AuthenticationResponse(newAccessToken, jwtUtil.getExpirationTime()); } /** * 登出並將 Token 加入黑名單 */ public void logout(String token) { String jwtToken = token.startsWith(\u0026#34;Bearer \u0026#34;) ? token.substring(7) : token; tokenBlacklistService.blacklistToken(jwtToken); } /** * 驗證 Token */ public boolean validateToken(String token) { String jwtToken = token.startsWith(\u0026#34;Bearer \u0026#34;) ? token.substring(7) : token; return jwtUtil.validateToken(jwtToken) \u0026amp;\u0026amp; !tokenBlacklistService.isTokenBlacklisted(jwtToken); } } 配置檔案 application.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # JWT 配置 jwt: # 使用強密鑰（至少256位） secret: ${JWT_SECRET:dGhpc2lzYXZlcnlzZWN1cmVzZWNyZXRrZXl0aGF0aXNhdGxlYXN0MjU2Yml0c2xvbmc=} # Access Token 過期時間（15分鐘） expiration: 900000 # Refresh Token 過期時間（7天） refresh-expiration: 604800000 # Spring Security 配置 spring: security: # OAuth2 配置（可選） oauth2: client: registration: google: client-id: ${GOOGLE_CLIENT_ID:} client-secret: ${GOOGLE_CLIENT_SECRET:} scope: openid,profile,email # 日誌配置 logging: level: com.example.jwt: DEBUG org.springframework.security: DEBUG 安全性最佳實踐 1. 密鑰管理 1 2 3 4 5 6 7 8 // 生成安全的密鑰 public class KeyGenerator { public static void main(String[] args) { SecretKey key = Keys.secretKeyFor(SignatureAlgorithm.HS256); String encodedKey = Encoders.BASE64.encode(key.getEncoded()); System.out.println(\u0026#34;Generated key: \u0026#34; + encodedKey); } } 2. Token 黑名單服務 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.example.jwt.service; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Service; import java.util.concurrent.TimeUnit; @Service public class TokenBlacklistService { @Autowired private RedisTemplate\u0026lt;String, String\u0026gt; redisTemplate; private static final String BLACKLIST_PREFIX = \u0026#34;jwt:blacklist:\u0026#34;; /** * 將 Token 加入黑名單 */ public void blacklistToken(String token) { String key = BLACKLIST_PREFIX + token; // 設定過期時間等於 Token 的剩餘有效時間 redisTemplate.opsForValue().set(key, \u0026#34;blacklisted\u0026#34;, 24, TimeUnit.HOURS); } /** * 檢查 Token 是否在黑名單中 */ public boolean isTokenBlacklisted(String token) { String key = BLACKLIST_PREFIX + token; return Boolean.TRUE.equals(redisTemplate.hasKey(key)); } } 3. 異常處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package com.example.jwt.exception; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.security.authentication.BadCredentialsException; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.RestControllerAdvice; @RestControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(BadCredentialsException.class) public ResponseEntity\u0026lt;ErrorResponse\u0026gt; handleBadCredentials(BadCredentialsException e) { ErrorResponse error = new ErrorResponse( HttpStatus.UNAUTHORIZED.value(), \u0026#34;認證失敗\u0026#34;, e.getMessage() ); return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error); } @ExceptionHandler(JwtException.class) public ResponseEntity\u0026lt;ErrorResponse\u0026gt; handleJwtException(JwtException e) { ErrorResponse error = new ErrorResponse( HttpStatus.UNAUTHORIZED.value(), \u0026#34;Token 錯誤\u0026#34;, e.getMessage() ); return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error); } } class ErrorResponse { private int status; private String error; private String message; private long timestamp; public ErrorResponse(int status, String error, String message) { this.status = status; this.error = error; this.message = message; this.timestamp = System.currentTimeMillis(); } // Getters and Setters // ... } 使用範例 1. 前端整合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // JavaScript 前端範例 class AuthService { constructor() { this.baseURL = \u0026#39;http://localhost:8080/api\u0026#39;; this.token = localStorage.getItem(\u0026#39;accessToken\u0026#39;); } async login(username, password) { try { const response = await fetch(`${this.baseURL}/auth/login`, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, body: JSON.stringify({ username, password }) }); if (response.ok) { const data = await response.json(); this.token = data.access_token; localStorage.setItem(\u0026#39;accessToken\u0026#39;, this.token); localStorage.setItem(\u0026#39;refreshToken\u0026#39;, data.refresh_token); return data; } else { throw new Error(\u0026#39;登入失敗\u0026#39;); } } catch (error) { console.error(\u0026#39;登入錯誤:\u0026#39;, error); throw error; } } async apiCall(endpoint, options = {}) { const config = { ...options, headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${this.token}`, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, ...options.headers } }; let response = await fetch(`${this.baseURL}${endpoint}`, config); // 如果 Token 過期，嘗試刷新 if (response.status === 401) { await this.refreshToken(); config.headers[\u0026#39;Authorization\u0026#39;] = `Bearer ${this.token}`; response = await fetch(`${this.baseURL}${endpoint}`, config); } return response; } async refreshToken() { const refreshToken = localStorage.getItem(\u0026#39;refreshToken\u0026#39;); if (!refreshToken) { this.logout(); return; } try { const response = await fetch(`${this.baseURL}/auth/refresh`, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${refreshToken}` } }); if (response.ok) { const data = await response.json(); this.token = data.access_token; localStorage.setItem(\u0026#39;accessToken\u0026#39;, this.token); } else { this.logout(); } } catch (error) { console.error(\u0026#39;Token 刷新失敗:\u0026#39;, error); this.logout(); } } logout() { localStorage.removeItem(\u0026#39;accessToken\u0026#39;); localStorage.removeItem(\u0026#39;refreshToken\u0026#39;); this.token = null; window.location.href = \u0026#39;/login\u0026#39;; } } 2. 測試範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package com.example.jwt; import com.example.jwt.util.JwtUtil; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.UserDetails; import java.util.ArrayList; import static org.junit.jupiter.api.Assertions.*; @SpringBootTest public class JwtUtilTest { @Autowired private JwtUtil jwtUtil; @Test public void testGenerateAndValidateToken() { // 建立測試使用者 UserDetails userDetails = new User(\u0026#34;testuser\u0026#34;, \u0026#34;password\u0026#34;, new ArrayList\u0026lt;\u0026gt;()); // 生成 Token String token = jwtUtil.generateAccessToken(userDetails); assertNotNull(token); // 驗證 Token assertTrue(jwtUtil.validateToken(token, userDetails)); // 提取使用者名稱 String extractedUsername = jwtUtil.extractUsername(token); assertEquals(\u0026#34;testuser\u0026#34;, extractedUsername); // 檢查 Token 是否未過期 assertFalse(jwtUtil.isTokenExpired(token)); } } 效能最佳化 1. Redis 快取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Configuration @EnableCaching public class CacheConfig { @Bean public CacheManager cacheManager(RedisConnectionFactory connectionFactory) { RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofMinutes(15)) .serializeKeysWith(RedisSerializationContext.SerializationPair .fromSerializer(new StringRedisSerializer())) .serializeValuesWith(RedisSerializationContext.SerializationPair .fromSerializer(new GenericJackson2JsonRedisSerializer())); return RedisCacheManager.builder(connectionFactory) .cacheDefaults(config) .build(); } } 2. 非同步處理 1 2 3 4 5 6 7 8 9 10 11 @Service public class AsyncAuthService { @Async @EventListener public void handleUserLogin(UserLoginEvent event) { // 記錄登入日誌 // 發送通知 // 更新使用者統計 } } 監控和日誌 1. 認證監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component public class AuthenticationEventListener { private static final Logger logger = LoggerFactory.getLogger(AuthenticationEventListener.class); @EventListener public void onAuthenticationSuccess(AuthenticationSuccessEvent event) { String username = event.getAuthentication().getName(); logger.info(\u0026#34;使用者 {} 登入成功\u0026#34;, username); } @EventListener public void onAuthenticationFailure(AbstractAuthenticationFailureEvent event) { String username = event.getAuthentication().getName(); logger.warn(\u0026#34;使用者 {} 登入失敗: {}\u0026#34;, username, event.getException().getMessage()); } } 2. 效能監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Aspect @Component public class JwtPerformanceAspect { private static final Logger logger = LoggerFactory.getLogger(JwtPerformanceAspect.class); @Around(\u0026#34;execution(* com.example.jwt.util.JwtUtil.*(..))\u0026#34;) public Object measureExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable { long startTime = System.currentTimeMillis(); Object result = joinPoint.proceed(); long endTime = System.currentTimeMillis(); logger.debug(\u0026#34;方法 {} 執行時間: {} ms\u0026#34;, joinPoint.getSignature().getName(), endTime - startTime); return result; } } 常見問題與解決方案 1. Token 過期處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 自動 Token 刷新攔截器 @Component public class TokenRefreshInterceptor implements HandlerInterceptor { @Autowired private JwtUtil jwtUtil; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = getTokenFromRequest(request); if (token != null \u0026amp;\u0026amp; jwtUtil.shouldRefreshToken(token)) { // 設定回應標頭提示前端刷新 Token response.setHeader(\u0026#34;X-Token-Refresh-Required\u0026#34;, \u0026#34;true\u0026#34;); } return true; } } 2. 跨域處理 1 2 3 4 5 6 7 8 9 10 11 12 13 @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/api/**\u0026#34;) .allowedOriginPatterns(\u0026#34;*\u0026#34;) .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;OPTIONS\u0026#34;) .allowedHeaders(\u0026#34;*\u0026#34;) .allowCredentials(true) .maxAge(3600); } } 總結 核心優勢 無狀態性：伺服器無需存儲 Session，適合分散式系統 可擴展性：支援微服務架構和負載均衡 跨域支援：解決傳統 Session 的跨域問題 安全性：數位簽名確保 Token 完整性 靈活性：可攜帶自訂使用者資訊 最佳實踐 使用強密鑰：至少 256 位的隨機密鑰 適當的過期時間：短期 Access Token + 長期 Refresh Token Token 黑名單：支援登出和緊急撤銷 HTTPS 傳輸：確保 Token 傳輸安全 輸入驗證：驗證所有使用者輸入 錯誤處理：優雅處理認證錯誤 監控日誌：記錄認證事件和異常 常用命令速查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 生成密鑰 openssl rand -base64 32 # 解析 JWT Token echo \u0026#34;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...\u0026#34; | cut -d. -f2 | base64 -d # 測試 API curl -X POST http://localhost:8080/api/auth/login \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;password\u0026#34;}\u0026#39; # 使用 Token 訪問 API curl -X GET http://localhost:8080/api/users \\ -H \u0026#34;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...\u0026#34; JWT 是現代 Web 應用程式認證的標準解決方案，正確實作能夠提供安全、可擴展的認證機制。記住：安全性設計應該從一開始就考慮，而不是後續添加的功能。\n參考資料 JWT Official Website RFC 7519 - JSON Web Token Spring Security Documentation JJWT Library OWASP JWT Security Guide ","permalink":"https://xinqilin.github.io/post/backend/jwt/","tags":["JWT","Spring Security","Authentication","Java","Spring Boot","Security","REST API","Token"],"title":"JWT 認證機制完整實作：Spring Security 整合與最佳實踐"},{"content":"概述 Swagger（現稱為 OpenAPI）是目前最流行的 REST API 文檔化工具之一。它不僅能自動生成美觀的 API 文檔，還提供互動式測試介面，支援多種程式語言的客戶端程式碼生成。本文將全面介紹如何在 Spring Boot 專案中整合和使用 Swagger，從基礎配置到進階功能的完整實戰指南。\n版本選擇與依賴配置 OpenAPI 3.0 vs Swagger 2.0 特性 Swagger 2.0 OpenAPI 3.0 規範版本 較舊 最新標準 Spring Boot 支援 良好 原生支援 功能豐富度 基本功能 豐富特性 社群活躍度 維護模式 積極開發 推薦度 僅限舊專案 強烈推薦 現代化依賴配置（OpenAPI 3.0） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!-- 推薦：SpringDoc OpenAPI 3 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-starter-webmvc-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 安全整合 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-security\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- WebFlux 支援 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-starter-webflux-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 傳統 Swagger 2.0 配置（僅供參考） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;!-- 傳統：Springfox Swagger 2 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; OpenAPI 3.0 基礎配置 1. 應用程式配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # application.yml springdoc: api-docs: path: /api-docs enabled: true swagger-ui: path: /swagger-ui.html enabled: true operations-sorter: method tags-sorter: alpha try-it-out-enabled: true filter: true display-request-duration: true packages-to-scan: com.example.controller paths-to-match: /api/** default-consumes-media-type: application/json default-produces-media-type: application/json # 自訂配置 app: api: title: E-Commerce API description: 電商平台核心 API 服務 version: 1.0.0 contact: name: API Support Team email: api-support@example.com url: https://example.com/support license: name: Apache 2.0 url: https://www.apache.org/licenses/LICENSE-2.0.html terms-of-service: https://example.com/terms 2. 進階 OpenAPI 配置類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @Configuration @EnableOpenApi public class OpenApiConfiguration { @Value(\u0026#34;${app.api.title}\u0026#34;) private String title; @Value(\u0026#34;${app.api.description}\u0026#34;) private String description; @Value(\u0026#34;${app.api.version}\u0026#34;) private String version; @Bean public OpenAPI customOpenAPI() { return new OpenAPI() .info(createApiInfo()) .servers(createServers()) .security(createSecurityRequirements()) .components(createComponents()); } private Info createApiInfo() { return new Info() .title(title) .description(description) .version(version) .contact(new Contact() .name(\u0026#34;API Support Team\u0026#34;) .email(\u0026#34;api-support@example.com\u0026#34;) .url(\u0026#34;https://example.com/support\u0026#34;)) .license(new License() .name(\u0026#34;Apache 2.0\u0026#34;) .url(\u0026#34;https://www.apache.org/licenses/LICENSE-2.0.html\u0026#34;)) .termsOfService(\u0026#34;https://example.com/terms\u0026#34;); } private List\u0026lt;Server\u0026gt; createServers() { return List.of( new Server() .url(\u0026#34;https://api.example.com\u0026#34;) .description(\u0026#34;Production Server\u0026#34;), new Server() .url(\u0026#34;https://staging-api.example.com\u0026#34;) .description(\u0026#34;Staging Server\u0026#34;), new Server() .url(\u0026#34;http://localhost:8080\u0026#34;) .description(\u0026#34;Development Server\u0026#34;) ); } private List\u0026lt;SecurityRequirement\u0026gt; createSecurityRequirements() { return List.of( new SecurityRequirement().addList(\u0026#34;bearerAuth\u0026#34;), new SecurityRequirement().addList(\u0026#34;apiKey\u0026#34;) ); } private Components createComponents() { return new Components() .addSecuritySchemes(\u0026#34;bearerAuth\u0026#34;, new SecurityScheme() .type(SecurityScheme.Type.HTTP) .scheme(\u0026#34;bearer\u0026#34;) .bearerFormat(\u0026#34;JWT\u0026#34;) .description(\u0026#34;JWT Bearer Token Authentication\u0026#34;)) .addSecuritySchemes(\u0026#34;apiKey\u0026#34;, new SecurityScheme() .type(SecurityScheme.Type.APIKEY) .in(SecurityScheme.In.HEADER) .name(\u0026#34;X-API-Key\u0026#34;) .description(\u0026#34;API Key Authentication\u0026#34;)) .addSchemas(\u0026#34;Error\u0026#34;, createErrorSchema()) .addSchemas(\u0026#34;PageInfo\u0026#34;, createPageInfoSchema()); } private Schema\u0026lt;?\u0026gt; createErrorSchema() { return new Schema\u0026lt;\u0026gt;() .type(\u0026#34;object\u0026#34;) .addProperties(\u0026#34;timestamp\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;string\u0026#34;).format(\u0026#34;date-time\u0026#34;)) .addProperties(\u0026#34;status\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;integer\u0026#34;)) .addProperties(\u0026#34;error\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;string\u0026#34;)) .addProperties(\u0026#34;message\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;string\u0026#34;)) .addProperties(\u0026#34;path\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;string\u0026#34;)); } private Schema\u0026lt;?\u0026gt; createPageInfoSchema() { return new Schema\u0026lt;\u0026gt;() .type(\u0026#34;object\u0026#34;) .addProperties(\u0026#34;page\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;integer\u0026#34;)) .addProperties(\u0026#34;size\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;integer\u0026#34;)) .addProperties(\u0026#34;totalElements\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;integer\u0026#34;)) .addProperties(\u0026#34;totalPages\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;integer\u0026#34;)); } } 控制器註解詳解 1. 完整的 REST Controller 範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 @RestController @RequestMapping(\u0026#34;/api/v1/users\u0026#34;) @Tag(name = \u0026#34;User Management\u0026#34;, description = \u0026#34;用戶管理相關 API\u0026#34;) @SecurityRequirement(name = \u0026#34;bearerAuth\u0026#34;) public class UserController { private final UserService userService; public UserController(UserService userService) { this.userService = userService; } @GetMapping @Operation( summary = \u0026#34;獲取用戶列表\u0026#34;, description = \u0026#34;分頁查詢用戶資訊，支援多種過濾條件\u0026#34;, tags = {\u0026#34;User Management\u0026#34;} ) @ApiResponses(value = { @ApiResponse( responseCode = \u0026#34;200\u0026#34;, description = \u0026#34;成功獲取用戶列表\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = PagedUserResponse.class), examples = @ExampleObject( name = \u0026#34;用戶列表範例\u0026#34;, value = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;content\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;username\u0026#34;: \u0026#34;john_doe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34;, \u0026#34;firstName\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Doe\u0026#34;, \u0026#34;createdAt\u0026#34;: \u0026#34;2023-01-15T10:30:00Z\u0026#34; } ], \u0026#34;pageable\u0026#34;: { \u0026#34;page\u0026#34;: 0, \u0026#34;size\u0026#34;: 20, \u0026#34;totalElements\u0026#34;: 1, \u0026#34;totalPages\u0026#34;: 1 } } \u0026#34;\u0026#34;\u0026#34; ) ) ), @ApiResponse( responseCode = \u0026#34;400\u0026#34;, description = \u0026#34;請求參數錯誤\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = ErrorResponse.class) ) ), @ApiResponse( responseCode = \u0026#34;401\u0026#34;, description = \u0026#34;未授權訪問\u0026#34;, content = @Content(schema = @Schema(implementation = ErrorResponse.class)) ), @ApiResponse( responseCode = \u0026#34;403\u0026#34;, description = \u0026#34;權限不足\u0026#34;, content = @Content(schema = @Schema(implementation = ErrorResponse.class)) ) }) public ResponseEntity\u0026lt;Page\u0026lt;UserResponse\u0026gt;\u0026gt; getUsers( @Parameter( description = \u0026#34;頁碼（從 0 開始）\u0026#34;, example = \u0026#34;0\u0026#34;, schema = @Schema(minimum = \u0026#34;0\u0026#34;, defaultValue = \u0026#34;0\u0026#34;) ) @RequestParam(defaultValue = \u0026#34;0\u0026#34;) @Min(0) int page, @Parameter( description = \u0026#34;每頁大小\u0026#34;, example = \u0026#34;20\u0026#34;, schema = @Schema(minimum = \u0026#34;1\u0026#34;, maximum = \u0026#34;100\u0026#34;, defaultValue = \u0026#34;20\u0026#34;) ) @RequestParam(defaultValue = \u0026#34;20\u0026#34;) @Min(1) @Max(100) int size, @Parameter( description = \u0026#34;排序欄位，格式：field,direction\u0026#34;, example = \u0026#34;createdAt,desc\u0026#34;, array = @ArraySchema(schema = @Schema(type = \u0026#34;string\u0026#34;)) ) @RequestParam(defaultValue = \u0026#34;createdAt,desc\u0026#34;) String[] sort, @Parameter( description = \u0026#34;用戶名搜尋關鍵字\u0026#34;, example = \u0026#34;john\u0026#34; ) @RequestParam(required = false) String username, @Parameter( description = \u0026#34;郵箱搜尋關鍵字\u0026#34;, example = \u0026#34;example.com\u0026#34; ) @RequestParam(required = false) String email, @Parameter( description = \u0026#34;用戶狀態過濾\u0026#34;, schema = @Schema(allowableValues = {\u0026#34;ACTIVE\u0026#34;, \u0026#34;INACTIVE\u0026#34;, \u0026#34;SUSPENDED\u0026#34;}) ) @RequestParam(required = false) UserStatus status ) { UserSearchCriteria criteria = UserSearchCriteria.builder() .username(username) .email(email) .status(status) .build(); Pageable pageable = createPageable(page, size, sort); Page\u0026lt;UserResponse\u0026gt; users = userService.findUsers(criteria, pageable); return ResponseEntity.ok(users); } @GetMapping(\u0026#34;/{id}\u0026#34;) @Operation( summary = \u0026#34;根據 ID 獲取用戶\u0026#34;, description = \u0026#34;根據用戶 ID 獲取詳細資訊\u0026#34; ) @ApiResponses(value = { @ApiResponse( responseCode = \u0026#34;200\u0026#34;, description = \u0026#34;成功獲取用戶資訊\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = UserDetailResponse.class) ) ), @ApiResponse(responseCode = \u0026#34;404\u0026#34;, description = \u0026#34;用戶不存在\u0026#34;) }) public ResponseEntity\u0026lt;UserDetailResponse\u0026gt; getUserById( @Parameter( description = \u0026#34;用戶 ID\u0026#34;, required = true, example = \u0026#34;123\u0026#34; ) @PathVariable @Positive Long id ) { UserDetailResponse user = userService.findDetailById(id); return ResponseEntity.ok(user); } @PostMapping @Operation( summary = \u0026#34;創建新用戶\u0026#34;, description = \u0026#34;創建新的用戶帳戶，郵箱必須唯一\u0026#34; ) @ApiResponses(value = { @ApiResponse( responseCode = \u0026#34;201\u0026#34;, description = \u0026#34;用戶創建成功\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = UserResponse.class) ) ), @ApiResponse( responseCode = \u0026#34;400\u0026#34;, description = \u0026#34;請求資料驗證失敗\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = ValidationErrorResponse.class) ) ), @ApiResponse( responseCode = \u0026#34;409\u0026#34;, description = \u0026#34;郵箱已存在\u0026#34; ) }) public ResponseEntity\u0026lt;UserResponse\u0026gt; createUser( @io.swagger.v3.oas.annotations.parameters.RequestBody( description = \u0026#34;用戶創建請求\u0026#34;, required = true, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = CreateUserRequest.class), examples = @ExampleObject( name = \u0026#34;用戶創建範例\u0026#34;, value = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;username\u0026#34;: \u0026#34;john_doe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34;, \u0026#34;firstName\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Doe\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;SecurePassword123!\u0026#34; } \u0026#34;\u0026#34;\u0026#34; ) ) ) @RequestBody @Valid CreateUserRequest request ) { UserResponse user = userService.createUser(request); URI location = URI.create(\u0026#34;/api/v1/users/\u0026#34; + user.getId()); return ResponseEntity.created(location).body(user); } @PutMapping(\u0026#34;/{id}\u0026#34;) @Operation( summary = \u0026#34;更新用戶資訊\u0026#34;, description = \u0026#34;更新指定用戶的基本資訊\u0026#34; ) public ResponseEntity\u0026lt;UserResponse\u0026gt; updateUser( @PathVariable @Positive Long id, @RequestBody @Valid UpdateUserRequest request ) { UserResponse user = userService.updateUser(id, request); return ResponseEntity.ok(user); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) @Operation( summary = \u0026#34;刪除用戶\u0026#34;, description = \u0026#34;軟刪除指定用戶（標記為已刪除狀態）\u0026#34; ) @ApiResponses(value = { @ApiResponse(responseCode = \u0026#34;204\u0026#34;, description = \u0026#34;刪除成功\u0026#34;), @ApiResponse(responseCode = \u0026#34;404\u0026#34;, description = \u0026#34;用戶不存在\u0026#34;), @ApiResponse(responseCode = \u0026#34;409\u0026#34;, description = \u0026#34;用戶有關聯資料，無法刪除\u0026#34;) }) public ResponseEntity\u0026lt;Void\u0026gt; deleteUser( @PathVariable @Positive Long id ) { userService.deleteUser(id); return ResponseEntity.noContent().build(); } @PostMapping(\u0026#34;/{id}/avatar\u0026#34;) @Operation( summary = \u0026#34;上傳用戶頭像\u0026#34;, description = \u0026#34;上傳用戶頭像圖片，支援 JPG、PNG 格式\u0026#34; ) @ApiResponses(value = { @ApiResponse( responseCode = \u0026#34;200\u0026#34;, description = \u0026#34;頭像上傳成功\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = UploadResponse.class) ) ), @ApiResponse(responseCode = \u0026#34;400\u0026#34;, description = \u0026#34;檔案格式不支援\u0026#34;), @ApiResponse(responseCode = \u0026#34;413\u0026#34;, description = \u0026#34;檔案大小超出限制\u0026#34;) }) public ResponseEntity\u0026lt;UploadResponse\u0026gt; uploadAvatar( @PathVariable @Positive Long id, @Parameter( description = \u0026#34;頭像圖片檔案\u0026#34;, required = true, content = @Content(mediaType = \u0026#34;multipart/form-data\u0026#34;) ) @RequestParam(\u0026#34;file\u0026#34;) MultipartFile file ) { UploadResponse response = userService.uploadAvatar(id, file); return ResponseEntity.ok(response); } } 2. DTO 類別註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @Schema(description = \u0026#34;用戶創建請求\u0026#34;) public class CreateUserRequest { @Schema( description = \u0026#34;用戶名\u0026#34;, example = \u0026#34;john_doe\u0026#34;, minLength = 3, maxLength = 50, pattern = \u0026#34;^[a-zA-Z0-9_]+$\u0026#34; ) @NotBlank(message = \u0026#34;用戶名不能為空\u0026#34;) @Size(min = 3, max = 50, message = \u0026#34;用戶名長度必須在 3-50 字元之間\u0026#34;) @Pattern(regexp = \u0026#34;^[a-zA-Z0-9_]+$\u0026#34;, message = \u0026#34;用戶名只能包含字母、數字和底線\u0026#34;) private String username; @Schema( description = \u0026#34;郵箱地址\u0026#34;, example = \u0026#34;john@example.com\u0026#34;, format = \u0026#34;email\u0026#34; ) @NotBlank(message = \u0026#34;郵箱不能為空\u0026#34;) @Email(message = \u0026#34;郵箱格式不正確\u0026#34;) private String email; @Schema( description = \u0026#34;名字\u0026#34;, example = \u0026#34;John\u0026#34;, maxLength = 30 ) @NotBlank(message = \u0026#34;名字不能為空\u0026#34;) @Size(max = 30, message = \u0026#34;名字長度不能超過 30 字元\u0026#34;) private String firstName; @Schema( description = \u0026#34;姓氏\u0026#34;, example = \u0026#34;Doe\u0026#34;, maxLength = 30 ) @NotBlank(message = \u0026#34;姓氏不能為空\u0026#34;) @Size(max = 30, message = \u0026#34;姓氏長度不能超過 30 字元\u0026#34;) private String lastName; @Schema( description = \u0026#34;密碼\u0026#34;, example = \u0026#34;SecurePassword123!\u0026#34;, minLength = 8, maxLength = 100, format = \u0026#34;password\u0026#34; ) @NotBlank(message = \u0026#34;密碼不能為空\u0026#34;) @Size(min = 8, max = 100, message = \u0026#34;密碼長度必須在 8-100 字元之間\u0026#34;) @Pattern( regexp = \u0026#34;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[@$!%*?\u0026amp;])[A-Za-z\\\\d@$!%*?\u0026amp;]+$\u0026#34;, message = \u0026#34;密碼必須包含大小寫字母、數字和特殊字元\u0026#34; ) private String password; @Schema( description = \u0026#34;出生日期\u0026#34;, example = \u0026#34;1990-01-15\u0026#34;, format = \u0026#34;date\u0026#34; ) @Past(message = \u0026#34;出生日期必須是過去的日期\u0026#34;) private LocalDate birthDate; @Schema( description = \u0026#34;用戶角色\u0026#34;, allowableValues = {\u0026#34;USER\u0026#34;, \u0026#34;ADMIN\u0026#34;, \u0026#34;MODERATOR\u0026#34;}, defaultValue = \u0026#34;USER\u0026#34; ) private UserRole role = UserRole.USER; // Getters and Setters... } @Schema(description = \u0026#34;分頁用戶回應\u0026#34;) public class PagedUserResponse { @Schema(description = \u0026#34;用戶列表\u0026#34;) private List\u0026lt;UserResponse\u0026gt; content; @Schema(description = \u0026#34;分頁資訊\u0026#34;) private PageInfo pageable; // Getters and Setters... } @Schema(description = \u0026#34;用戶基本資訊回應\u0026#34;) public class UserResponse { @Schema(description = \u0026#34;用戶 ID\u0026#34;, example = \u0026#34;123\u0026#34;) private Long id; @Schema(description = \u0026#34;用戶名\u0026#34;, example = \u0026#34;john_doe\u0026#34;) private String username; @Schema(description = \u0026#34;郵箱\u0026#34;, example = \u0026#34;john@example.com\u0026#34;) private String email; @Schema(description = \u0026#34;全名\u0026#34;, example = \u0026#34;John Doe\u0026#34;) private String fullName; @Schema(description = \u0026#34;頭像 URL\u0026#34;, example = \u0026#34;https://example.com/avatars/123.jpg\u0026#34;) private String avatarUrl; @Schema(description = \u0026#34;用戶狀態\u0026#34;, allowableValues = {\u0026#34;ACTIVE\u0026#34;, \u0026#34;INACTIVE\u0026#34;, \u0026#34;SUSPENDED\u0026#34;}) private UserStatus status; @Schema(description = \u0026#34;創建時間\u0026#34;, format = \u0026#34;date-time\u0026#34;) private LocalDateTime createdAt; @Schema(description = \u0026#34;最後登入時間\u0026#34;, format = \u0026#34;date-time\u0026#34;) private LocalDateTime lastLoginAt; // Getters and Setters... } 安全配置整合 1. JWT Bearer Token 整合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @Configuration @EnableWebSecurity public class SecurityConfiguration { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { return http .csrf(csrf -\u0026gt; csrf.disable()) .authorizeHttpRequests(auth -\u0026gt; auth // Swagger 相關路徑公開 .requestMatchers( \u0026#34;/api-docs/**\u0026#34;, \u0026#34;/swagger-ui/**\u0026#34;, \u0026#34;/swagger-ui.html\u0026#34;, \u0026#34;/webjars/**\u0026#34; ).permitAll() // 公開 API .requestMatchers(HttpMethod.POST, \u0026#34;/api/v1/auth/**\u0026#34;).permitAll() .requestMatchers(HttpMethod.GET, \u0026#34;/api/v1/public/**\u0026#34;).permitAll() // 需要認證的 API .anyRequest().authenticated() ) .oauth2ResourceServer(oauth2 -\u0026gt; oauth2 .jwt(jwt -\u0026gt; jwt.jwtDecoder(jwtDecoder())) ) .sessionManagement(session -\u0026gt; session .sessionCreationPolicy(SessionCreationPolicy.STATELESS) ) .build(); } @Bean public JwtDecoder jwtDecoder() { return NimbusJwtDecoder.withJwkSetUri(\u0026#34;https://your-auth-server/.well-known/jwks.json\u0026#34;) .build(); } } // 在 Controller 中指定安全需求 @RestController @RequestMapping(\u0026#34;/api/v1/admin\u0026#34;) @Tag(name = \u0026#34;Admin Management\u0026#34;, description = \u0026#34;管理員專用 API\u0026#34;) @SecurityRequirement(name = \u0026#34;bearerAuth\u0026#34;) @PreAuthorize(\u0026#34;hasRole(\u0026#39;ADMIN\u0026#39;)\u0026#34;) public class AdminController { @GetMapping(\u0026#34;/users\u0026#34;) @Operation( summary = \u0026#34;管理員查看所有用戶\u0026#34;, description = \u0026#34;需要 ADMIN 角色權限\u0026#34; ) @PreAuthorize(\u0026#34;hasAuthority(\u0026#39;USER_READ_ALL\u0026#39;)\u0026#34;) public ResponseEntity\u0026lt;Page\u0026lt;UserResponse\u0026gt;\u0026gt; getAllUsersForAdmin( @ParameterObject Pageable pageable ) { // Implementation... return ResponseEntity.ok().build(); } } 2. API Key 認證 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 @Component public class ApiKeyAuthenticationFilter extends OncePerRequestFilter { private static final String API_KEY_HEADER = \u0026#34;X-API-Key\u0026#34;; private final ApiKeyService apiKeyService; public ApiKeyAuthenticationFilter(ApiKeyService apiKeyService) { this.apiKeyService = apiKeyService; } @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain ) throws ServletException, IOException { String apiKey = request.getHeader(API_KEY_HEADER); if (apiKey != null \u0026amp;\u0026amp; apiKeyService.isValidApiKey(apiKey)) { ApiKeyDetails details = apiKeyService.getApiKeyDetails(apiKey); ApiKeyAuthenticationToken authentication = new ApiKeyAuthenticationToken(details); SecurityContextHolder.getContext().setAuthentication(authentication); } filterChain.doFilter(request, response); } } // 在特定 Controller 中使用 API Key @RestController @RequestMapping(\u0026#34;/api/v1/webhook\u0026#34;) @Tag(name = \u0026#34;Webhook API\u0026#34;, description = \u0026#34;第三方系統回調 API\u0026#34;) @SecurityRequirement(name = \u0026#34;apiKey\u0026#34;) public class WebhookController { @PostMapping(\u0026#34;/payment\u0026#34;) @Operation( summary = \u0026#34;支付結果回調\u0026#34;, description = \u0026#34;第三方支付系統回調通知\u0026#34; ) public ResponseEntity\u0026lt;Void\u0026gt; handlePaymentWebhook( @RequestBody PaymentWebhookRequest request ) { // Implementation... return ResponseEntity.ok().build(); } } 進階功能配置 1. 自訂文檔分組 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @Configuration public class OpenApiGroupConfiguration { @Bean @Primary public GroupedOpenApi publicApi() { return GroupedOpenApi.builder() .group(\u0026#34;public\u0026#34;) .displayName(\u0026#34;Public API\u0026#34;) .pathsToMatch(\u0026#34;/api/v1/public/**\u0026#34;, \u0026#34;/api/v1/auth/**\u0026#34;) .build(); } @Bean public GroupedOpenApi userApi() { return GroupedOpenApi.builder() .group(\u0026#34;user\u0026#34;) .displayName(\u0026#34;User API\u0026#34;) .pathsToMatch(\u0026#34;/api/v1/users/**\u0026#34;, \u0026#34;/api/v1/profile/**\u0026#34;) .addOperationCustomizer((operation, handlerMethod) -\u0026gt; { operation.addSecurityItem(new SecurityRequirement().addList(\u0026#34;bearerAuth\u0026#34;)); return operation; }) .build(); } @Bean public GroupedOpenApi adminApi() { return GroupedOpenApi.builder() .group(\u0026#34;admin\u0026#34;) .displayName(\u0026#34;Admin API\u0026#34;) .pathsToMatch(\u0026#34;/api/v1/admin/**\u0026#34;) .addOperationCustomizer((operation, handlerMethod) -\u0026gt; { operation.addSecurityItem(new SecurityRequirement().addList(\u0026#34;bearerAuth\u0026#34;)); // 添加管理員 API 的額外標籤 operation.addTagsItem(\u0026#34;Admin Only\u0026#34;); return operation; }) .build(); } @Bean public GroupedOpenApi internalApi() { return GroupedOpenApi.builder() .group(\u0026#34;internal\u0026#34;) .displayName(\u0026#34;Internal API\u0026#34;) .pathsToMatch(\u0026#34;/api/internal/**\u0026#34;) .addOperationCustomizer((operation, handlerMethod) -\u0026gt; { operation.addSecurityItem(new SecurityRequirement().addList(\u0026#34;apiKey\u0026#34;)); return operation; }) .build(); } } 2. 自訂操作符處理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @Component public class CustomOperationCustomizer implements OperationCustomizer { @Override public Operation customize(Operation operation, HandlerMethod handlerMethod) { // 自動添加通用錯誤回應 addCommonErrorResponses(operation); // 為分頁端點添加通用參數 if (isPaginationEndpoint(handlerMethod)) { addPaginationParameters(operation); } // 添加請求追蹤資訊 addRequestTrackingInfo(operation); return operation; } private void addCommonErrorResponses(Operation operation) { ApiResponses responses = operation.getResponses(); if (responses.get(\u0026#34;400\u0026#34;) == null) { responses.addApiResponse(\u0026#34;400\u0026#34;, new ApiResponse() .description(\u0026#34;請求參數錯誤\u0026#34;) .content(new Content() .addMediaType(\u0026#34;application/json\u0026#34;, new MediaType() .schema(new Schema\u0026lt;\u0026gt;().$ref(\u0026#34;#/components/schemas/Error\u0026#34;))))); } if (responses.get(\u0026#34;500\u0026#34;) == null) { responses.addApiResponse(\u0026#34;500\u0026#34;, new ApiResponse() .description(\u0026#34;內部伺服器錯誤\u0026#34;) .content(new Content() .addMediaType(\u0026#34;application/json\u0026#34;, new MediaType() .schema(new Schema\u0026lt;\u0026gt;().$ref(\u0026#34;#/components/schemas/Error\u0026#34;))))); } } private boolean isPaginationEndpoint(HandlerMethod handlerMethod) { return Arrays.stream(handlerMethod.getMethodParameters()) .anyMatch(param -\u0026gt; Pageable.class.isAssignableFrom(param.getParameterType())); } private void addPaginationParameters(Operation operation) { if (operation.getParameters() == null) { operation.setParameters(new ArrayList\u0026lt;\u0026gt;()); } // 添加通用分頁參數 operation.getParameters().add(new Parameter() .name(\u0026#34;page\u0026#34;) .in(ParameterIn.QUERY) .description(\u0026#34;頁碼（從 0 開始）\u0026#34;) .schema(new IntegerSchema().minimum(BigDecimal.ZERO)._default(0))); operation.getParameters().add(new Parameter() .name(\u0026#34;size\u0026#34;) .in(ParameterIn.QUERY) .description(\u0026#34;每頁大小\u0026#34;) .schema(new IntegerSchema().minimum(BigDecimal.ONE).maximum(BigDecimal.valueOf(100))._default(20))); } private void addRequestTrackingInfo(Operation operation) { operation.addExtension(\u0026#34;x-request-id\u0026#34;, \u0026#34;自動生成的請求追蹤 ID\u0026#34;); operation.addExtension(\u0026#34;x-rate-limit\u0026#34;, \u0026#34;API 呼叫頻率限制資訊\u0026#34;); } } 3. 自訂 Schema 處理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @Component public class CustomModelConverter implements ModelConverter { @Override public ModelConverterContext resolve( AnnotatedType annotatedType, ModelConverterContext context, Iterator\u0026lt;ModelConverter\u0026gt; chain ) { if (chain.hasNext()) { context = chain.next().resolve(annotatedType, context, chain); } // 自訂枚舉處理 if (annotatedType.getType() instanceof Class\u0026lt;?\u0026gt; clazz \u0026amp;\u0026amp; clazz.isEnum()) { Schema\u0026lt;?\u0026gt; schema = context.getDefinedModels().get(annotatedType.getType().getTypeName()); if (schema != null) { enhanceEnumSchema(schema, clazz); } } return context; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private void enhanceEnumSchema(Schema\u0026lt;?\u0026gt; schema, Class\u0026lt;?\u0026gt; enumClass) { if (enumClass.isEnum()) { Enum\u0026lt;?\u0026gt;[] enumConstants = (Enum\u0026lt;?\u0026gt;[]) enumClass.getEnumConstants(); List\u0026lt;String\u0026gt; enumValues = Arrays.stream(enumConstants) .map(Enum::name) .collect(Collectors.toList()); schema.setEnum(enumValues); // 添加枚舉描述 StringBuilder description = new StringBuilder(schema.getDescription() != null ? schema.getDescription() : \u0026#34;\u0026#34;); description.append(\u0026#34;\\n\\n可用值：\\n\u0026#34;); for (Enum\u0026lt;?\u0026gt; enumConstant : enumConstants) { description.append(\u0026#34;- `\u0026#34;).append(enumConstant.name()).append(\u0026#34;`\u0026#34;); // 如果枚舉有描述方法，添加描述 try { Method getDescription = enumClass.getMethod(\u0026#34;getDescription\u0026#34;); Object desc = getDescription.invoke(enumConstant); if (desc != null) { description.append(\u0026#34;: \u0026#34;).append(desc); } } catch (Exception ignored) { // 忽略沒有 getDescription 方法的情況 } description.append(\u0026#34;\\n\u0026#34;); } schema.setDescription(description.toString()); } } } 測試整合 1. API 文檔測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @TestMethodOrder(OrderAnnotation.class) class OpenApiDocumentationTest { @Autowired private TestRestTemplate restTemplate; @LocalServerPort private int port; @Test @Order(1) void testOpenApiJsonGeneration() { String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/api-docs\u0026#34;; ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.getForEntity(url, String.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK); assertThat(response.getBody()).isNotNull(); // 驗證 JSON 結構 DocumentContext context = JsonPath.parse(response.getBody()); assertThat(context.read(\u0026#34;$.openapi\u0026#34;, String.class)).isEqualTo(\u0026#34;3.0.1\u0026#34;); assertThat(context.read(\u0026#34;$.info.title\u0026#34;, String.class)).isNotEmpty(); assertThat(context.read(\u0026#34;$.paths\u0026#34;, Map.class)).isNotEmpty(); } @Test @Order(2) void testSwaggerUiAccess() { String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/swagger-ui.html\u0026#34;; ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.getForEntity(url, String.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK); assertThat(response.getBody()).contains(\u0026#34;Swagger UI\u0026#34;); } @Test @Order(3) void testApiGroupsGeneration() { String[] groups = {\u0026#34;public\u0026#34;, \u0026#34;user\u0026#34;, \u0026#34;admin\u0026#34;, \u0026#34;internal\u0026#34;}; for (String group : groups) { String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/api-docs/\u0026#34; + group; ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.getForEntity(url, String.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK); DocumentContext context = JsonPath.parse(response.getBody()); assertThat(context.read(\u0026#34;$.paths\u0026#34;, Map.class)).isNotEmpty(); } } @Test @Order(4) void testSecuritySchemesDefinition() { String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/api-docs\u0026#34;; ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.getForEntity(url, String.class); DocumentContext context = JsonPath.parse(response.getBody()); // 驗證安全方案定義 assertThat(context.read(\u0026#34;$.components.securitySchemes.bearerAuth.type\u0026#34;, String.class)) .isEqualTo(\u0026#34;http\u0026#34;); assertThat(context.read(\u0026#34;$.components.securitySchemes.apiKey.type\u0026#34;, String.class)) .isEqualTo(\u0026#34;apiKey\u0026#34;); } } 2. 契約測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) class ApiContractTest { @Autowired private TestRestTemplate restTemplate; @Autowired private ObjectMapper objectMapper; @LocalServerPort private int port; @Test void testUserApiContract() throws Exception { // 獲取 OpenAPI 規範 String openApiJson = getOpenApiJson(); OpenAPIV3Parser parser = new OpenAPIV3Parser(); OpenAPI openAPI = parser.readContents(openApiJson).getOpenAPI(); // 測試用戶創建端點 PathItem userPath = openAPI.getPaths().get(\u0026#34;/api/v1/users\u0026#34;); assertThat(userPath).isNotNull(); Operation postOperation = userPath.getPost(); assertThat(postOperation).isNotNull(); assertThat(postOperation.getSummary()).isEqualTo(\u0026#34;創建新用戶\u0026#34;); // 驗證請求 Schema RequestBody requestBody = postOperation.getRequestBody(); assertThat(requestBody).isNotNull(); Content content = requestBody.getContent(); MediaType mediaType = content.get(\u0026#34;application/json\u0026#34;); assertThat(mediaType).isNotNull(); // 驗證回應 Schema ApiResponse response201 = postOperation.getResponses().get(\u0026#34;201\u0026#34;); assertThat(response201).isNotNull(); assertThat(response201.getDescription()).isEqualTo(\u0026#34;用戶創建成功\u0026#34;); } @Test void testActualApiMatchesContract() throws Exception { // 根據文檔測試實際 API String requestJson = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;username\u0026#34;: \u0026#34;test_user\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;test@example.com\u0026#34;, \u0026#34;firstName\u0026#34;: \u0026#34;Test\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;User\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;TestPassword123!\u0026#34; } \u0026#34;\u0026#34;\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); headers.setBearerAuth(\u0026#34;valid-jwt-token\u0026#34;); HttpEntity\u0026lt;String\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(requestJson, headers); // 假設這個端點在測試環境中可用 String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/api/v1/users\u0026#34;; ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.postForEntity(url, request, String.class); // 根據文檔，應該返回 201 或 401（如果沒有有效 token） assertThat(response.getStatusCode()) .isIn(HttpStatus.CREATED, HttpStatus.UNAUTHORIZED); } private String getOpenApiJson() { String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/api-docs\u0026#34;; return restTemplate.getForObject(url, String.class); } } 部署與 CI/CD 整合 1. 文檔生成腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #!/bin/bash # scripts/generate-api-docs.sh set -e echo \u0026#34;🚀 生成 API 文檔...\u0026#34; # 啟動應用程式 echo \u0026#34;啟動 Spring Boot 應用程式...\u0026#34; java -jar target/api-service.jar --server.port=8080 \u0026amp; APP_PID=$! # 等待應用程式啟動 echo \u0026#34;等待應用程式啟動...\u0026#34; for i in {1..30}; do if curl -s http://localhost:8080/actuator/health \u0026gt; /dev/null; then echo \u0026#34;應用程式已啟動\u0026#34; break fi sleep 2 done # 生成 OpenAPI JSON echo \u0026#34;下載 OpenAPI 規範...\u0026#34; curl -o docs/openapi.json http://localhost:8080/api-docs # 生成不同格式的文檔 echo \u0026#34;生成 HTML 文檔...\u0026#34; npx @redocly/openapi-cli build-docs docs/openapi.json --output docs/api.html echo \u0026#34;生成 Markdown 文檔...\u0026#34; npx widdershins docs/openapi.json -o docs/api.md # 生成客戶端 SDK echo \u0026#34;生成客戶端 SDK...\u0026#34; mkdir -p generated/java-client npx @openapitools/openapi-generator-cli generate \\ -i docs/openapi.json \\ -g java \\ -o generated/java-client \\ --additional-properties=invokerPackage=com.example.client # 停止應用程式 echo \u0026#34;停止應用程式...\u0026#34; kill $APP_PID echo \u0026#34;✅ API 文檔生成完成\u0026#34; 2. GitHub Actions 工作流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 # .github/workflows/api-docs.yml name: Generate API Documentation on: push: branches: [ main, develop ] pull_request: branches: [ main ] jobs: generate-docs: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set up JDK 17 uses: actions/setup-java@v3 with: java-version: \u0026#39;17\u0026#39; distribution: \u0026#39;temurin\u0026#39; - name: Cache Maven dependencies uses: actions/cache@v3 with: path: ~/.m2 key: ${{ runner.os }}-m2-${{ hashFiles(\u0026#39;**/pom.xml\u0026#39;) }} - name: Build application run: mvn clean package -DskipTests - name: Setup Node.js uses: actions/setup-node@v3 with: node-version: \u0026#39;18\u0026#39; - name: Install documentation tools run: | npm install -g @redocly/openapi-cli npm install -g widdershins npm install -g @openapitools/openapi-generator-cli - name: Generate API documentation run: | chmod +x scripts/generate-api-docs.sh ./scripts/generate-api-docs.sh - name: Upload documentation artifacts uses: actions/upload-artifact@v3 with: name: api-documentation path: | docs/ generated/ - name: Deploy to GitHub Pages if: github.ref == \u0026#39;refs/heads/main\u0026#39; uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./docs 3. Docker 整合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Dockerfile.docs FROM openjdk:17-jdk-slim as builder WORKDIR /app COPY . . RUN ./mvnw clean package -DskipTests FROM node:18-alpine as docs-generator WORKDIR /app # 安裝文檔生成工具 RUN npm install -g @redocly/openapi-cli widdershins @openapitools/openapi-generator-cli # 複製應用程式 COPY --from=builder /app/target/*.jar app.jar # 生成文檔的腳本 COPY scripts/generate-docs-docker.sh . RUN chmod +x generate-docs-docker.sh EXPOSE 8080 CMD [\u0026#34;./generate-docs-docker.sh\u0026#34;] 效能優化與最佳實踐 1. 大型 API 的文檔優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @Configuration public class OpenApiPerformanceConfiguration { @Bean @ConditionalOnProperty(name = \u0026#34;springdoc.api-docs.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public OpenApiCustomiser openApiCustomiser() { return openApi -\u0026gt; { // 移除不必要的 Schema removeUnusedSchemas(openApi); // 簡化複雜的嵌套對象 simplifyNestedObjects(openApi); // 添加快取頭 addCacheHeaders(openApi); }; } private void removeUnusedSchemas(OpenAPI openApi) { if (openApi.getComponents() != null \u0026amp;\u0026amp; openApi.getComponents().getSchemas() != null) { Set\u0026lt;String\u0026gt; usedSchemas = findUsedSchemas(openApi); openApi.getComponents().getSchemas().entrySet() .removeIf(entry -\u0026gt; !usedSchemas.contains(entry.getKey())); } } private Set\u0026lt;String\u0026gt; findUsedSchemas(OpenAPI openApi) { Set\u0026lt;String\u0026gt; usedSchemas = new HashSet\u0026lt;\u0026gt;(); if (openApi.getPaths() != null) { openApi.getPaths().values().forEach(pathItem -\u0026gt; { Stream.of( pathItem.getGet(), pathItem.getPost(), pathItem.getPut(), pathItem.getDelete(), pathItem.getPatch() ).filter(Objects::nonNull) .forEach(operation -\u0026gt; collectUsedSchemas(operation, usedSchemas)); }); } return usedSchemas; } private void collectUsedSchemas(Operation operation, Set\u0026lt;String\u0026gt; usedSchemas) { // 從請求體收集 if (operation.getRequestBody() != null \u0026amp;\u0026amp; operation.getRequestBody().getContent() != null) { operation.getRequestBody().getContent().values() .forEach(mediaType -\u0026gt; collectSchemaRefs(mediaType.getSchema(), usedSchemas)); } // 從回應收集 if (operation.getResponses() != null) { operation.getResponses().values().forEach(response -\u0026gt; { if (response.getContent() != null) { response.getContent().values() .forEach(mediaType -\u0026gt; collectSchemaRefs(mediaType.getSchema(), usedSchemas)); } }); } } private void collectSchemaRefs(Schema\u0026lt;?\u0026gt; schema, Set\u0026lt;String\u0026gt; usedSchemas) { if (schema != null) { if (schema.get$ref() != null) { String schemaName = schema.get$ref().substring(\u0026#34;#/components/schemas/\u0026#34;.length()); usedSchemas.add(schemaName); } // 遞迴處理嵌套 Schema if (schema.getProperties() != null) { schema.getProperties().values().forEach(prop -\u0026gt; collectSchemaRefs((Schema\u0026lt;?\u0026gt;) prop, usedSchemas)); } } } } 2. 快取策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @RestController @RequestMapping(\u0026#34;/api-docs\u0026#34;) public class CachedApiDocsController { private final SpringDocConfigProperties springDocConfigProperties; private final ObjectMapper objectMapper; private final Cache\u0026lt;String, String\u0026gt; apiDocsCache; public CachedApiDocsController( SpringDocConfigProperties springDocConfigProperties, ObjectMapper objectMapper ) { this.springDocConfigProperties = springDocConfigProperties; this.objectMapper = objectMapper; this.apiDocsCache = Caffeine.newBuilder() .maximumSize(10) .expireAfterWrite(Duration.ofMinutes(30)) .build(); } @GetMapping( value = \u0026#34;/{group}\u0026#34;, produces = MediaType.APPLICATION_JSON_VALUE ) public ResponseEntity\u0026lt;String\u0026gt; getCachedApiDocs( @PathVariable String group, HttpServletRequest request ) { String cacheKey = group + \u0026#34;_\u0026#34; + getVersionHash(); String cachedDocs = apiDocsCache.get(cacheKey, key -\u0026gt; { // 生成文檔的邏輯 return generateApiDocs(group); }); return ResponseEntity.ok() .cacheControl(CacheControl.maxAge(Duration.ofHours(1))) .eTag(calculateETag(cachedDocs)) .body(cachedDocs); } private String getVersionHash() { // 基於應用程式版本和配置生成雜湊 String version = getClass().getPackage().getImplementationVersion(); return DigestUtils.md5Hex(version != null ? version : \u0026#34;dev\u0026#34;); } private String calculateETag(String content) { return \u0026#34;\\\u0026#34;\u0026#34; + DigestUtils.md5Hex(content) + \u0026#34;\\\u0026#34;\u0026#34;; } } 3. 環境配置最佳實踐 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # application-dev.yml springdoc: api-docs: enabled: true swagger-ui: enabled: true try-it-out-enabled: true operations-sorter: method tags-sorter: alpha display-request-duration: true doc-expansion: list default-models-expand-depth: 2 # application-prod.yml springdoc: api-docs: enabled: false # 生產環境關閉 swagger-ui: enabled: false # 生產環境關閉 # application-staging.yml springdoc: api-docs: enabled: true swagger-ui: enabled: true try-it-out-enabled: false # 測試環境禁止直接測試 監控與分析 1. API 使用情況追蹤 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Component public class ApiUsageTracker { private final MeterRegistry meterRegistry; private final Counter apiCallsCounter; private final Timer apiResponseTimer; public ApiUsageTracker(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; this.apiCallsCounter = Counter.builder(\u0026#34;api.calls\u0026#34;) .description(\u0026#34;API 呼叫次數\u0026#34;) .register(meterRegistry); this.apiResponseTimer = Timer.builder(\u0026#34;api.response.time\u0026#34;) .description(\u0026#34;API 回應時間\u0026#34;) .register(meterRegistry); } @EventListener public void trackApiCall(ApiCallEvent event) { apiCallsCounter .tag(\u0026#34;endpoint\u0026#34;, event.getEndpoint()) .tag(\u0026#34;method\u0026#34;, event.getMethod()) .tag(\u0026#34;status\u0026#34;, String.valueOf(event.getStatusCode())) .increment(); apiResponseTimer .tag(\u0026#34;endpoint\u0026#34;, event.getEndpoint()) .record(event.getResponseTime(), TimeUnit.MILLISECONDS); } } @RestController @RequestMapping(\u0026#34;/api/v1/analytics\u0026#34;) @Tag(name = \u0026#34;API Analytics\u0026#34;, description = \u0026#34;API 使用情況分析\u0026#34;) public class ApiAnalyticsController { private final MeterRegistry meterRegistry; public ApiAnalyticsController(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; } @GetMapping(\u0026#34;/metrics\u0026#34;) @Operation(summary = \u0026#34;獲取 API 使用統計\u0026#34;) public ResponseEntity\u0026lt;ApiMetrics\u0026gt; getApiMetrics() { Map\u0026lt;String, Double\u0026gt; endpointCalls = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;String, Double\u0026gt; averageResponseTimes = new HashMap\u0026lt;\u0026gt;(); meterRegistry.getMeters().forEach(meter -\u0026gt; { if (meter instanceof Counter counter \u0026amp;\u0026amp; meter.getId().getName().equals(\u0026#34;api.calls\u0026#34;)) { String endpoint = meter.getId().getTag(\u0026#34;endpoint\u0026#34;); endpointCalls.put(endpoint, counter.count()); } if (meter instanceof Timer timer \u0026amp;\u0026amp; meter.getId().getName().equals(\u0026#34;api.response.time\u0026#34;)) { String endpoint = meter.getId().getTag(\u0026#34;endpoint\u0026#34;); averageResponseTimes.put(endpoint, timer.mean(TimeUnit.MILLISECONDS)); } }); ApiMetrics metrics = new ApiMetrics(endpointCalls, averageResponseTimes); return ResponseEntity.ok(metrics); } } 總結 Swagger/OpenAPI 是現代 API 開發的必備工具，提供了從文檔生成到測試、監控的完整解決方案。透過本文的深入介紹，我們了解到：\n核心價值 自動化文檔：減少手動維護成本，確保文檔與程式碼同步 互動式測試：提供友善的 API 測試介面 團隊協作：統一的 API 規範促進前後端協作 程式碼生成：支援多種語言的客戶端 SDK 自動生成 最佳實踐要點 選擇 OpenAPI 3.0：使用最新標準和工具鏈 完整的註解：提供詳細的描述、範例和驗證規則 安全整合：正確配置認證和授權機制 效能優化：適當的快取和文檔分組策略 CI/CD 整合：自動化文檔生成和部署流程 進階應用 契約測試和 API 治理 多環境配置和版本管理 監控和分析 API 使用情況 與微服務架構的整合 正確實施 Swagger/OpenAPI 不僅能提升開發效率，還能建立標準化的 API 開發流程，為團隊帶來長期的技術價值。\n參考資料 OpenAPI Specification SpringDoc OpenAPI Spring Boot OpenAPI Integration OpenAPI Generator Swagger UI Configuration ","permalink":"https://xinqilin.github.io/post/backend/swagger2/","tags":["Java","Spring","Swagger","OpenAPI","API","Documentation","SpringBoot","REST"],"title":"Swagger/OpenAPI 完整指南：API 文檔化與測試最佳實踐"},{"content":"概述 RestTemplate 是 Spring Framework 提供的同步 HTTP 客戶端，用於簡化 RESTful Web 服務的調用。雖然在 Spring 5.0 之後被標記為維護模式（推薦使用 WebClient），但在許多現有項目中仍廣泛使用。本文將深入介紹 RestTemplate 的完整使用方法和最佳實踐。\n核心特性 簡化 HTTP 操作：提供便捷的 GET、POST、PUT、DELETE 等方法 自動序列化：支援 JSON、XML 等格式的自動轉換 異常處理：統一的異常處理機制 攔截器支援：請求和響應攔截器 靈活配置：連接池、超時、重試等配置 適用場景 微服務通信：服務間的 HTTP 調用 第三方 API 整合：調用外部 REST API 資料同步：不同系統間的資料交換 輕量級 HTTP 客戶端：簡單的 HTTP 請求需求 基礎配置與設定 1. 依賴配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;dependencies\u0026gt; \u0026lt;!-- Spring Boot Starter Web --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Apache HttpClient（可選，提供更好的連接池支援） --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- OkHttp（可選，現代化的 HTTP 客戶端） --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.squareup.okhttp3\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;okhttp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Jackson（JSON 處理） --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Testing --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 2. 基礎配置類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 package com.example.resttemplate.config; import org.apache.http.client.HttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.impl.conn.PoolingHttpClientConnectionManager; import org.springframework.boot.web.client.RestTemplateBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.client.HttpComponentsClientHttpRequestFactory; import org.springframework.http.client.SimpleClientHttpRequestFactory; import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter; import org.springframework.web.client.RestTemplate; import java.time.Duration; import java.util.Arrays; @Configuration public class RestTemplateConfig { /** * 基礎 RestTemplate 配置 */ @Bean(\u0026#34;basicRestTemplate\u0026#34;) public RestTemplate basicRestTemplate() { SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); factory.setConnectTimeout(5000); // 連接超時 5 秒 factory.setReadTimeout(10000); // 讀取超時 10 秒 RestTemplate restTemplate = new RestTemplate(factory); // 添加 JSON 消息轉換器 restTemplate.getMessageConverters().add(new MappingJackson2HttpMessageConverter()); return restTemplate; } /** * 使用 RestTemplateBuilder 構建（推薦方式） */ @Bean(\u0026#34;standardRestTemplate\u0026#34;) public RestTemplate standardRestTemplate(RestTemplateBuilder builder) { return builder .setConnectTimeout(Duration.ofSeconds(5)) .setReadTimeout(Duration.ofSeconds(10)) .additionalMessageConverters(new MappingJackson2HttpMessageConverter()) .build(); } /** * 高性能 RestTemplate（使用 Apache HttpClient） */ @Bean(\u0026#34;highPerformanceRestTemplate\u0026#34;) public RestTemplate highPerformanceRestTemplate() { // 連接池管理器 PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(); connectionManager.setMaxTotal(200); // 最大連接數 connectionManager.setDefaultMaxPerRoute(50); // 每個路由的最大連接數 // HttpClient 配置 HttpClient httpClient = HttpClients.custom() .setConnectionManager(connectionManager) .setConnectionManagerShared(true) .build(); // 請求工廠 HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(httpClient); factory.setConnectTimeout(5000); factory.setReadTimeout(10000); return new RestTemplate(factory); } /** * 帶有自訂配置的 RestTemplate */ @Bean(\u0026#34;customRestTemplate\u0026#34;) public RestTemplate customRestTemplate() { RestTemplate restTemplate = new RestTemplate(); // 添加攔截器 restTemplate.setInterceptors(Arrays.asList( new LoggingInterceptor(), new AuthenticationInterceptor(), new RetryInterceptor() )); // 設置錯誤處理器 restTemplate.setErrorHandler(new CustomResponseErrorHandler()); return restTemplate; } } 3. 屬性配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # application.yml rest-client: connection: timeout: 5000 read-timeout: 10000 max-connections: 200 max-connections-per-route: 50 retry: max-attempts: 3 delay: 1000 base-urls: user-service: \u0026#34;http://localhost:8081\u0026#34; order-service: \u0026#34;http://localhost:8082\u0026#34; payment-service: \u0026#34;http://localhost:8083\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @ConfigurationProperties(prefix = \u0026#34;rest-client\u0026#34;) @Component public class RestClientProperties { private Connection connection = new Connection(); private Retry retry = new Retry(); private Map\u0026lt;String, String\u0026gt; baseUrls = new HashMap\u0026lt;\u0026gt;(); // getter 和 setter 方法 public static class Connection { private int timeout = 5000; private int readTimeout = 10000; private int maxConnections = 200; private int maxConnectionsPerRoute = 50; // getter 和 setter 方法 } public static class Retry { private int maxAttempts = 3; private long delay = 1000; // getter 和 setter 方法 } } 基礎 HTTP 操作 1. GET 請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 package com.example.resttemplate.service; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.core.ParameterizedTypeReference; import org.springframework.http.*; import org.springframework.stereotype.Service; import org.springframework.web.client.RestTemplate; import org.springframework.web.util.UriComponentsBuilder; import java.net.URI; import java.util.HashMap; import java.util.List; import java.util.Map; @Service public class RestClientService { private final RestTemplate restTemplate; public RestClientService(@Qualifier(\u0026#34;standardRestTemplate\u0026#34;) RestTemplate restTemplate) { this.restTemplate = restTemplate; } /** * 基礎 GET 請求 */ public User getUserById(Long userId) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; return restTemplate.getForObject(url, User.class, userId); } /** * 帶有查詢參數的 GET 請求 */ public List\u0026lt;User\u0026gt; getUsersByDepartment(String department, int page, int size) { String url = \u0026#34;https://api.example.com/users\u0026#34;; URI uri = UriComponentsBuilder.fromUriString(url) .queryParam(\u0026#34;department\u0026#34;, department) .queryParam(\u0026#34;page\u0026#34;, page) .queryParam(\u0026#34;size\u0026#34;, size) .build() .toUri(); ResponseEntity\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; response = restTemplate.exchange( uri, HttpMethod.GET, null, new ParameterizedTypeReference\u0026lt;List\u0026lt;User\u0026gt;\u0026gt;() {} ); return response.getBody(); } /** * 使用 Map 作為 URI 變數 */ public User getUserWithMap(Long userId) { String url = \u0026#34;https://api.example.com/users/{id}/profile/{section}\u0026#34;; Map\u0026lt;String, Object\u0026gt; uriVariables = new HashMap\u0026lt;\u0026gt;(); uriVariables.put(\u0026#34;id\u0026#34;, userId); uriVariables.put(\u0026#34;section\u0026#34;, \u0026#34;basic\u0026#34;); return restTemplate.getForObject(url, User.class, uriVariables); } /** * 帶有請求頭的 GET 請求 */ public User getUserWithHeaders(Long userId, String authToken) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.set(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + authToken); headers.set(\u0026#34;Accept\u0026#34;, MediaType.APPLICATION_JSON_VALUE); HttpEntity\u0026lt;String\u0026gt; entity = new HttpEntity\u0026lt;\u0026gt;(headers); ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.exchange( url, HttpMethod.GET, entity, User.class, userId ); return response.getBody(); } /** * 獲取完整的響應資訊 */ public ResponseEntity\u0026lt;User\u0026gt; getUserWithFullResponse(Long userId) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.getForEntity(url, User.class, userId); // 可以獲取狀態碼、頭部、主體等資訊 HttpStatus statusCode = response.getStatusCode(); HttpHeaders responseHeaders = response.getHeaders(); User user = response.getBody(); return response; } } 2. POST 請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 /** * POST 請求範例 */ @Service public class PostRequestService { private final RestTemplate restTemplate; public PostRequestService(@Qualifier(\u0026#34;standardRestTemplate\u0026#34;) RestTemplate restTemplate) { this.restTemplate = restTemplate; } /** * 基礎 POST 請求 */ public User createUser(User newUser) { String url = \u0026#34;https://api.example.com/users\u0026#34;; return restTemplate.postForObject(url, newUser, User.class); } /** * 帶有請求頭的 POST 請求 */ public ResponseEntity\u0026lt;User\u0026gt; createUserWithHeaders(User newUser, String authToken) { String url = \u0026#34;https://api.example.com/users\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); headers.set(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + authToken); HttpEntity\u0026lt;User\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(newUser, headers); return restTemplate.postForEntity(url, request, User.class); } /** * 表單數據 POST 請求 */ public String submitForm(String email, String password) { String url = \u0026#34;https://api.example.com/login\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); MultiValueMap\u0026lt;String, String\u0026gt; formData = new LinkedMultiValueMap\u0026lt;\u0026gt;(); formData.add(\u0026#34;email\u0026#34;, email); formData.add(\u0026#34;password\u0026#34;, password); HttpEntity\u0026lt;MultiValueMap\u0026lt;String, String\u0026gt;\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(formData, headers); return restTemplate.postForObject(url, request, String.class); } /** * JSON 數據 POST 請求 */ public ApiResponse\u0026lt;User\u0026gt; createUserWithResponse(CreateUserRequest request) { String url = \u0026#34;https://api.example.com/users\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); headers.set(\u0026#34;X-Request-ID\u0026#34;, generateRequestId()); HttpEntity\u0026lt;CreateUserRequest\u0026gt; httpEntity = new HttpEntity\u0026lt;\u0026gt;(request, headers); ResponseEntity\u0026lt;ApiResponse\u0026lt;User\u0026gt;\u0026gt; response = restTemplate.exchange( url, HttpMethod.POST, httpEntity, new ParameterizedTypeReference\u0026lt;ApiResponse\u0026lt;User\u0026gt;\u0026gt;() {} ); return response.getBody(); } /** * 文件上傳 POST 請求 */ public String uploadFile(MultipartFile file, String description) { String url = \u0026#34;https://api.example.com/files/upload\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.MULTIPART_FORM_DATA); MultiValueMap\u0026lt;String, Object\u0026gt; formData = new LinkedMultiValueMap\u0026lt;\u0026gt;(); formData.add(\u0026#34;file\u0026#34;, file.getResource()); formData.add(\u0026#34;description\u0026#34;, description); HttpEntity\u0026lt;MultiValueMap\u0026lt;String, Object\u0026gt;\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(formData, headers); return restTemplate.postForObject(url, request, String.class); } private String generateRequestId() { return UUID.randomUUID().toString(); } } 3. PUT 和 DELETE 請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 /** * PUT 和 DELETE 請求範例 */ @Service public class UpdateDeleteService { private final RestTemplate restTemplate; public UpdateDeleteService(@Qualifier(\u0026#34;standardRestTemplate\u0026#34;) RestTemplate restTemplate) { this.restTemplate = restTemplate; } /** * PUT 更新請求 */ public User updateUser(Long userId, User updatedUser) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity\u0026lt;User\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(updatedUser, headers); ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.exchange( url, HttpMethod.PUT, request, User.class, userId ); return response.getBody(); } /** * PATCH 部分更新請求 */ public User partialUpdateUser(Long userId, Map\u0026lt;String, Object\u0026gt; updates) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(updates, headers); ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.exchange( url, HttpMethod.PATCH, request, User.class, userId ); return response.getBody(); } /** * DELETE 刪除請求 */ public void deleteUser(Long userId) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; restTemplate.delete(url, userId); } /** * 帶有響應的 DELETE 請求 */ public ApiResponse\u0026lt;Void\u0026gt; deleteUserWithResponse(Long userId, String authToken) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.set(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + authToken); HttpEntity\u0026lt;String\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(headers); ResponseEntity\u0026lt;ApiResponse\u0026lt;Void\u0026gt;\u0026gt; response = restTemplate.exchange( url, HttpMethod.DELETE, request, new ParameterizedTypeReference\u0026lt;ApiResponse\u0026lt;Void\u0026gt;\u0026gt;() {}, userId ); return response.getBody(); } /** * 批量刪除請求 */ public void deleteUsers(List\u0026lt;Long\u0026gt; userIds) { String url = \u0026#34;https://api.example.com/users/batch\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); DeleteBatchRequest request = new DeleteBatchRequest(userIds); HttpEntity\u0026lt;DeleteBatchRequest\u0026gt; httpEntity = new HttpEntity\u0026lt;\u0026gt;(request, headers); restTemplate.exchange( url, HttpMethod.DELETE, httpEntity, Void.class ); } } 高級功能與自訂 1. 攔截器實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 /** * 日誌攔截器 */ @Component public class LoggingInterceptor implements ClientHttpRequestInterceptor { private static final Logger logger = LoggerFactory.getLogger(LoggingInterceptor.class); @Override public ClientHttpResponse intercept( HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { logRequest(request, body); long startTime = System.currentTimeMillis(); ClientHttpResponse response = execution.execute(request, body); long duration = System.currentTimeMillis() - startTime; logResponse(response, duration); return response; } private void logRequest(HttpRequest request, byte[] body) { logger.info(\u0026#34;===========================request begin================================================\u0026#34;); logger.info(\u0026#34;URI : {}\u0026#34;, request.getURI()); logger.info(\u0026#34;Method : {}\u0026#34;, request.getMethod()); logger.info(\u0026#34;Headers : {}\u0026#34;, request.getHeaders()); logger.info(\u0026#34;Request body: {}\u0026#34;, new String(body, StandardCharsets.UTF_8)); logger.info(\u0026#34;==========================request end================================================\u0026#34;); } private void logResponse(ClientHttpResponse response, long duration) throws IOException { logger.info(\u0026#34;============================response begin==========================================\u0026#34;); logger.info(\u0026#34;Status code : {}\u0026#34;, response.getStatusCode()); logger.info(\u0026#34;Status text : {}\u0026#34;, response.getStatusText()); logger.info(\u0026#34;Headers : {}\u0026#34;, response.getHeaders()); logger.info(\u0026#34;Duration : {} ms\u0026#34;, duration); logger.info(\u0026#34;=======================response end=================================================\u0026#34;); } } /** * 認證攔截器 */ @Component public class AuthenticationInterceptor implements ClientHttpRequestInterceptor { private final TokenService tokenService; public AuthenticationInterceptor(TokenService tokenService) { this.tokenService = tokenService; } @Override public ClientHttpResponse intercept( HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { // 獲取並設置認證 token String token = tokenService.getCurrentToken(); if (token != null) { request.getHeaders().set(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + token); } return execution.execute(request, body); } } /** * 重試攔截器 */ @Component public class RetryInterceptor implements ClientHttpRequestInterceptor { private static final Logger logger = LoggerFactory.getLogger(RetryInterceptor.class); private final int maxRetries; private final long retryDelay; public RetryInterceptor(@Value(\u0026#34;${rest-client.retry.max-attempts:3}\u0026#34;) int maxRetries, @Value(\u0026#34;${rest-client.retry.delay:1000}\u0026#34;) long retryDelay) { this.maxRetries = maxRetries; this.retryDelay = retryDelay; } @Override public ClientHttpResponse intercept( HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { IOException lastException = null; for (int attempt = 1; attempt \u0026lt;= maxRetries; attempt++) { try { ClientHttpResponse response = execution.execute(request, body); // 檢查是否需要重試（例如：5xx 錯誤） if (shouldRetry(response) \u0026amp;\u0026amp; attempt \u0026lt; maxRetries) { logger.warn(\u0026#34;Request failed with status {}, retrying... (attempt {}/{})\u0026#34;, response.getStatusCode(), attempt, maxRetries); // 等待後重試 try { Thread.sleep(retryDelay * attempt); // 指數退避 } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new IOException(\u0026#34;Interrupted during retry delay\u0026#34;, e); } continue; } return response; } catch (IOException e) { lastException = e; if (attempt \u0026lt; maxRetries) { logger.warn(\u0026#34;Request failed, retrying... (attempt {}/{}) - {}\u0026#34;, attempt, maxRetries, e.getMessage()); try { Thread.sleep(retryDelay * attempt); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); throw new IOException(\u0026#34;Interrupted during retry delay\u0026#34;, ie); } } else { logger.error(\u0026#34;Request failed after {} attempts\u0026#34;, maxRetries, e); } } } throw lastException; } private boolean shouldRetry(ClientHttpResponse response) throws IOException { HttpStatus status = response.getStatusCode(); return status.is5xxServerError() || status == HttpStatus.REQUEST_TIMEOUT; } } 2. 自訂錯誤處理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 /** * 自訂響應錯誤處理器 */ @Component public class CustomResponseErrorHandler implements ResponseErrorHandler { private static final Logger logger = LoggerFactory.getLogger(CustomResponseErrorHandler.class); @Override public boolean hasError(ClientHttpResponse response) throws IOException { HttpStatus status = response.getStatusCode(); return status.series() == HttpStatus.Series.CLIENT_ERROR || status.series() == HttpStatus.Series.SERVER_ERROR; } @Override public void handleError(ClientHttpResponse response) throws IOException { HttpStatus status = response.getStatusCode(); String responseBody = getResponseBody(response); logger.error(\u0026#34;HTTP Error: {} - {}, Response: {}\u0026#34;, status.value(), status.getReasonPhrase(), responseBody); switch (status.series()) { case CLIENT_ERROR: handleClientError(status, responseBody); break; case SERVER_ERROR: handleServerError(status, responseBody); break; default: throw new RestClientException(\u0026#34;Unknown HTTP error: \u0026#34; + status); } } private void handleClientError(HttpStatus status, String responseBody) { switch (status) { case BAD_REQUEST: throw new BadRequestException(\u0026#34;Invalid request: \u0026#34; + responseBody); case UNAUTHORIZED: throw new UnauthorizedException(\u0026#34;Authentication required\u0026#34;); case FORBIDDEN: throw new ForbiddenException(\u0026#34;Access denied\u0026#34;); case NOT_FOUND: throw new NotFoundException(\u0026#34;Resource not found\u0026#34;); case CONFLICT: throw new ConflictException(\u0026#34;Resource conflict: \u0026#34; + responseBody); case TOO_MANY_REQUESTS: throw new RateLimitException(\u0026#34;Rate limit exceeded\u0026#34;); default: throw new ClientErrorException(\u0026#34;Client error: \u0026#34; + status + \u0026#34; - \u0026#34; + responseBody); } } private void handleServerError(HttpStatus status, String responseBody) { switch (status) { case INTERNAL_SERVER_ERROR: throw new ServerErrorException(\u0026#34;Internal server error: \u0026#34; + responseBody); case BAD_GATEWAY: throw new BadGatewayException(\u0026#34;Bad gateway\u0026#34;); case SERVICE_UNAVAILABLE: throw new ServiceUnavailableException(\u0026#34;Service unavailable\u0026#34;); case GATEWAY_TIMEOUT: throw new GatewayTimeoutException(\u0026#34;Gateway timeout\u0026#34;); default: throw new ServerErrorException(\u0026#34;Server error: \u0026#34; + status + \u0026#34; - \u0026#34; + responseBody); } } private String getResponseBody(ClientHttpResponse response) { try (InputStream inputStream = response.getBody()) { return StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { logger.warn(\u0026#34;Failed to read response body\u0026#34;, e); return \u0026#34;Unable to read response body\u0026#34;; } } } 3. 自訂異常類別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 // 基礎異常類別 public abstract class RestClientException extends RuntimeException { public RestClientException(String message) { super(message); } public RestClientException(String message, Throwable cause) { super(message, cause); } } // 客戶端錯誤異常 public class ClientErrorException extends RestClientException { public ClientErrorException(String message) { super(message); } } public class BadRequestException extends ClientErrorException { public BadRequestException(String message) { super(message); } } public class UnauthorizedException extends ClientErrorException { public UnauthorizedException(String message) { super(message); } } public class ForbiddenException extends ClientErrorException { public ForbiddenException(String message) { super(message); } } public class NotFoundException extends ClientErrorException { public NotFoundException(String message) { super(message); } } public class ConflictException extends ClientErrorException { public ConflictException(String message) { super(message); } } public class RateLimitException extends ClientErrorException { public RateLimitException(String message) { super(message); } } // 服務器錯誤異常 public class ServerErrorException extends RestClientException { public ServerErrorException(String message) { super(message); } } public class BadGatewayException extends ServerErrorException { public BadGatewayException(String message) { super(message); } } public class ServiceUnavailableException extends ServerErrorException { public ServiceUnavailableException(String message) { super(message); } } public class GatewayTimeoutException extends ServerErrorException { public GatewayTimeoutException(String message) { super(message); } } 實際應用場景 1. 微服務通信 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 /** * 用戶服務客戶端 */ @Service public class UserServiceClient { private final RestTemplate restTemplate; private final RestClientProperties properties; public UserServiceClient(@Qualifier(\u0026#34;highPerformanceRestTemplate\u0026#34;) RestTemplate restTemplate, RestClientProperties properties) { this.restTemplate = restTemplate; this.properties = properties; } /** * 獲取用戶資訊 */ public Optional\u0026lt;User\u0026gt; getUserById(Long userId) { String url = properties.getBaseUrls().get(\u0026#34;user-service\u0026#34;) + \u0026#34;/api/users/{id}\u0026#34;; try { User user = restTemplate.getForObject(url, User.class, userId); return Optional.ofNullable(user); } catch (NotFoundException e) { return Optional.empty(); } } /** * 批量獲取用戶資訊 */ public List\u0026lt;User\u0026gt; getUsersByIds(List\u0026lt;Long\u0026gt; userIds) { String url = properties.getBaseUrls().get(\u0026#34;user-service\u0026#34;) + \u0026#34;/api/users/batch\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity\u0026lt;List\u0026lt;Long\u0026gt;\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(userIds, headers); ResponseEntity\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; response = restTemplate.exchange( url, HttpMethod.POST, request, new ParameterizedTypeReference\u0026lt;List\u0026lt;User\u0026gt;\u0026gt;() {} ); return response.getBody(); } /** * 創建用戶 */ public User createUser(CreateUserRequest request) { String url = properties.getBaseUrls().get(\u0026#34;user-service\u0026#34;) + \u0026#34;/api/users\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity\u0026lt;CreateUserRequest\u0026gt; httpEntity = new HttpEntity\u0026lt;\u0026gt;(request, headers); return restTemplate.postForObject(url, httpEntity, User.class); } /** * 更新用戶狀態 */ public void updateUserStatus(Long userId, UserStatus status) { String url = properties.getBaseUrls().get(\u0026#34;user-service\u0026#34;) + \u0026#34;/api/users/{id}/status\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); UpdateStatusRequest request = new UpdateStatusRequest(status); HttpEntity\u0026lt;UpdateStatusRequest\u0026gt; httpEntity = new HttpEntity\u0026lt;\u0026gt;(request, headers); restTemplate.exchange(url, HttpMethod.PUT, httpEntity, Void.class, userId); } } /** * 訂單服務客戶端 */ @Service public class OrderServiceClient { private final RestTemplate restTemplate; private final RestClientProperties properties; public OrderServiceClient(@Qualifier(\u0026#34;highPerformanceRestTemplate\u0026#34;) RestTemplate restTemplate, RestClientProperties properties) { this.restTemplate = restTemplate; this.properties = properties; } /** * 創建訂單 */ public Order createOrder(CreateOrderRequest request) { String url = properties.getBaseUrls().get(\u0026#34;order-service\u0026#34;) + \u0026#34;/api/orders\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); headers.set(\u0026#34;X-Request-ID\u0026#34;, UUID.randomUUID().toString()); HttpEntity\u0026lt;CreateOrderRequest\u0026gt; httpEntity = new HttpEntity\u0026lt;\u0026gt;(request, headers); ResponseEntity\u0026lt;Order\u0026gt; response = restTemplate.postForEntity(url, httpEntity, Order.class); if (response.getStatusCode() == HttpStatus.CREATED) { return response.getBody(); } else { throw new RuntimeException(\u0026#34;Failed to create order: \u0026#34; + response.getStatusCode()); } } /** * 獲取用戶訂單列表 */ public PagedResponse\u0026lt;Order\u0026gt; getUserOrders(Long userId, int page, int size) { String url = properties.getBaseUrls().get(\u0026#34;order-service\u0026#34;) + \u0026#34;/api/users/{userId}/orders\u0026#34;; URI uri = UriComponentsBuilder.fromUriString(url) .queryParam(\u0026#34;page\u0026#34;, page) .queryParam(\u0026#34;size\u0026#34;, size) .build(userId); ResponseEntity\u0026lt;PagedResponse\u0026lt;Order\u0026gt;\u0026gt; response = restTemplate.exchange( uri, HttpMethod.GET, null, new ParameterizedTypeReference\u0026lt;PagedResponse\u0026lt;Order\u0026gt;\u0026gt;() {} ); return response.getBody(); } /** * 取消訂單 */ public void cancelOrder(Long orderId, String reason) { String url = properties.getBaseUrls().get(\u0026#34;order-service\u0026#34;) + \u0026#34;/api/orders/{id}/cancel\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); CancelOrderRequest request = new CancelOrderRequest(reason); HttpEntity\u0026lt;CancelOrderRequest\u0026gt; httpEntity = new HttpEntity\u0026lt;\u0026gt;(request, headers); restTemplate.exchange(url, HttpMethod.POST, httpEntity, Void.class, orderId); } } 2. 第三方 API 整合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 /** * 第三方支付服務整合 */ @Service public class PaymentGatewayClient { private final RestTemplate restTemplate; private final PaymentConfig paymentConfig; public PaymentGatewayClient(@Qualifier(\u0026#34;customRestTemplate\u0026#34;) RestTemplate restTemplate, PaymentConfig paymentConfig) { this.restTemplate = restTemplate; this.paymentConfig = paymentConfig; } /** * 創建支付訂單 */ public PaymentResponse createPayment(PaymentRequest paymentRequest) { String url = paymentConfig.getBaseUrl() + \u0026#34;/api/v1/payments\u0026#34;; HttpHeaders headers = createAuthHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity\u0026lt;PaymentRequest\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(paymentRequest, headers); try { ResponseEntity\u0026lt;PaymentResponse\u0026gt; response = restTemplate.postForEntity( url, request, PaymentResponse.class); return response.getBody(); } catch (Exception e) { throw new PaymentException(\u0026#34;Failed to create payment\u0026#34;, e); } } /** * 查詢支付狀態 */ public PaymentStatus queryPaymentStatus(String paymentId) { String url = paymentConfig.getBaseUrl() + \u0026#34;/api/v1/payments/{paymentId}/status\u0026#34;; HttpHeaders headers = createAuthHeaders(); HttpEntity\u0026lt;String\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(headers); try { ResponseEntity\u0026lt;PaymentStatusResponse\u0026gt; response = restTemplate.exchange( url, HttpMethod.GET, request, PaymentStatusResponse.class, paymentId); return response.getBody().getStatus(); } catch (NotFoundException e) { throw new PaymentNotFoundException(\u0026#34;Payment not found: \u0026#34; + paymentId); } } /** * 退款請求 */ public RefundResponse processRefund(String paymentId, RefundRequest refundRequest) { String url = paymentConfig.getBaseUrl() + \u0026#34;/api/v1/payments/{paymentId}/refund\u0026#34;; HttpHeaders headers = createAuthHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity\u0026lt;RefundRequest\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(refundRequest, headers); try { ResponseEntity\u0026lt;RefundResponse\u0026gt; response = restTemplate.exchange( url, HttpMethod.POST, request, RefundResponse.class, paymentId); return response.getBody(); } catch (Exception e) { throw new RefundException(\u0026#34;Failed to process refund\u0026#34;, e); } } /** * 創建認證頭 */ private HttpHeaders createAuthHeaders() { HttpHeaders headers = new HttpHeaders(); String auth = paymentConfig.getApiKey() + \u0026#34;:\u0026#34; + paymentConfig.getApiSecret(); String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes()); headers.set(\u0026#34;Authorization\u0026#34;, \u0026#34;Basic \u0026#34; + encodedAuth); headers.set(\u0026#34;X-API-Version\u0026#34;, paymentConfig.getApiVersion()); return headers; } } /** * 外部資料同步服務 */ @Service public class DataSyncService { private final RestTemplate restTemplate; private final DataSyncConfig config; public DataSyncService(@Qualifier(\u0026#34;standardRestTemplate\u0026#34;) RestTemplate restTemplate, DataSyncConfig config) { this.restTemplate = restTemplate; this.config = config; } /** * 同步用戶資料 */ @Async public CompletableFuture\u0026lt;SyncResult\u0026gt; syncUserData() { String url = config.getExternalApiUrl() + \u0026#34;/users/export\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.set(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + config.getAccessToken()); headers.set(\u0026#34;Accept\u0026#34;, MediaType.APPLICATION_JSON_VALUE); HttpEntity\u0026lt;String\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(headers); try { ResponseEntity\u0026lt;List\u0026lt;ExternalUser\u0026gt;\u0026gt; response = restTemplate.exchange( url, HttpMethod.GET, request, new ParameterizedTypeReference\u0026lt;List\u0026lt;ExternalUser\u0026gt;\u0026gt;() {} ); List\u0026lt;ExternalUser\u0026gt; externalUsers = response.getBody(); // 處理同步邏輯 int syncedCount = processSyncData(externalUsers); return CompletableFuture.completedFuture( new SyncResult(true, syncedCount, \u0026#34;Sync completed successfully\u0026#34;)); } catch (Exception e) { return CompletableFuture.completedFuture( new SyncResult(false, 0, \u0026#34;Sync failed: \u0026#34; + e.getMessage())); } } private int processSyncData(List\u0026lt;ExternalUser\u0026gt; externalUsers) { // 同步處理邏輯 return externalUsers != null ? externalUsers.size() : 0; } } 效能優化與監控 1. 連接池優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 /** * 高效能 RestTemplate 配置 */ @Configuration public class HighPerformanceRestTemplateConfig { @Bean(\u0026#34;pooledRestTemplate\u0026#34;) public RestTemplate pooledRestTemplate() { // 連接池管理器配置 PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(); connectionManager.setMaxTotal(300); // 最大連接數 connectionManager.setDefaultMaxPerRoute(100); // 每個路由的最大連接數 connectionManager.setValidateAfterInactivity(2000); // 連接空閒檢查時間 // 連接池清理策略 connectionManager.closeExpiredConnections(); connectionManager.closeIdleConnections(30, TimeUnit.SECONDS); // 請求配置 RequestConfig requestConfig = RequestConfig.custom() .setConnectionRequestTimeout(5000) // 從連接池獲取連接的超時時間 .setConnectTimeout(5000) // 連接超時時間 .setSocketTimeout(30000) // 讀取超時時間 .build(); // HttpClient 配置 CloseableHttpClient httpClient = HttpClients.custom() .setConnectionManager(connectionManager) .setDefaultRequestConfig(requestConfig) .setRetryHandler(new DefaultHttpRequestRetryHandler(3, true)) .setKeepAliveStrategy((response, context) -\u0026gt; 30 * 1000) // 30 秒 keep-alive .build(); // 請求工廠 HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(httpClient); return new RestTemplate(factory); } /** * 連接池監控 */ @Component public class ConnectionPoolMonitor { private final PoolingHttpClientConnectionManager connectionManager; private final MeterRegistry meterRegistry; public ConnectionPoolMonitor(PoolingHttpClientConnectionManager connectionManager, MeterRegistry meterRegistry) { this.connectionManager = connectionManager; this.meterRegistry = meterRegistry; // 註冊連接池指標 Gauge.builder(\u0026#34;http.connections.total\u0026#34;) .description(\u0026#34;Total connections in pool\u0026#34;) .register(meterRegistry, this, monitor -\u0026gt; monitor.connectionManager.getTotalStats().getMax()); Gauge.builder(\u0026#34;http.connections.available\u0026#34;) .description(\u0026#34;Available connections in pool\u0026#34;) .register(meterRegistry, this, monitor -\u0026gt; monitor.connectionManager.getTotalStats().getAvailable()); Gauge.builder(\u0026#34;http.connections.leased\u0026#34;) .description(\u0026#34;Leased connections in pool\u0026#34;) .register(meterRegistry, this, monitor -\u0026gt; monitor.connectionManager.getTotalStats().getLeased()); } @EventListener @Async public void logConnectionPoolStats(ApplicationReadyEvent event) { ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); executor.scheduleAtFixedRate(this::logStats, 0, 30, TimeUnit.SECONDS); } private void logStats() { PoolStats totalStats = connectionManager.getTotalStats(); logger.info(\u0026#34;Connection Pool Stats - Total: {}, Available: {}, Leased: {}, Pending: {}\u0026#34;, totalStats.getMax(), totalStats.getAvailable(), totalStats.getLeased(), totalStats.getPending()); } } } 2. 響應時間監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 /** * HTTP 請求監控攔截器 */ @Component public class MetricsInterceptor implements ClientHttpRequestInterceptor { private final MeterRegistry meterRegistry; private final Timer.Builder timerBuilder; public MetricsInterceptor(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; this.timerBuilder = Timer.builder(\u0026#34;http.client.requests\u0026#34;) .description(\u0026#34;HTTP client request duration\u0026#34;); } @Override public ClientHttpResponse intercept( HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { Timer.Sample sample = Timer.start(meterRegistry); try { ClientHttpResponse response = execution.execute(request, body); // 記錄成功請求指標 sample.stop(timerBuilder .tag(\u0026#34;method\u0026#34;, request.getMethod().name()) .tag(\u0026#34;uri\u0026#34;, getUriTemplate(request.getURI())) .tag(\u0026#34;status\u0026#34;, String.valueOf(response.getStatusCode().value())) .tag(\u0026#34;outcome\u0026#34;, getOutcome(response)) .register(meterRegistry)); return response; } catch (IOException e) { // 記錄失敗請求指標 sample.stop(timerBuilder .tag(\u0026#34;method\u0026#34;, request.getMethod().name()) .tag(\u0026#34;uri\u0026#34;, getUriTemplate(request.getURI())) .tag(\u0026#34;status\u0026#34;, \u0026#34;IO_ERROR\u0026#34;) .tag(\u0026#34;outcome\u0026#34;, \u0026#34;ERROR\u0026#34;) .register(meterRegistry)); throw e; } } private String getUriTemplate(URI uri) { String path = uri.getPath(); // 簡化路徑模板（移除具體 ID） return path.replaceAll(\u0026#34;/\\\\d+\u0026#34;, \u0026#34;/{id}\u0026#34;); } private String getOutcome(ClientHttpResponse response) throws IOException { HttpStatus status = response.getStatusCode(); if (status.is2xxSuccessful()) { return \u0026#34;SUCCESS\u0026#34;; } else if (status.is4xxClientError()) { return \u0026#34;CLIENT_ERROR\u0026#34;; } else if (status.is5xxServerError()) { return \u0026#34;SERVER_ERROR\u0026#34;; } else { return \u0026#34;UNKNOWN\u0026#34;; } } } 3. 快取策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 /** * 帶快取的 REST 客戶端 */ @Service public class CachedRestClientService { private final RestTemplate restTemplate; private final CacheManager cacheManager; public CachedRestClientService(@Qualifier(\u0026#34;standardRestTemplate\u0026#34;) RestTemplate restTemplate, CacheManager cacheManager) { this.restTemplate = restTemplate; this.cacheManager = cacheManager; } /** * 帶快取的用戶查詢 */ @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#userId\u0026#34;, unless = \u0026#34;#result == null\u0026#34;) public User getUserById(Long userId) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; return restTemplate.getForObject(url, User.class, userId); } /** * 快取失效更新 */ @CacheEvict(value = \u0026#34;users\u0026#34;, key = \u0026#34;#userId\u0026#34;) public User updateUser(Long userId, User updatedUser) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity\u0026lt;User\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(updatedUser, headers); ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.exchange( url, HttpMethod.PUT, request, User.class, userId); return response.getBody(); } /** * 條件快取：基於響應頭的快取策略 */ public User getUserWithConditionalCache(Long userId) { String url = \u0026#34;https://api.example.com/users/{id}\u0026#34;; // 檢查快取 Cache cache = cacheManager.getCache(\u0026#34;users\u0026#34;); Cache.ValueWrapper cachedValue = cache.get(userId); HttpHeaders headers = new HttpHeaders(); if (cachedValue != null) { CachedUser cachedUser = (CachedUser) cachedValue.get(); // 添加 If-None-Match 頭 headers.set(\u0026#34;If-None-Match\u0026#34;, cachedUser.getEtag()); } HttpEntity\u0026lt;String\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(headers); try { ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.exchange( url, HttpMethod.GET, request, User.class, userId); // 更新快取 String etag = response.getHeaders().getETag(); if (etag != null) { CachedUser cachedUser = new CachedUser(response.getBody(), etag); cache.put(userId, cachedUser); } return response.getBody(); } catch (HttpClientErrorException e) { if (e.getStatusCode() == HttpStatus.NOT_MODIFIED \u0026amp;\u0026amp; cachedValue != null) { // 返回快取的值 return ((CachedUser) cachedValue.get()).getUser(); } throw e; } } private static class CachedUser { private final User user; private final String etag; public CachedUser(User user, String etag) { this.user = user; this.etag = etag; } public User getUser() { return user; } public String getEtag() { return etag; } } } 測試策略 1. 單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 /** * RestTemplate 單元測試 */ @ExtendWith(MockitoExtension.class) class RestClientServiceTest { @Mock private RestTemplate restTemplate; @InjectMocks private RestClientService restClientService; private MockRestServiceServer mockServer; private ObjectMapper objectMapper; @BeforeEach void setUp() { mockServer = MockRestServiceServer.createServer(restTemplate); objectMapper = new ObjectMapper(); } @Test @DisplayName(\u0026#34;成功獲取用戶資訊\u0026#34;) void testGetUserById_Success() throws JsonProcessingException { // Given Long userId = 1L; User expectedUser = new User(userId, \u0026#34;john@example.com\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;); String expectedJson = objectMapper.writeValueAsString(expectedUser); mockServer.expect(requestTo(\u0026#34;https://api.example.com/users/1\u0026#34;)) .andExpect(method(HttpMethod.GET)) .andRespond(withSuccess(expectedJson, MediaType.APPLICATION_JSON)); // When User actualUser = restClientService.getUserById(userId); // Then mockServer.verify(); assertThat(actualUser).isNotNull(); assertThat(actualUser.getId()).isEqualTo(userId); assertThat(actualUser.getEmail()).isEqualTo(\u0026#34;john@example.com\u0026#34;); } @Test @DisplayName(\u0026#34;用戶不存在時拋出異常\u0026#34;) void testGetUserById_NotFound() { // Given Long userId = 999L; mockServer.expect(requestTo(\u0026#34;https://api.example.com/users/999\u0026#34;)) .andExpect(method(HttpMethod.GET)) .andRespond(withStatus(HttpStatus.NOT_FOUND)); // When \u0026amp; Then assertThatThrownBy(() -\u0026gt; restClientService.getUserById(userId)) .isInstanceOf(NotFoundException.class); mockServer.verify(); } @Test @DisplayName(\u0026#34;帶有查詢參數的 GET 請求\u0026#34;) void testGetUsersByDepartment() throws JsonProcessingException { // Given String department = \u0026#34;IT\u0026#34;; int page = 0; int size = 10; List\u0026lt;User\u0026gt; expectedUsers = Arrays.asList( new User(1L, \u0026#34;john@example.com\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;), new User(2L, \u0026#34;jane@example.com\u0026#34;, \u0026#34;Jane\u0026#34;, \u0026#34;Smith\u0026#34;) ); String expectedJson = objectMapper.writeValueAsString(expectedUsers); mockServer.expect(requestTo(containsString(\u0026#34;https://api.example.com/users\u0026#34;))) .andExpect(queryParam(\u0026#34;department\u0026#34;, \u0026#34;IT\u0026#34;)) .andExpect(queryParam(\u0026#34;page\u0026#34;, \u0026#34;0\u0026#34;)) .andExpect(queryParam(\u0026#34;size\u0026#34;, \u0026#34;10\u0026#34;)) .andExpect(method(HttpMethod.GET)) .andRespond(withSuccess(expectedJson, MediaType.APPLICATION_JSON)); // When List\u0026lt;User\u0026gt; actualUsers = restClientService.getUsersByDepartment(department, page, size); // Then mockServer.verify(); assertThat(actualUsers).hasSize(2); } @Test @DisplayName(\u0026#34;POST 請求創建用戶\u0026#34;) void testCreateUser() throws JsonProcessingException { // Given User newUser = new User(null, \u0026#34;bob@example.com\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Johnson\u0026#34;); User createdUser = new User(3L, \u0026#34;bob@example.com\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Johnson\u0026#34;); String requestJson = objectMapper.writeValueAsString(newUser); String responseJson = objectMapper.writeValueAsString(createdUser); mockServer.expect(requestTo(\u0026#34;https://api.example.com/users\u0026#34;)) .andExpect(method(HttpMethod.POST)) .andExpect(content().json(requestJson)) .andExpected(header(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;)) .andRespond(withSuccess(responseJson, MediaType.APPLICATION_JSON)); // When User actualUser = restClientService.createUser(newUser); // Then mockServer.verify(); assertThat(actualUser.getId()).isEqualTo(3L); assertThat(actualUser.getEmail()).isEqualTo(\u0026#34;bob@example.com\u0026#34;); } @Test @DisplayName(\u0026#34;服務器錯誤時的重試機制\u0026#34;) void testRetryOnServerError() { // Given Long userId = 1L; mockServer.expect(times(3), requestTo(\u0026#34;https://api.example.com/users/1\u0026#34;)) .andExpect(method(HttpMethod.GET)) .andRespond(withServerError()); // When \u0026amp; Then assertThatThrownBy(() -\u0026gt; restClientService.getUserById(userId)) .isInstanceOf(ServerErrorException.class); mockServer.verify(); } } 2. 整合測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 /** * RestTemplate 整合測試 */ @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @TestPropertySource(locations = \u0026#34;classpath:application-integration-test.properties\u0026#34;) class RestClientIntegrationTest { @Autowired private RestClientService restClientService; @Autowired private TestRestTemplate testRestTemplate; @MockBean private RestTemplate restTemplate; private WireMockServer wireMockServer; @BeforeEach void setUp() { wireMockServer = new WireMockServer(wireMockConfig().port(8089)); wireMockServer.start(); configureFor(\u0026#34;localhost\u0026#34;, 8089); } @AfterEach void tearDown() { wireMockServer.stop(); } @Test @DisplayName(\u0026#34;完整的用戶管理流程\u0026#34;) void testCompleteUserManagementFlow() throws JsonProcessingException { ObjectMapper objectMapper = new ObjectMapper(); // 1. 模擬創建用戶 API User newUser = new User(null, \u0026#34;integration@example.com\u0026#34;, \u0026#34;Integration\u0026#34;, \u0026#34;Test\u0026#34;); User createdUser = new User(1L, \u0026#34;integration@example.com\u0026#34;, \u0026#34;Integration\u0026#34;, \u0026#34;Test\u0026#34;); stubFor(post(urlEqualTo(\u0026#34;/api/users\u0026#34;)) .willReturn(aResponse() .withStatus(201) .withHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .withBody(objectMapper.writeValueAsString(createdUser)))); // 2. 模擬獲取用戶 API stubFor(get(urlEqualTo(\u0026#34;/api/users/1\u0026#34;)) .willReturn(aResponse() .withStatus(200) .withHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .withBody(objectMapper.writeValueAsString(createdUser)))); // 3. 模擬更新用戶 API User updatedUser = new User(1L, \u0026#34;updated@example.com\u0026#34;, \u0026#34;Updated\u0026#34;, \u0026#34;User\u0026#34;); stubFor(put(urlEqualTo(\u0026#34;/api/users/1\u0026#34;)) .willReturn(aResponse() .withStatus(200) .withHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .withBody(objectMapper.writeValueAsString(updatedUser)))); // 4. 模擬刪除用戶 API stubFor(delete(urlEqualTo(\u0026#34;/api/users/1\u0026#34;)) .willReturn(aResponse().withStatus(204))); // 執行測試流程 // 創建用戶 User created = restClientService.createUser(newUser); assertThat(created.getId()).isEqualTo(1L); // 獲取用戶 User retrieved = restClientService.getUserById(1L); assertThat(retrieved.getEmail()).isEqualTo(\u0026#34;integration@example.com\u0026#34;); // 更新用戶 User updated = restClientService.updateUser(1L, updatedUser); assertThat(updated.getEmail()).isEqualTo(\u0026#34;updated@example.com\u0026#34;); // 刪除用戶 assertDoesNotThrow(() -\u0026gt; restClientService.deleteUser(1L)); // 驗證所有請求都被調用 verify(postRequestedFor(urlEqualTo(\u0026#34;/api/users\u0026#34;))); verify(getRequestedFor(urlEqualTo(\u0026#34;/api/users/1\u0026#34;))); verify(putRequestedFor(urlEqualTo(\u0026#34;/api/users/1\u0026#34;))); verify(deleteRequestedFor(urlEqualTo(\u0026#34;/api/users/1\u0026#34;))); } @Test @DisplayName(\u0026#34;錯誤處理和重試機制\u0026#34;) void testErrorHandlingAndRetry() { // 模擬服務器錯誤，然後成功 stubFor(get(urlEqualTo(\u0026#34;/api/users/1\u0026#34;)) .inScenario(\u0026#34;Retry Scenario\u0026#34;) .whenScenarioStateIs(STARTED) .willSetStateTo(\u0026#34;First Attempt\u0026#34;) .willReturn(aResponse().withStatus(500))); stubFor(get(urlEqualTo(\u0026#34;/api/users/1\u0026#34;)) .inScenario(\u0026#34;Retry Scenario\u0026#34;) .whenScenarioStateIs(\u0026#34;First Attempt\u0026#34;) .willSetStateTo(\u0026#34;Second Attempt\u0026#34;) .willReturn(aResponse().withStatus(500))); stubFor(get(urlEqualTo(\u0026#34;/api/users/1\u0026#34;)) .inScenario(\u0026#34;Retry Scenario\u0026#34;) .whenScenarioStateIs(\u0026#34;Second Attempt\u0026#34;) .willReturn(aResponse() .withStatus(200) .withHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .withBody(\u0026#34;{\\\u0026#34;id\\\u0026#34;:1,\\\u0026#34;email\\\u0026#34;:\\\u0026#34;test@example.com\\\u0026#34;}\u0026#34;))); // 執行測試 User user = restClientService.getUserById(1L); assertThat(user.getId()).isEqualTo(1L); // 驗證重試了 3 次 verify(3, getRequestedFor(urlEqualTo(\u0026#34;/api/users/1\u0026#34;))); } } 現代化替代方案 1. WebClient 遷移指南 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /** * WebClient 遷移範例 */ @Service public class ModernRestClientService { private final WebClient webClient; public ModernRestClientService(WebClient.Builder webClientBuilder) { this.webClient = webClientBuilder .baseUrl(\u0026#34;https://api.example.com\u0026#34;) .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .build(); } /** * 異步 GET 請求 */ public Mono\u0026lt;User\u0026gt; getUserByIdAsync(Long userId) { return webClient.get() .uri(\u0026#34;/users/{id}\u0026#34;, userId) .retrieve() .bodyToMono(User.class); } /** * 響應式 POST 請求 */ public Mono\u0026lt;User\u0026gt; createUserAsync(User newUser) { return webClient.post() .uri(\u0026#34;/users\u0026#34;) .bodyValue(newUser) .retrieve() .bodyToMono(User.class); } /** * 錯誤處理 */ public Mono\u0026lt;User\u0026gt; getUserWithErrorHandling(Long userId) { return webClient.get() .uri(\u0026#34;/users/{id}\u0026#34;, userId) .retrieve() .onStatus(HttpStatus::is4xxClientError, response -\u0026gt; Mono.error(new NotFoundException(\u0026#34;User not found\u0026#34;))) .onStatus(HttpStatus::is5xxServerError, response -\u0026gt; Mono.error(new ServerErrorException(\u0026#34;Server error\u0026#34;))) .bodyToMono(User.class); } /** * 流式處理 */ public Flux\u0026lt;User\u0026gt; getAllUsersStream() { return webClient.get() .uri(\u0026#34;/users/stream\u0026#34;) .retrieve() .bodyToFlux(User.class); } } 2. RestTemplate vs WebClient 對比 特性 RestTemplate WebClient API 風格 同步阻塞 異步非阻塞 響應式支援 不支援 完整支援 效能 中等 高 記憶體使用 較高 較低 背壓處理 不支援 支援 Spring 5+ 支援 維護模式 主推方案 學習曲線 較低 較高 最佳實踐與建議 1. 配置最佳實踐 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 /** * RestTemplate 最佳實踐配置 */ @Configuration public class RestTemplateBestPractices { /** * 生產環境推薦配置 */ @Bean @Primary public RestTemplate productionRestTemplate() { // 1. 使用連接池 PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(); connectionManager.setMaxTotal(200); connectionManager.setDefaultMaxPerRoute(50); connectionManager.setValidateAfterInactivity(2000); // 2. 配置超時 RequestConfig requestConfig = RequestConfig.custom() .setConnectionRequestTimeout(5000) .setConnectTimeout(5000) .setSocketTimeout(30000) .build(); // 3. 配置重試 HttpRequestRetryHandler retryHandler = new DefaultHttpRequestRetryHandler(3, true); // 4. 配置 Keep-Alive ConnectionKeepAliveStrategy keepAliveStrategy = (response, context) -\u0026gt; 30 * 1000; CloseableHttpClient httpClient = HttpClients.custom() .setConnectionManager(connectionManager) .setDefaultRequestConfig(requestConfig) .setRetryHandler(retryHandler) .setKeepAliveStrategy(keepAliveStrategy) .build(); HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(httpClient); RestTemplate restTemplate = new RestTemplate(factory); // 5. 添加攔截器 restTemplate.setInterceptors(Arrays.asList( new LoggingInterceptor(), new MetricsInterceptor(meterRegistry), new AuthenticationInterceptor(tokenService) )); // 6. 設置錯誤處理器 restTemplate.setErrorHandler(new CustomResponseErrorHandler()); return restTemplate; } /** * 常見錯誤和解決方案 */ public void demonstrateCommonPitfalls() { // ❌ 錯誤：未設置超時 RestTemplate badTemplate = new RestTemplate(); // ✅ 正確：設置合理的超時 SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); factory.setConnectTimeout(5000); factory.setReadTimeout(30000); RestTemplate goodTemplate = new RestTemplate(factory); // ❌ 錯誤：未使用連接池 // 每次請求都創建新連接 // ✅ 正確：使用連接池復用連接 // 見上面的生產環境配置 // ❌ 錯誤：未處理異常 try { String result = badTemplate.getForObject(\u0026#34;http://api.example.com/data\u0026#34;, String.class); } catch (Exception e) { // 直接忽略異常 } // ✅ 正確：適當的異常處理 try { String result = goodTemplate.getForObject(\u0026#34;http://api.example.com/data\u0026#34;, String.class); } catch (ResourceAccessException e) { logger.error(\u0026#34;Network error\u0026#34;, e); throw new ServiceUnavailableException(\u0026#34;Service temporarily unavailable\u0026#34;); } catch (HttpClientErrorException e) { logger.error(\u0026#34;Client error: {}\u0026#34;, e.getStatusCode(), e); throw new BadRequestException(\u0026#34;Invalid request\u0026#34;); } } } 2. 安全性考量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 /** * RestTemplate 安全配置 */ @Configuration public class SecureRestTemplateConfig { /** * HTTPS 配置 */ @Bean public RestTemplate secureRestTemplate() throws Exception { TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -\u0026gt; true; SSLContext sslContext = org.apache.http.ssl.SSLContexts.custom() .loadTrustMaterial(null, acceptingTrustStrategy) .build(); SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext); CloseableHttpClient httpClient = HttpClients.custom() .setSSLSocketFactory(csf) .build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(); requestFactory.setHttpClient(httpClient); return new RestTemplate(requestFactory); } /** * 認證配置 */ @Component public class SecureAuthInterceptor implements ClientHttpRequestInterceptor { @Override public ClientHttpResponse intercept( HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { // 1. 添加 API Key request.getHeaders().set(\u0026#34;X-API-Key\u0026#34;, getApiKey()); // 2. 添加請求簽名 String signature = generateSignature(request, body); request.getHeaders().set(\u0026#34;X-Signature\u0026#34;, signature); // 3. 添加時間戳防重放 request.getHeaders().set(\u0026#34;X-Timestamp\u0026#34;, String.valueOf(System.currentTimeMillis())); return execution.execute(request, body); } private String getApiKey() { // 從安全配置中獲取 API Key return securityConfig.getApiKey(); } private String generateSignature(HttpRequest request, byte[] body) { // 實作請求簽名邏輯 return hmacSha256(request.getURI() + new String(body), getSecretKey()); } } } 總結 RestTemplate 作為 Spring 生態系統中的經典 HTTP 客戶端，提供了豐富的功能和良好的擴展性：\n主要優勢 簡單易用：直觀的 API 設計，易於上手 功能完整：支援所有 HTTP 方法和豐富的配置選項 Spring 整合：與 Spring 框架完美整合 擴展性好：支援攔截器、錯誤處理器等擴展機制 穩定成熟：經過長期驗證，穩定可靠 適用場景 傳統 Spring 應用：非響應式應用的 HTTP 客戶端需求 微服務通信：服務間的同步調用 第三方 API 整合：調用外部 REST API 遺留系統維護：現有系統的維護和升級 遷移建議 雖然 RestTemplate 在維護模式，但對於以下情況建議遷移到 WebClient：\n新項目開發：使用 WebClient 獲得更好的效能 高並發需求：WebClient 的非阻塞特性更適合 響應式程式設計：需要響應式流的場景 效能敏感：對效能有較高要求的應用 通過合理的配置和最佳實踐，RestTemplate 仍然是一個可靠的 HTTP 客戶端選擇，特別是在現有項目的維護和漸進式升級場景中。\n","permalink":"https://xinqilin.github.io/post/backend/resttemplate/","tags":["Spring","RestTemplate","HTTP Client","WebClient","REST API","Microservices","Error Handling","Testing","Performance"],"title":"Spring RestTemplate 完整實戰指南：HTTP 客戶端最佳實踐"},{"content":"前言 在現代軟體開發中，設定檔是不可或缺的一環。從 Java 的 Spring Boot 框架 (Spring MVC 過往使用大量的 XML)，到我目前使用的 Hugo 靜態網站產生器，都能看到 .properties、.yml 或 .toml 等格式的身影。\n雖然這些格式各有優勢，但在雲原生領域，特別是設定 Kubernetes (K8s) 資源時，YAML (YAML Ain\u0026rsquo;t Markup Language) 已成為事實上的標準。因此，掌握 YAML 的語法至關重要。\n核心語法 YAML 的設計目標是易於人類閱讀和撰寫。它的語法主要基於縮排和幾個簡單的符號。\n註解: 使用 # 號標示單行註解。 文件開頭: 使用三個連字號 --- 作為文件的開始符號 (選用)。 鍵值對 (Key-Value Pair) YAML 的基本組成單位是鍵值對，格式為 key: value (注意冒號後面需要一個空格)。\n1 apiVersion: v1 階層/物件 (Objects) 透過換行和縮排 (建議使用兩個空格) 來表示階層關係。這在 JSON 中相當於一個物件。\n以下範例等同於 spring.datasource.username = \u0026quot;root\u0026quot;。\n1 2 3 spring: datasource: username: root 陣列/列表 (Arrays/Lists) 陣列有兩種常見的表示方式：\n塊序列 (Block Sequence): 透過換行、縮排，並在每個元素前加上 - (連字號 + 空格) 來表示。這種形式更易讀，且元素可以是複雜的物件。\n1 2 3 args: - \u0026#34;parameter1\u0026#34; - \u0026#34;parameter2\u0026#34; 流序列 (Flow Sequence): 將所有元素放在方括號 [] 中，並用逗號分隔。適合表示簡單的一維陣列。\n1 2 items: [1, 2, 3, 4, 5] args: [\u0026#34;parameter1\u0026#34;, \u0026#34;parameter2\u0026#34;] 綜合範例 讓我們來看一個更完整的範例，這個範例來自 CloudBees YAML Tutorial。\nYAML 格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --- doe: \u0026#34;a deer, a female deer\u0026#34; ray: \u0026#34;a drop of golden sun\u0026#34; pi: 3.14159 xmas: true french-hens: 3 calling-birds: - huey - dewey - louie - fred xmas-fifth-day: calling-birds: four french-hens: 3 golden-rings: 5 partridges: count: 1 location: \u0026#34;a pear tree\u0026#34; turtle-doves: two 等效的 JSON 格式 這個 YAML 結構可以完全對應到以下的 JSON 物件，展示了其清晰的資料表達能力。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \u0026#34;doe\u0026#34;: \u0026#34;a deer, a female deer\u0026#34;, \u0026#34;ray\u0026#34;: \u0026#34;a drop of golden sun\u0026#34;, \u0026#34;pi\u0026#34;: 3.14159, \u0026#34;xmas\u0026#34;: true, \u0026#34;french-hens\u0026#34;: 3, \u0026#34;calling-birds\u0026#34;: [ \u0026#34;huey\u0026#34;, \u0026#34;dewey\u0026#34;, \u0026#34;louie\u0026#34;, \u0026#34;fred\u0026#34; ], \u0026#34;xmas-fifth-day\u0026#34;: { \u0026#34;calling-birds\u0026#34;: \u0026#34;four\u0026#34;, \u0026#34;french-hens\u0026#34;: 3, \u0026#34;golden-rings\u0026#34;: 5, \u0026#34;partridges\u0026#34;: { \u0026#34;count\u0026#34;: 1, \u0026#34;location\u0026#34;: \u0026#34;a pear tree\u0026#34; }, \u0026#34;turtle-doves\u0026#34;: \u0026#34;two\u0026#34; } } 參考資料 CloudBees YAML Tutorial 菜鳥教程 - YAML 簡介 ","permalink":"https://xinqilin.github.io/post/tools/yaml/","tags":["YAML","Configuration","Kubernetes","Spring Boot","DevOps"],"title":"YAML 語法從入門到實踐"},{"content":"MergeSort Time complexity = log n * O(n) = O(n logn)\nMergeSort 套一句柯P 講的話，小問題解決了，就沒有大問題了\n將 n 個個數的陣列，先左右各切一半，一直切，切到最小單位後，開始拿兩條被切的單位做排序、合併 ! 合久必分，分久必合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import java.util.*; public class MergeSort { public static void mergeSort(int[] array) { int[] workArray = new int[array.length]; Sort(array, workArray, 0, array.length - 1); } private static void Sort(int[] array, int[] workArray, int start, int end) { if (start \u0026gt;= end) return; //避免溢位 start + end 可能超出去 int mid = start + (end - start)/2; Sort(array, workArray, start, mid); Sort(array, workArray, mid+1, end); Merge(array, workArray, start, mid, mid+1, end); } private static void Merge(int[] array, int[] workArray, int leftStart, int leftEnd, int rightStart, int rightEnd) { int leftPtr = leftStart, rightPtr = rightStart, index = leftStart; while (leftPtr \u0026lt;= leftEnd || rightPtr \u0026lt;= rightEnd) { if (leftPtr \u0026lt;= leftEnd \u0026amp;\u0026amp; rightPtr \u0026lt;= rightEnd) { //最後一排 if (array[rightPtr] \u0026lt; array[leftPtr]) workArray[index] = array[rightPtr++]; else workArray[index] = array[leftPtr++]; } else if (leftPtr \u0026lt;= leftEnd){ // 左邊排序 workArray[index] = array[leftPtr++]; }else{ // 右邊排序 workArray[index] = array[rightPtr++]; } ++index; } for (int i = leftStart; i \u0026lt; index; i++) array[i] = workArray[i]; } public static void main(String[] args) { int[] data = new int[10]; for (int i = 0; i \u0026lt; data.length; i++) { data[i] = (int) (Math.random() * 100); } System.out.println(\u0026#34;before: \u0026#34; + Arrays.toString(data)); mergeSort(data); System.out.println(\u0026#34;after: \u0026#34; + Arrays.toString(data)); } } ![MergeSortResult](images/Algorithm/mergeSort/mergeSortResult.png) 演算法序列，會用來記錄算法，再用自己或其他人寫的 code 我能吸收的做紀錄，目的是讓自己能多看，然後背起來\n","permalink":"https://xinqilin.github.io/post/algorithm/mergesort/","tags":["Java","Algorithm"],"title":"MergeSort"},{"content":"CQRS (Command Query Responsibility Segregation) Command: 命令 會對系統產生『影響』的動作 沒有『結果』回傳 Query: 查詢 不會對系統產生『影響』的動作 會回傳『結果』 CQS 原則的限制 當查詢所回傳的結果只有短暫的存在意義時便不適用 =\u0026gt; Queue.poll(), Stack.pop()\nCQS: 適用於方法 CQRS: 適用於模型類別\nEvent Sourcing 1 事件源（Event Sourcing）常與 CQRS 一併提及，此設計模式的用意，根據 Martin Fowler 的說法，是要讓應用程式能夠將異動資料的事件按照發生的時間順序全部記錄下來；如此一來，我們不只能夠查詢過去任意時間點的資料狀態，也能夠重現特定時間範圍之間所發生的事件過程。比如說，採用 Event Sourcing 的銀行交易系統可以讓使用者得知帳戶餘額是如何變成目前的狀態的。Event Sourcing 常與 CQRS 一起搭配運用，但採用 CQRS 模式的應用程式並不一定需要使用 Event Sourcing。 reference: huanlintalk\n","permalink":"https://xinqilin.github.io/post/architecture/cqrs/","tags":[],"title":"CQRS"},{"content":"概述 在 Java 程式開發中，經常需要對 Map 集合按照 Value 值進行排序。Map 本身並不保證元素的順序，因此需要採用特定的技術來實現按 Value 排序。本文將深入介紹多種實作方式，並分析其效能特徵和適用場景。\n核心概念 Map 排序特性：Map 接口本身不提供排序功能 排序策略：通過轉換為 List 或使用 Stream API 實現 排序穩定性：保持相等元素的相對順序 效能考量：時間複雜度和空間複雜度的權衡 常見應用場景 統計排名：字頻統計、用戶評分排序 資料分析：銷售數據排序、效能指標排名 快取管理：LRU 快取的熱點資料排序 搜尋結果：相關性得分排序 實作方法一：Collections.sort + Map.Entry 1. 基礎實作 這是最傳統且直觀的方法，通過將 Map 的 entrySet 轉換為 List 進行排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package com.example.sorting; import java.util.*; import java.util.stream.Collectors; public class MapSortingExample { public static void main(String[] args) { // 創建測試資料 Map\u0026lt;String, Integer\u0026gt; wordFrequency = createSampleData(); // 方法一：使用 Collections.sort 排序 Map\u0026lt;String, Integer\u0026gt; sortedByValue = sortByValueUsingCollections(wordFrequency); System.out.println(\u0026#34;排序結果: \u0026#34; + sortedByValue); } /** * 使用 Collections.sort 按 Value 排序（降序） */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValueUsingCollections(Map\u0026lt;K, V\u0026gt; map) { // 將 Map 的 entrySet 轉換為 List List\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(map.entrySet()); // 使用 Collections.sort 排序 Collections.sort(list, new Comparator\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt;() { @Override public int compare(Map.Entry\u0026lt;K, V\u0026gt; entry1, Map.Entry\u0026lt;K, V\u0026gt; entry2) { // 降序排列：entry2 - entry1 return entry2.getValue().compareTo(entry1.getValue()); } }); // 將排序後的結果放入 LinkedHashMap 保持順序 Map\u0026lt;K, V\u0026gt; sortedMap = new LinkedHashMap\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;K, V\u0026gt; entry : list) { sortedMap.put(entry.getKey(), entry.getValue()); } return sortedMap; } /** * 創建測試資料 */ private static Map\u0026lt;String, Integer\u0026gt; createSampleData() { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;apple\u0026#34;, 10); map.put(\u0026#34;banana\u0026#34;, 25); map.put(\u0026#34;cherry\u0026#34;, 5); map.put(\u0026#34;date\u0026#34;, 15); map.put(\u0026#34;elderberry\u0026#34;, 30); return map; } } 2. Lambda 表達式簡化版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** * 使用 Lambda 表達式簡化比較器 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValueWithLambda(Map\u0026lt;K, V\u0026gt; map) { List\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(map.entrySet()); // Lambda 表達式簡化比較器 Collections.sort(list, (entry1, entry2) -\u0026gt; entry2.getValue().compareTo(entry1.getValue()) ); Map\u0026lt;K, V\u0026gt; sortedMap = new LinkedHashMap\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;K, V\u0026gt; entry : list) { sortedMap.put(entry.getKey(), entry.getValue()); } return sortedMap; } /** * 更簡潔的 Lambda 版本，支援升序/降序 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValue( Map\u0026lt;K, V\u0026gt; map, boolean ascending) { List\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(map.entrySet()); if (ascending) { Collections.sort(list, Map.Entry.comparingByValue()); } else { Collections.sort(list, Map.Entry.\u0026lt;K, V\u0026gt;comparingByValue().reversed()); } return list.stream() .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } 實作方法二：Stream API 1. 基礎 Stream 排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * 使用 Stream API 進行排序 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValueUsingStream( Map\u0026lt;K, V\u0026gt; map, boolean ascending) { return map.entrySet() .stream() .sorted(ascending ? Map.Entry.comparingByValue() : Map.Entry.\u0026lt;K, V\u0026gt;comparingByValue().reversed()) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } /** * 支援自訂比較器的 Stream 排序 */ public static \u0026lt;K, V\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValueWithCustomComparator( Map\u0026lt;K, V\u0026gt; map, Comparator\u0026lt;V\u0026gt; valueComparator) { return map.entrySet() .stream() .sorted(Map.Entry.comparingByValue(valueComparator)) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } 2. 並行 Stream 排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * 使用並行 Stream 提升大資料集的排序效能 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValueParallel( Map\u0026lt;K, V\u0026gt; map, boolean ascending) { return map.entrySet() .parallelStream() .sorted(ascending ? Map.Entry.comparingByValue() : Map.Entry.\u0026lt;K, V\u0026gt;comparingByValue().reversed()) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } 實作方法三：使用 TreeMap 1. Value-to-Key 反轉策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 /** * 使用 TreeMap 實現按 Value 排序 * 注意：此方法適用於 Value 值唯一的情況 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValueUsingTreeMap(Map\u0026lt;K, V\u0026gt; map) { // 創建一個以 Value 為 Key 的 TreeMap TreeMap\u0026lt;V, K\u0026gt; reversedMap = new TreeMap\u0026lt;\u0026gt;(Collections.reverseOrder()); for (Map.Entry\u0026lt;K, V\u0026gt; entry : map.entrySet()) { reversedMap.put(entry.getValue(), entry.getKey()); } // 重新構建原始格式的 Map Map\u0026lt;K, V\u0026gt; sortedMap = new LinkedHashMap\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;V, K\u0026gt; entry : reversedMap.entrySet()) { sortedMap.put(entry.getValue(), entry.getKey()); } return sortedMap; } /** * 處理重複 Value 的 TreeMap 排序 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortByValueWithDuplicates(Map\u0026lt;K, V\u0026gt; map) { // 使用 TreeMap，Key 為複合鍵：Value + 原始Key TreeMap\u0026lt;String, Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; sortedTreeMap = new TreeMap\u0026lt;\u0026gt;((key1, key2) -\u0026gt; { String[] parts1 = key1.split(\u0026#34;###\u0026#34;); String[] parts2 = key2.split(\u0026#34;###\u0026#34;); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value1 = (V) parts1[0]; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value2 = (V) parts2[0]; int valueComparison = value2.compareTo(value1); // 降序 if (valueComparison != 0) { return valueComparison; } return parts1[1].compareTo(parts2[1]); // 按原始 Key 排序 }); for (Map.Entry\u0026lt;K, V\u0026gt; entry : map.entrySet()) { String compositeKey = entry.getValue() + \u0026#34;###\u0026#34; + entry.getKey(); sortedTreeMap.put(compositeKey, entry); } Map\u0026lt;K, V\u0026gt; result = new LinkedHashMap\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;K, V\u0026gt; entry : sortedTreeMap.values()) { result.put(entry.getKey(), entry.getValue()); } return result; } 實作方法四：Key List 排序 1. 基於 Key 的間接排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * 通過排序 Key 列表實現間接排序 * 適用於需要保留原始 Map 的場景 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; List\u0026lt;K\u0026gt; sortKeysByValue( Map\u0026lt;K, V\u0026gt; map, boolean ascending) { List\u0026lt;K\u0026gt; keys = new ArrayList\u0026lt;\u0026gt;(map.keySet()); Collections.sort(keys, (key1, key2) -\u0026gt; { V value1 = map.get(key1); V value2 = map.get(key2); if (ascending) { return value1.compareTo(value2); } else { return value2.compareTo(value1); } }); return keys; } /** * 使用排序後的 Key 列表創建新的有序 Map */ public static \u0026lt;K, V\u0026gt; Map\u0026lt;K, V\u0026gt; createSortedMapFromKeys(Map\u0026lt;K, V\u0026gt; originalMap, List\u0026lt;K\u0026gt; sortedKeys) { Map\u0026lt;K, V\u0026gt; sortedMap = new LinkedHashMap\u0026lt;\u0026gt;(); for (K key : sortedKeys) { sortedMap.put(key, originalMap.get(key)); } return sortedMap; } 複雜排序場景 1. 多級排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 多級排序：先按 Value 排序，Value 相同時按 Key 排序 */ public static \u0026lt;K extends Comparable\u0026lt;K\u0026gt;, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; multiLevelSort(Map\u0026lt;K, V\u0026gt; map) { return map.entrySet() .stream() .sorted(Map.Entry.\u0026lt;K, V\u0026gt;comparingByValue().reversed() .thenComparing(Map.Entry.comparingByKey())) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } 2. 自訂物件排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * 自訂物件作為 Value 的排序 */ public static class ScoreData implements Comparable\u0026lt;ScoreData\u0026gt; { private final int score; private final String level; public ScoreData(int score, String level) { this.score = score; this.level = level; } @Override public int compareTo(ScoreData other) { int scoreComparison = Integer.compare(other.score, this.score); // 分數降序 if (scoreComparison != 0) { return scoreComparison; } return this.level.compareTo(other.level); // 等級升序 } // getter, setter, toString 方法 public int getScore() { return score; } public String getLevel() { return level; } @Override public String toString() { return String.format(\u0026#34;ScoreData{score=%d, level=\u0026#39;%s\u0026#39;}\u0026#34;, score, level); } } /** * 排序包含自訂物件的 Map */ public static Map\u0026lt;String, ScoreData\u0026gt; sortByScoreData(Map\u0026lt;String, ScoreData\u0026gt; map) { return map.entrySet() .stream() .sorted(Map.Entry.comparingByValue()) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } 效能分析與比較 1. 效能測試框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package com.example.performance; import java.util.*; import java.util.concurrent.TimeUnit; public class MapSortingPerformanceTest { private static final int[] DATA_SIZES = {1000, 10000, 100000, 1000000}; public static void main(String[] args) { System.out.println(\u0026#34;Map Sorting Performance Comparison\u0026#34;); System.out.println(\u0026#34;=====================================\u0026#34;); for (int size : DATA_SIZES) { System.out.printf(\u0026#34;\\nTesting with %d elements:\\n\u0026#34;, size); Map\u0026lt;String, Integer\u0026gt; testData = generateTestData(size); runPerformanceTest(\u0026#34;Collections.sort\u0026#34;, testData, MapSortingExample::sortByValueUsingCollections); runPerformanceTest(\u0026#34;Stream API\u0026#34;, testData, map -\u0026gt; sortByValueUsingStream(map, false)); runPerformanceTest(\u0026#34;Parallel Stream\u0026#34;, testData, map -\u0026gt; sortByValueParallel(map, false)); } } private static void runPerformanceTest(String method, Map\u0026lt;String, Integer\u0026gt; data, SortingFunction\u0026lt;String, Integer\u0026gt; sortFunction) { // 預熱 for (int i = 0; i \u0026lt; 3; i++) { sortFunction.sort(new HashMap\u0026lt;\u0026gt;(data)); } // 正式測試 long startTime = System.nanoTime(); Map\u0026lt;String, Integer\u0026gt; result = sortFunction.sort(new HashMap\u0026lt;\u0026gt;(data)); long endTime = System.nanoTime(); long duration = TimeUnit.NANOSECONDS.toMillis(endTime - startTime); System.out.printf(\u0026#34; %-15s: %4d ms (result size: %d)\\n\u0026#34;, method, duration, result.size()); } private static Map\u0026lt;String, Integer\u0026gt; generateTestData(int size) { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Random random = new Random(42); // 固定種子確保可重現性 for (int i = 0; i \u0026lt; size; i++) { String key = \u0026#34;key\u0026#34; + i; Integer value = random.nextInt(1000); map.put(key, value); } return map; } @FunctionalInterface interface SortingFunction\u0026lt;K, V\u0026gt; { Map\u0026lt;K, V\u0026gt; sort(Map\u0026lt;K, V\u0026gt; map); } } 2. 效能分析結果 方法 時間複雜度 空間複雜度 適用場景 Collections.sort O(n log n) O(n) 小到中型資料集，需要穩定排序 Stream API O(n log n) O(n) 函數式程式設計風格，程式碼簡潔 Parallel Stream O(n log n) O(n) 大型資料集，多核心處理器 TreeMap 反轉 O(n log n) O(n) Value 值唯一，需要持續有序 3. 記憶體使用分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 記憶體使用監控工具 */ public class MemoryAnalyzer { public static void analyzeMemoryUsage(String testName, Runnable test) { System.gc(); // 建議垃圾回收 Runtime runtime = Runtime.getRuntime(); long beforeMemory = runtime.totalMemory() - runtime.freeMemory(); test.run(); long afterMemory = runtime.totalMemory() - runtime.freeMemory(); long memoryUsed = afterMemory - beforeMemory; System.out.printf(\u0026#34;%s - Memory used: %.2f MB\\n\u0026#34;, testName, memoryUsed / (1024.0 * 1024.0)); } } 實際應用範例 1. 字頻統計和排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * 文本字頻統計與排序應用 */ public class WordFrequencyAnalyzer { /** * 統計文本中的字頻並排序 */ public static Map\u0026lt;String, Integer\u0026gt; analyzeWordFrequency(String text, int topN) { // 文本預處理和字頻統計 Map\u0026lt;String, Integer\u0026gt; wordCount = Arrays.stream(text.toLowerCase() .replaceAll(\u0026#34;[^a-zA-Z\\\\s]\u0026#34;, \u0026#34;\u0026#34;) .split(\u0026#34;\\\\s+\u0026#34;)) .filter(word -\u0026gt; !word.isEmpty()) .collect(Collectors.toMap( word -\u0026gt; word, word -\u0026gt; 1, Integer::sum, HashMap::new )); // 按頻率排序並取前 N 個 return wordCount.entrySet() .stream() .sorted(Map.Entry.\u0026lt;String, Integer\u0026gt;comparingByValue().reversed()) .limit(topN) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } public static void main(String[] args) { String sampleText = \u0026#34;The quick brown fox jumps over the lazy dog. \u0026#34; + \u0026#34;The dog was really lazy and the fox was very quick.\u0026#34;; Map\u0026lt;String, Integer\u0026gt; topWords = analyzeWordFrequency(sampleText, 5); System.out.println(\u0026#34;Top 5 most frequent words:\u0026#34;); topWords.forEach((word, count) -\u0026gt; System.out.printf(\u0026#34; %s: %d times\\n\u0026#34;, word, count)); } } 2. 使用者評分排序系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /** * 使用者評分排序系統 */ public class UserRatingSystem { public static class UserRating { private final String userId; private final double averageRating; private final int totalReviews; public UserRating(String userId, double averageRating, int totalReviews) { this.userId = userId; this.averageRating = averageRating; this.totalReviews = totalReviews; } public double getWeightedScore() { // 加權評分：考慮評論數量 return averageRating * Math.log(totalReviews + 1); } // getter 方法 public String getUserId() { return userId; } public double getAverageRating() { return averageRating; } public int getTotalReviews() { return totalReviews; } @Override public String toString() { return String.format(\u0026#34;UserRating{userId=\u0026#39;%s\u0026#39;, avgRating=%.2f, reviews=%d, weighted=%.2f}\u0026#34;, userId, averageRating, totalReviews, getWeightedScore()); } } /** * 根據加權評分排序用戶 */ public static Map\u0026lt;String, UserRating\u0026gt; sortUsersByRating(Map\u0026lt;String, UserRating\u0026gt; users) { return users.entrySet() .stream() .sorted(Map.Entry.\u0026lt;String, UserRating\u0026gt;comparingByValue( (r1, r2) -\u0026gt; Double.compare(r2.getWeightedScore(), r1.getWeightedScore()))) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } public static void main(String[] args) { Map\u0026lt;String, UserRating\u0026gt; users = new HashMap\u0026lt;\u0026gt;(); users.put(\u0026#34;user1\u0026#34;, new UserRating(\u0026#34;user1\u0026#34;, 4.5, 100)); users.put(\u0026#34;user2\u0026#34;, new UserRating(\u0026#34;user2\u0026#34;, 4.8, 50)); users.put(\u0026#34;user3\u0026#34;, new UserRating(\u0026#34;user3\u0026#34;, 4.2, 200)); users.put(\u0026#34;user4\u0026#34;, new UserRating(\u0026#34;user4\u0026#34;, 4.9, 25)); Map\u0026lt;String, UserRating\u0026gt; sortedUsers = sortUsersByRating(users); System.out.println(\u0026#34;Users sorted by weighted rating:\u0026#34;); sortedUsers.values().forEach(System.out::println); } } 最佳實踐與建議 1. 選擇合適的排序方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * 排序方法選擇指南 */ public class SortingMethodSelector { /** * 根據資料特徵選擇最佳排序方法 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; smartSort( Map\u0026lt;K, V\u0026gt; map, SortingContext context) { int size = map.size(); // 小資料集：使用 Collections.sort if (size \u0026lt; 1000) { return sortByValueUsingCollections(map); } // 大資料集且有多核心：使用並行 Stream if (size \u0026gt; 100000 \u0026amp;\u0026amp; context.isParallelProcessingAvailable()) { return sortByValueParallel(map, context.isAscending()); } // 中等資料集：使用 Stream API return sortByValueUsingStream(map, context.isAscending()); } public static class SortingContext { private final boolean ascending; private final boolean parallelProcessingAvailable; public SortingContext(boolean ascending, boolean parallelProcessingAvailable) { this.ascending = ascending; this.parallelProcessingAvailable = parallelProcessingAvailable; } public boolean isAscending() { return ascending; } public boolean isParallelProcessingAvailable() { return parallelProcessingAvailable; } } } 2. 避免常見陷阱 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * 常見錯誤和解決方案 */ public class CommonPitfalls { /** * 錯誤：使用 HashMap 儲存排序結果（會丟失順序） */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; wrongApproach(Map\u0026lt;K, V\u0026gt; map) { // ❌ 錯誤：HashMap 不保證順序 return map.entrySet() .stream() .sorted(Map.Entry.comparingByValue()) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, HashMap::new // ❌ 這裡應該使用 LinkedHashMap )); } /** * 正確：使用 LinkedHashMap 保持順序 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; correctApproach(Map\u0026lt;K, V\u0026gt; map) { // ✅ 正確：LinkedHashMap 保持插入順序 return map.entrySet() .stream() .sorted(Map.Entry.comparingByValue()) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new // ✅ 正確 )); } /** * 處理 null 值的排序 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortWithNulls(Map\u0026lt;K, V\u0026gt; map) { return map.entrySet() .stream() .sorted(Map.Entry.comparingByValue( Comparator.nullsLast(Comparator.naturalOrder()))) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } } 3. 執行緒安全考量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * 執行緒安全的 Map 排序 */ public class ThreadSafeSorting { /** * 對 ConcurrentHashMap 進行安全排序 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortConcurrentMap( ConcurrentHashMap\u0026lt;K, V\u0026gt; concurrentMap) { // 創建快照避免併發修改 Map\u0026lt;K, V\u0026gt; snapshot = new HashMap\u0026lt;\u0026gt;(concurrentMap); return snapshot.entrySet() .stream() .sorted(Map.Entry.comparingByValue()) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -\u0026gt; oldValue, LinkedHashMap::new )); } /** * 返回執行緒安全的排序結果 */ public static \u0026lt;K, V extends Comparable\u0026lt;V\u0026gt;\u0026gt; Map\u0026lt;K, V\u0026gt; sortAndMakeThreadSafe(Map\u0026lt;K, V\u0026gt; map) { Map\u0026lt;K, V\u0026gt; sortedMap = sortByValueUsingStream(map, false); return Collections.synchronizedMap(sortedMap); } } 總結 Map 按 Value 排序是 Java 開發中的常見需求，本文介紹了四種主要實作方法：\nCollections.sort：傳統方法，適合小到中型資料集 Stream API：現代函數式方法，程式碼簡潔易讀 Parallel Stream：適合大型資料集的並行處理 TreeMap 策略：適合特殊場景，如 Value 唯一的情況 選擇建議 小資料集（\u0026lt; 1000）：使用 Collections.sort 中等資料集（1000-100000）：使用 Stream API 大資料集（\u0026gt; 100000）：使用 Parallel Stream 需要持續有序：考慮使用 TreeMap 或 LinkedHashMap 函數式程式設計：優先選擇 Stream API 關鍵要點 保持順序：使用 LinkedHashMap 儲存排序結果 效能考量：根據資料大小選擇合適的方法 執行緒安全：併發環境下注意同步問題 null 處理：使用 Comparator.nullsLast() 處理 null 值 記憶體管理：大資料集時注意記憶體使用 通過掌握這些技術和最佳實踐，您可以在各種場景下高效地實現 Map 按 Value 排序功能。\n","permalink":"https://xinqilin.github.io/post/backend/map-sort-by-value/","tags":["Java","Map","Sorting","Collections","Stream API","Performance","Lambda","TreeMap","LinkedHashMap","Comparator"],"title":"Java Map 按 Value 排序：完整實作與效能優化指南"},{"content":"Git tag\n1 2 3 4 5 6 7 8 9 git tag deploy/{env_name}/{feature_name} git push origin deploy/{env_name}/{feature_name} git tag -d/--delete deploy/{env_name}/{feature_name} git push origin --delete deploy/{env_name}/{feature_name} git push origin :{tagname} git describe --always HEAD remote info\n1 2 git remote show origin ","permalink":"https://xinqilin.github.io/post/tools/git/","tags":[],"title":"Git"},{"content":"概述 dig（Domain Information Groper）是一個功能強大的命令行 DNS 查詢工具，用於執行 DNS 查詢並顯示詳細的查詢結果。它是網路管理員、系統管理員和開發者進行 DNS 診斷、網路故障排除和域名解析分析的必備工具。\n核心特徵 靈活的查詢選項：支援各種 DNS 記錄類型查詢 詳細的輸出資訊：提供完整的 DNS 響應詳情 多種輸出格式：支援簡潔、詳細和自訂格式 強大的診斷功能：追蹤查詢路徑和效能分析 腳本友好：適合自動化和批次處理 安裝與環境準備 各系統安裝方法 1 2 3 4 5 6 7 8 9 10 11 12 # Ubuntu/Debian sudo apt-get install dnsutils # CentOS/RHEL/Fedora sudo yum install bind-utils # CentOS 7 及以下 sudo dnf install bind-utils # Fedora/CentOS 8+ # macOS (通常已預裝) brew install bind # 驗證安裝 dig -v 基本語法 1 dig [@server] [domain] [type] [options] 基本使用 簡單 DNS 查詢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 基本查詢（A 記錄） dig google.com # 指定記錄類型 dig google.com A dig google.com AAAA dig google.com MX dig google.com NS dig google.com TXT # 簡潔輸出 dig google.com +short # 只顯示答案部分 dig google.com +noall +answer 查詢結果解析 標準 dig 輸出包含以下部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 dig www.google.com ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.16.1 \u0026lt;\u0026lt;\u0026gt;\u0026gt; www.google.com ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 12345 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: # 查詢問題 ;www.google.com. IN A ;; ANSWER SECTION: # 查詢答案 www.google.com. 299 IN A 142.250.191.68 ;; Query time: 15 msec # 查詢時間 ;; SERVER: 8.8.8.8#53(8.8.8.8) # DNS 伺服器 ;; WHEN: Mon Jan 08 21:40:50 CST 2024 ;; MSG SIZE rcvd: 59 # 響應大小 DNS 記錄類型查詢 A 和 AAAA 記錄 1 2 3 4 5 6 7 8 9 10 # IPv4 地址記錄（A） dig example.com A dig example.com A +short # IPv6 地址記錄（AAAA） dig example.com AAAA dig example.com AAAA +short # 同時查詢 A 和 AAAA dig example.com A AAAA MX 記錄（郵件交換） 1 2 3 4 5 6 7 8 9 # 查詢郵件伺服器 dig google.com MX dig google.com MX +short # 查詢特定域名的郵件配置 dig gmail.com MX +noall +answer # 顯示優先級和郵件伺服器 dig yahoo.com MX | grep -E \u0026#34;^[^;].*MX\u0026#34; NS 記錄（名稱伺服器） 1 2 3 4 5 6 7 8 9 # 查詢域名伺服器 dig google.com NS dig google.com NS +short # 查詢根域名伺服器 dig . NS +short # 查詢特定 TLD 的名稱伺服器 dig com NS +short TXT 記錄（文本記錄） 1 2 3 4 5 6 7 8 9 10 11 12 # 查詢 TXT 記錄 dig google.com TXT dig google.com TXT +short # 查詢 SPF 記錄 dig _spf.google.com TXT # 查詢 DKIM 記錄 dig selector1._domainkey.example.com TXT # 查詢 DMARC 記錄 dig _dmarc.example.com TXT SOA 記錄（授權起始） 1 2 3 4 5 6 # 查詢 SOA 記錄 dig google.com SOA dig google.com SOA +short # 詳細 SOA 信息 dig google.com SOA +noall +answer +multiline CNAME 記錄（別名） 1 2 3 4 5 6 # 查詢 CNAME 記錄 dig www.github.com CNAME dig www.github.com CNAME +short # 追蹤 CNAME 鏈 dig www.example.com +trace PTR 記錄（反向查詢） 1 2 3 4 5 6 7 8 9 # 反向 DNS 查詢 dig -x 8.8.8.8 dig -x 8.8.8.8 +short # 手動 PTR 查詢 dig 8.8.8.8.in-addr.arpa PTR # IPv6 反向查詢 dig -x 2001:4860:4860::8888 進階查詢選項 指定 DNS 伺服器 1 2 3 4 5 6 7 8 9 10 # 使用 Google DNS dig @8.8.8.8 google.com # 使用 Cloudflare DNS dig @1.1.1.1 google.com # 使用多個 DNS 伺服器比較 dig @8.8.8.8 google.com +short dig @1.1.1.1 google.com +short dig @208.67.222.222 google.com +short # OpenDNS 查詢追蹤 1 2 3 4 5 6 7 8 9 10 11 # 追蹤 DNS 解析路徑 dig google.com +trace # 追蹤特定記錄類型 dig google.com MX +trace # 簡化追蹤輸出 dig google.com +trace +short # 追蹤並顯示所有步驟 dig google.com +trace +additional +all 輸出格式控制 1 2 3 4 5 6 7 8 9 10 11 12 # 簡潔輸出 dig google.com +short dig google.com +noall +answer # 多行格式化輸出 dig google.com SOA +multiline # 隱藏特定部分 dig google.com +nocomments +noquestion +noauthority +noadditional +nostats # 自訂輸出組合 dig google.com +nocmd +noall +answer +multiline 網路診斷與故障排除 DNS 效能測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 測量查詢時間 dig google.com | grep \u0026#34;Query time\u0026#34; # 批次效能測試 for i in {1..10}; do dig google.com +stats | grep \u0026#34;Query time\u0026#34; done # 比較不同 DNS 伺服器效能 dns_servers=(\u0026#34;8.8.8.8\u0026#34; \u0026#34;1.1.1.1\u0026#34; \u0026#34;208.67.222.222\u0026#34;) for server in \u0026#34;${dns_servers[@]}\u0026#34;; do echo \u0026#34;Testing $server:\u0026#34; dig @$server google.com +stats | grep \u0026#34;Query time\u0026#34; done DNS 快取分析 1 2 3 4 5 6 7 8 # 檢查 TTL 值 dig google.com +noall +answer # 監控 TTL 變化 watch -n 5 \u0026#39;dig google.com +noall +answer\u0026#39; # 檢查快取狀態 dig google.com +norecurse 域名可用性檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 檢查域名是否存在 dig example.com ANY +short # 檢查域名狀態 dig example.com +short \u0026gt; /dev/null \u0026amp;\u0026amp; echo \u0026#34;Domain exists\u0026#34; || echo \u0026#34;Domain not found\u0026#34; # 批次域名檢查 domains=(\u0026#34;google.com\u0026#34; \u0026#34;example.com\u0026#34; \u0026#34;nonexistent-domain-12345.com\u0026#34;) for domain in \u0026#34;${domains[@]}\u0026#34;; do if dig \u0026#34;$domain\u0026#34; +short \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;$domain: EXISTS\u0026#34; else echo \u0026#34;$domain: NOT FOUND\u0026#34; fi done DNSSEC 驗證 1 2 3 4 5 6 7 8 9 10 11 # 檢查 DNSSEC 支援 dig google.com +dnssec +multiline # 驗證 DNSSEC 簽名 dig google.com DNSKEY +dnssec # 檢查 DS 記錄 dig google.com DS +dnssec # 驗證鏈 dig +trace +dnssec google.com 實戰應用場景 1. 郵件伺服器診斷 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/bin/bash # mail_server_check.sh - 郵件伺服器診斷腳本 check_mail_server() { local domain=\u0026#34;$1\u0026#34; echo \u0026#34;=== Mail Server Diagnosis for $domain ===\u0026#34; # 檢查 MX 記錄 echo \u0026#34;MX Records:\u0026#34; dig \u0026#34;$domain\u0026#34; MX +noall +answer # 檢查 SPF 記錄 echo -e \u0026#34;\\nSPF Record:\u0026#34; dig \u0026#34;$domain\u0026#34; TXT +short | grep -i spf # 檢查 DMARC 記錄 echo -e \u0026#34;\\nDMARC Record:\u0026#34; dig \u0026#34;_dmarc.$domain\u0026#34; TXT +short # 檢查常見 DKIM 選擇器 echo -e \u0026#34;\\nDKIM Records:\u0026#34; selectors=(\u0026#34;default\u0026#34; \u0026#34;selector1\u0026#34; \u0026#34;selector2\u0026#34; \u0026#34;google\u0026#34; \u0026#34;k1\u0026#34;) for selector in \u0026#34;${selectors[@]}\u0026#34;; do result=$(dig \u0026#34;${selector}._domainkey.$domain\u0026#34; TXT +short 2\u0026gt;/dev/null) if [ -n \u0026#34;$result\u0026#34; ]; then echo \u0026#34;$selector: $result\u0026#34; fi done } # 使用範例 check_mail_server \u0026#34;gmail.com\u0026#34; 2. 網站可用性監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #!/bin/bash # website_dns_monitor.sh - 網站 DNS 監控腳本 monitor_website() { local domain=\u0026#34;$1\u0026#34; local log_file=\u0026#34;${2:-dns_monitor.log}\u0026#34; timestamp=$(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;) # 檢查 A 記錄 a_record=$(dig \u0026#34;$domain\u0026#34; A +short | head -1) # 檢查 AAAA 記錄 aaaa_record=$(dig \u0026#34;$domain\u0026#34; AAAA +short | head -1) # 測量查詢時間 query_time=$(dig \u0026#34;$domain\u0026#34; | grep \u0026#34;Query time\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) # 檢查 DNS 伺服器響應 dns_server=$(dig \u0026#34;$domain\u0026#34; | grep \u0026#34;SERVER:\u0026#34; | awk \u0026#39;{print $2}\u0026#39;) # 記錄結果 log_entry=\u0026#34;$timestamp | $domain | A: $a_record | AAAA: $aaaa_record | Time: ${query_time}ms | Server: $dns_server\u0026#34; echo \u0026#34;$log_entry\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; # 檢查異常 if [ -z \u0026#34;$a_record\u0026#34; ]; then echo \u0026#34;WARNING: No A record found for $domain\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; fi if [ \u0026#34;${query_time:-0}\u0026#34; -gt 1000 ]; then echo \u0026#34;WARNING: Slow DNS response (${query_time}ms) for $domain\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; fi } # 監控多個網站 websites=(\u0026#34;google.com\u0026#34; \u0026#34;github.com\u0026#34; \u0026#34;stackoverflow.com\u0026#34;) for site in \u0026#34;${websites[@]}\u0026#34;; do monitor_website \u0026#34;$site\u0026#34; done 3. DNS 伺服器效能比較 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #!/bin/bash # dns_performance_test.sh - DNS 效能測試腳本 dns_performance_test() { local domain=\u0026#34;${1:-google.com}\u0026#34; local test_count=\u0026#34;${2:-10}\u0026#34; # DNS 伺服器列表 declare -A dns_servers=( [\u0026#34;Google\u0026#34;]=\u0026#34;8.8.8.8\u0026#34; [\u0026#34;Cloudflare\u0026#34;]=\u0026#34;1.1.1.1\u0026#34; [\u0026#34;OpenDNS\u0026#34;]=\u0026#34;208.67.222.222\u0026#34; [\u0026#34;Quad9\u0026#34;]=\u0026#34;9.9.9.9\u0026#34; ) echo \u0026#34;DNS Performance Test for $domain\u0026#34; echo \u0026#34;==================================\u0026#34; for name in \u0026#34;${!dns_servers[@]}\u0026#34;; do server=\u0026#34;${dns_servers[$name]}\u0026#34; echo -e \u0026#34;\\nTesting $name ($server):\u0026#34; total_time=0 successful_queries=0 for i in $(seq 1 $test_count); do query_time=$(dig @\u0026#34;$server\u0026#34; \u0026#34;$domain\u0026#34; +stats 2\u0026gt;/dev/null | grep \u0026#34;Query time\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) if [ -n \u0026#34;$query_time\u0026#34; ]; then total_time=$((total_time + query_time)) successful_queries=$((successful_queries + 1)) echo -n \u0026#34;.\u0026#34; else echo -n \u0026#34;x\u0026#34; fi done if [ $successful_queries -gt 0 ]; then average_time=$((total_time / successful_queries)) echo -e \u0026#34;\\nAverage: ${average_time}ms (${successful_queries}/${test_count} successful)\u0026#34; else echo -e \u0026#34;\\nFailed: No successful queries\u0026#34; fi done } # 執行測試 dns_performance_test \u0026#34;google.com\u0026#34; 5 4. 域名變更追蹤 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #!/bin/bash # dns_change_tracker.sh - DNS 變更追蹤腳本 track_dns_changes() { local domain=\u0026#34;$1\u0026#34; local record_type=\u0026#34;${2:-A}\u0026#34; local interval=\u0026#34;${3:-300}\u0026#34; # 5分鐘 local log_file=\u0026#34;dns_changes_${domain}_${record_type}.log\u0026#34; echo \u0026#34;Tracking DNS changes for $domain ($record_type record)\u0026#34; echo \u0026#34;Log file: $log_file\u0026#34; previous_result=\u0026#34;\u0026#34; while true; do timestamp=$(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;) current_result=$(dig \u0026#34;$domain\u0026#34; \u0026#34;$record_type\u0026#34; +short | sort | tr \u0026#39;\\n\u0026#39; \u0026#39; \u0026#39;) if [ \u0026#34;$current_result\u0026#34; != \u0026#34;$previous_result\u0026#34; ]; then if [ -n \u0026#34;$previous_result\u0026#34; ]; then echo \u0026#34;$timestamp | CHANGE DETECTED\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; echo \u0026#34;$timestamp | Old: $previous_result\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; echo \u0026#34;$timestamp | New: $current_result\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; echo \u0026#34;$timestamp | ---\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; else echo \u0026#34;$timestamp | Initial: $current_result\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; fi previous_result=\u0026#34;$current_result\u0026#34; else echo \u0026#34;$timestamp | No change: $current_result\u0026#34; fi sleep \u0026#34;$interval\u0026#34; done } # 使用範例 # track_dns_changes \u0026#34;example.com\u0026#34; \u0026#34;A\u0026#34; 60 5. 批次域名分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #!/bin/bash # batch_domain_analysis.sh - 批次域名分析腳本 analyze_domains() { local domain_file=\u0026#34;$1\u0026#34; local output_file=\u0026#34;${2:-domain_analysis_$(date +%Y%m%d_%H%M%S).csv}\u0026#34; # CSV 標題 echo \u0026#34;Domain,A_Record,MX_Record,NS_Record,TXT_Count,Query_Time_ms,Status\u0026#34; \u0026gt; \u0026#34;$output_file\u0026#34; while IFS= read -r domain; do # 跳過空行和註解 [[ -z \u0026#34;$domain\u0026#34; || \u0026#34;$domain\u0026#34; =~ ^[[:space:]]*# ]] \u0026amp;\u0026amp; continue echo \u0026#34;Analyzing: $domain\u0026#34; # 查詢各種記錄 a_record=$(dig \u0026#34;$domain\u0026#34; A +short | head -1) mx_record=$(dig \u0026#34;$domain\u0026#34; MX +short | head -1 | awk \u0026#39;{print $2}\u0026#39;) ns_record=$(dig \u0026#34;$domain\u0026#34; NS +short | head -1) txt_count=$(dig \u0026#34;$domain\u0026#34; TXT +short | wc -l) # 測量查詢時間 query_time=$(dig \u0026#34;$domain\u0026#34; | grep \u0026#34;Query time\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) # 判斷狀態 if [ -n \u0026#34;$a_record\u0026#34; ]; then status=\u0026#34;Active\u0026#34; elif dig \u0026#34;$domain\u0026#34; +short \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then status=\u0026#34;Registered\u0026#34; else status=\u0026#34;Not Found\u0026#34; fi # 寫入 CSV echo \u0026#34;$domain,$a_record,$mx_record,$ns_record,$txt_count,$query_time,$status\u0026#34; \u0026gt;\u0026gt; \u0026#34;$output_file\u0026#34; done \u0026lt; \u0026#34;$domain_file\u0026#34; echo \u0026#34;Analysis complete. Results saved to: $output_file\u0026#34; } # 建立範例域名列表 cat \u0026gt; domains.txt \u0026lt;\u0026lt; EOF google.com github.com stackoverflow.com example.com nonexistent-domain-12345.com EOF # 執行分析 analyze_domains \u0026#34;domains.txt\u0026#34; 進階技巧與最佳化 1. 自訂查詢腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #!/bin/bash # dig_wrapper.sh - dig 包裝器腳本 # 彩色輸出 RED=\u0026#39;\\033[0;31m\u0026#39; GREEN=\u0026#39;\\033[0;32m\u0026#39; YELLOW=\u0026#39;\\033[1;33m\u0026#39; BLUE=\u0026#39;\\033[0;34m\u0026#39; NC=\u0026#39;\\033[0m\u0026#39; # No Color enhanced_dig() { local domain=\u0026#34;$1\u0026#34; local record_type=\u0026#34;${2:-A}\u0026#34; echo -e \u0026#34;${BLUE}=== Enhanced DNS Query: $domain ($record_type) ===${NC}\u0026#34; # 基本查詢 echo -e \u0026#34;\\n${GREEN}Basic Query:${NC}\u0026#34; dig \u0026#34;$domain\u0026#34; \u0026#34;$record_type\u0026#34; +noall +answer # 查詢時間和伺服器資訊 echo -e \u0026#34;\\n${GREEN}Performance Info:${NC}\u0026#34; dig \u0026#34;$domain\u0026#34; \u0026#34;$record_type\u0026#34; | grep -E \u0026#34;(Query time|SERVER:)\u0026#34; # 權威伺服器查詢 echo -e \u0026#34;\\n${GREEN}Authoritative Servers:${NC}\u0026#34; dig \u0026#34;$domain\u0026#34; NS +short # 如果是 A 記錄，也顯示反向查詢 if [ \u0026#34;$record_type\u0026#34; = \u0026#34;A\u0026#34; ]; then echo -e \u0026#34;\\n${GREEN}Reverse DNS:${NC}\u0026#34; ip=$(dig \u0026#34;$domain\u0026#34; A +short | head -1) if [ -n \u0026#34;$ip\u0026#34; ]; then dig -x \u0026#34;$ip\u0026#34; +short fi fi } # 使用範例 enhanced_dig \u0026#34;google.com\u0026#34; \u0026#34;A\u0026#34; 2. DNS 健康檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #!/bin/bash # dns_health_check.sh - DNS 健康檢查腳本 dns_health_check() { local domain=\u0026#34;$1\u0026#34; echo \u0026#34;DNS Health Check for: $domain\u0026#34; echo \u0026#34;=============================\u0026#34; # 檢查項目計數 local total_checks=0 local passed_checks=0 # 1. 檢查 A 記錄 echo -n \u0026#34;Checking A record... \u0026#34; total_checks=$((total_checks + 1)) if dig \u0026#34;$domain\u0026#34; A +short \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;✓ PASS\u0026#34; passed_checks=$((passed_checks + 1)) else echo \u0026#34;✗ FAIL\u0026#34; fi # 2. 檢查 NS 記錄 echo -n \u0026#34;Checking NS records... \u0026#34; total_checks=$((total_checks + 1)) ns_count=$(dig \u0026#34;$domain\u0026#34; NS +short | wc -l) if [ \u0026#34;$ns_count\u0026#34; -ge 2 ]; then echo \u0026#34;✓ PASS ($ns_count nameservers)\u0026#34; passed_checks=$((passed_checks + 1)) else echo \u0026#34;✗ FAIL (only $ns_count nameserver)\u0026#34; fi # 3. 檢查 SOA 記錄 echo -n \u0026#34;Checking SOA record... \u0026#34; total_checks=$((total_checks + 1)) if dig \u0026#34;$domain\u0026#34; SOA +short \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;✓ PASS\u0026#34; passed_checks=$((passed_checks + 1)) else echo \u0026#34;✗ FAIL\u0026#34; fi # 4. 檢查查詢時間 echo -n \u0026#34;Checking query performance... \u0026#34; total_checks=$((total_checks + 1)) query_time=$(dig \u0026#34;$domain\u0026#34; | grep \u0026#34;Query time\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) if [ \u0026#34;${query_time:-9999}\u0026#34; -lt 1000 ]; then echo \u0026#34;✓ PASS (${query_time}ms)\u0026#34; passed_checks=$((passed_checks + 1)) else echo \u0026#34;✗ FAIL (${query_time}ms - too slow)\u0026#34; fi # 5. 檢查權威伺服器一致性 echo -n \u0026#34;Checking authoritative server consistency... \u0026#34; total_checks=$((total_checks + 1)) ns_servers=$(dig \u0026#34;$domain\u0026#34; NS +short) consistent=true if [ -n \u0026#34;$ns_servers\u0026#34; ]; then first_result=$(dig @$(echo \u0026#34;$ns_servers\u0026#34; | head -1) \u0026#34;$domain\u0026#34; A +short | sort) while IFS= read -r server; do current_result=$(dig @\u0026#34;$server\u0026#34; \u0026#34;$domain\u0026#34; A +short | sort) if [ \u0026#34;$current_result\u0026#34; != \u0026#34;$first_result\u0026#34; ]; then consistent=false break fi done \u0026lt;\u0026lt;\u0026lt; \u0026#34;$ns_servers\u0026#34; if $consistent; then echo \u0026#34;✓ PASS\u0026#34; passed_checks=$((passed_checks + 1)) else echo \u0026#34;✗ FAIL (inconsistent results)\u0026#34; fi else echo \u0026#34;✗ FAIL (no nameservers found)\u0026#34; fi # 總結 echo echo \u0026#34;Health Check Summary: $passed_checks/$total_checks passed\u0026#34; if [ \u0026#34;$passed_checks\u0026#34; -eq \u0026#34;$total_checks\u0026#34; ]; then echo \u0026#34;Status: ✓ HEALTHY\u0026#34; return 0 else echo \u0026#34;Status: ✗ ISSUES DETECTED\u0026#34; return 1 fi } # 使用範例 dns_health_check \u0026#34;google.com\u0026#34; 3. 配置檔案管理 建立 ~/.digrc 配置檔案：\n1 2 3 4 # ~/.digrc - dig 預設配置 +noall +answer +time=5 +tries=3 或使用環境變數：\n1 2 3 4 5 6 7 # 在 ~/.bashrc 或 ~/.zshrc 中添加 export DIG_DEFAULT_OPTS=\u0026#34;+short +time=3\u0026#34; # 使用別名 alias digs=\u0026#39;dig +short\u0026#39; alias digt=\u0026#39;dig +trace\u0026#39; alias digx=\u0026#39;dig +short +time=1\u0026#39; 常見問題與解決方案 1. 查詢超時問題 1 2 3 4 5 6 7 8 # 調整超時設定 dig google.com +time=10 +tries=3 # 使用 TCP 查詢 dig google.com +tcp # 檢查網路連接 dig google.com +trace | grep -E \u0026#34;(SERVFAIL|TIMEOUT)\u0026#34; 2. DNS 伺服器問題 1 2 3 4 5 6 7 8 # 測試多個 DNS 伺服器 dns_test() { local domain=\u0026#34;$1\u0026#34; for server in 8.8.8.8 1.1.1.1 208.67.222.222; do echo \u0026#34;Testing $server:\u0026#34; dig @$server \u0026#34;$domain\u0026#34; +short +time=3 || echo \u0026#34;Failed\u0026#34; done } 3. 記錄解析問題 1 2 3 4 5 6 7 8 # 檢查完整的解析路徑 dig google.com +trace +all # 驗證 DNSSEC dig google.com +dnssec +multiline # 檢查快取污染 dig google.com @8.8.8.8 +norecurse 與其他工具整合 1. 與 nslookup 比較 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # dig 格式 dig google.com A +short # nslookup 格式 nslookup google.com | grep \u0026#34;Address:\u0026#34; | tail -1 | awk \u0026#39;{print $2}\u0026#39; # 轉換腳本 dig2nslookup() { local domain=\u0026#34;$1\u0026#34; echo \u0026#34;Server: $(dig google.com | grep SERVER | awk \u0026#39;{print $2}\u0026#39; | cut -d# -f1)\u0026#34; echo \u0026#34;Address: $(dig google.com | grep SERVER | awk \u0026#39;{print $2}\u0026#39;)\u0026#34; echo echo \u0026#34;Name: $domain\u0026#34; dig \u0026#34;$domain\u0026#34; A +short | while read ip; do echo \u0026#34;Address: $ip\u0026#34; done } 2. 與監控系統整合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # Nagios 檢查腳本 check_dns_record() { local domain=\u0026#34;$1\u0026#34; local expected=\u0026#34;$2\u0026#34; local timeout=\u0026#34;${3:-5}\u0026#34; result=$(dig \u0026#34;$domain\u0026#34; A +short +time=\u0026#34;$timeout\u0026#34; 2\u0026gt;/dev/null | head -1) if [ \u0026#34;$result\u0026#34; = \u0026#34;$expected\u0026#34; ]; then echo \u0026#34;OK - DNS record matches: $result\u0026#34; exit 0 elif [ -z \u0026#34;$result\u0026#34; ]; then echo \u0026#34;CRITICAL - No DNS record found\u0026#34; exit 2 else echo \u0026#34;WARNING - DNS record mismatch. Expected: $expected, Got: $result\u0026#34; exit 1 fi } # Prometheus 指標生成 generate_dns_metrics() { local domain=\u0026#34;$1\u0026#34; query_time=$(dig \u0026#34;$domain\u0026#34; | grep \u0026#34;Query time\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) record_count=$(dig \u0026#34;$domain\u0026#34; A +short | wc -l) echo \u0026#34;dns_query_duration_ms{domain=\\\u0026#34;$domain\\\u0026#34;} $query_time\u0026#34; echo \u0026#34;dns_record_count{domain=\\\u0026#34;$domain\\\u0026#34;,type=\\\u0026#34;A\\\u0026#34;} $record_count\u0026#34; } 總結 核心優勢 功能完整：支援所有 DNS 記錄類型和查詢選項 輸出詳細：提供完整的 DNS 響應資訊 診斷能力：強大的網路故障排除功能 腳本友好：適合自動化和批次處理 標準工具：廣泛支援和良好的文檔 最佳實踐 適當的超時設定：避免查詢掛起 使用追蹤功能：診斷複雜的 DNS 問題 驗證多個來源：比較不同 DNS 伺服器的結果 記錄和監控：建立 DNS 變更的歷史記錄 安全考慮：驗證 DNSSEC 和檢查 DNS 劫持 常用命令速查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 基本查詢 dig domain.com # 標準查詢 dig domain.com +short # 簡潔輸出 dig domain.com +trace # 追蹤解析路徑 # 記錄類型 dig domain.com A # IPv4 地址 dig domain.com AAAA # IPv6 地址 dig domain.com MX # 郵件交換 dig domain.com NS # 名稱伺服器 dig domain.com TXT # 文本記錄 # 進階選項 dig @8.8.8.8 domain.com # 指定 DNS 伺服器 dig -x 8.8.8.8 # 反向查詢 dig domain.com +dnssec # DNSSEC 驗證 dig domain.com +norecurse # 非遞歸查詢 dig 是網路管理和 DNS 診斷的核心工具，掌握其使用技巧能夠大幅提升網路問題診斷和域名管理的效率。記住：理解 DNS 系統的工作原理是有效使用 dig 的基礎。\n參考資料 BIND 9 Administrator Reference Manual RFC 1035 - Domain Names DNS and BIND on IPv6 DNSSEC Guide Linux dig Command Tutorial ","permalink":"https://xinqilin.github.io/post/tools/dig/","tags":["Linux","Dig","DNS","Network","Debugging","System Administration","Command Line"],"title":"Dig 命令完整指南：DNS 查詢與網路診斷的強大工具"},{"content":"SFTP 企業級工具類實作指南 簡介 在現代企業應用中，安全的文件傳輸是不可或缺的功能。SFTP（SSH File Transfer Protocol）提供了一種安全、可靠的文件傳輸方案。本文將詳細介紹如何在 Spring Boot 中實作企業級的 SFTP 工具類，包含連線池管理、錯誤處理、效能優化等關鍵功能。\n核心依賴配置 Maven 依賴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;dependencies\u0026gt; \u0026lt;!-- SFTP 核心依賴 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.jcraft\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsch\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1.55\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Apache Commons Pool2 連線池 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-pool2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.11.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot Starter --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot Configuration Processor --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Micrometer 監控 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.micrometer\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;micrometer-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Gradle 依賴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 dependencies { // SFTP 核心依賴 implementation \u0026#39;com.jcraft:jsch:0.1.55\u0026#39; // Apache Commons Pool2 連線池 implementation \u0026#39;org.apache.commons:commons-pool2:2.11.1\u0026#39; // Spring Boot Starter implementation \u0026#39;org.springframework.boot:spring-boot-starter\u0026#39; // Spring Boot Configuration Processor annotationProcessor \u0026#39;org.springframework.boot:spring-boot-configuration-processor\u0026#39; // Micrometer 監控 implementation \u0026#39;io.micrometer:micrometer-core\u0026#39; } 配置類別 SFTP 配置屬性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Configuration; import lombok.Data; @Data @Configuration @ConfigurationProperties(prefix = \u0026#34;sftp\u0026#34;) public class SftpProperties { // 連線配置 private String host; private int port = 22; private String username; private String password; private String privateKeyPath; private String passphrase; // 連線池配置 private Pool pool = new Pool(); // 超時配置 private int connectTimeout = 30000; private int sessionTimeout = 30000; private int channelTimeout = 30000; // 重試配置 private int maxRetries = 3; private int retryDelay = 1000; // 安全配置 private boolean strictHostKeyChecking = false; private String knownHostsFile; private String hostKeyAlgorithms; @Data public static class Pool { private int maxActive = 10; private int maxIdle = 5; private int minIdle = 1; private long maxWait = 10000; private boolean testOnBorrow = true; private boolean testOnReturn = true; private boolean testWhileIdle = true; private long timeBetweenEvictionRuns = 60000; private long minEvictableIdleTime = 300000; } } application.yml 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 sftp: host: sftp.example.com port: 22 username: ${SFTP_USERNAME:sftpuser} password: ${SFTP_PASSWORD:} private-key-path: ${SFTP_PRIVATE_KEY_PATH:} passphrase: ${SFTP_PASSPHRASE:} # 連線池配置 pool: max-active: 20 max-idle: 10 min-idle: 2 max-wait: 15000 test-on-borrow: true test-on-return: true test-while-idle: true time-between-eviction-runs: 60000 min-evictable-idle-time: 300000 # 超時配置 connect-timeout: 30000 session-timeout: 30000 channel-timeout: 30000 # 重試配置 max-retries: 3 retry-delay: 1000 # 安全配置 strict-host-key-checking: false known-hosts-file: ~/.ssh/known_hosts host-key-algorithms: ssh-rsa,ssh-dss # 監控配置 management: endpoints: web: exposure: include: health,metrics,info,sftp metrics: tags: application: sftp-service 核心實作類別 SFTP 連線工廠 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 import com.jcraft.jsch.*; import lombok.extern.slf4j.Slf4j; import org.apache.commons.pool2.BasePooledObjectFactory; import org.apache.commons.pool2.PooledObject; import org.apache.commons.pool2.impl.DefaultPooledObject; import org.springframework.stereotype.Component; import java.io.File; import java.util.Properties; @Slf4j @Component public class SftpConnectionFactory extends BasePooledObjectFactory\u0026lt;ChannelSftp\u0026gt; { private final SftpProperties sftpProperties; private final JSch jsch; public SftpConnectionFactory(SftpProperties sftpProperties) { this.sftpProperties = sftpProperties; this.jsch = new JSch(); initializeJSch(); } private void initializeJSch() { try { // 設定私鑰 if (sftpProperties.getPrivateKeyPath() != null) { if (sftpProperties.getPassphrase() != null) { jsch.addIdentity(sftpProperties.getPrivateKeyPath(), sftpProperties.getPassphrase()); } else { jsch.addIdentity(sftpProperties.getPrivateKeyPath()); } } // 設定 known_hosts if (sftpProperties.getKnownHostsFile() != null) { jsch.setKnownHosts(sftpProperties.getKnownHostsFile()); } log.info(\u0026#34;SFTP JSch 初始化完成\u0026#34;); } catch (JSchException e) { log.error(\u0026#34;SFTP JSch 初始化失敗\u0026#34;, e); throw new RuntimeException(\u0026#34;SFTP JSch 初始化失敗\u0026#34;, e); } } @Override public ChannelSftp create() throws Exception { log.debug(\u0026#34;創建新的 SFTP 連線到 {}:{}\u0026#34;, sftpProperties.getHost(), sftpProperties.getPort()); Session session = jsch.getSession( sftpProperties.getUsername(), sftpProperties.getHost(), sftpProperties.getPort() ); // 設定密碼（如果有） if (sftpProperties.getPassword() != null) { session.setPassword(sftpProperties.getPassword()); } // 設定連線屬性 Properties config = new Properties(); config.put(\u0026#34;StrictHostKeyChecking\u0026#34;, sftpProperties.isStrictHostKeyChecking() ? \u0026#34;yes\u0026#34; : \u0026#34;no\u0026#34;); if (sftpProperties.getHostKeyAlgorithms() != null) { config.put(\u0026#34;server_host_key\u0026#34;, sftpProperties.getHostKeyAlgorithms()); } session.setConfig(config); session.setTimeout(sftpProperties.getSessionTimeout()); // 建立連線 session.connect(sftpProperties.getConnectTimeout()); Channel channel = session.openChannel(\u0026#34;sftp\u0026#34;); channel.connect(sftpProperties.getChannelTimeout()); ChannelSftp channelSftp = (ChannelSftp) channel; log.debug(\u0026#34;SFTP 連線創建成功\u0026#34;); return channelSftp; } @Override public PooledObject\u0026lt;ChannelSftp\u0026gt; wrap(ChannelSftp channelSftp) { return new DefaultPooledObject\u0026lt;\u0026gt;(channelSftp); } @Override public boolean validateObject(PooledObject\u0026lt;ChannelSftp\u0026gt; pooledObject) { ChannelSftp channelSftp = pooledObject.getObject(); return channelSftp != null \u0026amp;\u0026amp; channelSftp.isConnected(); } @Override public void destroyObject(PooledObject\u0026lt;ChannelSftp\u0026gt; pooledObject) throws Exception { ChannelSftp channelSftp = pooledObject.getObject(); if (channelSftp != null) { Session session = channelSftp.getSession(); if (channelSftp.isConnected()) { channelSftp.disconnect(); } if (session != null \u0026amp;\u0026amp; session.isConnected()) { session.disconnect(); } } log.debug(\u0026#34;SFTP 連線已銷毀\u0026#34;); } } SFTP 連線池管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import org.apache.commons.pool2.ObjectPool; import org.apache.commons.pool2.impl.GenericObjectPool; import org.apache.commons.pool2.impl.GenericObjectPoolConfig; import org.springframework.stereotype.Component; import lombok.extern.slf4j.Slf4j; @Slf4j @Component public class SftpConnectionPoolManager { private final ObjectPool\u0026lt;ChannelSftp\u0026gt; sftpPool; private final SftpProperties sftpProperties; public SftpConnectionPoolManager(SftpConnectionFactory factory, SftpProperties sftpProperties) { this.sftpProperties = sftpProperties; this.sftpPool = createPool(factory); } private ObjectPool\u0026lt;ChannelSftp\u0026gt; createPool(SftpConnectionFactory factory) { GenericObjectPoolConfig\u0026lt;ChannelSftp\u0026gt; config = new GenericObjectPoolConfig\u0026lt;\u0026gt;(); config.setMaxTotal(sftpProperties.getPool().getMaxActive()); config.setMaxIdle(sftpProperties.getPool().getMaxIdle()); config.setMinIdle(sftpProperties.getPool().getMinIdle()); config.setMaxWaitMillis(sftpProperties.getPool().getMaxWait()); config.setTestOnBorrow(sftpProperties.getPool().isTestOnBorrow()); config.setTestOnReturn(sftpProperties.getPool().isTestOnReturn()); config.setTestWhileIdle(sftpProperties.getPool().isTestWhileIdle()); config.setTimeBetweenEvictionRunsMillis(sftpProperties.getPool().getTimeBetweenEvictionRuns()); config.setMinEvictableIdleTimeMillis(sftpProperties.getPool().getMinEvictableIdleTime()); return new GenericObjectPool\u0026lt;\u0026gt;(factory, config); } public ChannelSftp borrowConnection() throws Exception { return sftpPool.borrowObject(); } public void returnConnection(ChannelSftp channelSftp) { if (channelSftp != null) { try { sftpPool.returnObject(channelSftp); } catch (Exception e) { log.error(\u0026#34;歸還 SFTP 連線失敗\u0026#34;, e); } } } public void invalidateConnection(ChannelSftp channelSftp) { if (channelSftp != null) { try { sftpPool.invalidateObject(channelSftp); } catch (Exception e) { log.error(\u0026#34;無效化 SFTP 連線失敗\u0026#34;, e); } } } public int getActiveConnections() { return sftpPool.getNumActive(); } public int getIdleConnections() { return sftpPool.getNumIdle(); } } 企業級 SFTP 工具類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 import com.jcraft.jsch.ChannelSftp; import com.jcraft.jsch.SftpException; import io.micrometer.core.instrument.Counter; import io.micrometer.core.instrument.MeterRegistry; import io.micrometer.core.instrument.Timer; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; import java.io.*; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.ArrayList; import java.util.List; import java.util.Vector; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.function.Function; @Slf4j @Component public class SftpUtil { private final SftpConnectionPoolManager connectionPoolManager; private final SftpProperties sftpProperties; private final ExecutorService executorService; // 監控指標 private final Counter uploadCounter; private final Counter downloadCounter; private final Counter deleteCounter; private final Counter errorCounter; private final Timer uploadTimer; private final Timer downloadTimer; public SftpUtil(SftpConnectionPoolManager connectionPoolManager, SftpProperties sftpProperties, MeterRegistry meterRegistry) { this.connectionPoolManager = connectionPoolManager; this.sftpProperties = sftpProperties; this.executorService = Executors.newFixedThreadPool(10); // 初始化監控指標 this.uploadCounter = Counter.builder(\u0026#34;sftp.upload.total\u0026#34;) .description(\u0026#34;Total number of file uploads\u0026#34;) .register(meterRegistry); this.downloadCounter = Counter.builder(\u0026#34;sftp.download.total\u0026#34;) .description(\u0026#34;Total number of file downloads\u0026#34;) .register(meterRegistry); this.deleteCounter = Counter.builder(\u0026#34;sftp.delete.total\u0026#34;) .description(\u0026#34;Total number of file deletions\u0026#34;) .register(meterRegistry); this.errorCounter = Counter.builder(\u0026#34;sftp.error.total\u0026#34;) .description(\u0026#34;Total number of errors\u0026#34;) .register(meterRegistry); this.uploadTimer = Timer.builder(\u0026#34;sftp.upload.duration\u0026#34;) .description(\u0026#34;File upload duration\u0026#34;) .register(meterRegistry); this.downloadTimer = Timer.builder(\u0026#34;sftp.download.duration\u0026#34;) .description(\u0026#34;File download duration\u0026#34;) .register(meterRegistry); } /** * 上傳文件 */ public boolean uploadFile(String localFilePath, String remoteFilePath) { return uploadTimer.recordCallable(() -\u0026gt; { boolean success = executeWithRetry(channelSftp -\u0026gt; { try { createRemoteDirectoryIfNotExists(channelSftp, getParentPath(remoteFilePath)); try (FileInputStream fis = new FileInputStream(localFilePath)) { channelSftp.put(fis, remoteFilePath); log.info(\u0026#34;文件上傳成功: {} -\u0026gt; {}\u0026#34;, localFilePath, remoteFilePath); uploadCounter.increment(); return true; } } catch (Exception e) { log.error(\u0026#34;文件上傳失敗: {} -\u0026gt; {}\u0026#34;, localFilePath, remoteFilePath, e); errorCounter.increment(); throw new RuntimeException(\u0026#34;文件上傳失敗\u0026#34;, e); } }); return success; }); } /** * 批量上傳文件 */ public List\u0026lt;CompletableFuture\u0026lt;Boolean\u0026gt;\u0026gt; uploadFilesAsync(List\u0026lt;FileTransferRequest\u0026gt; requests) { List\u0026lt;CompletableFuture\u0026lt;Boolean\u0026gt;\u0026gt; futures = new ArrayList\u0026lt;\u0026gt;(); for (FileTransferRequest request : requests) { CompletableFuture\u0026lt;Boolean\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; uploadFile(request.getLocalPath(), request.getRemotePath()), executorService); futures.add(future); } return futures; } /** * 下載文件 */ public boolean downloadFile(String remoteFilePath, String localFilePath) { return downloadTimer.recordCallable(() -\u0026gt; { boolean success = executeWithRetry(channelSftp -\u0026gt; { try { createLocalDirectoryIfNotExists(getParentPath(localFilePath)); try (FileOutputStream fos = new FileOutputStream(localFilePath)) { channelSftp.get(remoteFilePath, fos); log.info(\u0026#34;文件下載成功: {} -\u0026gt; {}\u0026#34;, remoteFilePath, localFilePath); downloadCounter.increment(); return true; } } catch (Exception e) { log.error(\u0026#34;文件下載失敗: {} -\u0026gt; {}\u0026#34;, remoteFilePath, localFilePath, e); errorCounter.increment(); throw new RuntimeException(\u0026#34;文件下載失敗\u0026#34;, e); } }); return success; }); } /** * 下載文件到輸出流 */ public void downloadFileToStream(String remoteFilePath, OutputStream outputStream) { executeWithRetry(channelSftp -\u0026gt; { try { channelSftp.get(remoteFilePath, outputStream); log.info(\u0026#34;文件下載到流成功: {}\u0026#34;, remoteFilePath); downloadCounter.increment(); return true; } catch (Exception e) { log.error(\u0026#34;文件下載到流失敗: {}\u0026#34;, remoteFilePath, e); errorCounter.increment(); throw new RuntimeException(\u0026#34;文件下載到流失敗\u0026#34;, e); } }); } /** * 獲取文件內容為字符串 */ public String getFileContent(String remoteFilePath) { return executeWithRetry(channelSftp -\u0026gt; { try (InputStream inputStream = channelSftp.get(remoteFilePath); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) { StringBuilder content = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { content.append(line).append(\u0026#34;\\n\u0026#34;); } log.info(\u0026#34;獲取文件內容成功: {}\u0026#34;, remoteFilePath); return content.toString(); } catch (Exception e) { log.error(\u0026#34;獲取文件內容失敗: {}\u0026#34;, remoteFilePath, e); errorCounter.increment(); throw new RuntimeException(\u0026#34;獲取文件內容失敗\u0026#34;, e); } }); } /** * 刪除文件 */ public boolean deleteFile(String remoteFilePath) { return executeWithRetry(channelSftp -\u0026gt; { try { channelSftp.rm(remoteFilePath); log.info(\u0026#34;文件刪除成功: {}\u0026#34;, remoteFilePath); deleteCounter.increment(); return true; } catch (Exception e) { log.error(\u0026#34;文件刪除失敗: {}\u0026#34;, remoteFilePath, e); errorCounter.increment(); throw new RuntimeException(\u0026#34;文件刪除失敗\u0026#34;, e); } }); } /** * 列出目錄文件 */ public List\u0026lt;SftpFileInfo\u0026gt; listFiles(String remotePath) { return executeWithRetry(channelSftp -\u0026gt; { try { Vector\u0026lt;ChannelSftp.LsEntry\u0026gt; entries = channelSftp.ls(remotePath); List\u0026lt;SftpFileInfo\u0026gt; fileInfos = new ArrayList\u0026lt;\u0026gt;(); for (ChannelSftp.LsEntry entry : entries) { if (!entry.getFilename().equals(\u0026#34;.\u0026#34;) \u0026amp;\u0026amp; !entry.getFilename().equals(\u0026#34;..\u0026#34;)) { SftpFileInfo fileInfo = new SftpFileInfo(); fileInfo.setFilename(entry.getFilename()); fileInfo.setSize(entry.getAttrs().getSize()); fileInfo.setModifiedTime(entry.getAttrs().getMTime()); fileInfo.setDirectory(entry.getAttrs().isDir()); fileInfos.add(fileInfo); } } log.info(\u0026#34;列出目錄文件成功: {}, 共 {} 個文件\u0026#34;, remotePath, fileInfos.size()); return fileInfos; } catch (Exception e) { log.error(\u0026#34;列出目錄文件失敗: {}\u0026#34;, remotePath, e); errorCounter.increment(); throw new RuntimeException(\u0026#34;列出目錄文件失敗\u0026#34;, e); } }); } /** * 檢查文件是否存在 */ public boolean fileExists(String remoteFilePath) { return executeWithRetry(channelSftp -\u0026gt; { try { channelSftp.stat(remoteFilePath); return true; } catch (SftpException e) { if (e.id == ChannelSftp.SSH_FX_NO_SUCH_FILE) { return false; } throw new RuntimeException(\u0026#34;檢查文件存在性失敗\u0026#34;, e); } }); } /** * 創建遠端目錄 */ public void createRemoteDirectory(String remotePath) { executeWithRetry(channelSftp -\u0026gt; { try { createRemoteDirectoryIfNotExists(channelSftp, remotePath); log.info(\u0026#34;創建遠端目錄成功: {}\u0026#34;, remotePath); return true; } catch (Exception e) { log.error(\u0026#34;創建遠端目錄失敗: {}\u0026#34;, remotePath, e); errorCounter.increment(); throw new RuntimeException(\u0026#34;創建遠端目錄失敗\u0026#34;, e); } }); } /** * 帶重試機制的執行器 */ private \u0026lt;T\u0026gt; T executeWithRetry(Function\u0026lt;ChannelSftp, T\u0026gt; operation) { int attempts = 0; Exception lastException = null; while (attempts \u0026lt; sftpProperties.getMaxRetries()) { ChannelSftp channelSftp = null; try { channelSftp = connectionPoolManager.borrowConnection(); return operation.apply(channelSftp); } catch (Exception e) { lastException = e; attempts++; if (channelSftp != null) { connectionPoolManager.invalidateConnection(channelSftp); channelSftp = null; } if (attempts \u0026lt; sftpProperties.getMaxRetries()) { log.warn(\u0026#34;SFTP 操作失敗，第 {} 次重試\u0026#34;, attempts, e); try { Thread.sleep(sftpProperties.getRetryDelay()); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); throw new RuntimeException(\u0026#34;操作被中斷\u0026#34;, ie); } } } finally { if (channelSftp != null) { connectionPoolManager.returnConnection(channelSftp); } } } throw new RuntimeException(\u0026#34;SFTP 操作失敗，已重試 \u0026#34; + sftpProperties.getMaxRetries() + \u0026#34; 次\u0026#34;, lastException); } /** * 創建遠端目錄（如果不存在） */ private void createRemoteDirectoryIfNotExists(ChannelSftp channelSftp, String remotePath) throws SftpException { if (remotePath == null || remotePath.trim().isEmpty()) { return; } String[] dirs = remotePath.split(\u0026#34;/\u0026#34;); String currentPath = \u0026#34;\u0026#34;; for (String dir : dirs) { if (dir.isEmpty()) continue; currentPath += \u0026#34;/\u0026#34; + dir; try { channelSftp.stat(currentPath); } catch (SftpException e) { if (e.id == ChannelSftp.SSH_FX_NO_SUCH_FILE) { channelSftp.mkdir(currentPath); } else { throw e; } } } } /** * 創建本地目錄（如果不存在） */ private void createLocalDirectoryIfNotExists(String localPath) throws IOException { if (localPath != null \u0026amp;\u0026amp; !localPath.trim().isEmpty()) { Path path = Paths.get(localPath); if (!Files.exists(path)) { Files.createDirectories(path); } } } /** * 獲取父路徑 */ private String getParentPath(String filePath) { if (filePath == null) return null; int lastSlashIndex = filePath.lastIndexOf(\u0026#39;/\u0026#39;); if (lastSlashIndex \u0026gt; 0) { return filePath.substring(0, lastSlashIndex); } return null; } /** * 獲取連線池狀態 */ public SftpConnectionPoolStatus getConnectionPoolStatus() { SftpConnectionPoolStatus status = new SftpConnectionPoolStatus(); status.setActiveConnections(connectionPoolManager.getActiveConnections()); status.setIdleConnections(connectionPoolManager.getIdleConnections()); return status; } } 支援類別 文件傳輸請求類 1 2 3 4 5 6 7 8 9 10 11 import lombok.Data; import lombok.AllArgsConstructor; import lombok.NoArgsConstructor; @Data @NoArgsConstructor @AllArgsConstructor public class FileTransferRequest { private String localPath; private String remotePath; } SFTP 文件信息類 1 2 3 4 5 6 7 8 9 import lombok.Data; @Data public class SftpFileInfo { private String filename; private long size; private int modifiedTime; private boolean directory; } 連線池狀態類 1 2 3 4 5 6 7 import lombok.Data; @Data public class SftpConnectionPoolStatus { private int activeConnections; private int idleConnections; } 服務層整合 SFTP 服務類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 import org.springframework.stereotype.Service; import org.springframework.web.multipart.MultipartFile; import lombok.extern.slf4j.Slf4j; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.List; import java.util.UUID; @Slf4j @Service public class SftpService { private final SftpUtil sftpUtil; private static final String TEMP_DIR = System.getProperty(\u0026#34;java.io.tmpdir\u0026#34;); public SftpService(SftpUtil sftpUtil) { this.sftpUtil = sftpUtil; } /** * 上傳 MultipartFile 到 SFTP */ public boolean uploadMultipartFile(MultipartFile file, String remoteDirectory) { String tempFilePath = null; try { // 創建臨時文件 tempFilePath = createTempFile(file); // 構建遠端路徑 String remoteFilePath = remoteDirectory + \u0026#34;/\u0026#34; + file.getOriginalFilename(); // 上傳文件 boolean success = sftpUtil.uploadFile(tempFilePath, remoteFilePath); if (success) { log.info(\u0026#34;MultipartFile 上傳成功: {}\u0026#34;, file.getOriginalFilename()); } return success; } catch (Exception e) { log.error(\u0026#34;MultipartFile 上傳失敗: {}\u0026#34;, file.getOriginalFilename(), e); return false; } finally { // 清理臨時文件 if (tempFilePath != null) { cleanupTempFile(tempFilePath); } } } /** * 批量上傳文件 */ public void uploadFiles(List\u0026lt;MultipartFile\u0026gt; files, String remoteDirectory) { for (MultipartFile file : files) { uploadMultipartFile(file, remoteDirectory); } } /** * 下載文件並返回字節數組 */ public byte[] downloadFileAsBytes(String remoteFilePath) { String tempFilePath = null; try { // 創建臨時文件路徑 tempFilePath = TEMP_DIR + \u0026#34;/\u0026#34; + UUID.randomUUID() + \u0026#34;_download\u0026#34;; // 下載文件 boolean success = sftpUtil.downloadFile(remoteFilePath, tempFilePath); if (success) { Path path = Paths.get(tempFilePath); return Files.readAllBytes(path); } return null; } catch (Exception e) { log.error(\u0026#34;下載文件失敗: {}\u0026#34;, remoteFilePath, e); return null; } finally { // 清理臨時文件 if (tempFilePath != null) { cleanupTempFile(tempFilePath); } } } /** * 獲取目錄文件列表 */ public List\u0026lt;SftpFileInfo\u0026gt; listDirectoryFiles(String remotePath) { return sftpUtil.listFiles(remotePath); } /** * 刪除文件 */ public boolean deleteFile(String remoteFilePath) { return sftpUtil.deleteFile(remoteFilePath); } /** * 檢查文件是否存在 */ public boolean checkFileExists(String remoteFilePath) { return sftpUtil.fileExists(remoteFilePath); } /** * 創建臨時文件 */ private String createTempFile(MultipartFile file) throws IOException { String tempFileName = UUID.randomUUID() + \u0026#34;_\u0026#34; + file.getOriginalFilename(); Path tempPath = Paths.get(TEMP_DIR, tempFileName); Files.write(tempPath, file.getBytes()); return tempPath.toString(); } /** * 清理臨時文件 */ private void cleanupTempFile(String tempFilePath) { try { Files.deleteIfExists(Paths.get(tempFilePath)); } catch (IOException e) { log.warn(\u0026#34;清理臨時文件失敗: {}\u0026#34;, tempFilePath, e); } } } 控制器層 SFTP 控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import org.springframework.web.multipart.MultipartFile; import lombok.extern.slf4j.Slf4j; import java.util.List; @Slf4j @RestController @RequestMapping(\u0026#34;/api/sftp\u0026#34;) public class SftpController { private final SftpService sftpService; public SftpController(SftpService sftpService) { this.sftpService = sftpService; } /** * 上傳文件 */ @PostMapping(\u0026#34;/upload\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; uploadFile(@RequestParam(\u0026#34;file\u0026#34;) MultipartFile file, @RequestParam(\u0026#34;directory\u0026#34;) String directory) { try { boolean success = sftpService.uploadMultipartFile(file, directory); if (success) { return ResponseEntity.ok(\u0026#34;文件上傳成功\u0026#34;); } else { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(\u0026#34;文件上傳失敗\u0026#34;); } } catch (Exception e) { log.error(\u0026#34;上傳文件異常\u0026#34;, e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(\u0026#34;上傳文件異常: \u0026#34; + e.getMessage()); } } /** * 批量上傳文件 */ @PostMapping(\u0026#34;/upload/batch\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; uploadFiles(@RequestParam(\u0026#34;files\u0026#34;) List\u0026lt;MultipartFile\u0026gt; files, @RequestParam(\u0026#34;directory\u0026#34;) String directory) { try { sftpService.uploadFiles(files, directory); return ResponseEntity.ok(\u0026#34;批量上傳成功\u0026#34;); } catch (Exception e) { log.error(\u0026#34;批量上傳文件異常\u0026#34;, e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(\u0026#34;批量上傳異常: \u0026#34; + e.getMessage()); } } /** * 下載文件 */ @GetMapping(\u0026#34;/download\u0026#34;) public ResponseEntity\u0026lt;byte[]\u0026gt; downloadFile(@RequestParam(\u0026#34;filePath\u0026#34;) String filePath) { try { byte[] fileBytes = sftpService.downloadFileAsBytes(filePath); if (fileBytes != null) { return ResponseEntity.ok() .header(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment; filename=\\\u0026#34;\u0026#34; + filePath.substring(filePath.lastIndexOf(\u0026#34;/\u0026#34;) + 1) + \u0026#34;\\\u0026#34;\u0026#34;) .body(fileBytes); } else { return ResponseEntity.notFound().build(); } } catch (Exception e) { log.error(\u0026#34;下載文件異常\u0026#34;, e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); } } /** * 列出目錄文件 */ @GetMapping(\u0026#34;/list\u0026#34;) public ResponseEntity\u0026lt;List\u0026lt;SftpFileInfo\u0026gt;\u0026gt; listFiles(@RequestParam(\u0026#34;directory\u0026#34;) String directory) { try { List\u0026lt;SftpFileInfo\u0026gt; files = sftpService.listDirectoryFiles(directory); return ResponseEntity.ok(files); } catch (Exception e) { log.error(\u0026#34;列出目錄文件異常\u0026#34;, e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); } } /** * 刪除文件 */ @DeleteMapping(\u0026#34;/delete\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; deleteFile(@RequestParam(\u0026#34;filePath\u0026#34;) String filePath) { try { boolean success = sftpService.deleteFile(filePath); if (success) { return ResponseEntity.ok(\u0026#34;文件刪除成功\u0026#34;); } else { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(\u0026#34;文件刪除失敗\u0026#34;); } } catch (Exception e) { log.error(\u0026#34;刪除文件異常\u0026#34;, e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(\u0026#34;刪除文件異常: \u0026#34; + e.getMessage()); } } /** * 檢查文件是否存在 */ @GetMapping(\u0026#34;/exists\u0026#34;) public ResponseEntity\u0026lt;Boolean\u0026gt; checkFileExists(@RequestParam(\u0026#34;filePath\u0026#34;) String filePath) { try { boolean exists = sftpService.checkFileExists(filePath); return ResponseEntity.ok(exists); } catch (Exception e) { log.error(\u0026#34;檢查文件存在性異常\u0026#34;, e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); } } } 監控與健康檢查 SFTP 健康檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import org.springframework.boot.actuator.health.Health; import org.springframework.boot.actuator.health.HealthIndicator; import org.springframework.stereotype.Component; import lombok.extern.slf4j.Slf4j; @Slf4j @Component public class SftpHealthIndicator implements HealthIndicator { private final SftpUtil sftpUtil; public SftpHealthIndicator(SftpUtil sftpUtil) { this.sftpUtil = sftpUtil; } @Override public Health health() { try { // 檢查連線池狀態 SftpConnectionPoolStatus poolStatus = sftpUtil.getConnectionPoolStatus(); Health.Builder builder = Health.up() .withDetail(\u0026#34;activeConnections\u0026#34;, poolStatus.getActiveConnections()) .withDetail(\u0026#34;idleConnections\u0026#34;, poolStatus.getIdleConnections()) .withDetail(\u0026#34;status\u0026#34;, \u0026#34;SFTP 服務正常運行\u0026#34;); return builder.build(); } catch (Exception e) { log.error(\u0026#34;SFTP 健康檢查失敗\u0026#34;, e); return Health.down() .withDetail(\u0026#34;error\u0026#34;, e.getMessage()) .withDetail(\u0026#34;status\u0026#34;, \u0026#34;SFTP 服務異常\u0026#34;) .build(); } } } 自訂監控端點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import org.springframework.boot.actuate.endpoint.annotation.Endpoint; import org.springframework.boot.actuator.endpoint.annotation.ReadOperation; import org.springframework.stereotype.Component; import java.util.HashMap; import java.util.Map; @Component @Endpoint(id = \u0026#34;sftp\u0026#34;) public class SftpEndpoint { private final SftpUtil sftpUtil; public SftpEndpoint(SftpUtil sftpUtil) { this.sftpUtil = sftpUtil; } @ReadOperation public Map\u0026lt;String, Object\u0026gt; sftpInfo() { Map\u0026lt;String, Object\u0026gt; info = new HashMap\u0026lt;\u0026gt;(); try { SftpConnectionPoolStatus poolStatus = sftpUtil.getConnectionPoolStatus(); info.put(\u0026#34;connectionPool\u0026#34;, poolStatus); info.put(\u0026#34;status\u0026#34;, \u0026#34;healthy\u0026#34;); } catch (Exception e) { info.put(\u0026#34;status\u0026#34;, \u0026#34;unhealthy\u0026#34;); info.put(\u0026#34;error\u0026#34;, e.getMessage()); } return info; } } 測試 單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 import org.junit.jupiter.api.Test; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.Mock; import org.mockito.junit.jupiter.MockitoExtension; import org.springframework.test.context.junit.jupiter.SpringJUnitConfig; import java.io.ByteArrayInputStream; import java.io.InputStream; import static org.junit.jupiter.api.Assertions.*; import static org.mockito.Mockito.*; @ExtendWith(MockitoExtension.class) @SpringJUnitConfig class SftpUtilTest { @Mock private SftpConnectionPoolManager mockConnectionPoolManager; @Mock private ChannelSftp mockChannelSftp; @Mock private SftpProperties mockSftpProperties; private SftpUtil sftpUtil; @BeforeEach void setUp() { when(mockSftpProperties.getMaxRetries()).thenReturn(3); when(mockSftpProperties.getRetryDelay()).thenReturn(1000); sftpUtil = new SftpUtil(mockConnectionPoolManager, mockSftpProperties, null); } @Test void testUploadFile_Success() throws Exception { // Given String localPath = \u0026#34;test.txt\u0026#34;; String remotePath = \u0026#34;/remote/test.txt\u0026#34;; when(mockConnectionPoolManager.borrowConnection()).thenReturn(mockChannelSftp); // When boolean result = sftpUtil.uploadFile(localPath, remotePath); // Then assertTrue(result); verify(mockChannelSftp, times(1)).put(any(InputStream.class), eq(remotePath)); verify(mockConnectionPoolManager, times(1)).returnConnection(mockChannelSftp); } @Test void testDownloadFile_Success() throws Exception { // Given String remotePath = \u0026#34;/remote/test.txt\u0026#34;; String localPath = \u0026#34;test.txt\u0026#34;; InputStream mockInputStream = new ByteArrayInputStream(\u0026#34;test content\u0026#34;.getBytes()); when(mockConnectionPoolManager.borrowConnection()).thenReturn(mockChannelSftp); when(mockChannelSftp.get(remotePath)).thenReturn(mockInputStream); // When boolean result = sftpUtil.downloadFile(remotePath, localPath); // Then assertTrue(result); verify(mockChannelSftp, times(1)).get(eq(remotePath), any()); verify(mockConnectionPoolManager, times(1)).returnConnection(mockChannelSftp); } @Test void testFileExists_FileExists() throws Exception { // Given String remotePath = \u0026#34;/remote/test.txt\u0026#34;; when(mockConnectionPoolManager.borrowConnection()).thenReturn(mockChannelSftp); when(mockChannelSftp.stat(remotePath)).thenReturn(null); // 不拋出異常表示文件存在 // When boolean result = sftpUtil.fileExists(remotePath); // Then assertTrue(result); verify(mockChannelSftp, times(1)).stat(remotePath); verify(mockConnectionPoolManager, times(1)).returnConnection(mockChannelSftp); } } 整合測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.ActiveProfiles; import org.springframework.test.context.junit.jupiter.SpringJUnitConfig; import org.springframework.beans.factory.annotation.Autowired; @SpringBootTest @ActiveProfiles(\u0026#34;test\u0026#34;) @SpringJUnitConfig class SftpIntegrationTest { @Autowired private SftpService sftpService; @Test void testSftpServiceIntegration() { // 整合測試應該使用測試 SFTP 服務器 // 這裡只是展示測試結構 // Given String testDirectory = \u0026#34;/test\u0026#34;; // When \u0026amp; Then // 執行實際的 SFTP 操作測試 assertDoesNotThrow(() -\u0026gt; { sftpService.listDirectoryFiles(testDirectory); }); } } 最佳實踐 1. 安全性考慮 1 2 3 4 5 6 7 8 9 10 11 12 13 # 生產環境配置 sftp: # 使用環境變數或 Vault 管理敏感信息 username: ${SFTP_USERNAME} password: ${SFTP_PASSWORD} private-key-path: ${SFTP_PRIVATE_KEY_PATH} # 啟用嚴格的主機密鑰檢查 strict-host-key-checking: true known-hosts-file: /etc/ssh/ssh_known_hosts # 使用安全的主機密鑰算法 host-key-algorithms: rsa-sha2-512,rsa-sha2-256 2. 效能優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 使用批量操作 @Component public class SftpBatchProcessor { public void processBatchUpload(List\u0026lt;FileTransferRequest\u0026gt; requests) { // 分批處理大量文件 int batchSize = 10; for (int i = 0; i \u0026lt; requests.size(); i += batchSize) { List\u0026lt;FileTransferRequest\u0026gt; batch = requests.subList(i, Math.min(i + batchSize, requests.size())); processBatch(batch); } } private void processBatch(List\u0026lt;FileTransferRequest\u0026gt; batch) { // 並行處理批次 List\u0026lt;CompletableFuture\u0026lt;Boolean\u0026gt;\u0026gt; futures = sftpUtil.uploadFilesAsync(batch); // 等待所有任務完成 CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join(); } } 3. 錯誤處理策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Component public class SftpErrorHandler { public void handleSftpError(Exception e, String operation, String filePath) { if (e instanceof SftpException) { SftpException sftpException = (SftpException) e; switch (sftpException.id) { case ChannelSftp.SSH_FX_NO_SUCH_FILE: log.warn(\u0026#34;文件不存在: {}\u0026#34;, filePath); break; case ChannelSftp.SSH_FX_PERMISSION_DENIED: log.error(\u0026#34;權限不足: {}\u0026#34;, filePath); break; case ChannelSftp.SSH_FX_CONNECTION_LOST: log.error(\u0026#34;連線中斷: {}\u0026#34;, filePath); // 觸發重連 break; default: log.error(\u0026#34;SFTP 操作失敗: {} - {}\u0026#34;, operation, filePath, e); } } else { log.error(\u0026#34;一般錯誤: {} - {}\u0026#34;, operation, filePath, e); } } } 總結 本文詳細介紹了企業級 SFTP 工具類的完整實作，包含以下關鍵特性：\n連線池管理：提供高效的連線復用機制 錯誤處理：完善的重試機制和錯誤處理策略 監控機制：整合 Micrometer 提供完整的監控指標 安全配置：支援多種認證方式和安全配置選項 批量操作：支援大量文件的並行處理 健康檢查：整合 Spring Boot Actuator 提供健康檢查 測試覆蓋：提供完整的單元測試和整合測試 這個 SFTP 工具類適用於各種企業級應用場景，能夠穩定、高效地處理文件傳輸任務，同時提供良好的可觀測性和維護性。\n","permalink":"https://xinqilin.github.io/post/backend/sftputil/","tags":["SFTP","Spring Boot","File Transfer","JSch","Security","Java","Connection Pool","Enterprise","File Management","SSH","Secure Transfer","Best Practices","Error Handling","Performance","Monitoring","Configuration"],"title":"Spring Boot SFTP 工具類：企業級安全文件傳輸系統實作指南"},{"content":"概述 在處理大量資料時，分頁查詢是必不可少的功能。Spring Data JPA 提供了強大的 Pageable 接口，配合 Specification 可以輕鬆實現靈活的分頁查詢功能。本文將深入介紹如何使用這些功能來構建高效的分頁系統。\n核心概念 Pageable：分頁參數接口，定義頁面大小、頁碼和排序規則 Page：分頁結果接口，包含資料和分頁資訊 Specification：查詢規格接口，用於動態構建查詢條件 Criteria API：JPA 標準的類型安全查詢 API 架構優勢 類型安全：Criteria API 提供編譯時檢查 動態查詢：根據條件動態構建 SQL 自動計數：自動執行 COUNT 查詢計算總數 靈活排序：支援多欄位排序 效能優化：支援各種優化策略 基礎配置 1. 依賴設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;!-- Spring Boot Starter Data JPA --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot Starter Web --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Database Driver (以 MySQL 為例) --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot Starter Validation --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 2. 實體類定義 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 package com.example.pagination.entity; import jakarta.persistence.*; import jakarta.validation.constraints.NotBlank; import jakarta.validation.constraints.Email; import org.hibernate.annotations.CreationTimestamp; import org.hibernate.annotations.UpdateTimestamp; import java.time.LocalDateTime; @Entity @Table(name = \u0026#34;users\u0026#34;, indexes = { @Index(name = \u0026#34;idx_username\u0026#34;, columnList = \u0026#34;username\u0026#34;), @Index(name = \u0026#34;idx_email\u0026#34;, columnList = \u0026#34;email\u0026#34;), @Index(name = \u0026#34;idx_status\u0026#34;, columnList = \u0026#34;status\u0026#34;), @Index(name = \u0026#34;idx_created_at\u0026#34;, columnList = \u0026#34;created_at\u0026#34;) }) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotBlank @Column(unique = true, nullable = false, length = 50) private String username; @NotBlank @Email @Column(unique = true, nullable = false, length = 100) private String email; @Column(name = \u0026#34;first_name\u0026#34;, length = 50) private String firstName; @Column(name = \u0026#34;last_name\u0026#34;, length = 50) private String lastName; @Enumerated(EnumType.STRING) @Column(nullable = false) private UserStatus status = UserStatus.ACTIVE; @Column(name = \u0026#34;age\u0026#34;) private Integer age; @Column(name = \u0026#34;city\u0026#34;, length = 100) private String city; @CreationTimestamp @Column(name = \u0026#34;created_at\u0026#34;, nullable = false, updatable = false) private LocalDateTime createdAt; @UpdateTimestamp @Column(name = \u0026#34;updated_at\u0026#34;, nullable = false) private LocalDateTime updatedAt; // 建構子 public User() {} public User(String username, String email, String firstName, String lastName) { this.username = username; this.email = email; this.firstName = firstName; this.lastName = lastName; } // Getters and Setters public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public UserStatus getStatus() { return status; } public void setStatus(UserStatus status) { this.status = status; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } public LocalDateTime getCreatedAt() { return createdAt; } public LocalDateTime getUpdatedAt() { return updatedAt; } } enum UserStatus { ACTIVE, INACTIVE, SUSPENDED, DELETED } 3. Repository 接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package com.example.pagination.repository; import com.example.pagination.entity.User; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.jpa.domain.Specification; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.JpaSpecificationExecutor; import org.springframework.data.jpa.repository.Query; import org.springframework.data.repository.query.Param; import org.springframework.stereotype.Repository; import java.time.LocalDateTime; import java.util.List; @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt;, JpaSpecificationExecutor\u0026lt;User\u0026gt; { // 基本分頁查詢 Page\u0026lt;User\u0026gt; findByStatus(UserStatus status, Pageable pageable); // 複合條件分頁查詢 Page\u0026lt;User\u0026gt; findByStatusAndAgeGreaterThan(UserStatus status, Integer age, Pageable pageable); // 模糊查詢分頁 Page\u0026lt;User\u0026gt; findByUsernameContainingIgnoreCase(String username, Pageable pageable); // 時間範圍查詢 Page\u0026lt;User\u0026gt; findByCreatedAtBetween(LocalDateTime start, LocalDateTime end, Pageable pageable); // 自訂查詢分頁 @Query(\u0026#34;SELECT u FROM User u WHERE u.city = :city AND u.age BETWEEN :minAge AND :maxAge\u0026#34;) Page\u0026lt;User\u0026gt; findByCityAndAgeBetween(@Param(\u0026#34;city\u0026#34;) String city, @Param(\u0026#34;minAge\u0026#34;) Integer minAge, @Param(\u0026#34;maxAge\u0026#34;) Integer maxAge, Pageable pageable); // 原生 SQL 分頁查詢 @Query(value = \u0026#34;SELECT * FROM users u WHERE u.email LIKE %:emailDomain%\u0026#34;, countQuery = \u0026#34;SELECT COUNT(*) FROM users u WHERE u.email LIKE %:emailDomain%\u0026#34;, nativeQuery = true) Page\u0026lt;User\u0026gt; findByEmailDomain(@Param(\u0026#34;emailDomain\u0026#34;) String emailDomain, Pageable pageable); // 投影查詢（只查詢部分欄位） @Query(\u0026#34;SELECT new com.example.pagination.dto.UserSummaryDto(u.id, u.username, u.email, u.status) \u0026#34; + \u0026#34;FROM User u WHERE u.status = :status\u0026#34;) Page\u0026lt;UserSummaryDto\u0026gt; findUserSummariesByStatus(@Param(\u0026#34;status\u0026#34;) UserStatus status, Pageable pageable); } Specification 動態查詢 1. 基礎 Specification 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 package com.example.pagination.specification; import com.example.pagination.entity.User; import com.example.pagination.entity.UserStatus; import org.springframework.data.jpa.domain.Specification; import jakarta.persistence.criteria.*; import java.time.LocalDateTime; import java.util.ArrayList; import java.util.List; public class UserSpecification { /** * 根據使用者名稱模糊查詢 */ public static Specification\u0026lt;User\u0026gt; usernameContains(String username) { return (root, query, criteriaBuilder) -\u0026gt; { if (username == null || username.trim().isEmpty()) { return criteriaBuilder.conjunction(); } return criteriaBuilder.like( criteriaBuilder.lower(root.get(\u0026#34;username\u0026#34;)), \u0026#34;%\u0026#34; + username.toLowerCase() + \u0026#34;%\u0026#34; ); }; } /** * 根據郵箱模糊查詢 */ public static Specification\u0026lt;User\u0026gt; emailContains(String email) { return (root, query, criteriaBuilder) -\u0026gt; { if (email == null || email.trim().isEmpty()) { return criteriaBuilder.conjunction(); } return criteriaBuilder.like( criteriaBuilder.lower(root.get(\u0026#34;email\u0026#34;)), \u0026#34;%\u0026#34; + email.toLowerCase() + \u0026#34;%\u0026#34; ); }; } /** * 根據狀態查詢 */ public static Specification\u0026lt;User\u0026gt; statusEquals(UserStatus status) { return (root, query, criteriaBuilder) -\u0026gt; { if (status == null) { return criteriaBuilder.conjunction(); } return criteriaBuilder.equal(root.get(\u0026#34;status\u0026#34;), status); }; } /** * 根據年齡範圍查詢 */ public static Specification\u0026lt;User\u0026gt; ageBetween(Integer minAge, Integer maxAge) { return (root, query, criteriaBuilder) -\u0026gt; { List\u0026lt;Predicate\u0026gt; predicates = new ArrayList\u0026lt;\u0026gt;(); if (minAge != null) { predicates.add(criteriaBuilder.greaterThanOrEqualTo(root.get(\u0026#34;age\u0026#34;), minAge)); } if (maxAge != null) { predicates.add(criteriaBuilder.lessThanOrEqualTo(root.get(\u0026#34;age\u0026#34;), maxAge)); } return criteriaBuilder.and(predicates.toArray(new Predicate[0])); }; } /** * 根據城市查詢 */ public static Specification\u0026lt;User\u0026gt; cityEquals(String city) { return (root, query, criteriaBuilder) -\u0026gt; { if (city == null || city.trim().isEmpty()) { return criteriaBuilder.conjunction(); } return criteriaBuilder.equal(root.get(\u0026#34;city\u0026#34;), city); }; } /** * 根據創建時間範圍查詢 */ public static Specification\u0026lt;User\u0026gt; createdAtBetween(LocalDateTime startDate, LocalDateTime endDate) { return (root, query, criteriaBuilder) -\u0026gt; { List\u0026lt;Predicate\u0026gt; predicates = new ArrayList\u0026lt;\u0026gt;(); if (startDate != null) { predicates.add(criteriaBuilder.greaterThanOrEqualTo(root.get(\u0026#34;createdAt\u0026#34;), startDate)); } if (endDate != null) { predicates.add(criteriaBuilder.lessThanOrEqualTo(root.get(\u0026#34;createdAt\u0026#34;), endDate)); } return criteriaBuilder.and(predicates.toArray(new Predicate[0])); }; } /** * 複合查詢 - 根據多個條件 */ public static Specification\u0026lt;User\u0026gt; withFilters(String username, String email, UserStatus status, Integer minAge, Integer maxAge, String city) { return Specification.where(usernameContains(username)) .and(emailContains(email)) .and(statusEquals(status)) .and(ageBetween(minAge, maxAge)) .and(cityEquals(city)); } /** * 進階查詢 - 支援 OR 條件 */ public static Specification\u0026lt;User\u0026gt; searchByKeyword(String keyword) { return (root, query, criteriaBuilder) -\u0026gt; { if (keyword == null || keyword.trim().isEmpty()) { return criteriaBuilder.conjunction(); } String likePattern = \u0026#34;%\u0026#34; + keyword.toLowerCase() + \u0026#34;%\u0026#34;; return criteriaBuilder.or( criteriaBuilder.like(criteriaBuilder.lower(root.get(\u0026#34;username\u0026#34;)), likePattern), criteriaBuilder.like(criteriaBuilder.lower(root.get(\u0026#34;email\u0026#34;)), likePattern), criteriaBuilder.like(criteriaBuilder.lower(root.get(\u0026#34;firstName\u0026#34;)), likePattern), criteriaBuilder.like(criteriaBuilder.lower(root.get(\u0026#34;lastName\u0026#34;)), likePattern), criteriaBuilder.like(criteriaBuilder.lower(root.get(\u0026#34;city\u0026#34;)), likePattern) ); }; } } 2. 動態 Specification 建構器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 package com.example.pagination.specification; import org.springframework.data.jpa.domain.Specification; import jakarta.persistence.criteria.CriteriaBuilder; import jakarta.persistence.criteria.Predicate; import jakarta.persistence.criteria.Root; import java.util.ArrayList; import java.util.List; public class DynamicSpecificationBuilder\u0026lt;T\u0026gt; { private List\u0026lt;Specification\u0026lt;T\u0026gt;\u0026gt; specifications = new ArrayList\u0026lt;\u0026gt;(); public DynamicSpecificationBuilder\u0026lt;T\u0026gt; with(String field, String operation, Object value) { if (value != null) { specifications.add(createSpecification(field, operation, value)); } return this; } public DynamicSpecificationBuilder\u0026lt;T\u0026gt; with(Specification\u0026lt;T\u0026gt; specification) { if (specification != null) { specifications.add(specification); } return this; } public Specification\u0026lt;T\u0026gt; build() { if (specifications.isEmpty()) { return null; } Specification\u0026lt;T\u0026gt; result = specifications.get(0); for (int i = 1; i \u0026lt; specifications.size(); i++) { result = Specification.where(result).and(specifications.get(i)); } return result; } private Specification\u0026lt;T\u0026gt; createSpecification(String field, String operation, Object value) { return (root, query, criteriaBuilder) -\u0026gt; { switch (operation.toLowerCase()) { case \u0026#34;eq\u0026#34;: case \u0026#34;equals\u0026#34;: return criteriaBuilder.equal(root.get(field), value); case \u0026#34;ne\u0026#34;: case \u0026#34;not_equals\u0026#34;: return criteriaBuilder.notEqual(root.get(field), value); case \u0026#34;gt\u0026#34;: case \u0026#34;greater_than\u0026#34;: return criteriaBuilder.greaterThan(root.get(field), (Comparable) value); case \u0026#34;gte\u0026#34;: case \u0026#34;greater_than_or_equal\u0026#34;: return criteriaBuilder.greaterThanOrEqualTo(root.get(field), (Comparable) value); case \u0026#34;lt\u0026#34;: case \u0026#34;less_than\u0026#34;: return criteriaBuilder.lessThan(root.get(field), (Comparable) value); case \u0026#34;lte\u0026#34;: case \u0026#34;less_than_or_equal\u0026#34;: return criteriaBuilder.lessThanOrEqualTo(root.get(field), (Comparable) value); case \u0026#34;like\u0026#34;: case \u0026#34;contains\u0026#34;: return criteriaBuilder.like( criteriaBuilder.lower(root.get(field)), \u0026#34;%\u0026#34; + value.toString().toLowerCase() + \u0026#34;%\u0026#34; ); case \u0026#34;starts_with\u0026#34;: return criteriaBuilder.like( criteriaBuilder.lower(root.get(field)), value.toString().toLowerCase() + \u0026#34;%\u0026#34; ); case \u0026#34;ends_with\u0026#34;: return criteriaBuilder.like( criteriaBuilder.lower(root.get(field)), \u0026#34;%\u0026#34; + value.toString().toLowerCase() ); case \u0026#34;in\u0026#34;: if (value instanceof List) { return root.get(field).in((List\u0026lt;?\u0026gt;) value); } return criteriaBuilder.equal(root.get(field), value); case \u0026#34;is_null\u0026#34;: return criteriaBuilder.isNull(root.get(field)); case \u0026#34;is_not_null\u0026#34;: return criteriaBuilder.isNotNull(root.get(field)); default: throw new IllegalArgumentException(\u0026#34;不支援的操作: \u0026#34; + operation); } }; } } DTO 和分頁請求處理 1. 分頁請求 DTO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 package com.example.pagination.dto; import com.example.pagination.entity.UserStatus; import jakarta.validation.constraints.Min; import jakarta.validation.constraints.Max; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.data.domain.Sort; import java.time.LocalDateTime; public class UserPageRequest { @Min(value = 0, message = \u0026#34;頁碼不能小於 0\u0026#34;) private int page = 0; @Min(value = 1, message = \u0026#34;每頁大小不能小於 1\u0026#34;) @Max(value = 100, message = \u0026#34;每頁大小不能超過 100\u0026#34;) private int size = 20; private String sortBy = \u0026#34;id\u0026#34;; private String sortDirection = \u0026#34;DESC\u0026#34;; // 查詢條件 private String username; private String email; private UserStatus status; private Integer minAge; private Integer maxAge; private String city; private String keyword; // 關鍵字搜索 private LocalDateTime startDate; private LocalDateTime endDate; // 建構子 public UserPageRequest() {} public UserPageRequest(int page, int size) { this.page = page; this.size = size; } /** * 轉換為 Pageable 物件 */ public Pageable toPageable() { Sort.Direction direction = Sort.Direction.fromString(sortDirection); Sort sort = Sort.by(direction, sortBy); return PageRequest.of(page, size, sort); } /** * 檢查是否有查詢條件 */ public boolean hasFilters() { return username != null || email != null || status != null || minAge != null || maxAge != null || city != null || keyword != null || startDate != null || endDate != null; } // Getters and Setters public int getPage() { return page; } public void setPage(int page) { this.page = page; } public int getSize() { return size; } public void setSize(int size) { this.size = size; } public String getSortBy() { return sortBy; } public void setSortBy(String sortBy) { this.sortBy = sortBy; } public String getSortDirection() { return sortDirection; } public void setSortDirection(String sortDirection) { this.sortDirection = sortDirection; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public UserStatus getStatus() { return status; } public void setStatus(UserStatus status) { this.status = status; } public Integer getMinAge() { return minAge; } public void setMinAge(Integer minAge) { this.minAge = minAge; } public Integer getMaxAge() { return maxAge; } public void setMaxAge(Integer maxAge) { this.maxAge = maxAge; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } public String getKeyword() { return keyword; } public void setKeyword(String keyword) { this.keyword = keyword; } public LocalDateTime getStartDate() { return startDate; } public void setStartDate(LocalDateTime startDate) { this.startDate = startDate; } public LocalDateTime getEndDate() { return endDate; } public void setEndDate(LocalDateTime endDate) { this.endDate = endDate; } } 2. 分頁回應 DTO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package com.example.pagination.dto; import org.springframework.data.domain.Page; import java.util.List; public class PageResponse\u0026lt;T\u0026gt; { private List\u0026lt;T\u0026gt; content; private int page; private int size; private long totalElements; private int totalPages; private boolean first; private boolean last; private boolean hasNext; private boolean hasPrevious; private int numberOfElements; // 建構子 public PageResponse() {} public PageResponse(Page\u0026lt;T\u0026gt; page) { this.content = page.getContent(); this.page = page.getNumber(); this.size = page.getSize(); this.totalElements = page.getTotalElements(); this.totalPages = page.getTotalPages(); this.first = page.isFirst(); this.last = page.isLast(); this.hasNext = page.hasNext(); this.hasPrevious = page.hasPrevious(); this.numberOfElements = page.getNumberOfElements(); } public static \u0026lt;T\u0026gt; PageResponse\u0026lt;T\u0026gt; of(Page\u0026lt;T\u0026gt; page) { return new PageResponse\u0026lt;\u0026gt;(page); } // Getters and Setters public List\u0026lt;T\u0026gt; getContent() { return content; } public void setContent(List\u0026lt;T\u0026gt; content) { this.content = content; } public int getPage() { return page; } public void setPage(int page) { this.page = page; } public int getSize() { return size; } public void setSize(int size) { this.size = size; } public long getTotalElements() { return totalElements; } public void setTotalElements(long totalElements) { this.totalElements = totalElements; } public int getTotalPages() { return totalPages; } public void setTotalPages(int totalPages) { this.totalPages = totalPages; } public boolean isFirst() { return first; } public void setFirst(boolean first) { this.first = first; } public boolean isLast() { return last; } public void setLast(boolean last) { this.last = last; } public boolean isHasNext() { return hasNext; } public void setHasNext(boolean hasNext) { this.hasNext = hasNext; } public boolean isHasPrevious() { return hasPrevious; } public void setHasPrevious(boolean hasPrevious) { this.hasPrevious = hasPrevious; } public int getNumberOfElements() { return numberOfElements; } public void setNumberOfElements(int numberOfElements) { this.numberOfElements = numberOfElements; } } 3. 使用者摘要 DTO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.example.pagination.dto; import com.example.pagination.entity.UserStatus; public class UserSummaryDto { private Long id; private String username; private String email; private UserStatus status; // 建構子 public UserSummaryDto() {} public UserSummaryDto(Long id, String username, String email, UserStatus status) { this.id = id; this.username = username; this.email = email; this.status = status; } // Getters and Setters public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public UserStatus getStatus() { return status; } public void setStatus(UserStatus status) { this.status = status; } } Service 層實作 1. 使用者服務介面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package com.example.pagination.service; import com.example.pagination.dto.PageResponse; import com.example.pagination.dto.UserPageRequest; import com.example.pagination.dto.UserSummaryDto; import com.example.pagination.entity.User; import com.example.pagination.entity.UserStatus; import org.springframework.data.domain.Page; public interface UserService { /** * 分頁查詢使用者 */ PageResponse\u0026lt;User\u0026gt; findUsers(UserPageRequest request); /** * 關鍵字搜索使用者 */ PageResponse\u0026lt;User\u0026gt; searchUsers(String keyword, UserPageRequest request); /** * 根據狀態分頁查詢使用者摘要 */ PageResponse\u0026lt;UserSummaryDto\u0026gt; findUserSummariesByStatus(UserStatus status, UserPageRequest request); /** * 高級搜索 */ PageResponse\u0026lt;User\u0026gt; advancedSearch(UserPageRequest request); } 2. 使用者服務實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 package com.example.pagination.service.impl; import com.example.pagination.dto.PageResponse; import com.example.pagination.dto.UserPageRequest; import com.example.pagination.dto.UserSummaryDto; import com.example.pagination.entity.User; import com.example.pagination.entity.UserStatus; import com.example.pagination.repository.UserRepository; import com.example.pagination.service.UserService; import com.example.pagination.specification.DynamicSpecificationBuilder; import com.example.pagination.specification.UserSpecification; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.jpa.domain.Specification; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; @Service @Transactional(readOnly = true) public class UserServiceImpl implements UserService { @Autowired private UserRepository userRepository; @Override public PageResponse\u0026lt;User\u0026gt; findUsers(UserPageRequest request) { Pageable pageable = request.toPageable(); if (!request.hasFilters()) { // 沒有過濾條件，直接分頁查詢 Page\u0026lt;User\u0026gt; page = userRepository.findAll(pageable); return PageResponse.of(page); } // 有過濾條件，使用 Specification Specification\u0026lt;User\u0026gt; spec = UserSpecification.withFilters( request.getUsername(), request.getEmail(), request.getStatus(), request.getMinAge(), request.getMaxAge(), request.getCity() ); Page\u0026lt;User\u0026gt; page = userRepository.findAll(spec, pageable); return PageResponse.of(page); } @Override public PageResponse\u0026lt;User\u0026gt; searchUsers(String keyword, UserPageRequest request) { Pageable pageable = request.toPageable(); Specification\u0026lt;User\u0026gt; spec = UserSpecification.searchByKeyword(keyword); Page\u0026lt;User\u0026gt; page = userRepository.findAll(spec, pageable); return PageResponse.of(page); } @Override public PageResponse\u0026lt;UserSummaryDto\u0026gt; findUserSummariesByStatus(UserStatus status, UserPageRequest request) { Pageable pageable = request.toPageable(); Page\u0026lt;UserSummaryDto\u0026gt; page = userRepository.findUserSummariesByStatus(status, pageable); return PageResponse.of(page); } @Override public PageResponse\u0026lt;User\u0026gt; advancedSearch(UserPageRequest request) { Pageable pageable = request.toPageable(); // 使用動態 Specification 建構器 DynamicSpecificationBuilder\u0026lt;User\u0026gt; builder = new DynamicSpecificationBuilder\u0026lt;\u0026gt;(); builder.with(\u0026#34;username\u0026#34;, \u0026#34;contains\u0026#34;, request.getUsername()) .with(\u0026#34;email\u0026#34;, \u0026#34;contains\u0026#34;, request.getEmail()) .with(\u0026#34;status\u0026#34;, \u0026#34;equals\u0026#34;, request.getStatus()) .with(\u0026#34;age\u0026#34;, \u0026#34;gte\u0026#34;, request.getMinAge()) .with(\u0026#34;age\u0026#34;, \u0026#34;lte\u0026#34;, request.getMaxAge()) .with(\u0026#34;city\u0026#34;, \u0026#34;equals\u0026#34;, request.getCity()) .with(\u0026#34;createdAt\u0026#34;, \u0026#34;gte\u0026#34;, request.getStartDate()) .with(\u0026#34;createdAt\u0026#34;, \u0026#34;lte\u0026#34;, request.getEndDate()); // 如果有關鍵字，添加關鍵字搜索 if (request.getKeyword() != null \u0026amp;\u0026amp; !request.getKeyword().trim().isEmpty()) { builder.with(UserSpecification.searchByKeyword(request.getKeyword())); } Specification\u0026lt;User\u0026gt; spec = builder.build(); Page\u0026lt;User\u0026gt; page = userRepository.findAll(spec, pageable); return PageResponse.of(page); } } Controller 層實作 1. 使用者控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package com.example.pagination.controller; import com.example.pagination.dto.PageResponse; import com.example.pagination.dto.UserPageRequest; import com.example.pagination.dto.UserSummaryDto; import com.example.pagination.entity.User; import com.example.pagination.entity.UserStatus; import com.example.pagination.service.UserService; import jakarta.validation.Valid; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) @CrossOrigin(origins = \u0026#34;*\u0026#34;, maxAge = 3600) public class UserController { @Autowired private UserService userService; /** * 分頁查詢使用者 */ @GetMapping public ResponseEntity\u0026lt;PageResponse\u0026lt;User\u0026gt;\u0026gt; getUsers(@Valid UserPageRequest request) { PageResponse\u0026lt;User\u0026gt; response = userService.findUsers(request); return ResponseEntity.ok(response); } /** * 關鍵字搜索使用者 */ @GetMapping(\u0026#34;/search\u0026#34;) public ResponseEntity\u0026lt;PageResponse\u0026lt;User\u0026gt;\u0026gt; searchUsers( @RequestParam String keyword, @Valid UserPageRequest request) { PageResponse\u0026lt;User\u0026gt; response = userService.searchUsers(keyword, request); return ResponseEntity.ok(response); } /** * 高級搜索 */ @PostMapping(\u0026#34;/advanced-search\u0026#34;) public ResponseEntity\u0026lt;PageResponse\u0026lt;User\u0026gt;\u0026gt; advancedSearch(@Valid @RequestBody UserPageRequest request) { PageResponse\u0026lt;User\u0026gt; response = userService.advancedSearch(request); return ResponseEntity.ok(response); } /** * 根據狀態查詢使用者摘要 */ @GetMapping(\u0026#34;/summaries\u0026#34;) public ResponseEntity\u0026lt;PageResponse\u0026lt;UserSummaryDto\u0026gt;\u0026gt; getUserSummaries( @RequestParam UserStatus status, @Valid UserPageRequest request) { PageResponse\u0026lt;UserSummaryDto\u0026gt; response = userService.findUserSummariesByStatus(status, request); return ResponseEntity.ok(response); } /** * 使用路徑參數的分頁查詢 */ @GetMapping(\u0026#34;/page/{page}/size/{size}\u0026#34;) public ResponseEntity\u0026lt;PageResponse\u0026lt;User\u0026gt;\u0026gt; getUsersWithPathParams( @PathVariable int page, @PathVariable int size, @RequestParam(required = false) String sortBy, @RequestParam(required = false) String sortDirection) { UserPageRequest request = new UserPageRequest(page, size); if (sortBy != null) request.setSortBy(sortBy); if (sortDirection != null) request.setSortDirection(sortDirection); PageResponse\u0026lt;User\u0026gt; response = userService.findUsers(request); return ResponseEntity.ok(response); } } 2. 分頁配置控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package com.example.pagination.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.data.domain.Sort; import org.springframework.data.web.PageableDefault; import org.springframework.data.web.SortDefault; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import java.util.HashMap; import java.util.Map; @RestController @RequestMapping(\u0026#34;/api/config\u0026#34;) public class PageConfigController { /** * 使用 Spring 自動解析的 Pageable 參數 */ @GetMapping(\u0026#34;/users\u0026#34;) public ResponseEntity\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; getUsersWithSpringPageable( @PageableDefault(page = 0, size = 20) @SortDefault(sort = \u0026#34;id\u0026#34;, direction = Sort.Direction.DESC) Pageable pageable) { Map\u0026lt;String, Object\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); result.put(\u0026#34;page\u0026#34;, pageable.getPageNumber()); result.put(\u0026#34;size\u0026#34;, pageable.getPageSize()); result.put(\u0026#34;sort\u0026#34;, pageable.getSort().toString()); return ResponseEntity.ok(result); } /** * 動態排序欄位驗證 */ @GetMapping(\u0026#34;/users/validated\u0026#34;) public ResponseEntity\u0026lt;Pageable\u0026gt; getValidatedPageable( @RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @RequestParam(defaultValue = \u0026#34;20\u0026#34;) int size, @RequestParam(defaultValue = \u0026#34;id\u0026#34;) String sortBy, @RequestParam(defaultValue = \u0026#34;DESC\u0026#34;) String sortDirection) { // 驗證排序欄位 String[] allowedSortFields = {\u0026#34;id\u0026#34;, \u0026#34;username\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;createdAt\u0026#34;, \u0026#34;updatedAt\u0026#34;}; boolean isValidSortField = false; for (String field : allowedSortFields) { if (field.equals(sortBy)) { isValidSortField = true; break; } } if (!isValidSortField) { sortBy = \u0026#34;id\u0026#34;; // 預設排序欄位 } Sort.Direction direction = Sort.Direction.fromString(sortDirection); Sort sort = Sort.by(direction, sortBy); Pageable pageable = PageRequest.of(page, size, sort); return ResponseEntity.ok(pageable); } } 效能優化技巧 1. 資料庫索引優化 1 2 3 4 5 6 7 8 9 10 11 12 13 -- 為常用查詢欄位建立索引 CREATE INDEX idx_users_username ON users(username); CREATE INDEX idx_users_email ON users(email); CREATE INDEX idx_users_status ON users(status); CREATE INDEX idx_users_created_at ON users(created_at); CREATE INDEX idx_users_city_status ON users(city, status); -- 複合索引優化多條件查詢 CREATE INDEX idx_users_status_age ON users(status, age); CREATE INDEX idx_users_city_age_status ON users(city, age, status); -- 分析查詢執行計畫 EXPLAIN SELECT * FROM users WHERE status = \u0026#39;ACTIVE\u0026#39; AND age \u0026gt; 25 ORDER BY created_at DESC LIMIT 20; 2. JPA 查詢優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package com.example.pagination.config; import org.springframework.context.annotation.Configuration; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import org.springframework.data.web.PageableHandlerMethodArgumentResolver; import org.springframework.data.web.config.EnableSpringDataWebSupport; import org.springframework.web.method.support.HandlerMethodArgumentResolver; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import java.util.List; @Configuration @EnableSpringDataWebSupport public class PaginationConfig implements WebMvcConfigurer { @Override public void addArgumentResolvers(List\u0026lt;HandlerMethodArgumentResolver\u0026gt; resolvers) { PageableHandlerMethodArgumentResolver resolver = new PageableHandlerMethodArgumentResolver(); // 設定預設分頁參數 resolver.setFallbackPageable(PageRequest.of(0, 20)); // 設定最大分頁大小 resolver.setMaxPageSize(100); // 設定一頁為 1 的參數（而不是 0） resolver.setOneIndexedParameters(false); resolvers.add(resolver); } } 3. 快取優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.example.pagination.service.impl; import org.springframework.cache.annotation.Cacheable; import org.springframework.stereotype.Service; @Service public class CachedUserService { @Autowired private UserRepository userRepository; /** * 快取熱門查詢結果 */ @Cacheable(value = \u0026#34;userPages\u0026#34;, key = \u0026#34;#status + \u0026#39;_\u0026#39; + #pageable.pageNumber + \u0026#39;_\u0026#39; + #pageable.pageSize\u0026#34;) public Page\u0026lt;User\u0026gt; findUsersByStatusCached(UserStatus status, Pageable pageable) { return userRepository.findByStatus(status, pageable); } /** * 快取總數查詢 */ @Cacheable(value = \u0026#34;userCounts\u0026#34;, key = \u0026#34;#status\u0026#34;) public long countUsersByStatus(UserStatus status) { return userRepository.countByStatus(status); } } 4. 批次查詢優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package com.example.pagination.service.impl; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageImpl; import org.springframework.data.domain.Pageable; import org.springframework.stereotype.Service; import java.util.List; @Service public class OptimizedUserService { @Autowired private UserRepository userRepository; /** * 避免 N+1 查詢問題 */ public Page\u0026lt;User\u0026gt; findUsersWithOptimization(Pageable pageable) { // 只查詢當前頁的資料 List\u0026lt;User\u0026gt; users = userRepository.findUsersWithPagination( pageable.getOffset(), pageable.getPageSize() ); // 單獨查詢總數（可以快取） long total = userRepository.countAllUsers(); return new PageImpl\u0026lt;\u0026gt;(users, pageable, total); } /** * 使用原生 SQL 優化大資料查詢 */ @Query(value = \u0026#34;\u0026#34;\u0026#34; SELECT u.* FROM users u WHERE u.status = :status ORDER BY u.id DESC LIMIT :limit OFFSET :offset \u0026#34;\u0026#34;\u0026#34;, nativeQuery = true) public List\u0026lt;User\u0026gt; findUsersWithNativeQuery( @Param(\u0026#34;status\u0026#34;) String status, @Param(\u0026#34;limit\u0026#34;) int limit, @Param(\u0026#34;offset\u0026#34;) long offset ); } 實戰範例 1. 電商訂單分頁查詢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 package com.example.pagination.example; import com.example.pagination.entity.Order; import com.example.pagination.entity.OrderStatus; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.jpa.domain.Specification; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.JpaSpecificationExecutor; import org.springframework.web.bind.annotation.*; import java.math.BigDecimal; import java.time.LocalDateTime; import java.util.List; // 訂單實體 @Entity @Table(name = \u0026#34;orders\u0026#34;) public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long orderId; @Column(name = \u0026#34;customer_id\u0026#34;) private String customerId; @Column(name = \u0026#34;total_amount\u0026#34;) private BigDecimal totalAmount; @Enumerated(EnumType.STRING) private OrderStatus status; @CreationTimestamp @Column(name = \u0026#34;created_at\u0026#34;) private LocalDateTime createdAt; // Getters and Setters... } // Repository 介面 public interface OrderRepository extends JpaRepository\u0026lt;Order, Long\u0026gt;, JpaSpecificationExecutor\u0026lt;Order\u0026gt; { Page\u0026lt;Order\u0026gt; findByCustomerId(String customerId, Pageable pageable); Page\u0026lt;Order\u0026gt; findByStatusAndCreatedAtBetween( OrderStatus status, LocalDateTime startDate, LocalDateTime endDate, Pageable pageable ); } // 訂單 Specification public class OrderSpecification { public static Specification\u0026lt;Order\u0026gt; hasCustomerId(String customerId) { return (root, query, cb) -\u0026gt; customerId == null ? cb.conjunction() : cb.equal(root.get(\u0026#34;customerId\u0026#34;), customerId); } public static Specification\u0026lt;Order\u0026gt; hasStatus(OrderStatus status) { return (root, query, cb) -\u0026gt; status == null ? cb.conjunction() : cb.equal(root.get(\u0026#34;status\u0026#34;), status); } public static Specification\u0026lt;Order\u0026gt; amountBetween(BigDecimal minAmount, BigDecimal maxAmount) { return (root, query, cb) -\u0026gt; { if (minAmount == null \u0026amp;\u0026amp; maxAmount == null) return cb.conjunction(); if (minAmount != null \u0026amp;\u0026amp; maxAmount != null) { return cb.between(root.get(\u0026#34;totalAmount\u0026#34;), minAmount, maxAmount); } else if (minAmount != null) { return cb.greaterThanOrEqualTo(root.get(\u0026#34;totalAmount\u0026#34;), minAmount); } else { return cb.lessThanOrEqualTo(root.get(\u0026#34;totalAmount\u0026#34;), maxAmount); } }; } public static Specification\u0026lt;Order\u0026gt; createdBetween(LocalDateTime start, LocalDateTime end) { return (root, query, cb) -\u0026gt; { if (start == null \u0026amp;\u0026amp; end == null) return cb.conjunction(); if (start != null \u0026amp;\u0026amp; end != null) { return cb.between(root.get(\u0026#34;createdAt\u0026#34;), start, end); } else if (start != null) { return cb.greaterThanOrEqualTo(root.get(\u0026#34;createdAt\u0026#34;), start); } else { return cb.lessThanOrEqualTo(root.get(\u0026#34;createdAt\u0026#34;), end); } }; } } // 控制器實作 @RestController @RequestMapping(\u0026#34;/api/orders\u0026#34;) public class OrderController { @Autowired private OrderRepository orderRepository; /** * 分頁查詢訂單 */ @GetMapping public ResponseEntity\u0026lt;Page\u0026lt;Order\u0026gt;\u0026gt; getOrders( @RequestParam(required = false) String customerId, @RequestParam(required = false) OrderStatus status, @RequestParam(required = false) BigDecimal minAmount, @RequestParam(required = false) BigDecimal maxAmount, @RequestParam(required = false) LocalDateTime startDate, @RequestParam(required = false) LocalDateTime endDate, Pageable pageable) { Specification\u0026lt;Order\u0026gt; spec = Specification .where(OrderSpecification.hasCustomerId(customerId)) .and(OrderSpecification.hasStatus(status)) .and(OrderSpecification.amountBetween(minAmount, maxAmount)) .and(OrderSpecification.createdBetween(startDate, endDate)); Page\u0026lt;Order\u0026gt; orders = orderRepository.findAll(spec, pageable); return ResponseEntity.ok(orders); } /** * 客戶訂單查詢 */ @GetMapping(\u0026#34;/customer/{customerId}\u0026#34;) public ResponseEntity\u0026lt;Page\u0026lt;Order\u0026gt;\u0026gt; getCustomerOrders( @PathVariable String customerId, @PageableDefault(size = 10, sort = \u0026#34;createdAt\u0026#34;, direction = Sort.Direction.DESC) Pageable pageable) { Page\u0026lt;Order\u0026gt; orders = orderRepository.findByCustomerId(customerId, pageable); return ResponseEntity.ok(orders); } } 2. 統計報表分頁查詢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package com.example.pagination.example; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.jpa.repository.Query; import org.springframework.data.repository.query.Param; import org.springframework.web.bind.annotation.*; import java.time.LocalDate; // 統計 DTO public class OrderStatistics { private String customerId; private String customerName; private Long orderCount; private BigDecimal totalAmount; private LocalDate lastOrderDate; public OrderStatistics(String customerId, String customerName, Long orderCount, BigDecimal totalAmount, LocalDate lastOrderDate) { this.customerId = customerId; this.customerName = customerName; this.orderCount = orderCount; this.totalAmount = totalAmount; this.lastOrderDate = lastOrderDate; } // Getters and Setters... } // Repository 統計查詢 public interface OrderStatisticsRepository extends JpaRepository\u0026lt;Order, Long\u0026gt; { @Query(\u0026#34;\u0026#34;\u0026#34; SELECT new com.example.pagination.example.OrderStatistics( o.customerId, c.name, COUNT(o.orderId), SUM(o.totalAmount), MAX(CAST(o.createdAt AS LocalDate)) ) FROM Order o JOIN Customer c ON o.customerId = c.customerId WHERE o.createdAt BETWEEN :startDate AND :endDate GROUP BY o.customerId, c.name HAVING COUNT(o.orderId) \u0026gt;= :minOrderCount \u0026#34;\u0026#34;\u0026#34;) Page\u0026lt;OrderStatistics\u0026gt; findOrderStatistics( @Param(\u0026#34;startDate\u0026#34;) LocalDateTime startDate, @Param(\u0026#34;endDate\u0026#34;) LocalDateTime endDate, @Param(\u0026#34;minOrderCount\u0026#34;) Long minOrderCount, Pageable pageable ); } // 統計報表控制器 @RestController @RequestMapping(\u0026#34;/api/reports\u0026#34;) public class ReportController { @Autowired private OrderStatisticsRepository statisticsRepository; @GetMapping(\u0026#34;/customer-statistics\u0026#34;) public ResponseEntity\u0026lt;Page\u0026lt;OrderStatistics\u0026gt;\u0026gt; getCustomerStatistics( @RequestParam LocalDate startDate, @RequestParam LocalDate endDate, @RequestParam(defaultValue = \u0026#34;1\u0026#34;) Long minOrderCount, @PageableDefault(size = 20, sort = \u0026#34;totalAmount\u0026#34;, direction = Sort.Direction.DESC) Pageable pageable) { LocalDateTime startDateTime = startDate.atStartOfDay(); LocalDateTime endDateTime = endDate.atTime(23, 59, 59); Page\u0026lt;OrderStatistics\u0026gt; statistics = statisticsRepository.findOrderStatistics( startDateTime, endDateTime, minOrderCount, pageable ); return ResponseEntity.ok(statistics); } } 測試實作 1. 單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 package com.example.pagination.service; import com.example.pagination.dto.PageResponse; import com.example.pagination.dto.UserPageRequest; import com.example.pagination.entity.User; import com.example.pagination.entity.UserStatus; import com.example.pagination.repository.UserRepository; import com.example.pagination.service.impl.UserServiceImpl; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.junit.jupiter.MockitoExtension; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageImpl; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Pageable; import java.util.Arrays; import java.util.List; import static org.junit.jupiter.api.Assertions.*; import static org.mockito.ArgumentMatchers.any; import static org.mockito.Mockito.*; @ExtendWith(MockitoExtension.class) public class UserServiceTest { @Mock private UserRepository userRepository; @InjectMocks private UserServiceImpl userService; private List\u0026lt;User\u0026gt; testUsers; @BeforeEach public void setUp() { User user1 = new User(\u0026#34;john\u0026#34;, \u0026#34;john@example.com\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;); User user2 = new User(\u0026#34;jane\u0026#34;, \u0026#34;jane@example.com\u0026#34;, \u0026#34;Jane\u0026#34;, \u0026#34;Smith\u0026#34;); testUsers = Arrays.asList(user1, user2); } @Test public void testFindUsersWithoutFilters() { // Given UserPageRequest request = new UserPageRequest(0, 10); Pageable pageable = PageRequest.of(0, 10); Page\u0026lt;User\u0026gt; page = new PageImpl\u0026lt;\u0026gt;(testUsers, pageable, testUsers.size()); when(userRepository.findAll(pageable)).thenReturn(page); // When PageResponse\u0026lt;User\u0026gt; result = userService.findUsers(request); // Then assertEquals(2, result.getContent().size()); assertEquals(0, result.getPage()); assertEquals(10, result.getSize()); assertEquals(2, result.getTotalElements()); verify(userRepository).findAll(pageable); verify(userRepository, never()).findAll(any(Specification.class), any(Pageable.class)); } @Test public void testFindUsersWithFilters() { // Given UserPageRequest request = new UserPageRequest(0, 10); request.setUsername(\u0026#34;john\u0026#34;); request.setStatus(UserStatus.ACTIVE); Pageable pageable = PageRequest.of(0, 10); Page\u0026lt;User\u0026gt; page = new PageImpl\u0026lt;\u0026gt;(Arrays.asList(testUsers.get(0)), pageable, 1); when(userRepository.findAll(any(Specification.class), eq(pageable))).thenReturn(page); // When PageResponse\u0026lt;User\u0026gt; result = userService.findUsers(request); // Then assertEquals(1, result.getContent().size()); assertEquals(\u0026#34;john\u0026#34;, result.getContent().get(0).getUsername()); verify(userRepository).findAll(any(Specification.class), eq(pageable)); verify(userRepository, never()).findAll(pageable); } @Test public void testSearchUsers() { // Given String keyword = \u0026#34;john\u0026#34;; UserPageRequest request = new UserPageRequest(0, 10); Pageable pageable = PageRequest.of(0, 10); Page\u0026lt;User\u0026gt; page = new PageImpl\u0026lt;\u0026gt;(Arrays.asList(testUsers.get(0)), pageable, 1); when(userRepository.findAll(any(Specification.class), eq(pageable))).thenReturn(page); // When PageResponse\u0026lt;User\u0026gt; result = userService.searchUsers(keyword, request); // Then assertEquals(1, result.getContent().size()); verify(userRepository).findAll(any(Specification.class), eq(pageable)); } } 2. 整合測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 package com.example.pagination.integration; import com.example.pagination.entity.User; import com.example.pagination.entity.UserStatus; import com.example.pagination.repository.UserRepository; import com.fasterxml.jackson.databind.ObjectMapper; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureWebMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.http.MediaType; import org.springframework.test.context.ActiveProfiles; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.setup.MockMvcBuilders; import org.springframework.transaction.annotation.Transactional; import org.springframework.web.context.WebApplicationContext; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; @SpringBootTest @AutoConfigureWebMvc @ActiveProfiles(\u0026#34;test\u0026#34;) @Transactional public class UserControllerIntegrationTest { @Autowired private WebApplicationContext webApplicationContext; @Autowired private UserRepository userRepository; @Autowired private ObjectMapper objectMapper; private MockMvc mockMvc; @BeforeEach public void setUp() { mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build(); // 建立測試資料 for (int i = 1; i \u0026lt;= 50; i++) { User user = new User(\u0026#34;user\u0026#34; + i, \u0026#34;user\u0026#34; + i + \u0026#34;@example.com\u0026#34;, \u0026#34;User\u0026#34;, String.valueOf(i)); user.setAge(20 + (i % 40)); user.setCity(i % 2 == 0 ? \u0026#34;Taipei\u0026#34; : \u0026#34;Kaohsiung\u0026#34;); user.setStatus(i % 3 == 0 ? UserStatus.INACTIVE : UserStatus.ACTIVE); userRepository.save(user); } } @Test public void testGetUsersWithDefaultPagination() throws Exception { mockMvc.perform(get(\u0026#34;/api/users\u0026#34;)) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.content\u0026#34;).isArray()) .andExpect(jsonPath(\u0026#34;$.page\u0026#34;).value(0)) .andExpect(jsonPath(\u0026#34;$.size\u0026#34;).value(20)) .andExpect(jsonPath(\u0026#34;$.totalElements\u0026#34;).value(50)) .andExpected(jsonPath(\u0026#34;$.totalPages\u0026#34;).value(3)); } @Test public void testGetUsersWithCustomPagination() throws Exception { mockMvc.perform(get(\u0026#34;/api/users\u0026#34;) .param(\u0026#34;page\u0026#34;, \u0026#34;1\u0026#34;) .param(\u0026#34;size\u0026#34;, \u0026#34;10\u0026#34;) .param(\u0026#34;sortBy\u0026#34;, \u0026#34;username\u0026#34;) .param(\u0026#34;sortDirection\u0026#34;, \u0026#34;ASC\u0026#34;)) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.content\u0026#34;).isArray()) .andExpect(jsonPath(\u0026#34;$.page\u0026#34;).value(1)) .andExpect(jsonPath(\u0026#34;$.size\u0026#34;).value(10)) .andExpect(jsonPath(\u0026#34;$.content.length()\u0026#34;).value(10)); } @Test public void testGetUsersWithFilters() throws Exception { mockMvc.perform(get(\u0026#34;/api/users\u0026#34;) .param(\u0026#34;status\u0026#34;, \u0026#34;ACTIVE\u0026#34;) .param(\u0026#34;city\u0026#34;, \u0026#34;Taipei\u0026#34;) .param(\u0026#34;minAge\u0026#34;, \u0026#34;25\u0026#34;) .param(\u0026#34;maxAge\u0026#34;, \u0026#34;35\u0026#34;)) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.content\u0026#34;).isArray()); } @Test public void testSearchUsers() throws Exception { mockMvc.perform(get(\u0026#34;/api/users/search\u0026#34;) .param(\u0026#34;keyword\u0026#34;, \u0026#34;user1\u0026#34;)) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.content\u0026#34;).isArray()); } } 常見問題與解決方案 1. 效能問題 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 問題：大資料量分頁查詢緩慢 // 解決方案：使用覆蓋索引和遊標分頁 @Repository public class OptimizedRepository { @PersistenceContext private EntityManager entityManager; /** * 使用遊標分頁避免 OFFSET 效能問題 */ public List\u0026lt;User\u0026gt; findUsersWithCursor(Long lastId, int limit) { return entityManager.createQuery( \u0026#34;SELECT u FROM User u WHERE u.id \u0026gt; :lastId ORDER BY u.id ASC\u0026#34;, User.class) .setParameter(\u0026#34;lastId\u0026#34;, lastId) .setMaxResults(limit) .getResultList(); } /** * 分離計數查詢和資料查詢 */ public Page\u0026lt;User\u0026gt; findUsersOptimized(Specification\u0026lt;User\u0026gt; spec, Pageable pageable) { // 先查詢資料 List\u0026lt;User\u0026gt; content = entityManager.createQuery(buildQuery(spec, pageable)) .setFirstResult((int) pageable.getOffset()) .setMaxResults(pageable.getPageSize()) .getResultList(); // 再查詢總數（可以快取） Long total = getCountFromCache(spec); return new PageImpl\u0026lt;\u0026gt;(content, pageable, total); } } 2. 記憶體問題 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 問題：大結果集導致記憶體溢出 // 解決方案：使用流式查詢和投影 @Service public class StreamingService { /** * 流式處理大資料集 */ @Transactional(readOnly = true) public void processLargeDataset(Specification\u0026lt;User\u0026gt; spec) { try (Stream\u0026lt;User\u0026gt; stream = userRepository.streamBySpec(spec)) { stream.forEach(this::processUser); } } /** * 只查詢必要欄位 */ @Query(\u0026#34;SELECT new com.example.dto.UserProjection(u.id, u.username, u.email) FROM User u\u0026#34;) Page\u0026lt;UserProjection\u0026gt; findUserProjections(Pageable pageable); } 3. 並發問題 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 問題：分頁過程中資料變化導致重複或遺漏 // 解決方案：使用快照隔離或版本控制 @Service public class ConsistentPaginationService { /** * 使用時間戳確保一致性 */ public Page\u0026lt;User\u0026gt; findUsersConsistently(UserPageRequest request, LocalDateTime snapshot) { Specification\u0026lt;User\u0026gt; spec = UserSpecification.withFilters( request.getUsername(), request.getEmail(), request.getStatus(), request.getMinAge(), request.getMaxAge(), request.getCity() ).and((root, query, cb) -\u0026gt; cb.lessThanOrEqualTo(root.get(\u0026#34;createdAt\u0026#34;), snapshot) ); return userRepository.findAll(spec, request.toPageable()); } } 總結 核心優勢 類型安全：Criteria API 提供編譯時檢查 動態查詢：根據條件靈活構建查詢 自動分頁：自動處理分頁邏輯和計數 效能優化：支援索引、快取和查詢優化 易於維護：結構化的查詢構建方式 最佳實踐 合理設定分頁大小：避免過大的頁面大小 建立適當索引：為查詢條件和排序欄位建立索引 使用投影查詢：只查詢需要的欄位 快取熱門查詢：快取頻繁查詢的結果 驗證輸入參數：防止 SQL 注入和無效查詢 監控查詢效能：定期檢查慢查詢 使用連接池：合理配置資料庫連接池 常用模式速查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 基本分頁 PageRequest.of(page, size, Sort.by(\u0026#34;fieldName\u0026#34;).descending()) // Specification 組合 Specification.where(spec1).and(spec2).or(spec3) // 動態條件 if (condition != null) { spec = spec.and(customSpec(condition)); } // 自訂排序 Sort.by(Sort.Order.desc(\u0026#34;field1\u0026#34;), Sort.Order.asc(\u0026#34;field2\u0026#34;)) // 投影查詢 @Query(\u0026#34;SELECT new dto.UserDto(u.id, u.name) FROM User u\u0026#34;) Page\u0026lt;UserDto\u0026gt; findUserDtos(Pageable pageable); Spring Data JPA 的 Pageable 和 Specification 提供了強大而靈活的分頁查詢功能，正確使用能夠大幅提升應用程式的查詢效能和使用者體驗。記住：理解底層的 SQL 生成機制有助於寫出更高效的查詢代碼。\n參考資料 Spring Data JPA 官方文檔 JPA Criteria API 規範 Spring Data Web Support Hibernate Performance Guide Database Indexing Best Practices ","permalink":"https://xinqilin.github.io/post/backend/jpapageable/","tags":["Spring Data JPA","Pageable","Pagination","Spring Boot","Database","Performance","Specification","Criteria API"],"title":"Spring Data JPA Pageable 分頁查詢：完整實作與效能優化指南"},{"content":"Side Project 企業級專案配置指南 簡介 在現代軟體開發中，一個良好的專案配置是成功的關鍵。本文將深入介紹如何從零開始建立一個企業級的 Side Project，包含完整的開發環境設定、專案結構規劃、依賴管理、容器化部署、監控系統與 CI/CD 流程。\n專案結構規劃 標準 Maven 專案結構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 project-root/ ├── src/ │ ├── main/ │ │ ├── java/ │ │ │ └── com/ │ │ │ └── company/ │ │ │ └── project/ │ │ │ ├── Application.java │ │ │ ├── config/ │ │ │ │ ├── AppConfig.java │ │ │ │ ├── SecurityConfig.java │ │ │ │ └── DatabaseConfig.java │ │ │ ├── controller/ │ │ │ ├── service/ │ │ │ │ ├── impl/ │ │ │ │ └── dto/ │ │ │ ├── repository/ │ │ │ ├── entity/ │ │ │ ├── exception/ │ │ │ └── util/ │ │ └── resources/ │ │ ├── application.yml │ │ ├── application-dev.yml │ │ ├── application-prod.yml │ │ ├── logback-spring.xml │ │ ├── banner.txt │ │ └── db/ │ │ └── migration/ │ └── test/ │ ├── java/ │ │ └── com/ │ │ └── company/ │ │ └── project/ │ │ ├── integration/ │ │ ├── unit/ │ │ └── TestApplication.java │ └── resources/ │ └── application-test.yml ├── docker/ │ ├── Dockerfile │ ├── docker-compose.yml │ └── docker-compose.prod.yml ├── .github/ │ └── workflows/ │ ├── ci.yml │ └── cd.yml ├── docs/ │ ├── api/ │ └── setup/ ├── scripts/ │ ├── build.sh │ ├── deploy.sh │ └── setup.sh ├── pom.xml ├── README.md └── .gitignore 核心依賴管理 完整的 Maven 依賴配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.company\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;side-project\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;Side Project\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Enterprise Side Project Configuration\u0026lt;/description\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;spring-cloud.version\u0026gt;2022.0.4\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;springdoc.version\u0026gt;2.2.0\u0026lt;/springdoc.version\u0026gt; \u0026lt;mapstruct.version\u0026gt;1.5.5.Final\u0026lt;/mapstruct.version\u0026gt; \u0026lt;testcontainers.version\u0026gt;1.19.0\u0026lt;/testcontainers.version\u0026gt; \u0026lt;jackson.version\u0026gt;2.15.2\u0026lt;/jackson.version\u0026gt; \u0026lt;guava.version\u0026gt;32.1.2-jre\u0026lt;/guava.version\u0026gt; \u0026lt;commons-lang3.version\u0026gt;3.13.0\u0026lt;/commons-lang3.version\u0026gt; \u0026lt;liquibase.version\u0026gt;4.23.2\u0026lt;/liquibase.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- Spring Boot Starters --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-cache\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Database --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.33\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Database Migration --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.liquibase\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;liquibase-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${liquibase.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Documentation --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-starter-webmvc-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${springdoc.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- JSON Processing --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jackson.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jackson.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.datatype\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-datatype-jsr310\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jackson.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Utilities --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang3\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${commons-lang3.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.guava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;guava\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${guava.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Mapping --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mapstruct\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mapstruct\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mapstruct.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Monitoring --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.micrometer\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;micrometer-registry-prometheus\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.logstash.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logstash-logback-encoder\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;7.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- JWT --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.11.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-impl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.11.5\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-jackson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.11.5\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Test Dependencies --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${testcontainers.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${testcontainers.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;redis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${testcontainers.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.11.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;17\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;17\u0026lt;/target\u0026gt; \u0026lt;annotationProcessorPaths\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;org.mapstruct\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mapstruct-processor\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mapstruct.version}\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok-mapstruct-binding\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.2.0\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;/annotationProcessorPaths\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.liquibase\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;liquibase-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${liquibase.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;propertyFile\u0026gt;src/main/resources/liquibase.properties\u0026lt;/propertyFile\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.jacoco\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jacoco-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.8.10\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;prepare-agent\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;report\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;test\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;report\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;com.google.cloud.tools\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jib-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;from\u0026gt; \u0026lt;image\u0026gt;eclipse-temurin:17-jre-alpine\u0026lt;/image\u0026gt; \u0026lt;/from\u0026gt; \u0026lt;to\u0026gt; \u0026lt;image\u0026gt;your-registry/side-project:${project.version}\u0026lt;/image\u0026gt; \u0026lt;/to\u0026gt; \u0026lt;container\u0026gt; \u0026lt;jvmFlags\u0026gt; \u0026lt;jvmFlag\u0026gt;-Xms512m\u0026lt;/jvmFlag\u0026gt; \u0026lt;jvmFlag\u0026gt;-Xmx2g\u0026lt;/jvmFlag\u0026gt; \u0026lt;/jvmFlags\u0026gt; \u0026lt;mainClass\u0026gt;com.company.project.Application\u0026lt;/mainClass\u0026gt; \u0026lt;ports\u0026gt; \u0026lt;port\u0026gt;8080\u0026lt;/port\u0026gt; \u0026lt;/ports\u0026gt; \u0026lt;/container\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 應用程式配置 主要配置檔案 - application.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 # 應用程式配置 spring: application: name: side-project profiles: active: ${SPRING_PROFILES_ACTIVE:dev} # 資料庫配置 datasource: url: jdbc:mysql://${DB_HOST:localhost}:${DB_PORT:3306}/${DB_NAME:side_project}?useSSL=false\u0026amp;serverTimezone=Asia/Taipei\u0026amp;allowPublicKeyRetrieval=true username: ${DB_USERNAME:root} password: ${DB_PASSWORD:password} driver-class-name: com.mysql.cj.jdbc.Driver hikari: minimum-idle: 5 maximum-pool-size: 20 idle-timeout: 30000 connection-timeout: 30000 max-lifetime: 1800000 pool-name: HikariCP # JPA 配置 jpa: hibernate: ddl-auto: validate show-sql: false properties: hibernate: dialect: org.hibernate.dialect.MySQL8Dialect format_sql: true use_sql_comments: true jdbc: batch_size: 25 order_inserts: true order_updates: true connection: provider_disables_autocommit: true query: in_clause_parameter_padding: true cache: use_second_level_cache: true use_query_cache: true region: factory_class: org.hibernate.cache.jcache.JCacheRegionFactory # Redis 配置 redis: host: ${REDIS_HOST:localhost} port: ${REDIS_PORT:6379} password: ${REDIS_PASSWORD:} database: 0 timeout: 10000ms lettuce: pool: max-active: 200 max-idle: 20 min-idle: 5 max-wait: 10000ms # Cache 配置 cache: type: redis redis: time-to-live: 600000 cache-null-values: false # Security 配置 security: oauth2: client: registration: google: client-id: ${GOOGLE_CLIENT_ID:your-google-client-id} client-secret: ${GOOGLE_CLIENT_SECRET:your-google-client-secret} scope: openid,profile,email # Liquibase 配置 liquibase: change-log: classpath:db/changelog/db.changelog-master.xml enabled: true # Jackson 配置 jackson: serialization: write-dates-as-timestamps: false indent-output: true deserialization: fail-on-unknown-properties: false time-zone: Asia/Taipei default-property-inclusion: non_null # 服務器配置 server: port: ${SERVER_PORT:8080} servlet: context-path: /api compression: enabled: true mime-types: text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json min-response-size: 1024 error: include-stacktrace: never include-message: always # 日誌配置 logging: level: root: INFO com.company.project: DEBUG org.springframework.security: DEBUG org.hibernate.SQL: DEBUG org.hibernate.type.descriptor.sql.BasicBinder: TRACE pattern: console: \u0026#34;%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\u0026#34; file: \u0026#34;%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\u0026#34; file: name: logs/application.log logback: rollingpolicy: max-file-size: 10MB max-history: 30 # 管理端點配置 management: endpoints: web: exposure: include: health,info,metrics,prometheus,liquibase,caches endpoint: health: show-details: always health: redis: enabled: true db: enabled: true metrics: export: prometheus: enabled: true tags: application: ${spring.application.name} environment: ${spring.profiles.active} # SpringDoc 配置 springdoc: api-docs: path: /api-docs swagger-ui: path: /swagger-ui.html operations-sorter: method tags-sorter: alpha packages-to-scan: com.company.project.controller # 應用程式自訂配置 app: jwt: secret: ${JWT_SECRET:your-secret-key-must-be-at-least-256-bits} expiration: ${JWT_EXPIRATION:86400000} # 24 hours refresh-expiration: ${JWT_REFRESH_EXPIRATION:604800000} # 7 days cors: allowed-origins: ${CORS_ALLOWED_ORIGINS:http://localhost:3000,http://localhost:8080} allowed-methods: ${CORS_ALLOWED_METHODS:GET,POST,PUT,DELETE,OPTIONS} allowed-headers: ${CORS_ALLOWED_HEADERS:*} allow-credentials: true rate-limit: enabled: true requests-per-minute: 60 burst-capacity: 100 file-storage: upload-dir: ${FILE_UPLOAD_DIR:uploads/} max-file-size: ${MAX_FILE_SIZE:10MB} allowed-extensions: ${ALLOWED_EXTENSIONS:jpg,jpeg,png,gif,pdf,docx,xlsx} 開發環境配置 - application-dev.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 spring: datasource: url: jdbc:mysql://localhost:3306/side_project_dev?useSSL=false\u0026amp;serverTimezone=Asia/Taipei username: root password: mysql jpa: hibernate: ddl-auto: update show-sql: true redis: host: localhost port: 6379 liquibase: enabled: false logging: level: root: DEBUG com.company.project: DEBUG org.springframework.web: DEBUG org.springframework.security: DEBUG management: endpoints: web: exposure: include: \u0026#34;*\u0026#34; app: jwt: secret: dev-secret-key-for-development-only-not-for-production expiration: 86400000 cors: allowed-origins: \u0026#34;http://localhost:3000,http://localhost:8080\u0026#34; 生產環境配置 - application-prod.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 spring: datasource: url: jdbc:mysql://${DB_HOST}:${DB_PORT}/${DB_NAME}?useSSL=true\u0026amp;serverTimezone=Asia/Taipei username: ${DB_USERNAME} password: ${DB_PASSWORD} hikari: minimum-idle: 10 maximum-pool-size: 50 idle-timeout: 60000 connection-timeout: 30000 max-lifetime: 1800000 jpa: hibernate: ddl-auto: validate show-sql: false redis: host: ${REDIS_HOST} port: ${REDIS_PORT} password: ${REDIS_PASSWORD} ssl: true liquibase: enabled: true logging: level: root: WARN com.company.project: INFO file: name: /var/log/side-project/application.log management: endpoints: web: exposure: include: health,info,metrics,prometheus endpoint: health: show-details: when-authorized app: jwt: secret: ${JWT_SECRET} expiration: ${JWT_EXPIRATION:3600000} cors: allowed-origins: ${CORS_ALLOWED_ORIGINS} 核心配置類別 主要應用程式配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.company.project.config; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Configuration; import lombok.Data; @Data @Configuration @ConfigurationProperties(prefix = \u0026#34;app\u0026#34;) public class AppProperties { private Jwt jwt = new Jwt(); private Cors cors = new Cors(); private RateLimit rateLimit = new RateLimit(); private FileStorage fileStorage = new FileStorage(); @Data public static class Jwt { private String secret; private long expiration; private long refreshExpiration; } @Data public static class Cors { private String allowedOrigins; private String allowedMethods; private String allowedHeaders; private boolean allowCredentials; } @Data public static class RateLimit { private boolean enabled; private int requestsPerMinute; private int burstCapacity; } @Data public static class FileStorage { private String uploadDir; private String maxFileSize; private String allowedExtensions; } } 資料庫配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.company.project.config; import com.zaxxer.hikari.HikariConfig; import com.zaxxer.hikari.HikariDataSource; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.data.jpa.repository.config.EnableJpaAuditing; import org.springframework.data.jpa.repository.config.EnableJpaRepositories; import org.springframework.transaction.annotation.EnableTransactionManagement; import javax.sql.DataSource; @Configuration @EnableJpaRepositories(basePackages = \u0026#34;com.company.project.repository\u0026#34;) @EnableJpaAuditing @EnableTransactionManagement public class DatabaseConfig { @Bean @Primary @ConfigurationProperties(\u0026#34;spring.datasource.hikari\u0026#34;) public HikariConfig hikariConfig() { return new HikariConfig(); } @Bean @Primary public DataSource dataSource() { return new HikariDataSource(hikariConfig()); } } Redis 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package com.company.project.config; import org.springframework.boot.autoconfigure.data.redis.RedisProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; import org.springframework.cache.annotation.EnableCaching; import org.springframework.cache.CacheManager; import org.springframework.data.redis.cache.RedisCacheManager; import org.springframework.data.redis.cache.RedisCacheConfiguration; import java.time.Duration; @Configuration @EnableCaching public class RedisConfig { @Bean public RedisConnectionFactory redisConnectionFactory(RedisProperties redisProperties) { return new LettuceConnectionFactory(redisProperties.getHost(), redisProperties.getPort()); } @Bean public RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate(RedisConnectionFactory connectionFactory) { RedisTemplate\u0026lt;String, Object\u0026gt; template = new RedisTemplate\u0026lt;\u0026gt;(); template.setConnectionFactory(connectionFactory); // 設定序列化器 template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(new GenericJackson2JsonRedisSerializer()); template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer()); template.afterPropertiesSet(); return template; } @Bean public CacheManager cacheManager(RedisConnectionFactory connectionFactory) { RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofMinutes(10)) .serializeKeysWith(org.springframework.data.redis.serializer.RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer())) .serializeValuesWith(org.springframework.data.redis.serializer.RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer())); return RedisCacheManager.builder(connectionFactory) .cacheDefaults(config) .build(); } } 安全配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package com.company.project.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.security.web.SecurityFilterChain; import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.CorsConfigurationSource; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import java.util.Arrays; @Configuration @EnableWebSecurity public class SecurityConfig { private final AppProperties appProperties; private final JwtAuthenticationFilter jwtAuthenticationFilter; public SecurityConfig(AppProperties appProperties, JwtAuthenticationFilter jwtAuthenticationFilter) { this.appProperties = appProperties; this.jwtAuthenticationFilter = jwtAuthenticationFilter; } @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http.csrf(csrf -\u0026gt; csrf.disable()) .cors(cors -\u0026gt; cors.configurationSource(corsConfigurationSource())) .sessionManagement(session -\u0026gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) .authorizeHttpRequests(authz -\u0026gt; authz .requestMatchers(\u0026#34;/api/auth/**\u0026#34;, \u0026#34;/api/public/**\u0026#34;).permitAll() .requestMatchers(\u0026#34;/api-docs/**\u0026#34;, \u0026#34;/swagger-ui/**\u0026#34;, \u0026#34;/swagger-ui.html\u0026#34;).permitAll() .requestMatchers(\u0026#34;/actuator/health\u0026#34;, \u0026#34;/actuator/info\u0026#34;).permitAll() .anyRequest().authenticated() ) .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class); return http.build(); } @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Bean public CorsConfigurationSource corsConfigurationSource() { CorsConfiguration configuration = new CorsConfiguration(); configuration.setAllowedOrigins(Arrays.asList(appProperties.getCors().getAllowedOrigins().split(\u0026#34;,\u0026#34;))); configuration.setAllowedMethods(Arrays.asList(appProperties.getCors().getAllowedMethods().split(\u0026#34;,\u0026#34;))); configuration.setAllowedHeaders(Arrays.asList(appProperties.getCors().getAllowedHeaders().split(\u0026#34;,\u0026#34;))); configuration.setAllowCredentials(appProperties.getCors().isAllowCredentials()); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\u0026#34;/**\u0026#34;, configuration); return source; } } OpenAPI 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package com.company.project.config; import io.swagger.v3.oas.models.OpenAPI; import io.swagger.v3.oas.models.info.Info; import io.swagger.v3.oas.models.info.Contact; import io.swagger.v3.oas.models.info.License; import io.swagger.v3.oas.models.security.SecurityRequirement; import io.swagger.v3.oas.models.security.SecurityScheme; import io.swagger.v3.oas.models.Components; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class OpenApiConfig { @Bean public OpenAPI customOpenAPI() { return new OpenAPI() .info(new Info() .title(\u0026#34;Side Project API\u0026#34;) .version(\u0026#34;1.0.0\u0026#34;) .description(\u0026#34;Enterprise Side Project API Documentation\u0026#34;) .contact(new Contact() .name(\u0026#34;Bill Lin\u0026#34;) .email(\u0026#34;bill@example.com\u0026#34;) .url(\u0026#34;https://github.com/yourhandle\u0026#34;)) .license(new License() .name(\u0026#34;MIT License\u0026#34;) .url(\u0026#34;https://opensource.org/licenses/MIT\u0026#34;))) .addSecurityItem(new SecurityRequirement().addList(\u0026#34;Bearer Authentication\u0026#34;)) .components(new Components() .addSecuritySchemes(\u0026#34;Bearer Authentication\u0026#34;, new SecurityScheme() .type(SecurityScheme.Type.HTTP) .scheme(\u0026#34;bearer\u0026#34;) .bearerFormat(\u0026#34;JWT\u0026#34;))); } } 容器化配置 Dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 # Multi-stage build FROM eclipse-temurin:17-jdk-alpine AS builder WORKDIR /app COPY pom.xml . COPY src ./src RUN ./mvnw clean package -DskipTests FROM eclipse-temurin:17-jre-alpine # 建立非 root 使用者 RUN addgroup -g 1001 -S appgroup \u0026amp;\u0026amp; \\ adduser -u 1001 -S appuser -G appgroup WORKDIR /app # 複製 JAR 檔案 COPY --from=builder /app/target/*.jar app.jar # 建立必要目錄 RUN mkdir -p /app/logs /app/uploads \u0026amp;\u0026amp; \\ chown -R appuser:appgroup /app # 切換到非 root 使用者 USER appuser # 健康檢查 HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \\ CMD curl -f http://localhost:8080/actuator/health || exit 1 # 暴露埠號 EXPOSE 8080 # JVM 調優參數 ENV JAVA_OPTS=\u0026#34;-Xms512m -Xmx2g -XX:+UseG1GC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/app/logs/\u0026#34; # 啟動應用程式 ENTRYPOINT [\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;java $JAVA_OPTS -jar app.jar\u0026#34;] docker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 version: \u0026#39;3.8\u0026#39; services: app: build: . ports: - \u0026#34;8080:8080\u0026#34; environment: - SPRING_PROFILES_ACTIVE=docker - DB_HOST=mysql - DB_PORT=3306 - DB_NAME=side_project - DB_USERNAME=root - DB_PASSWORD=mysql - REDIS_HOST=redis - REDIS_PORT=6379 depends_on: - mysql - redis volumes: - ./logs:/app/logs - ./uploads:/app/uploads networks: - app-network restart: unless-stopped mysql: image: mysql:8.0 environment: - MYSQL_ROOT_PASSWORD=mysql - MYSQL_DATABASE=side_project - MYSQL_USER=app - MYSQL_PASSWORD=app ports: - \u0026#34;3306:3306\u0026#34; volumes: - mysql_data:/var/lib/mysql - ./docker/mysql/init.sql:/docker-entrypoint-initdb.d/init.sql networks: - app-network restart: unless-stopped redis: image: redis:7-alpine ports: - \u0026#34;6379:6379\u0026#34; volumes: - redis_data:/data networks: - app-network restart: unless-stopped prometheus: image: prom/prometheus:latest ports: - \u0026#34;9090:9090\u0026#34; volumes: - ./docker/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml networks: - app-network restart: unless-stopped grafana: image: grafana/grafana:latest ports: - \u0026#34;3000:3000\u0026#34; environment: - GF_SECURITY_ADMIN_PASSWORD=admin volumes: - grafana_data:/var/lib/grafana - ./docker/grafana/dashboards:/etc/grafana/provisioning/dashboards - ./docker/grafana/datasources:/etc/grafana/provisioning/datasources networks: - app-network restart: unless-stopped nginx: image: nginx:alpine ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; volumes: - ./docker/nginx/nginx.conf:/etc/nginx/nginx.conf - ./docker/nginx/ssl:/etc/nginx/ssl depends_on: - app networks: - app-network restart: unless-stopped volumes: mysql_data: redis_data: grafana_data: networks: app-network: driver: bridge 生產環境 docker-compose.prod.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 version: \u0026#39;3.8\u0026#39; services: app: image: your-registry/side-project:latest deploy: replicas: 3 resources: limits: memory: 2G cpus: \u0026#39;1\u0026#39; reservations: memory: 1G cpus: \u0026#39;0.5\u0026#39; restart_policy: condition: on-failure delay: 10s max_attempts: 3 environment: - SPRING_PROFILES_ACTIVE=prod - DB_HOST=mysql-prod - DB_PORT=3306 - DB_NAME=side_project_prod - DB_USERNAME=${DB_USERNAME} - DB_PASSWORD=${DB_PASSWORD} - REDIS_HOST=redis-prod - REDIS_PORT=6379 - REDIS_PASSWORD=${REDIS_PASSWORD} - JWT_SECRET=${JWT_SECRET} secrets: - db_password - jwt_secret networks: - app-network logging: driver: \u0026#34;json-file\u0026#34; options: max-size: \u0026#34;10m\u0026#34; max-file: \u0026#34;3\u0026#34; mysql-prod: image: mysql:8.0 environment: - MYSQL_ROOT_PASSWORD_FILE=/run/secrets/db_password - MYSQL_DATABASE=side_project_prod volumes: - mysql_prod_data:/var/lib/mysql secrets: - db_password networks: - app-network deploy: resources: limits: memory: 2G cpus: \u0026#39;1\u0026#39; redis-prod: image: redis:7-alpine command: redis-server --requirepass ${REDIS_PASSWORD} volumes: - redis_prod_data:/data networks: - app-network deploy: resources: limits: memory: 512M cpus: \u0026#39;0.5\u0026#39; secrets: db_password: external: true jwt_secret: external: true volumes: mysql_prod_data: redis_prod_data: networks: app-network: driver: overlay 監控配置 logback-spring.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;include resource=\u0026#34;org/springframework/boot/logging/logback/defaults.xml\u0026#34;/\u0026gt; \u0026lt;springProfile name=\u0026#34;!prod\u0026#34;\u0026gt; \u0026lt;include resource=\u0026#34;org/springframework/boot/logging/logback/console-appender.xml\u0026#34;/\u0026gt; \u0026lt;root level=\u0026#34;INFO\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;CONSOLE\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/springProfile\u0026gt; \u0026lt;springProfile name=\u0026#34;prod\u0026#34;\u0026gt; \u0026lt;appender name=\u0026#34;FILE\u0026#34; class=\u0026#34;ch.qos.logback.core.rolling.RollingFileAppender\u0026#34;\u0026gt; \u0026lt;file\u0026gt;/var/log/side-project/application.log\u0026lt;/file\u0026gt; \u0026lt;encoder class=\u0026#34;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder\u0026#34;\u0026gt; \u0026lt;providers\u0026gt; \u0026lt;timestamp/\u0026gt; \u0026lt;logLevel/\u0026gt; \u0026lt;loggerName/\u0026gt; \u0026lt;mdc/\u0026gt; \u0026lt;message/\u0026gt; \u0026lt;stackTrace/\u0026gt; \u0026lt;/providers\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;rollingPolicy class=\u0026#34;ch.qos.logback.core.rolling.TimeBasedRollingPolicy\u0026#34;\u0026gt; \u0026lt;fileNamePattern\u0026gt;/var/log/side-project/application.%d{yyyy-MM-dd}.%i.log\u0026lt;/fileNamePattern\u0026gt; \u0026lt;timeBasedFileNamingAndTriggeringPolicy class=\u0026#34;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\u0026#34;\u0026gt; \u0026lt;maxFileSize\u0026gt;100MB\u0026lt;/maxFileSize\u0026gt; \u0026lt;/timeBasedFileNamingAndTriggeringPolicy\u0026gt; \u0026lt;maxHistory\u0026gt;30\u0026lt;/maxHistory\u0026gt; \u0026lt;totalSizeCap\u0026gt;3GB\u0026lt;/totalSizeCap\u0026gt; \u0026lt;/rollingPolicy\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;appender name=\u0026#34;METRICS\u0026#34; class=\u0026#34;ch.qos.logback.core.rolling.RollingFileAppender\u0026#34;\u0026gt; \u0026lt;file\u0026gt;/var/log/side-project/metrics.log\u0026lt;/file\u0026gt; \u0026lt;encoder class=\u0026#34;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder\u0026#34;\u0026gt; \u0026lt;providers\u0026gt; \u0026lt;timestamp/\u0026gt; \u0026lt;logLevel/\u0026gt; \u0026lt;loggerName/\u0026gt; \u0026lt;mdc/\u0026gt; \u0026lt;message/\u0026gt; \u0026lt;/providers\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;rollingPolicy class=\u0026#34;ch.qos.logback.core.rolling.TimeBasedRollingPolicy\u0026#34;\u0026gt; \u0026lt;fileNamePattern\u0026gt;/var/log/side-project/metrics.%d{yyyy-MM-dd}.log\u0026lt;/fileNamePattern\u0026gt; \u0026lt;maxHistory\u0026gt;7\u0026lt;/maxHistory\u0026gt; \u0026lt;/rollingPolicy\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;logger name=\u0026#34;metrics\u0026#34; level=\u0026#34;INFO\u0026#34; additivity=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;METRICS\u0026#34;/\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;root level=\u0026#34;INFO\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;FILE\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/springProfile\u0026gt; \u0026lt;/configuration\u0026gt; Prometheus 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # docker/prometheus/prometheus.yml global: scrape_interval: 15s evaluation_interval: 15s scrape_configs: - job_name: \u0026#39;side-project\u0026#39; static_configs: - targets: [\u0026#39;app:8080\u0026#39;] metrics_path: \u0026#39;/actuator/prometheus\u0026#39; scrape_interval: 10s - job_name: \u0026#39;mysql\u0026#39; static_configs: - targets: [\u0026#39;mysql:3306\u0026#39;] - job_name: \u0026#39;redis\u0026#39; static_configs: - targets: [\u0026#39;redis:6379\u0026#39;] CI/CD 配置 GitHub Actions - CI 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 # .github/workflows/ci.yml name: CI on: push: branches: [ main, develop ] pull_request: branches: [ main ] jobs: test: runs-on: ubuntu-latest services: mysql: image: mysql:8.0 env: MYSQL_ROOT_PASSWORD: mysql MYSQL_DATABASE: side_project_test ports: - 3306:3306 options: \u0026gt;- --health-cmd=\u0026#34;mysqladmin ping\u0026#34; --health-interval=10s --health-timeout=5s --health-retries=3 redis: image: redis:7-alpine ports: - 6379:6379 options: \u0026gt;- --health-cmd=\u0026#34;redis-cli ping\u0026#34; --health-interval=10s --health-timeout=5s --health-retries=3 steps: - uses: actions/checkout@v3 - name: Set up JDK 17 uses: actions/setup-java@v3 with: java-version: \u0026#39;17\u0026#39; distribution: \u0026#39;temurin\u0026#39; - name: Cache Maven dependencies uses: actions/cache@v3 with: path: ~/.m2 key: ${{ runner.os }}-m2-${{ hashFiles(\u0026#39;**/pom.xml\u0026#39;) }} restore-keys: ${{ runner.os }}-m2 - name: Run tests run: mvn clean test env: SPRING_PROFILES_ACTIVE: test DB_HOST: localhost DB_PORT: 3306 DB_NAME: side_project_test DB_USERNAME: root DB_PASSWORD: mysql REDIS_HOST: localhost REDIS_PORT: 6379 - name: Generate test report uses: dorny/test-reporter@v1 if: success() || failure() with: name: Maven Tests path: target/surefire-reports/*.xml reporter: java-junit - name: Upload coverage to Codecov uses: codecov/codecov-action@v3 with: file: ./target/site/jacoco/jacoco.xml - name: SonarCloud Scan uses: SonarSource/sonarcloud-github-action@master env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }} GitHub Actions - CD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # .github/workflows/cd.yml name: CD on: push: branches: [ main ] tags: [ \u0026#39;v*\u0026#39; ] jobs: deploy: runs-on: ubuntu-latest if: github.ref == \u0026#39;refs/heads/main\u0026#39; steps: - uses: actions/checkout@v3 - name: Set up JDK 17 uses: actions/setup-java@v3 with: java-version: \u0026#39;17\u0026#39; distribution: \u0026#39;temurin\u0026#39; - name: Build with Maven run: mvn clean package -DskipTests - name: Build Docker image run: | docker build -t ${{ secrets.REGISTRY_URL }}/side-project:${{ github.sha }} . docker tag ${{ secrets.REGISTRY_URL }}/side-project:${{ github.sha }} ${{ secrets.REGISTRY_URL }}/side-project:latest - name: Login to Container Registry uses: docker/login-action@v2 with: registry: ${{ secrets.REGISTRY_URL }} username: ${{ secrets.REGISTRY_USERNAME }} password: ${{ secrets.REGISTRY_PASSWORD }} - name: Push Docker image run: | docker push ${{ secrets.REGISTRY_URL }}/side-project:${{ github.sha }} docker push ${{ secrets.REGISTRY_URL }}/side-project:latest - name: Deploy to production uses: appleboy/ssh-action@v0.1.5 with: host: ${{ secrets.HOST }} username: ${{ secrets.USERNAME }} key: ${{ secrets.SSH_KEY }} script: | cd /opt/side-project docker-compose pull docker-compose up -d docker system prune -f 部署腳本 建構腳本 - scripts/build.sh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #!/bin/bash # 建構腳本 set -e echo \u0026#34;開始建構 Side Project...\u0026#34; # 清理舊的建構檔案 echo \u0026#34;清理舊的建構檔案...\u0026#34; mvn clean # 執行測試 echo \u0026#34;執行測試...\u0026#34; mvn test # 建構應用程式 echo \u0026#34;建構應用程式...\u0026#34; mvn package -DskipTests # 建構 Docker 映像 echo \u0026#34;建構 Docker 映像...\u0026#34; docker build -t side-project:latest . echo \u0026#34;建構完成！\u0026#34; 部署腳本 - scripts/deploy.sh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #!/bin/bash # 部署腳本 set -e ENVIRONMENT=${1:-dev} VERSION=${2:-latest} echo \u0026#34;部署 Side Project 到 $ENVIRONMENT 環境...\u0026#34; case $ENVIRONMENT in \u0026#34;dev\u0026#34;) echo \u0026#34;部署到開發環境...\u0026#34; docker-compose -f docker-compose.yml up -d ;; \u0026#34;staging\u0026#34;) echo \u0026#34;部署到測試環境...\u0026#34; docker-compose -f docker-compose.staging.yml up -d ;; \u0026#34;prod\u0026#34;) echo \u0026#34;部署到生產環境...\u0026#34; docker-compose -f docker-compose.prod.yml up -d ;; *) echo \u0026#34;未知環境: $ENVIRONMENT\u0026#34; exit 1 ;; esac echo \u0026#34;部署完成！\u0026#34; echo \u0026#34;健康檢查中...\u0026#34; sleep 30 # 健康檢查 for i in {1..5}; do if curl -f http://localhost:8080/actuator/health \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;應用程式健康狀態正常\u0026#34; break else echo \u0026#34;健康檢查失敗，重試中... ($i/5)\u0026#34; sleep 10 fi done 自訂 Banner resources/banner.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 _____ _ _ _____ _ _ / ____(_) | | | __ \\ (_) | | | (___ _ __| | ___ | |__) |____ ___ _ ___ ___| |_ \\___ \\| |/ _` |/ _ \\ | ___/ \u0026#39;__/ _ \\ |/ _ \\/ __| __| ____) | | (_| | __/ | | | | | (_) | | __/ (__| |_ |_____/|_|\\__,_|\\___| |_| |_| \\___/| |\\___|\\___|\\__| _/ | |__/ :: Spring Boot :: (v3.1.5) :: Application Version :: 1.0.0 :: Environment :: ${spring.profiles.active} :: Port :: ${server.port} 最佳實踐與建議 1. 安全性最佳實踐 1 2 3 4 5 6 7 8 9 10 11 12 13 # 生產環境安全配置 security: headers: frame-options: DENY content-type-options: nosniff xss-protection: 1; mode=block referrer-policy: strict-origin-when-cross-origin ssl: enabled: true key-store: /etc/ssl/keystore.p12 key-store-password: ${SSL_KEYSTORE_PASSWORD} key-store-type: PKCS12 2. 效能優化配置 1 2 3 4 5 6 7 8 9 10 11 # JVM 調優 JAVA_OPTS: \u0026gt; -server -Xms1g -Xmx2g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+UseStringDeduplication -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/side-project/ -Dspring.profiles.active=prod 3. 監控與告警 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 自訂監控指標 management: metrics: export: prometheus: enabled: true cloudwatch: enabled: true namespace: SideProject step: 1m distribution: percentiles: http.server.requests: 0.5, 0.95, 0.99 spring.data.repository.invocations: 0.5, 0.95, 0.99 4. 資料庫優化 1 2 3 4 5 6 7 8 9 10 11 # 資料庫連線池優化 spring: datasource: hikari: minimum-idle: 10 maximum-pool-size: 50 idle-timeout: 600000 connection-timeout: 30000 max-lifetime: 1800000 leak-detection-threshold: 60000 connection-test-query: SELECT 1 總結 本文提供了一個完整的 Side Project 企業級配置指南，包含：\n完整的專案結構：標準化的 Maven 專案結構 現代化依賴管理：使用最新的 Spring Boot 3.x 和 Java 17 多環境配置：開發、測試、生產環境的完整配置 安全性配置：JWT、CORS、OAuth2 等安全機制 容器化部署：Docker 和 docker-compose 配置 監控系統：Prometheus、Grafana 監控配置 CI/CD 流程：GitHub Actions 自動化部署 最佳實踐：安全性、效能、監控等方面的建議 這個配置可以作為任何 Side Project 的起點，提供了企業級的可擴展性和可維護性。通過遵循這些最佳實踐，您可以快速建立一個穩定、安全、高效的應用程式。\n","permalink":"https://xinqilin.github.io/post/backend/sideprojectconfig/","tags":["Project Setup","Configuration","Development","Best Practices","Spring Boot","Docker","DevOps","Microservices","CI/CD","Production","Architecture","Infrastructure","Environment","Deployment"],"title":"Side Project 企業級專案配置指南：完整開發環境設定與最佳實踐"},{"content":"概述 Spring Framework 廣泛使用註解（Annotations）來簡化配置和提升開發效率。從 Spring 2.5 開始引入註解驅動配置，到 Spring Boot 的自動配置，註解已成為現代 Spring 應用程式開發的核心。本文將系統性地整理 Spring 生態系統中的重要註解，並提供實用的程式碼範例。\n核心容器註解 1. Bean 定義與管理 @Component 系列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // 通用組件 @Component public class UserValidator { public boolean validate(User user) { return user != null \u0026amp;\u0026amp; user.getEmail() != null; } } // 服務層組件 @Service public class UserService { @Autowired private UserRepository userRepository; public User findById(Long id) { return userRepository.findById(id).orElse(null); } } // 資料存取層組件 @Repository public class UserRepositoryImpl implements UserRepository { @PersistenceContext private EntityManager entityManager; @Override public Optional\u0026lt;User\u0026gt; findById(Long id) { User user = entityManager.find(User.class, id); return Optional.ofNullable(user); } } // Web 層組件 @Controller public class UserController { @Autowired private UserService userService; @GetMapping(\u0026#34;/users/{id}\u0026#34;) @ResponseBody public User getUser(@PathVariable Long id) { return userService.findById(id); } } // RESTful API 控制器 @RestController // 等同於 @Controller + @ResponseBody @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserRestController { @Autowired private UserService userService; @GetMapping(\u0026#34;/{id}\u0026#34;) public User getUser(@PathVariable Long id) { return userService.findById(id); } } @Configuration 和 @Bean 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Configuration @EnableTransactionManagement @ComponentScan(basePackages = \u0026#34;com.example\u0026#34;) public class AppConfiguration { @Bean @Primary // 當有多個相同類型的 Bean 時，優先使用這個 public DataSource primaryDataSource() { HikariDataSource dataSource = new HikariDataSource(); dataSource.setJdbcUrl(\u0026#34;jdbc:mysql://localhost:3306/primary\u0026#34;); dataSource.setUsername(\u0026#34;user\u0026#34;); dataSource.setPassword(\u0026#34;password\u0026#34;); return dataSource; } @Bean @Qualifier(\u0026#34;secondary\u0026#34;) // 使用限定符區分 public DataSource secondaryDataSource() { HikariDataSource dataSource = new HikariDataSource(); dataSource.setJdbcUrl(\u0026#34;jdbc:mysql://localhost:3306/secondary\u0026#34;); dataSource.setUsername(\u0026#34;user\u0026#34;); dataSource.setPassword(\u0026#34;password\u0026#34;); return dataSource; } @Bean @Scope(\u0026#34;prototype\u0026#34;) // 每次注入都創建新實例 public OrderProcessor orderProcessor() { return new OrderProcessor(); } @Bean @Lazy // 延遲初始化 public ExpensiveService expensiveService() { return new ExpensiveService(); } } 2. 依賴注入註解 @Autowired 和相關註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Service public class OrderService { // 建構子注入（推薦） private final PaymentService paymentService; private final EmailService emailService; @Autowired public OrderService(PaymentService paymentService, EmailService emailService) { this.paymentService = paymentService; this.emailService = emailService; } // 可選依賴 @Autowired(required = false) private Optional\u0026lt;SmsService\u0026gt; smsService; // 集合注入 @Autowired private List\u0026lt;NotificationProvider\u0026gt; notificationProviders; // 使用限定符 @Autowired @Qualifier(\u0026#34;primary\u0026#34;) private DataSource primaryDataSource; // JSR-330 標準註解 @Inject // 等同於 @Autowired private AuditService auditService; @Named(\u0026#34;cache\u0026#34;) // 等同於 @Qualifier private CacheManager cacheManager; } @Value 屬性注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @Component public class ConfigurationService { // 基本屬性注入 @Value(\u0026#34;${app.name}\u0026#34;) private String appName; // 預設值 @Value(\u0026#34;${app.timeout:30}\u0026#34;) private int timeout; // 系統屬性 @Value(\u0026#34;#{systemProperties[\u0026#39;user.home\u0026#39;]}\u0026#34;) private String userHome; // SpEL 表達式 @Value(\u0026#34;#{T(java.lang.Math).random() * 100}\u0026#34;) private double randomNumber; // 陣列注入 @Value(\u0026#34;${app.allowed-origins}\u0026#34;) private String[] allowedOrigins; // List 注入 @Value(\u0026#34;#{\u0026#39;${app.features}\u0026#39;.split(\u0026#39;,\u0026#39;)}\u0026#34;) private List\u0026lt;String\u0026gt; features; // Map 注入 @Value(\u0026#34;#{${app.database-config}}\u0026#34;) private Map\u0026lt;String, String\u0026gt; databaseConfig; // 建構子參數注入 public ConfigurationService(@Value(\u0026#34;${app.version}\u0026#34;) String version) { this.version = version; } } Web 相關註解 1. MVC 控制器註解 @RequestMapping 系列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @RestController @RequestMapping(\u0026#34;/api/v1/orders\u0026#34;) @CrossOrigin(origins = \u0026#34;http://localhost:3000\u0026#34;) // CORS 設定 public class OrderController { @Autowired private OrderService orderService; // GET 請求 @GetMapping public Page\u0026lt;Order\u0026gt; getOrders( @RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @RequestParam(defaultValue = \u0026#34;20\u0026#34;) int size, @RequestParam(required = false) String status, Pageable pageable) { return orderService.findOrders(status, pageable); } // 路徑變數 @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;Order\u0026gt; getOrder(@PathVariable Long id) { return orderService.findById(id) .map(order -\u0026gt; ResponseEntity.ok(order)) .orElse(ResponseEntity.notFound().build()); } // POST 請求 @PostMapping @ResponseStatus(HttpStatus.CREATED) public Order createOrder(@RequestBody @Valid CreateOrderRequest request) { return orderService.createOrder(request); } // PUT 請求 @PutMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;Order\u0026gt; updateOrder( @PathVariable Long id, @RequestBody @Valid UpdateOrderRequest request) { return orderService.updateOrder(id, request) .map(order -\u0026gt; ResponseEntity.ok(order)) .orElse(ResponseEntity.notFound().build()); } // DELETE 請求 @DeleteMapping(\u0026#34;/{id}\u0026#34;) @ResponseStatus(HttpStatus.NO_CONTENT) public void deleteOrder(@PathVariable Long id) { orderService.deleteOrder(id); } // 檔案上傳 @PostMapping(\u0026#34;/{id}/attachments\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; uploadAttachment( @PathVariable Long id, @RequestParam(\u0026#34;file\u0026#34;) MultipartFile file) { String fileUrl = orderService.uploadAttachment(id, file); return ResponseEntity.ok(fileUrl); } // 自訂 HTTP 方法 @RequestMapping(value = \u0026#34;/{id}/status\u0026#34;, method = RequestMethod.PATCH) public Order updateOrderStatus( @PathVariable Long id, @RequestBody OrderStatusUpdate statusUpdate) { return orderService.updateStatus(id, statusUpdate); } } 參數處理註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @RestController public class UserController { // 請求頭處理 @GetMapping(\u0026#34;/profile\u0026#34;) public UserProfile getProfile( @RequestHeader(\u0026#34;Authorization\u0026#34;) String authToken, @RequestHeader(value = \u0026#34;User-Agent\u0026#34;, required = false) String userAgent) { return userService.getProfile(authToken); } // Cookie 處理 @GetMapping(\u0026#34;/preferences\u0026#34;) public UserPreferences getPreferences( @CookieValue(name = \u0026#34;sessionId\u0026#34;, required = false) String sessionId) { return userService.getPreferences(sessionId); } // Session 屬性 @PostMapping(\u0026#34;/login\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; login( @RequestBody LoginRequest request, @SessionAttribute(required = false) String captcha, HttpSession session) { if (userService.validateLogin(request, captcha)) { session.setAttribute(\u0026#34;userId\u0026#34;, request.getUsername()); return ResponseEntity.ok(\u0026#34;Login successful\u0026#34;); } return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(\u0026#34;Login failed\u0026#34;); } // Model 屬性 @ModelAttribute(\u0026#34;commonData\u0026#34;) public CommonData getCommonData() { return new CommonData(); } @GetMapping(\u0026#34;/dashboard\u0026#34;) public String dashboard(@ModelAttribute(\u0026#34;commonData\u0026#34;) CommonData commonData) { return \u0026#34;dashboard\u0026#34;; } } 2. 驗證註解 Bean Validation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @RestController @Validated // 開啟驗證 public class UserController { @PostMapping(\u0026#34;/users\u0026#34;) public ResponseEntity\u0026lt;User\u0026gt; createUser(@RequestBody @Valid CreateUserRequest request) { User user = userService.createUser(request); return ResponseEntity.ok(user); } @GetMapping(\u0026#34;/users/{id}\u0026#34;) public User getUser(@PathVariable @Min(1) Long id) { return userService.findById(id); } } // 請求 DTO 與驗證 public class CreateUserRequest { @NotBlank(message = \u0026#34;姓名不能為空\u0026#34;) @Size(min = 2, max = 50, message = \u0026#34;姓名長度必須在 2-50 字元之間\u0026#34;) private String name; @NotBlank(message = \u0026#34;信箱不能為空\u0026#34;) @Email(message = \u0026#34;信箱格式不正確\u0026#34;) private String email; @NotNull(message = \u0026#34;年齡不能為空\u0026#34;) @Min(value = 18, message = \u0026#34;年齡必須大於等於 18\u0026#34;) @Max(value = 120, message = \u0026#34;年齡必須小於等於 120\u0026#34;) private Integer age; @Pattern(regexp = \u0026#34;^\\\\+?[1-9]\\\\d{1,14}$\u0026#34;, message = \u0026#34;電話號碼格式不正確\u0026#34;) private String phone; @Valid // 巢狀物件驗證 private Address address; @NotEmpty(message = \u0026#34;至少要有一個興趣\u0026#34;) private List\u0026lt;@NotBlank String\u0026gt; interests; // getters and setters... } // 自訂驗證註解 @Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) @Constraint(validatedBy = UniqueEmailValidator.class) public @interface UniqueEmail { String message() default \u0026#34;信箱已被使用\u0026#34;; Class\u0026lt;?\u0026gt;[] groups() default {}; Class\u0026lt;? extends Payload\u0026gt;[] payload() default {}; } @Component public class UniqueEmailValidator implements ConstraintValidator\u0026lt;UniqueEmail, String\u0026gt; { @Autowired private UserRepository userRepository; @Override public boolean isValid(String email, ConstraintValidatorContext context) { return email == null || !userRepository.existsByEmail(email); } } 資料存取註解 1. JPA 和 Hibernate 註解 實體定義 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @Entity @Table(name = \u0026#34;users\u0026#34;, indexes = { @Index(name = \u0026#34;idx_email\u0026#34;, columnList = \u0026#34;email\u0026#34;), @Index(name = \u0026#34;idx_created_at\u0026#34;, columnList = \u0026#34;created_at\u0026#34;) }) @EntityListeners(AuditingEntityListener.class) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = \u0026#34;full_name\u0026#34;, nullable = false, length = 100) private String name; @Column(unique = true, nullable = false) private String email; @Enumerated(EnumType.STRING) @Column(name = \u0026#34;user_status\u0026#34;) private UserStatus status = UserStatus.ACTIVE; @CreatedDate @Column(name = \u0026#34;created_at\u0026#34;, updatable = false) private LocalDateTime createdAt; @LastModifiedDate @Column(name = \u0026#34;updated_at\u0026#34;) private LocalDateTime updatedAt; @CreatedBy @Column(name = \u0026#34;created_by\u0026#34;, updatable = false) private String createdBy; @LastModifiedBy @Column(name = \u0026#34;updated_by\u0026#34;) private String updatedBy; // 一對多關係 @OneToMany(mappedBy = \u0026#34;user\u0026#34;, cascade = CascadeType.ALL, orphanRemoval = true) @JsonIgnore private List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;(); // 多對一關係 @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;department_id\u0026#34;) private Department department; // 多對多關係 @ManyToMany @JoinTable( name = \u0026#34;user_roles\u0026#34;, joinColumns = @JoinColumn(name = \u0026#34;user_id\u0026#34;), inverseJoinColumns = @JoinColumn(name = \u0026#34;role_id\u0026#34;) ) private Set\u0026lt;Role\u0026gt; roles = new HashSet\u0026lt;\u0026gt;(); // 版本控制（樂觀鎖定） @Version private Long version; // getters and setters... } Repository 介面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt;, JpaSpecificationExecutor\u0026lt;User\u0026gt; { // 查詢方法名稱規則 Optional\u0026lt;User\u0026gt; findByEmail(String email); List\u0026lt;User\u0026gt; findByStatusAndCreatedAtAfter(UserStatus status, LocalDateTime date); Page\u0026lt;User\u0026gt; findByNameContainingIgnoreCase(String name, Pageable pageable); // 自訂查詢 @Query(\u0026#34;SELECT u FROM User u WHERE u.email = ?1 AND u.status = ?2\u0026#34;) Optional\u0026lt;User\u0026gt; findByEmailAndStatus(String email, UserStatus status); // 命名參數 @Query(\u0026#34;SELECT u FROM User u WHERE u.name LIKE %:name% ORDER BY u.createdAt DESC\u0026#34;) List\u0026lt;User\u0026gt; findByNameContaining(@Param(\u0026#34;name\u0026#34;) String name); // 原生 SQL @Query(value = \u0026#34;SELECT * FROM users WHERE email = ?1\u0026#34;, nativeQuery = true) User findByEmailNative(String email); // 更新查詢 @Modifying @Query(\u0026#34;UPDATE User u SET u.status = :status WHERE u.id = :id\u0026#34;) int updateUserStatus(@Param(\u0026#34;id\u0026#34;) Long id, @Param(\u0026#34;status\u0026#34;) UserStatus status); // 刪除查詢 @Modifying @Query(\u0026#34;DELETE FROM User u WHERE u.status = :status\u0026#34;) void deleteByStatus(@Param(\u0026#34;status\u0026#34;) UserStatus status); // 投影查詢 @Query(\u0026#34;SELECT new com.example.dto.UserSummary(u.id, u.name, u.email) FROM User u\u0026#34;) List\u0026lt;UserSummary\u0026gt; findUserSummaries(); // 計數查詢 long countByStatus(UserStatus status); boolean existsByEmail(String email); } 2. 交易管理 @Transactional 註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Service @Transactional // 類別層級的交易設定 public class OrderService { @Autowired private OrderRepository orderRepository; @Autowired private PaymentService paymentService; @Autowired private InventoryService inventoryService; // 預設交易設定 public Order createOrder(CreateOrderRequest request) { Order order = new Order(request); order = orderRepository.save(order); // 這些操作都在同一個交易中 paymentService.processPayment(order); inventoryService.updateStock(order.getItems()); return order; } // 唯讀交易（效能優化） @Transactional(readOnly = true) public List\u0026lt;Order\u0026gt; findOrdersByUser(Long userId) { return orderRepository.findByUserId(userId); } // 指定傳播行為 @Transactional(propagation = Propagation.REQUIRES_NEW) public void logOrderEvent(Long orderId, String event) { // 這個方法總是在新的交易中執行 OrderEvent orderEvent = new OrderEvent(orderId, event); orderEventRepository.save(orderEvent); } // 指定隔離級別 @Transactional(isolation = Isolation.SERIALIZABLE) public void processHighValueOrder(Order order) { // 序列化隔離級別，避免併發問題 processOrder(order); } // 異常回滾設定 @Transactional(rollbackFor = {Exception.class}, noRollbackFor = {ValidationException.class}) public void complexOperation() { // 遇到任何 Exception 都回滾，除了 ValidationException } // 超時設定 @Transactional(timeout = 30) // 30 秒超時 public void longRunningOperation() { // 長時間運行的操作 } // 指定交易管理器 @Transactional(transactionManager = \u0026#34;secondaryTransactionManager\u0026#34;) public void operationOnSecondaryDatabase() { // 使用指定的交易管理器 } } 排程和非同步處理 1. 排程任務註解 @Scheduled 和 @EnableScheduling 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 @Configuration @EnableScheduling public class SchedulingConfig { @Bean public TaskScheduler taskScheduler() { ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.setPoolSize(10); scheduler.setThreadNamePrefix(\u0026#34;scheduled-task-\u0026#34;); scheduler.initialize(); return scheduler; } } @Component @Slf4j public class ScheduledTasks { @Autowired private OrderService orderService; @Autowired private EmailService emailService; // 固定延遲執行（上次執行完成後多久再執行） @Scheduled(fixedDelay = 5000) // 5 秒 public void processOrders() { log.info(\u0026#34;處理待處理訂單\u0026#34;); orderService.processePendingOrders(); } // 固定頻率執行（固定間隔執行） @Scheduled(fixedRate = 10000) // 10 秒 public void heartbeat() { log.info(\u0026#34;系統心跳檢查\u0026#34;); // 系統健康檢查邏輯 } // 初始延遲 @Scheduled(fixedDelay = 30000, initialDelay = 60000) // 1 分鐘後開始，然後每 30 秒執行 public void cleanupTempFiles() { log.info(\u0026#34;清理暫存檔案\u0026#34;); // 清理邏輯 } // Cron 表達式 - 每分鐘執行 @Scheduled(cron = \u0026#34;0 * * * * *\u0026#34;) public void everyMinute() { log.info(\u0026#34;每分鐘執行的任務\u0026#34;); } // Cron 表達式 - 每天凌晨 2 點執行 @Scheduled(cron = \u0026#34;0 0 2 * * *\u0026#34;) public void dailyReport() { log.info(\u0026#34;產生每日報告\u0026#34;); emailService.sendDailyReport(); } // Cron 表達式 - 工作日上午 9 點執行 @Scheduled(cron = \u0026#34;0 0 9 * * MON-FRI\u0026#34;) public void workdayMorningTask() { log.info(\u0026#34;工作日早晨任務\u0026#34;); } // Cron 表達式 - 每月最後一天執行 @Scheduled(cron = \u0026#34;0 0 0 L * *\u0026#34;) public void monthlyTask() { log.info(\u0026#34;月末任務\u0026#34;); } // 使用配置屬性 @Scheduled(cron = \u0026#34;${app.cleanup.cron:0 0 3 * * *}\u0026#34;) // 預設每天凌晨 3 點 public void configuredTask() { log.info(\u0026#34;可配置的排程任務\u0026#34;); } // 條件性排程 @Scheduled(fixedDelay = 60000) @ConditionalOnProperty(name = \u0026#34;app.monitoring.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public void monitoringTask() { log.info(\u0026#34;監控任務\u0026#34;); } } Cron 表達式詳解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /** * Cron 表達式格式：秒 分 時 日 月 週 * * 欄位說明： * - 秒：0-59 * - 分：0-59 * - 時：0-23 * - 日：1-31 * - 月：1-12 或 JAN-DEC * - 週：0-7 或 SUN-SAT (0 和 7 都代表週日) * * 特殊字符： * * : 匹配任意值 * ? : 只能用在日和週，表示不指定值 * - : 表示範圍 (例如：1-5) * , : 表示列舉 (例如：1,3,5) * / : 表示增量 (例如：0/15 表示從 0 開始每 15 分鐘) * L : 表示最後 (例如：L 在日欄位表示該月最後一天) * W : 表示工作日 (例如：15W 表示距離 15 號最近的工作日) * # : 表示第幾個週幾 (例如：6#3 表示第三個週五) */ @Component public class CronExamples { @Scheduled(cron = \u0026#34;0 0 * * * *\u0026#34;) // 每小時整點執行 public void hourly() {} @Scheduled(cron = \u0026#34;*/10 * * * * *\u0026#34;) // 每 10 秒執行 public void every10Seconds() {} @Scheduled(cron = \u0026#34;0 0 8-18 * * *\u0026#34;) // 每天 8-18 點整點執行 public void businessHours() {} @Scheduled(cron = \u0026#34;0 0/30 8-18 * * *\u0026#34;) // 每天 8-18 點每半小時執行 public void businessHalfHour() {} @Scheduled(cron = \u0026#34;0 0 9-17 * * MON-FRI\u0026#34;) // 工作日 9-17 點整點執行 public void workingHours() {} @Scheduled(cron = \u0026#34;0 0 0 25 12 ?\u0026#34;) // 每年聖誕節 00:00 執行 public void christmas() {} @Scheduled(cron = \u0026#34;0 0 0 L * *\u0026#34;) // 每月最後一天 00:00 執行 public void lastDayOfMonth() {} @Scheduled(cron = \u0026#34;0 0 0 LW * *\u0026#34;) // 每月最後一個工作日 00:00 執行 public void lastWorkdayOfMonth() {} @Scheduled(cron = \u0026#34;0 0 0 * * 1#1\u0026#34;) // 每月第一個週一 00:00 執行 public void firstMondayOfMonth() {} } 2. 非同步處理註解 @Async 和 @EnableAsync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 @Configuration @EnableAsync public class AsyncConfig implements AsyncConfigurer { @Override @Bean(name = \u0026#34;taskExecutor\u0026#34;) public Executor getAsyncExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(5); executor.setMaxPoolSize(20); executor.setQueueCapacity(100); executor.setThreadNamePrefix(\u0026#34;async-task-\u0026#34;); executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); executor.initialize(); return executor; } @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() { return (ex, method, params) -\u0026gt; { log.error(\u0026#34;非同步方法 {} 執行異常\u0026#34;, method.getName(), ex); }; } } @Service @Slf4j public class NotificationService { // 簡單非同步方法 @Async public void sendEmail(String to, String subject, String content) { log.info(\u0026#34;發送郵件到 {}\u0026#34;, to); // 模擬郵件發送 try { Thread.sleep(2000); log.info(\u0026#34;郵件發送完成\u0026#34;); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } // 返回 CompletableFuture @Async public CompletableFuture\u0026lt;String\u0026gt; sendSms(String phone, String message) { log.info(\u0026#34;發送簡訊到 {}\u0026#34;, phone); try { Thread.sleep(1000); return CompletableFuture.completedFuture(\u0026#34;簡訊發送成功\u0026#34;); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return CompletableFuture.failedFuture(e); } } // 指定執行器 @Async(\u0026#34;taskExecutor\u0026#34;) public CompletableFuture\u0026lt;Boolean\u0026gt; processLargeFile(String filePath) { log.info(\u0026#34;開始處理大檔案：{}\u0026#34;, filePath); try { // 模擬檔案處理 Thread.sleep(5000); log.info(\u0026#34;檔案處理完成：{}\u0026#34;, filePath); return CompletableFuture.completedFuture(true); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return CompletableFuture.failedFuture(e); } } // 批量非同步處理 public CompletableFuture\u0026lt;Void\u0026gt; sendBulkNotifications(List\u0026lt;User\u0026gt; users, String message) { List\u0026lt;CompletableFuture\u0026lt;Void\u0026gt;\u0026gt; futures = users.stream() .map(user -\u0026gt; sendNotificationAsync(user, message)) .collect(Collectors.toList()); return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])); } @Async private CompletableFuture\u0026lt;Void\u0026gt; sendNotificationAsync(User user, String message) { // 發送通知邏輯 return CompletableFuture.completedFuture(null); } } Spring Boot 特定註解 1. 自動配置註解 @SpringBootApplication 分解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // @SpringBootApplication 等同於以下三個註解的組合： // @Configuration + @EnableAutoConfiguration + @ComponentScan @SpringBootApplication // 等同於： // @Configuration // @EnableAutoConfiguration // @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), // @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } // 自訂掃描配置 @SpringBootApplication( scanBasePackages = {\u0026#34;com.example.app\u0026#34;, \u0026#34;com.example.shared\u0026#34;}, exclude = {DataSourceAutoConfiguration.class} // 排除特定自動配置 ) public class CustomApplication { public static void main(String[] args) { SpringApplication.run(CustomApplication.class, args); } } 條件註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @Configuration public class ConditionalConfiguration { // 當類別存在時 @Bean @ConditionalOnClass(RedisTemplate.class) public RedisService redisService() { return new RedisService(); } // 當類別不存在時 @Bean @ConditionalOnMissingClass(\u0026#34;com.example.CustomService\u0026#34;) public DefaultService defaultService() { return new DefaultService(); } // 當 Bean 存在時 @Bean @ConditionalOnBean(DataSource.class) public JdbcTemplate jdbcTemplate(DataSource dataSource) { return new JdbcTemplate(dataSource); } // 當 Bean 不存在時 @Bean @ConditionalOnMissingBean(EmailService.class) public EmailService mockEmailService() { return new MockEmailService(); } // 當屬性存在且符合條件時 @Bean @ConditionalOnProperty(name = \u0026#34;app.cache.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;, matchIfMissing = false) public CacheManager cacheManager() { return new ConcurrentMapCacheManager(); } // 當 Web 應用程式時 @Bean @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) public WebMvcConfigurer webMvcConfigurer() { return new CustomWebMvcConfigurer(); } // 當非 Web 應用程式時 @Bean @ConditionalOnNotWebApplication public CommandLineRunner commandLineRunner() { return args -\u0026gt; System.out.println(\u0026#34;Non-web application started\u0026#34;); } // 當特定 Profile 啟用時 @Bean @Profile(\u0026#34;development\u0026#34;) public DataSource devDataSource() { return new H2DataSource(); } @Bean @Profile(\u0026#34;production\u0026#34;) public DataSource prodDataSource() { return new MySQLDataSource(); } // 自訂條件 @Bean @ConditionalOnCustomCondition public CustomService customService() { return new CustomService(); } } // 自訂條件實作 public class CustomCondition implements Condition { @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { // 自訂條件邏輯 String osName = context.getEnvironment().getProperty(\u0026#34;os.name\u0026#34;); return osName != null \u0026amp;\u0026amp; osName.toLowerCase().contains(\u0026#34;windows\u0026#34;); } } @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Conditional(CustomCondition.class) public @interface ConditionalOnCustomCondition { } 2. 配置屬性註解 @ConfigurationProperties 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @ConfigurationProperties(prefix = \u0026#34;app\u0026#34;) @Component @Validated @Data public class AppProperties { @NotBlank private String name; @NotBlank private String version; @Valid private Database database = new Database(); @Valid private Cache cache = new Cache(); private List\u0026lt;String\u0026gt; allowedOrigins = new ArrayList\u0026lt;\u0026gt;(); private Map\u0026lt;String, String\u0026gt; headers = new HashMap\u0026lt;\u0026gt;(); @Data public static class Database { @NotBlank private String url; @NotBlank private String username; @NotBlank private String password; @Min(1) @Max(100) private int maxConnections = 10; @DurationMin(seconds = 1) @DurationMax(minutes = 5) private Duration timeout = Duration.ofSeconds(30); } @Data public static class Cache { private boolean enabled = true; @Positive private int maxSize = 1000; @DurationMin(minutes = 1) private Duration ttl = Duration.ofMinutes(10); private CacheType type = CacheType.MEMORY; } public enum CacheType { MEMORY, REDIS, HAZELCAST } } // 使用配置 @Service @RequiredArgsConstructor public class AppService { private final AppProperties appProperties; public void printConfig() { System.out.println(\u0026#34;App Name: \u0026#34; + appProperties.getName()); System.out.println(\u0026#34;Database URL: \u0026#34; + appProperties.getDatabase().getUrl()); System.out.println(\u0026#34;Cache Enabled: \u0026#34; + appProperties.getCache().isEnabled()); } } 快取註解 @EnableCaching 和快取操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 @Configuration @EnableCaching public class CacheConfig { @Bean public CacheManager cacheManager() { ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager(); cacheManager.setAllowNullValues(false); return cacheManager; } } @Service @Slf4j public class UserService { @Autowired private UserRepository userRepository; // 快取結果 @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;) public User findById(Long id) { log.info(\u0026#34;從資料庫載入使用者：{}\u0026#34;, id); return userRepository.findById(id).orElse(null); } // 條件快取 @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#email\u0026#34;, condition = \u0026#34;#email.length() \u0026gt; 5\u0026#34;) public User findByEmail(String email) { return userRepository.findByEmail(email).orElse(null); } // 快取多個值 @Cacheable(value = \u0026#34;userProfiles\u0026#34;, key = \u0026#34;#user.id\u0026#34;, unless = \u0026#34;#result.isEmpty()\u0026#34;) public List\u0026lt;UserProfile\u0026gt; getUserProfiles(User user) { return userProfileRepository.findByUserId(user.getId()); } // 更新快取 @CachePut(value = \u0026#34;users\u0026#34;, key = \u0026#34;#user.id\u0026#34;) public User updateUser(User user) { log.info(\u0026#34;更新使用者並刷新快取：{}\u0026#34;, user.getId()); return userRepository.save(user); } // 清除快取 @CacheEvict(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;) public void deleteUser(Long id) { log.info(\u0026#34;刪除使用者並清除快取：{}\u0026#34;, id); userRepository.deleteById(id); } // 清除所有快取 @CacheEvict(value = \u0026#34;users\u0026#34;, allEntries = true) public void clearUserCache() { log.info(\u0026#34;清除所有使用者快取\u0026#34;); } // 組合快取操作 @Caching( cacheable = @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;), evict = @CacheEvict(value = \u0026#34;userStats\u0026#34;, key = \u0026#34;#id\u0026#34;) ) public User findAndUpdateStats(Long id) { User user = userRepository.findById(id).orElse(null); if (user != null) { updateUserStats(user); } return user; } // 自訂快取鍵生成器 @Cacheable(value = \u0026#34;userSearch\u0026#34;, keyGenerator = \u0026#34;customKeyGenerator\u0026#34;) public List\u0026lt;User\u0026gt; searchUsers(UserSearchCriteria criteria) { return userRepository.findByCriteria(criteria); } } @Component(\u0026#34;customKeyGenerator\u0026#34;) public class CustomKeyGenerator implements KeyGenerator { @Override public Object generate(Object target, Method method, Object... params) { return method.getName() + \u0026#34;_\u0026#34; + Arrays.toString(params); } } 測試註解 Spring Boot 測試註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 // 完整的 Spring Boot 測試 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @TestPropertySource(properties = { \u0026#34;spring.datasource.url=jdbc:h2:mem:testdb\u0026#34;, \u0026#34;spring.jpa.hibernate.ddl-auto=create-drop\u0026#34; }) class IntegrationTest { @Autowired private TestRestTemplate restTemplate; @Autowired private UserService userService; @Test void testCreateUser() { CreateUserRequest request = new CreateUserRequest(\u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.postForEntity(\u0026#34;/api/users\u0026#34;, request, User.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED); assertThat(response.getBody().getName()).isEqualTo(\u0026#34;John\u0026#34;); } } // Web 層測試 @WebMvcTest(UserController.class) class UserControllerTest { @Autowired private MockMvc mockMvc; @MockBean private UserService userService; @Test void testGetUser() throws Exception { User user = new User(1L, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); when(userService.findById(1L)).thenReturn(user); mockMvc.perform(get(\u0026#34;/api/users/1\u0026#34;)) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.name\u0026#34;).value(\u0026#34;John\u0026#34;)) .andExpect(jsonPath(\u0026#34;$.email\u0026#34;).value(\u0026#34;john@example.com\u0026#34;)); } } // 資料層測試 @DataJpaTest class UserRepositoryTest { @Autowired private TestEntityManager entityManager; @Autowired private UserRepository userRepository; @Test void testFindByEmail() { // Given User user = new User(\u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); entityManager.persistAndFlush(user); // When Optional\u0026lt;User\u0026gt; found = userRepository.findByEmail(\u0026#34;john@example.com\u0026#34;); // Then assertThat(found).isPresent(); assertThat(found.get().getName()).isEqualTo(\u0026#34;John\u0026#34;); } } // JSON 序列化測試 @JsonTest class UserJsonTest { @Autowired private JacksonTester\u0026lt;User\u0026gt; json; @Test void testSerialize() throws Exception { User user = new User(1L, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); assertThat(json.write(user)).isEqualToJson(\u0026#34;user.json\u0026#34;); assertThat(json.write(user)).hasJsonPathStringValue(\u0026#34;@.name\u0026#34;); assertThat(json.write(user)).extractingJsonPathStringValue(\u0026#34;@.name\u0026#34;).isEqualTo(\u0026#34;John\u0026#34;); } @Test void testDeserialize() throws Exception { String content = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34; } \u0026#34;\u0026#34;\u0026#34;; assertThat(json.parse(content)).usingRecursiveComparison() .isEqualTo(new User(1L, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;)); } } 事件處理註解 @EventListener 和 @TransactionalEventListener 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // 事件定義 public class OrderCreatedEvent { private final Order order; private final LocalDateTime timestamp; public OrderCreatedEvent(Order order) { this.order = order; this.timestamp = LocalDateTime.now(); } // getters... } // 事件發布 @Service @RequiredArgsConstructor public class OrderService { private final OrderRepository orderRepository; private final ApplicationEventPublisher eventPublisher; @Transactional public Order createOrder(CreateOrderRequest request) { Order order = new Order(request); order = orderRepository.save(order); // 發布事件 eventPublisher.publishEvent(new OrderCreatedEvent(order)); return order; } } // 事件監聽 @Component @Slf4j public class OrderEventListener { @Autowired private EmailService emailService; @Autowired private InventoryService inventoryService; // 基本事件監聽 @EventListener public void handleOrderCreated(OrderCreatedEvent event) { log.info(\u0026#34;訂單創建事件：{}\u0026#34;, event.getOrder().getId()); } // 條件事件監聽 @EventListener(condition = \u0026#34;#event.order.amount \u0026gt; 1000\u0026#34;) public void handleHighValueOrder(OrderCreatedEvent event) { log.info(\u0026#34;高價值訂單創建：{}\u0026#34;, event.getOrder().getId()); // 特殊處理邏輯 } // 非同步事件處理 @EventListener @Async public void sendOrderConfirmationEmail(OrderCreatedEvent event) { log.info(\u0026#34;發送訂單確認郵件：{}\u0026#34;, event.getOrder().getId()); emailService.sendOrderConfirmation(event.getOrder()); } // 交易事件監聽（在交易提交後執行） @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT) public void updateInventoryAfterOrderCreated(OrderCreatedEvent event) { log.info(\u0026#34;交易提交後更新庫存：{}\u0026#34;, event.getOrder().getId()); inventoryService.updateStock(event.getOrder().getItems()); } // 交易回滾時執行 @TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK) public void handleOrderCreationRollback(OrderCreatedEvent event) { log.warn(\u0026#34;訂單創建回滾：{}\u0026#34;, event.getOrder().getId()); // 回滾處理邏輯 } // 監聽多種事件類型 @EventListener({OrderCreatedEvent.class, OrderUpdatedEvent.class}) public void handleOrderEvents(Object event) { log.info(\u0026#34;處理訂單事件：{}\u0026#34;, event.getClass().getSimpleName()); } } 總結 Spring Framework 的註解系統為開發者提供了強大且靈活的配置方式。透過合理使用這些註解，可以大幅簡化配置工作並提升開發效率。\n最佳實踐建議 優先使用註解配置：相比 XML 配置，註解更直觀且易於維護 組合使用註解：善用 @SpringBootApplication 等組合註解 適當使用條件註解：根據環境動態配置 Bean 驗證配置屬性：使用 @Validated 確保配置正確性 合理使用快取：在適當的地方使用快取提升效能 測試覆蓋：使用專門的測試註解進行各層測試 事件驅動設計：使用事件機制降低組件耦合度 注意事項 註解過載：避免在單一類別或方法上使用過多註解 配置外部化：敏感配置應使用外部屬性檔案 效能考量：注意代理模式可能帶來的效能影響 測試友善：設計時考慮測試的便利性 掌握這些註解的正確使用方式，將能大幅提升 Spring 應用程式的開發效率和程式碼品質。\n參考資料 Spring Framework Reference Documentation Spring Boot Reference Guide Spring Data JPA Reference Bean Validation Specification Cron Expression Generator ","permalink":"https://xinqilin.github.io/post/backend/springannotation/","tags":["Java","Spring","Annotation","Spring-Boot","Configuration","Web","Data","Security"],"title":"Spring Framework 註解完整指南：從基礎到進階應用"},{"content":"概述 AWK 是一種強大的模式掃描和處理語言，由 Alfred Aho、Peter Weinberger 和 Brian Kernighan 於 1977 年在貝爾實驗室開發。AWK 特別適合處理結構化文本資料，能夠進行複雜的文本分析、報表生成和資料提取。\n核心特徵 模式-動作程式設計：基於模式匹配執行相應動作 自動欄位分割：自動將輸入行分割為欄位 強大的內建變數：提供豐富的環境資訊 數學運算能力：支援完整的算術和字串操作 正規表達式支援：強大的模式匹配功能 基本語法 1 2 3 awk \u0026#39;pattern { action }\u0026#39; file(s) awk -f script.awk file(s) command | awk \u0026#39;pattern { action }\u0026#39; AWK 程式結構 1 2 3 awk \u0026#39;BEGIN { 初始化動作 } pattern { 主要處理動作 } END { 結束動作 }\u0026#39; file 基本範例 1 2 3 4 5 6 7 8 9 10 11 # 列印整個檔案 awk \u0026#39;{print}\u0026#39; file.txt # 等同於 awk \u0026#39;{print $0}\u0026#39; file.txt # 列印特定欄位 awk \u0026#39;{print $1, $3}\u0026#39; file.txt # 列印第1和第3欄位 # 簡單過濾 awk \u0026#39;/pattern/ {print}\u0026#39; file.txt # 列印包含 pattern 的行 # 計算統計 awk \u0026#39;{sum += $1} END {print sum}\u0026#39; file.txt # 計算第1欄位總和 欄位和記錄 欄位處理 AWK 自動將每行輸入分割為欄位，預設分隔符為空白字元：\n1 2 3 4 5 6 7 8 9 10 11 # 欄位變數 $0 # 整行內容 $1 # 第1個欄位 $2 # 第2個欄位 $NF # 最後一個欄位 $(NF-1) # 倒數第2個欄位 # 實際範例 echo \u0026#34;apple banana cherry\u0026#34; | awk \u0026#39;{print $2}\u0026#39; # banana echo \u0026#34;1 2 3 4 5\u0026#34; | awk \u0026#39;{print $NF}\u0026#39; # 5 echo \u0026#34;a:b:c:d\u0026#34; | awk -F: \u0026#39;{print $3}\u0026#39; # c 自訂分隔符 1 2 3 4 5 6 7 8 # 使用 -F 選項 awk -F: \u0026#39;{print $1, $3}\u0026#39; /etc/passwd # 使用冒號作分隔符 awk -F\u0026#39;,\u0026#39; \u0026#39;{print $2}\u0026#39; data.csv # CSV 檔案處理 awk -F\u0026#39;[,:]\u0026#39; \u0026#39;{print $1, $3}\u0026#39; file.txt # 多個分隔符 # 在程式中設定 awk \u0026#39;BEGIN {FS=\u0026#34;,\u0026#34;} {print $1, $2}\u0026#39; data.csv # 在 BEGIN 中設定 awk \u0026#39;{FS=\u0026#34;,\u0026#34;} NR\u0026gt;1 {print $1, $2}\u0026#39; data.csv # 動態改變分隔符 輸出欄位分隔符 1 2 3 4 5 6 7 # 設定輸出分隔符 awk \u0026#39;BEGIN {OFS=\u0026#34;\\t\u0026#34;} {print $1, $2, $3}\u0026#39; file.txt # 使用 tab 分隔輸出 awk \u0026#39;BEGIN {OFS=\u0026#34; | \u0026#34;} {print $1, $2}\u0026#39; file.txt # 使用 \u0026#34; | \u0026#34; 分隔 # 重建行 awk \u0026#39;{$1=$1; print}\u0026#39; file.txt # 重新格式化空白 awk \u0026#39;BEGIN {OFS=\u0026#34;,\u0026#34;} {$1=$1; print}\u0026#39; file.txt # 轉換為 CSV 格式 內建變數 核心內建變數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 記錄相關 NR # 總記錄數（行號） FNR # 當前檔案的記錄數 NF # 當前記錄的欄位數 # 分隔符相關 FS # 輸入欄位分隔符 OFS # 輸出欄位分隔符 RS # 輸入記錄分隔符 ORS # 輸出記錄分隔符 # 檔案相關 FILENAME # 當前處理的檔案名 ARGC # 命令行參數個數 ARGV # 命令行參數陣列 實用範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 使用 NR 添加行號 awk \u0026#39;{print NR, $0}\u0026#39; file.txt # 使用 NF 檢查欄位數 awk \u0026#39;NF != 3 {print \u0026#34;Line \u0026#34; NR \u0026#34; has \u0026#34; NF \u0026#34; fields\u0026#34;}\u0026#39; file.txt # 處理多個檔案時使用 FNR awk \u0026#39;{print FILENAME, FNR, $0}\u0026#39; file1.txt file2.txt # 使用 ARGC 和 ARGV awk \u0026#39;BEGIN { print \u0026#34;Total arguments:\u0026#34;, ARGC for (i=0; i\u0026lt;ARGC; i++) print \u0026#34;ARGV[\u0026#34; i \u0026#34;]:\u0026#34;, ARGV[i] }\u0026#39; file1 file2 特殊變數 1 2 3 4 5 6 7 8 9 10 11 # 數字格式 OFMT # 數字輸出格式（預設 \u0026#34;%.6g\u0026#34;） CONVFMT # 字串轉換格式 # 模式匹配 RSTART # match() 函數匹配的起始位置 RLENGTH # match() 函數匹配的長度 # 其他 SUBSEP # 下標分隔符（用於多維陣列） ENVIRON # 環境變數陣列 模式匹配 基本模式 1 2 3 4 5 6 7 8 9 10 11 12 13 # 正規表達式模式 awk \u0026#39;/pattern/ {print}\u0026#39; file.txt # 匹配包含 pattern 的行 awk \u0026#39;/^[0-9]/ {print}\u0026#39; file.txt # 匹配以數字開頭的行 awk \u0026#39;/\\.txt$/ {print}\u0026#39; file.txt # 匹配以 .txt 結尾的行 # 關係表達式模式 awk \u0026#39;$1 \u0026gt; 100 {print}\u0026#39; file.txt # 第1欄位 \u0026gt; 100 awk \u0026#39;NF == 5 {print}\u0026#39; file.txt # 有5個欄位的行 awk \u0026#39;length($0) \u0026gt; 80 {print}\u0026#39; file.txt # 行長度 \u0026gt; 80 # 範圍模式 awk \u0026#39;/start/,/end/ {print}\u0026#39; file.txt # 從 start 到 end 的行 awk \u0026#39;NR==5,NR==10 {print}\u0026#39; file.txt # 第5到10行 進階模式 1 2 3 4 5 6 7 8 9 10 11 # 組合模式 awk \u0026#39;/error/ \u0026amp;\u0026amp; $3 \u0026gt; 100 {print}\u0026#39; file.txt # AND 條件 awk \u0026#39;/warn/ || /error/ {print}\u0026#39; file.txt # OR 條件 awk \u0026#39;!/debug/ {print}\u0026#39; file.txt # NOT 條件 # 欄位模式匹配 awk \u0026#39;$2 ~ /pattern/ {print}\u0026#39; file.txt # 第2欄位匹配 pattern awk \u0026#39;$1 !~ /^[0-9]/ {print}\u0026#39; file.txt # 第1欄位不以數字開頭 # 複雜條件 awk \u0026#39;$1==\u0026#34;ERROR\u0026#34; \u0026amp;\u0026amp; $3\u0026gt;threshold {count++} END {print count}\u0026#39; file.txt 動作和控制結構 基本動作 1 2 3 4 5 6 7 8 # 列印動作 awk \u0026#39;{print}\u0026#39; file.txt # 列印整行 awk \u0026#39;{print $1, $2}\u0026#39; file.txt # 列印特定欄位 awk \u0026#39;{printf \u0026#34;%s: %d\\n\u0026#34;, $1, $2}\u0026#39; file.txt # 格式化列印 # 賦值動作 awk \u0026#39;{$1=\u0026#34;NEW\u0026#34;; print}\u0026#39; file.txt # 修改欄位值 awk \u0026#39;{sum += $1} END {print sum}\u0026#39; file.txt # 累加計算 控制結構 if-else 語句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 基本 if 語句 awk \u0026#39;{ if ($1 \u0026gt; 100) print \u0026#34;Large:\u0026#34;, $0 else print \u0026#34;Small:\u0026#34;, $0 }\u0026#39; file.txt # 多重條件 awk \u0026#39;{ if ($1 \u0026gt;= 90) grade = \u0026#34;A\u0026#34; else if ($1 \u0026gt;= 80) grade = \u0026#34;B\u0026#34; else if ($1 \u0026gt;= 70) grade = \u0026#34;C\u0026#34; else grade = \u0026#34;F\u0026#34; print $0, grade }\u0026#39; scores.txt 迴圈結構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # for 迴圈 awk \u0026#39;{ for (i=1; i\u0026lt;=NF; i++) { print \u0026#34;Field \u0026#34; i \u0026#34;:\u0026#34;, $i } }\u0026#39; file.txt # while 迴圈 awk \u0026#39;{ i = 1 while (i \u0026lt;= NF) { print $i i++ } }\u0026#39; file.txt # for-in 迴圈（陣列） awk \u0026#39;{ for (i in array) { print i, array[i] } }\u0026#39; file.txt 函數應用 字串函數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # length() - 字串長度 awk \u0026#39;{print length($0)}\u0026#39; file.txt # 每行長度 awk \u0026#39;length($0) \u0026gt; 80\u0026#39; file.txt # 長度超過80的行 # substr() - 子字串 awk \u0026#39;{print substr($1, 1, 3)}\u0026#39; file.txt # 第1欄位前3個字元 awk \u0026#39;{print substr($0, 5)}\u0026#39; file.txt # 從第5個字元開始 # index() - 查找位置 awk \u0026#39;{print index($0, \u0026#34;pattern\u0026#34;)}\u0026#39; file.txt # pattern 的位置 # split() - 分割字串 awk \u0026#39;{n=split($0, array, \u0026#34;,\u0026#34;); print n}\u0026#39; file.txt # 用逗號分割 # gsub() 和 sub() - 替換 awk \u0026#39;{gsub(/old/, \u0026#34;new\u0026#34;); print}\u0026#39; file.txt # 全域替換 awk \u0026#39;{sub(/old/, \u0026#34;new\u0026#34;); print}\u0026#39; file.txt # 只替換第一個 # tolower() 和 toupper() - 大小寫轉換 awk \u0026#39;{print tolower($0)}\u0026#39; file.txt # 轉小寫 awk \u0026#39;{print toupper($1)}\u0026#39; file.txt # 第1欄位轉大寫 數學函數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 基本數學函數 awk \u0026#39;{print sqrt($1)}\u0026#39; file.txt # 平方根 awk \u0026#39;{print int($1)}\u0026#39; file.txt # 取整數 awk \u0026#39;{print sin($1), cos($1)}\u0026#39; file.txt # 三角函數 # 統計函數 awk \u0026#39;{ sum += $1 count++ } END { print \u0026#34;Average:\u0026#34;, sum/count print \u0026#34;Total:\u0026#34;, sum }\u0026#39; file.txt # 最大值和最小值 awk \u0026#39;{ if (NR==1 || $1 \u0026gt; max) max = $1 if (NR==1 || $1 \u0026lt; min) min = $1 } END { print \u0026#34;Max:\u0026#34;, max, \u0026#34;Min:\u0026#34;, min }\u0026#39; file.txt 自訂函數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 定義函數 awk \u0026#39; function factorial(n) { if (n \u0026lt;= 1) return 1 return n * factorial(n-1) } { print $1, factorial($1) }\u0026#39; file.txt # 字串處理函數 awk \u0026#39; function trim(str) { gsub(/^[ \\t]+|[ \\t]+$/, \u0026#34;\u0026#34;, str) return str } { print trim($0) }\u0026#39; file.txt 陣列應用 一維陣列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 基本陣列操作 awk \u0026#39;{ arr[NR] = $0 } END { for (i=1; i\u0026lt;=NR; i++) { print i, arr[i] } }\u0026#39; file.txt # 關聯陣列 awk \u0026#39;{ count[$1]++ } END { for (item in count) { print item, count[item] } }\u0026#39; file.txt # 陣列排序 awk \u0026#39;{ arr[NR] = $1 } END { n = asort(arr) # 排序值 for (i=1; i\u0026lt;=n; i++) { print arr[i] } }\u0026#39; file.txt 多維陣列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 使用 SUBSEP 分隔多維索引 awk \u0026#39;BEGIN {SUBSEP = \u0026#34;:\u0026#34;} { matrix[$1,$2] = $3 } END { for (key in matrix) { print key, matrix[key] } }\u0026#39; file.txt # 二維統計 awk \u0026#39;{ sales[$1][$2] += $3 } END { for (region in sales) { for (product in sales[region]) { print region, product, sales[region][product] } } }\u0026#39; sales_data.txt 實戰應用場景 1. 日誌分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 存取日誌分析 awk \u0026#39;{ # 統計狀態碼 status[$9]++ # 統計 IP 地址 ip[$1]++ # 計算總流量 if ($10 != \u0026#34;-\u0026#34;) bytes += $10 } END { print \u0026#34;=== Status Code Statistics ===\u0026#34; for (code in status) { print code, status[code] } print \u0026#34;\\n=== Top 10 IP Addresses ===\u0026#34; PROCINFO[\u0026#34;sorted_in\u0026#34;] = \u0026#34;@val_num_desc\u0026#34; n = 0 for (addr in ip) { if (++n \u0026lt;= 10) print addr, ip[addr] } print \u0026#34;\\nTotal Bytes:\u0026#34;, bytes }\u0026#39; access.log # 錯誤日誌監控 awk \u0026#39; BEGIN { print \u0026#34;Error Analysis Report\u0026#34; } /ERROR|FATAL/ { split($1, date, \u0026#34;-\u0026#34;) errors[date[1] \u0026#34;-\u0026#34; date[2]]++ error_details[NR] = $0 } END { print \u0026#34;Errors by Month:\u0026#34; for (month in errors) { print month, errors[month] } }\u0026#39; error.log 2. 資料處理和統計 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # CSV 資料分析 awk -F, \u0026#39; NR==1 { # 跳過標題行 next } { # 銷售資料統計 total_sales += $3 sales_by_region[$2] += $3 if ($3 \u0026gt; max_sale) { max_sale = $3 max_sale_record = $0 } } END { print \u0026#34;Total Sales: $\u0026#34; total_sales print \u0026#34;Average Sale: $\u0026#34; total_sales/(NR-1) print \u0026#34;Largest Sale: $\u0026#34; max_sale print \u0026#34;Record:\u0026#34;, max_sale_record print \u0026#34;\\nSales by Region:\u0026#34; for (region in sales_by_region) { print region \u0026#34;: $\u0026#34; sales_by_region[region] } }\u0026#39; sales.csv # 成績統計 awk \u0026#39;{ # 計算每個學生的平均分 sum = 0 for (i=2; i\u0026lt;=NF; i++) { sum += $i subject_total[i-1] += $i } avg = sum / (NF-1) print $1, avg if (avg \u0026gt;= 90) grade_count[\u0026#34;A\u0026#34;]++ else if (avg \u0026gt;= 80) grade_count[\u0026#34;B\u0026#34;]++ else if (avg \u0026gt;= 70) grade_count[\u0026#34;C\u0026#34;]++ else grade_count[\u0026#34;F\u0026#34;]++ student_count++ } END { print \u0026#34;\\nGrade Distribution:\u0026#34; for (grade in grade_count) { printf \u0026#34;%s: %d (%.1f%%)\\n\u0026#34;, grade, grade_count[grade], grade_count[grade]/student_count*100 } }\u0026#39; grades.txt 3. 系統監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 程序監控 ps aux | awk \u0026#39; NR\u0026gt;1 { # 跳過標題行 cpu[$11] += $3 # 依程式名稱累加 CPU 使用率 mem[$11] += $4 # 依程式名稱累加記憶體使用率 proc_count[$11]++ } END { print \u0026#34;Process Resource Usage:\u0026#34; printf \u0026#34;%-20s %s %s %s\\n\u0026#34;, \u0026#34;PROCESS\u0026#34;, \u0026#34;COUNT\u0026#34;, \u0026#34;CPU%\u0026#34;, \u0026#34;MEM%\u0026#34; for (proc in cpu) { printf \u0026#34;%-20s %5d %6.1f %6.1f\\n\u0026#34;, proc, proc_count[proc], cpu[proc], mem[proc] } }\u0026#39; # 磁碟使用分析 df -h | awk \u0026#39; NR\u0026gt;1 { # 解析使用百分比 gsub(/%/, \u0026#34;\u0026#34;, $5) usage = $5 if (usage \u0026gt;= 90) { critical[++crit_count] = $6 \u0026#34; (\u0026#34; usage \u0026#34;%)\u0026#34; } else if (usage \u0026gt;= 80) { warning[++warn_count] = $6 \u0026#34; (\u0026#34; usage \u0026#34;%)\u0026#34; } } END { if (crit_count \u0026gt; 0) { print \u0026#34;CRITICAL: High disk usage detected!\u0026#34; for (i=1; i\u0026lt;=crit_count; i++) { print \u0026#34; \u0026#34; critical[i] } } if (warn_count \u0026gt; 0) { print \u0026#34;WARNING: Moderate disk usage:\u0026#34; for (i=1; i\u0026lt;=warn_count; i++) { print \u0026#34; \u0026#34; warning[i] } } }\u0026#39; 4. 文件格式轉換 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # JSON 簡單生成 awk -F, \u0026#39; BEGIN { print \u0026#34;{\u0026#34; } NR\u0026gt;1 { printf \u0026#34; \\\u0026#34;%s\\\u0026#34;: {\\n\u0026#34;, $1 printf \u0026#34; \\\u0026#34;name\\\u0026#34;: \\\u0026#34;%s\\\u0026#34;,\\n\u0026#34;, $2 printf \u0026#34; \\\u0026#34;age\\\u0026#34;: %d,\\n\u0026#34;, $3 printf \u0026#34; \\\u0026#34;city\\\u0026#34;: \\\u0026#34;%s\\\u0026#34;\\n\u0026#34;, $4 printf \u0026#34; }%s\\n\u0026#34;, (NR\u0026lt;total_lines ? \u0026#34;,\u0026#34; : \u0026#34;\u0026#34;) } END { print \u0026#34;}\u0026#34; }\u0026#39; data.csv # HTML 表格生成 awk -F, \u0026#39; BEGIN { print \u0026#34;\u0026lt;table border=\\\u0026#34;1\\\u0026#34;\u0026gt;\u0026#34; } NR==1 { print \u0026#34;\u0026lt;tr\u0026gt;\u0026#34; for (i=1; i\u0026lt;=NF; i++) { print \u0026#34;\u0026lt;th\u0026gt;\u0026#34; $i \u0026#34;\u0026lt;/th\u0026gt;\u0026#34; } print \u0026#34;\u0026lt;/tr\u0026gt;\u0026#34; } NR\u0026gt;1 { print \u0026#34;\u0026lt;tr\u0026gt;\u0026#34; for (i=1; i\u0026lt;=NF; i++) { print \u0026#34;\u0026lt;td\u0026gt;\u0026#34; $i \u0026#34;\u0026lt;/td\u0026gt;\u0026#34; } print \u0026#34;\u0026lt;/tr\u0026gt;\u0026#34; } END { print \u0026#34;\u0026lt;/table\u0026gt;\u0026#34; }\u0026#39; data.csv # 配置檔轉換 awk \u0026#39; /^[^#]/ \u0026amp;\u0026amp; /=/ { split($0, pair, \u0026#34;=\u0026#34;) key = pair[1] value = pair[2] gsub(/^[ \\t]+|[ \\t]+$/, \u0026#34;\u0026#34;, key) # trim gsub(/^[ \\t]+|[ \\t]+$/, \u0026#34;\u0026#34;, value) print key \u0026#34;: \\\u0026#34;\u0026#34; value \u0026#34;\\\u0026#34;\u0026#34; }\u0026#39; config.ini 5. 報表生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 # 銷售報表 awk -F, \u0026#39; BEGIN { print \u0026#34;Sales Report\u0026#34; print \u0026#34;============\u0026#34; total = 0 } NR\u0026gt;1 { date = $1 product = $2 amount = $3 # 按日期統計 daily_sales[date] += amount # 按產品統計 product_sales[product] += amount total += amount } END { print \u0026#34;\\nDaily Sales:\u0026#34; PROCINFO[\u0026#34;sorted_in\u0026#34;] = \u0026#34;@ind_str_asc\u0026#34; for (date in daily_sales) { printf \u0026#34;%-12s: $%8.2f\\n\u0026#34;, date, daily_sales[date] } print \u0026#34;\\nProduct Sales:\u0026#34; PROCINFO[\u0026#34;sorted_in\u0026#34;] = \u0026#34;@val_num_desc\u0026#34; for (product in product_sales) { printf \u0026#34;%-15s: $%8.2f (%4.1f%%)\\n\u0026#34;, product, product_sales[product], product_sales[product]/total*100 } printf \u0026#34;\\nTotal Sales: $%.2f\\n\u0026#34;, total }\u0026#39; sales.csv # 網站流量報表 awk \u0026#39;{ # 解析日期時間 gsub(/\\[|\\]/, \u0026#34;\u0026#34;, $4) split($4, datetime, \u0026#34;:\u0026#34;) date = datetime[1] hour = datetime[2] # 統計 daily_hits[date]++ hourly_hits[hour]++ if ($9 == \u0026#34;404\u0026#34;) not_found++ if ($9 ~ /^[45]/) errors++ total_hits++ } END { print \u0026#34;Website Traffic Report\u0026#34; print \u0026#34;=====================\u0026#34; print \u0026#34;\\nDaily Traffic:\u0026#34; for (date in daily_hits) { printf \u0026#34;%s: %d hits\\n\u0026#34;, date, daily_hits[date] } print \u0026#34;\\nHourly Distribution:\u0026#34; for (h=0; h\u0026lt;24; h++) { printf \u0026#34;%02d:00: %d hits\\n\u0026#34;, h, hourly_hits[h] } printf \u0026#34;\\nError Summary:\\n\u0026#34; printf \u0026#34;404 Errors: %d (%.1f%%)\\n\u0026#34;, not_found, not_found/total_hits*100 printf \u0026#34;5xx Errors: %d (%.1f%%)\\n\u0026#34;, errors, errors/total_hits*100 }\u0026#39; access.log 進階技巧 1. 多檔案處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 比較兩個檔案 awk \u0026#39; FNR==NR { # 處理第一個檔案 file1[FNR] = $0 next } { # 處理第二個檔案 if (file1[FNR] != $0) { print \u0026#34;Line \u0026#34; FNR \u0026#34; differs:\u0026#34; print \u0026#34;File1: \u0026#34; file1[FNR] print \u0026#34;File2: \u0026#34; $0 } }\u0026#39; file1.txt file2.txt # 合併檔案資料 awk \u0026#39; FNR==NR { # 第一個檔案：建立索引 lookup[$1] = $2 next } { # 第二個檔案：查找並合併 if ($1 in lookup) { print $0, lookup[$1] } }\u0026#39; lookup.txt data.txt 2. 複雜文本解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # XML 簡單解析 awk \u0026#39; /\u0026lt;([^\u0026gt;]+)\u0026gt;([^\u0026lt;]*)\u0026lt;\\/\\1\u0026gt;/ { match($0, /\u0026lt;([^\u0026gt;]+)\u0026gt;([^\u0026lt;]*)\u0026lt;\\/\\1\u0026gt;/, arr) print \u0026#34;Tag:\u0026#34;, arr[1], \u0026#34;Content:\u0026#34;, arr[2] }\u0026#39; simple.xml # 配置檔解析 awk \u0026#39; /^\\[.*\\]$/ { # 區段標題 gsub(/\\[|\\]/, \u0026#34;\u0026#34;) section = $0 next } /^[^#].*=/ { # 鍵值對 split($0, kv, \u0026#34;=\u0026#34;) key = kv[1] value = kv[2] gsub(/^[ \\t]+|[ \\t]+$/, \u0026#34;\u0026#34;, key) gsub(/^[ \\t]+|[ \\t]+$/, \u0026#34;\u0026#34;, value) config[section][key] = value } END { for (sect in config) { print \u0026#34;[\u0026#34; sect \u0026#34;]\u0026#34; for (k in config[sect]) { print k \u0026#34; = \u0026#34; config[sect][k] } print \u0026#34;\u0026#34; } }\u0026#39; config.ini 3. 效能優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 避免重複計算 awk \u0026#39;{ # 好的做法：儲存計算結果 len = length($0) if (len \u0026gt; max_len) { max_len = len longest_line = $0 } }\u0026#39; file.txt # 使用陣列而非字串連接 awk \u0026#39;{ # 好的做法：使用陣列 lines[NR] = $0 } END { for (i=NR; i\u0026gt;=1; i--) { print lines[i] } }\u0026#39; file.txt # 提早退出 awk \u0026#39;{ if (found_count \u0026gt;= 10) exit if (/pattern/) { print found_count++ } }\u0026#39; large_file.txt 腳本檔案 建立 script.awk 檔案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #!/usr/bin/awk -f BEGIN { FS = \u0026#34;,\u0026#34; OFS = \u0026#34;\\t\u0026#34; print \u0026#34;Processing CSV file...\u0026#34; } # 跳過空行 /^$/ { next } # 處理標題行 NR == 1 { print \u0026#34;Headers:\u0026#34;, $0 next } # 主要處理邏輯 { # 資料驗證 if (NF != 4) { print \u0026#34;Warning: Line \u0026#34; NR \u0026#34; has \u0026#34; NF \u0026#34; fields\u0026#34; \u0026gt; \u0026#34;/dev/stderr\u0026#34; next } # 處理資料 name = $1 age = $2 salary = $3 department = $4 # 統計 total_salary += salary dept_count[department]++ employee_count++ # 輸出處理結果 print name, age, salary, department } END { print \u0026#34;\\n=== Summary ===\u0026#34; print \u0026#34;Total employees:\u0026#34;, employee_count print \u0026#34;Average salary:\u0026#34;, total_salary/employee_count print \u0026#34;\\nDepartment distribution:\u0026#34; for (dept in dept_count) { printf \u0026#34;%-15s: %d\\n\u0026#34;, dept, dept_count[dept] } } 使用腳本：\n1 2 3 4 chmod +x script.awk ./script.awk data.csv # 或 awk -f script.awk data.csv 常見錯誤與除錯 1. 常見錯誤 1 2 3 4 5 6 7 8 9 10 # 錯誤：字串比較使用數值運算子 awk \u0026#39;$1 \u0026gt; \u0026#34;50\u0026#34;\u0026#39; file.txt # 錯誤：字串比較 awk \u0026#39;$1 + 0 \u0026gt; 50\u0026#39; file.txt # 正確：強制數值比較 # 錯誤：陣列索引問題 awk \u0026#39;{arr[0] = $1}\u0026#39; file.txt # 注意：AWK 陣列從1開始習慣使用 # 錯誤：未初始化變數 awk \u0026#39;{sum += $1} END {print sum/count}\u0026#39; file.txt # count 未初始化 awk \u0026#39;{sum += $1; count++} END {print sum/count}\u0026#39; file.txt # 正確 2. 除錯技巧 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 添加除錯輸出 awk \u0026#39;{ print \u0026#34;Debug: NR=\u0026#34; NR \u0026#34;, NF=\u0026#34; NF \u0026#34;, $0=\u0026#34; $0 \u0026gt; \u0026#34;/dev/stderr\u0026#34; # 主要邏輯 }\u0026#39; file.txt # 使用條件除錯 awk \u0026#39;{ if (debug) print \u0026#34;Processing:\u0026#34;, $0 # 主要邏輯 }\u0026#39; debug=1 file.txt # 分步驗證 awk \u0026#39;{print \u0026#34;Line \u0026#34; NR \u0026#34;: \u0026#34; $1}\u0026#39; file.txt | head -5 與其他工具整合 1. 與 grep 和 sed 組合 1 2 3 4 5 # 過濾後處理 grep \u0026#34;ERROR\u0026#34; log.txt | awk \u0026#39;{print $1, $3}\u0026#39; # 多步處理 cat data.txt | grep -v \u0026#34;^#\u0026#34; | sed \u0026#39;s/,/ /g\u0026#39; | awk \u0026#39;{print $1, $2}\u0026#39; 2. 與 sort 組合 1 2 3 4 5 # 排序後統計 awk \u0026#39;{print $1}\u0026#39; file.txt | sort | uniq -c | awk \u0026#39;{print $2, $1}\u0026#39; # 管道處理 awk \u0026#39;{print $3, $0}\u0026#39; file.txt | sort -nr | awk \u0026#39;{$1=\u0026#34;\u0026#34;; print}\u0026#39; 3. 與資料庫整合 1 2 3 4 5 6 7 8 9 10 11 # 生成 SQL 插入語句 awk -F, \u0026#39; NR\u0026gt;1 { printf \u0026#34;INSERT INTO users (name, age, city) VALUES (\\\u0026#34;%s\\\u0026#34;, %d, \\\u0026#34;%s\\\u0026#34;);\\n\u0026#34;, $1, $2, $3 }\u0026#39; data.csv # 生成批次更新腳本 awk \u0026#39;{ print \u0026#34;UPDATE table SET status=1 WHERE id=\u0026#34; $1 \u0026#34;;\u0026#34; }\u0026#39; ids.txt 總結 核心優勢 強大的模式匹配：支援複雜的正規表達式 豐富的內建功能：字串處理、數學運算、陣列操作 高效的文本處理：適合大量資料處理 靈活的程式結構：支援完整的程式設計概念 最佳實踐 善用 BEGIN 和 END：初始化和清理工作 合理使用陣列：避免記憶體過度使用 模式化程式設計：將常用邏輯封裝為函數 輸入驗證：檢查資料格式和欄位數量 錯誤處理：適當的錯誤檢查和恢復機制 學習路徑 1 2 3 4 5 6 7 8 9 10 11 12 # 基礎階段 awk \u0026#39;{print $1}\u0026#39; file.txt # 欄位處理 awk \u0026#39;/pattern/ {print}\u0026#39; file.txt # 模式匹配 awk \u0026#39;{sum += $1} END {print sum}\u0026#39; file.txt # 基本統計 # 進階階段 awk -F, \u0026#39;{arr[$1] += $2} END {for(i in arr) print i, arr[i]}\u0026#39; file.csv # 陣列應用 awk \u0026#39;function f(x) {return x*x} {print f($1)}\u0026#39; file.txt # 自訂函數 # 專家階段 awk \u0026#39;/start/,/end/ {if(/important/) print}\u0026#39; file.txt # 複雜模式 awk \u0026#39;BEGIN{PROCINFO[\u0026#34;sorted_in\u0026#34;]=\u0026#34;@val_num_desc\u0026#34;} ...\u0026#39; # 高級特性 AWK 是文本處理和資料分析的強大工具，掌握其核心概念和常用技巧，能夠大幅提升資料處理的效率和準確性。記住：AWK 的核心在於模式-動作程式設計思維，善用這個特性能夠解決複雜的文本處理問題。\n參考資料 GAWK Manual The AWK Programming Language Advanced Bash-Scripting Guide POSIX AWK Specification ","permalink":"https://xinqilin.github.io/post/tools/awk/","tags":["Linux","AWK","Text Processing","Data Analysis","Pattern Scanning","Shell","Unix"],"title":"AWK 程式設計完整指南：Linux 文本處理與資料分析利器"},{"content":"概述 Java 8 引入了多個強大的 Map 計算方法，這些方法提供了原子性的讀取-計算-寫入操作，不僅簡化了程式碼，也提高了執行效率和執行緒安全性。本文將深入探討這些方法的使用場景、效能特性和最佳實踐。\n核心計算方法 putIfAbsent：條件式插入，僅在 Key 不存在時插入值 compute：基於 Key 和現有 Value 計算新值 computeIfAbsent：Key 不存在時執行計算並插入 computeIfPresent：Key 存在時執行計算並更新 merge：合併現有值與新值 優勢與特點 原子性操作：避免 Check-Then-Act 競態條件 效能優化：減少重複的查找操作 簡潔語法：使用 Lambda 表達式簡化程式碼 執行緒安全：與 ConcurrentHashMap 結合提供執行緒安全 基礎使用範例 1. 環境設定與初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.example.mapcompute; import java.util.*; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ThreadLocalRandom; import java.util.function.Function; import java.util.stream.Collectors; import java.util.stream.IntStream; public class MapComputeExample { public static void main(String[] args) { // 初始化測試資料 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;apple\u0026#34;, 5); map.put(\u0026#34;banana\u0026#34;, 10); map.put(\u0026#34;cherry\u0026#34;, 3); System.out.println(\u0026#34;初始 Map: \u0026#34; + map); demonstratePutIfAbsent(new HashMap\u0026lt;\u0026gt;(map)); demonstrateCompute(new HashMap\u0026lt;\u0026gt;(map)); demonstrateComputeIfAbsent(new HashMap\u0026lt;\u0026gt;(map)); demonstrateComputeIfPresent(new HashMap\u0026lt;\u0026gt;(map)); demonstrateMerge(new HashMap\u0026lt;\u0026gt;(map)); } } 方法一：putIfAbsent 1. 基礎用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * putIfAbsent: 僅在 Key 不存在時插入值 * 返回值：Key 存在時返回現有值，不存在時返回 null（插入後） */ public static void demonstratePutIfAbsent(Map\u0026lt;String, Integer\u0026gt; map) { System.out.println(\u0026#34;\\n=== putIfAbsent 示範 ===\u0026#34;); // Case 1: Key 已存在 - 不插入，返回現有值 Integer result1 = map.putIfAbsent(\u0026#34;apple\u0026#34;, 99); System.out.println(\u0026#34;putIfAbsent(\u0026#39;apple\u0026#39;, 99) 返回: \u0026#34; + result1); // 5 System.out.println(\u0026#34;map 內容: \u0026#34; + map); // apple 仍為 5 // Case 2: Key 不存在 - 插入新值，返回 null Integer result2 = map.putIfAbsent(\u0026#34;orange\u0026#34;, 8); System.out.println(\u0026#34;putIfAbsent(\u0026#39;orange\u0026#39;, 8) 返回: \u0026#34; + result2); // null System.out.println(\u0026#34;map 內容: \u0026#34; + map); // 新增了 orange=8 // Case 3: Value 為 null 的情況 map.put(\u0026#34;grape\u0026#34;, null); Integer result3 = map.putIfAbsent(\u0026#34;grape\u0026#34;, 15); System.out.println(\u0026#34;putIfAbsent(\u0026#39;grape\u0026#39;, 15) 返回: \u0026#34; + result3); // null System.out.println(\u0026#34;map 內容: \u0026#34; + map); // grape 被設為 15 } 2. 實際應用：快取初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /** * 快取初始化模式：確保每個 Key 只初始化一次 */ public class CacheInitializationExample { private final Map\u0026lt;String, ExpensiveObject\u0026gt; cache = new ConcurrentHashMap\u0026lt;\u0026gt;(); /** * 使用 putIfAbsent 實現執行緒安全的快取初始化 */ public ExpensiveObject getOrCreateObject(String key) { ExpensiveObject existing = cache.get(key); if (existing != null) { return existing; } // 創建昂貴對象 ExpensiveObject newObject = new ExpensiveObject(key); // 原子性插入，避免重複創建 ExpensiveObject result = cache.putIfAbsent(key, newObject); return result != null ? result : newObject; } /** * 更簡潔的寫法（但可能創建多餘物件） */ public ExpensiveObject getOrCreateObjectSimple(String key) { return cache.putIfAbsent(key, new ExpensiveObject(key)); } public static class ExpensiveObject { private final String id; private final long creationTime; public ExpensiveObject(String id) { this.id = id; this.creationTime = System.currentTimeMillis(); // 模擬昂貴的初始化過程 try { Thread.sleep(10); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } @Override public String toString() { return String.format(\u0026#34;ExpensiveObject{id=\u0026#39;%s\u0026#39;, created=%d}\u0026#34;, id, creationTime); } } } 方法二：compute 1. 基礎用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * compute: 無條件執行計算，可處理 Key 存在或不存在的情況 * 計算函數接收 (key, value) 參數，value 可能為 null */ public static void demonstrateCompute(Map\u0026lt;String, Integer\u0026gt; map) { System.out.println(\u0026#34;\\n=== compute 示範 ===\u0026#34;); // Case 1: Key 存在 - 基於現有值計算 Integer result1 = map.compute(\u0026#34;apple\u0026#34;, (key, value) -\u0026gt; value + 10); System.out.println(\u0026#34;compute(\u0026#39;apple\u0026#39;, v -\u0026gt; v + 10) 返回: \u0026#34; + result1); // 15 System.out.println(\u0026#34;map 內容: \u0026#34; + map); // Case 2: Key 不存在 - value 為 null Integer result2 = map.compute(\u0026#34;orange\u0026#34;, (key, value) -\u0026gt; { System.out.println(\u0026#34;計算 \u0026#34; + key + \u0026#34;, 當前值: \u0026#34; + value); return value == null ? 1 : value + 1; }); System.out.println(\u0026#34;compute(\u0026#39;orange\u0026#39;, ...) 返回: \u0026#34; + result2); // 1 // Case 3: 計算結果為 null - 移除該 Key Integer result3 = map.compute(\u0026#34;cherry\u0026#34;, (key, value) -\u0026gt; { return value \u0026lt; 5 ? null : value; // cherry=3 \u0026lt; 5，返回 null }); System.out.println(\u0026#34;compute(\u0026#39;cherry\u0026#39;, ...) 返回: \u0026#34; + result3); // null System.out.println(\u0026#34;map 內容: \u0026#34; + map); // cherry 被移除 } 2. 複雜計算範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 /** * 複雜計算應用：統計和聚合操作 */ public class ComputeAdvancedExample { /** * 實現計數器功能 */ public static Map\u0026lt;String, Integer\u0026gt; updateCounters(Map\u0026lt;String, Integer\u0026gt; counters, List\u0026lt;String\u0026gt; events) { for (String event : events) { counters.compute(event, (key, count) -\u0026gt; count == null ? 1 : count + 1); } return counters; } /** * 實現累加器功能 */ public static Map\u0026lt;String, Double\u0026gt; updateAccumulators(Map\u0026lt;String, Double\u0026gt; accumulators, Map\u0026lt;String, Double\u0026gt; newValues) { for (Map.Entry\u0026lt;String, Double\u0026gt; entry : newValues.entrySet()) { accumulators.compute(entry.getKey(), (key, current) -\u0026gt; { double newValue = entry.getValue(); return current == null ? newValue : current + newValue; }); } return accumulators; } /** * 條件式更新：基於複雜邏輯的值計算 */ public static Map\u0026lt;String, String\u0026gt; updateStatus(Map\u0026lt;String, String\u0026gt; statusMap, String key, String newStatus) { return Map.of(key, statusMap.compute(key, (k, currentStatus) -\u0026gt; { if (currentStatus == null) { return newStatus; } // 狀態轉換邏輯 switch (currentStatus) { case \u0026#34;PENDING\u0026#34;: return List.of(\u0026#34;PROCESSING\u0026#34;, \u0026#34;CANCELLED\u0026#34;).contains(newStatus) ? newStatus : currentStatus; case \u0026#34;PROCESSING\u0026#34;: return List.of(\u0026#34;COMPLETED\u0026#34;, \u0026#34;FAILED\u0026#34;).contains(newStatus) ? newStatus : currentStatus; default: return currentStatus; // 不允許從終態轉換 } })); } public static void main(String[] args) { // 測試計數器 Map\u0026lt;String, Integer\u0026gt; counters = new HashMap\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; events = Arrays.asList(\u0026#34;login\u0026#34;, \u0026#34;logout\u0026#34;, \u0026#34;login\u0026#34;, \u0026#34;error\u0026#34;, \u0026#34;login\u0026#34;); updateCounters(counters, events); System.out.println(\u0026#34;事件計數: \u0026#34; + counters); // 測試累加器 Map\u0026lt;String, Double\u0026gt; accumulators = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;String, Double\u0026gt; newValues = Map.of(\u0026#34;sales\u0026#34;, 100.5, \u0026#34;costs\u0026#34;, 75.2); updateAccumulators(accumulators, newValues); System.out.println(\u0026#34;累加結果: \u0026#34; + accumulators); } } 方法三：computeIfAbsent 1. 基礎用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * computeIfAbsent: 僅在 Key 不存在時執行計算 * 是 putIfAbsent 的計算版本，支援 Lambda 表達式 */ public static void demonstrateComputeIfAbsent(Map\u0026lt;String, Integer\u0026gt; map) { System.out.println(\u0026#34;\\n=== computeIfAbsent 示範 ===\u0026#34;); // Case 1: Key 存在 - 不執行計算，返回現有值 Integer result1 = map.computeIfAbsent(\u0026#34;apple\u0026#34;, key -\u0026gt; { System.out.println(\u0026#34;為 \u0026#34; + key + \u0026#34; 執行計算\u0026#34;); // 不會列印 return 999; }); System.out.println(\u0026#34;computeIfAbsent(\u0026#39;apple\u0026#39;, ...) 返回: \u0026#34; + result1); // 5 // Case 2: Key 不存在 - 執行計算並插入 Integer result2 = map.computeIfAbsent(\u0026#34;orange\u0026#34;, key -\u0026gt; { System.out.println(\u0026#34;為 \u0026#34; + key + \u0026#34; 執行計算\u0026#34;); // 會列印 return key.length() * 10; // 基於 key 計算值 }); System.out.println(\u0026#34;computeIfAbsent(\u0026#39;orange\u0026#39;, ...) 返回: \u0026#34; + result2); // 60 // Case 3: 計算結果為 null - 不插入 Integer result3 = map.computeIfAbsent(\u0026#34;grape\u0026#34;, key -\u0026gt; null); System.out.println(\u0026#34;computeIfAbsent(\u0026#39;grape\u0026#39;, -\u0026gt; null) 返回: \u0026#34; + result3); // null System.out.println(\u0026#34;map 內容: \u0026#34; + map); // grape 不會被插入 } 2. 實際應用：延遲初始化集合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 /** * 延遲初始化應用：動態創建集合和複雜對象 */ public class LazyInitializationExample { private final Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; groupMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final Map\u0026lt;String, Set\u0026lt;Integer\u0026gt;\u0026gt; categoryMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final Map\u0026lt;String, Map\u0026lt;String, Object\u0026gt;\u0026gt; configMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); /** * 延遲初始化 List 集合 */ public void addToGroup(String groupName, String item) { groupMap.computeIfAbsent(groupName, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(item); } /** * 延遲初始化 Set 集合 */ public void addToCategory(String category, Integer value) { categoryMap.computeIfAbsent(category, k -\u0026gt; new HashSet\u0026lt;\u0026gt;()).add(value); } /** * 延遲初始化巢狀 Map */ public void setConfig(String module, String key, Object value) { configMap.computeIfAbsent(module, k -\u0026gt; new ConcurrentHashMap\u0026lt;\u0026gt;()).put(key, value); } /** * 複雜對象的延遲初始化 */ private final Map\u0026lt;String, DatabaseConnection\u0026gt; connectionPool = new ConcurrentHashMap\u0026lt;\u0026gt;(); public DatabaseConnection getConnection(String database) { return connectionPool.computeIfAbsent(database, dbName -\u0026gt; { System.out.println(\u0026#34;創建新的資料庫連接: \u0026#34; + dbName); return new DatabaseConnection(dbName); }); } /** * 基於外部資源的延遲載入 */ private final Map\u0026lt;String, UserProfile\u0026gt; userCache = new ConcurrentHashMap\u0026lt;\u0026gt;(); public UserProfile getUserProfile(String userId) { return userCache.computeIfAbsent(userId, id -\u0026gt; { // 模擬從資料庫載入用戶資料 System.out.println(\u0026#34;從資料庫載入用戶: \u0026#34; + id); return loadUserFromDatabase(id); }); } // 輔助類別和方法 public static class DatabaseConnection { private final String database; private final long createdAt; public DatabaseConnection(String database) { this.database = database; this.createdAt = System.currentTimeMillis(); } @Override public String toString() { return String.format(\u0026#34;Connection{db=\u0026#39;%s\u0026#39;, created=%d}\u0026#34;, database, createdAt); } } public static class UserProfile { private final String userId; private final String name; public UserProfile(String userId, String name) { this.userId = userId; this.name = name; } @Override public String toString() { return String.format(\u0026#34;UserProfile{id=\u0026#39;%s\u0026#39;, name=\u0026#39;%s\u0026#39;}\u0026#34;, userId, name); } } private UserProfile loadUserFromDatabase(String userId) { // 模擬資料庫查詢延遲 try { Thread.sleep(50); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } return new UserProfile(userId, \u0026#34;User-\u0026#34; + userId); } public static void main(String[] args) { LazyInitializationExample example = new LazyInitializationExample(); // 測試群組管理 example.addToGroup(\u0026#34;admins\u0026#34;, \u0026#34;alice\u0026#34;); example.addToGroup(\u0026#34;admins\u0026#34;, \u0026#34;bob\u0026#34;); example.addToGroup(\u0026#34;users\u0026#34;, \u0026#34;charlie\u0026#34;); System.out.println(\u0026#34;群組: \u0026#34; + example.groupMap); // 測試連接池 DatabaseConnection conn1 = example.getConnection(\u0026#34;user_db\u0026#34;); DatabaseConnection conn2 = example.getConnection(\u0026#34;user_db\u0026#34;); // 同一個實例 System.out.println(\u0026#34;連接1: \u0026#34; + conn1); System.out.println(\u0026#34;連接2: \u0026#34; + conn2); System.out.println(\u0026#34;是否為同一個連接: \u0026#34; + (conn1 == conn2)); } } 方法四：computeIfPresent 1. 基礎用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * computeIfPresent: 僅在 Key 存在且值不為 null 時執行計算 */ public static void demonstrateComputeIfPresent(Map\u0026lt;String, Integer\u0026gt; map) { System.out.println(\u0026#34;\\n=== computeIfPresent 示範 ===\u0026#34;); // Case 1: Key 存在且值不為 null - 執行計算 Integer result1 = map.computeIfPresent(\u0026#34;apple\u0026#34;, (key, value) -\u0026gt; { System.out.println(\u0026#34;為 \u0026#34; + key + \u0026#34; 執行計算，當前值: \u0026#34; + value); return value * 2; }); System.out.println(\u0026#34;computeIfPresent(\u0026#39;apple\u0026#39;, v -\u0026gt; v * 2) 返回: \u0026#34; + result1); // 10 // Case 2: Key 不存在 - 不執行計算 Integer result2 = map.computeIfPresent(\u0026#34;orange\u0026#34;, (key, value) -\u0026gt; { System.out.println(\u0026#34;這行不會執行\u0026#34;); return 999; }); System.out.println(\u0026#34;computeIfPresent(\u0026#39;orange\u0026#39;, ...) 返回: \u0026#34; + result2); // null // Case 3: Key 存在但值為 null - 不執行計算 map.put(\u0026#34;grape\u0026#34;, null); Integer result3 = map.computeIfPresent(\u0026#34;grape\u0026#34;, (key, value) -\u0026gt; { System.out.println(\u0026#34;這行也不會執行\u0026#34;); return 123; }); System.out.println(\u0026#34;computeIfPresent(\u0026#39;grape\u0026#39;, ...) 返回: \u0026#34; + result3); // null // Case 4: 計算結果為 null - 移除該 Key Integer result4 = map.computeIfPresent(\u0026#34;banana\u0026#34;, (key, value) -\u0026gt; { return value \u0026gt; 15 ? null : value + 5; // banana=10 \u0026lt;= 15，返回 15 }); System.out.println(\u0026#34;computeIfPresent(\u0026#39;banana\u0026#39;, ...) 返回: \u0026#34; + result4); // 15 System.out.println(\u0026#34;map 內容: \u0026#34; + map); } 2. 實際應用：條件式更新 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 /** * 條件式更新應用：基於現有值的智能更新 */ public class ConditionalUpdateExample { /** * 分數系統：只更新有效分數 */ public static Map\u0026lt;String, Integer\u0026gt; updateScores(Map\u0026lt;String, Integer\u0026gt; scores, Map\u0026lt;String, Integer\u0026gt; scoreChanges) { for (Map.Entry\u0026lt;String, Integer\u0026gt; change : scoreChanges.entrySet()) { scores.computeIfPresent(change.getKey(), (player, currentScore) -\u0026gt; { int newScore = currentScore + change.getValue(); // 分數不能低於 0 return Math.max(0, newScore); }); } return scores; } /** * 庫存管理：只減少現有庫存 */ public static Map\u0026lt;String, Integer\u0026gt; reduceInventory(Map\u0026lt;String, Integer\u0026gt; inventory, Map\u0026lt;String, Integer\u0026gt; orders) { Map\u0026lt;String, Integer\u0026gt; processed = new HashMap\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;String, Integer\u0026gt; order : orders.entrySet()) { Integer newStock = inventory.computeIfPresent(order.getKey(), (item, stock) -\u0026gt; { int orderQuantity = order.getValue(); if (stock \u0026gt;= orderQuantity) { return stock - orderQuantity; } else { // 庫存不足，不處理訂單 return stock; } }); if (newStock != null) { int originalStock = newStock + order.getValue(); if (originalStock \u0026gt;= order.getValue()) { processed.put(order.getKey(), order.getValue()); } } } return processed; } /** * 過期資料清理：基於時間戳的條件更新 */ public static class TimestampCache { private final Map\u0026lt;String, Long\u0026gt; timestampMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final long TTL_MILLIS = 300_000; // 5 分鐘 public void touch(String key) { timestampMap.put(key, System.currentTimeMillis()); } public boolean isValid(String key) { return timestampMap.computeIfPresent(key, (k, timestamp) -\u0026gt; { long now = System.currentTimeMillis(); if (now - timestamp \u0026gt; TTL_MILLIS) { return null; // 過期，移除 } return timestamp; // 仍有效 }) != null; } public int cleanupExpired() { int removed = 0; long now = System.currentTimeMillis(); Iterator\u0026lt;Map.Entry\u0026lt;String, Long\u0026gt;\u0026gt; iterator = timestampMap.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry\u0026lt;String, Long\u0026gt; entry = iterator.next(); if (now - entry.getValue() \u0026gt; TTL_MILLIS) { iterator.remove(); removed++; } } return removed; } } public static void main(String[] args) { // 測試分數更新 Map\u0026lt;String, Integer\u0026gt; scores = new HashMap\u0026lt;\u0026gt;(); scores.put(\u0026#34;Alice\u0026#34;, 100); scores.put(\u0026#34;Bob\u0026#34;, 150); Map\u0026lt;String, Integer\u0026gt; changes = new HashMap\u0026lt;\u0026gt;(); changes.put(\u0026#34;Alice\u0026#34;, 50); // 有效玩家 changes.put(\u0026#34;Charlie\u0026#34;, 25); // 不存在的玩家 changes.put(\u0026#34;Bob\u0026#34;, -200); // 會觸發最小值限制 updateScores(scores, changes); System.out.println(\u0026#34;更新後分數: \u0026#34; + scores); // 測試時間戳快取 TimestampCache cache = new TimestampCache(); cache.touch(\u0026#34;session1\u0026#34;); System.out.println(\u0026#34;session1 是否有效: \u0026#34; + cache.isValid(\u0026#34;session1\u0026#34;)); try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } System.out.println(\u0026#34;session1 是否仍有效: \u0026#34; + cache.isValid(\u0026#34;session1\u0026#34;)); } } 方法五：merge 1. 基礎用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** * merge: 合併現有值與新值 * 如果 Key 不存在或值為 null，直接使用新值 * 如果 Key 存在且值不為 null，使用合併函數計算結果 */ public static void demonstrateMerge(Map\u0026lt;String, Integer\u0026gt; map) { System.out.println(\u0026#34;\\n=== merge 示範 ===\u0026#34;); // Case 1: Key 存在 - 執行合併操作 Integer result1 = map.merge(\u0026#34;apple\u0026#34;, 20, (oldValue, newValue) -\u0026gt; { System.out.println(\u0026#34;合併 apple: \u0026#34; + oldValue + \u0026#34; + \u0026#34; + newValue); return oldValue + newValue; }); System.out.println(\u0026#34;merge(\u0026#39;apple\u0026#39;, 20, sum) 返回: \u0026#34; + result1); // 25 // Case 2: Key 不存在 - 直接使用新值 Integer result2 = map.merge(\u0026#34;orange\u0026#34;, 15, (oldValue, newValue) -\u0026gt; { System.out.println(\u0026#34;這行不會執行，因為 orange 不存在\u0026#34;); return oldValue + newValue; }); System.out.println(\u0026#34;merge(\u0026#39;orange\u0026#39;, 15, sum) 返回: \u0026#34; + result2); // 15 // Case 3: 合併結果為 null - 移除該 Key Integer result3 = map.merge(\u0026#34;banana\u0026#34;, 5, (oldValue, newValue) -\u0026gt; { return oldValue == newValue ? null : oldValue + newValue; }); System.out.println(\u0026#34;merge(\u0026#39;banana\u0026#39;, 5, ...) 返回: \u0026#34; + result3); // null（banana=10 != 5） System.out.println(\u0026#34;map 內容: \u0026#34; + map); // Case 4: 值為 null 的情況 map.put(\u0026#34;grape\u0026#34;, null); Integer result4 = map.merge(\u0026#34;grape\u0026#34;, 30, Integer::sum); System.out.println(\u0026#34;merge(\u0026#39;grape\u0026#39;, 30, sum) 返回: \u0026#34; + result4); // 30 } 2. 高級合併應用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 /** * 高級合併應用：資料聚合和統計分析 */ public class AdvancedMergeExample { /** * 統計資料合併：累加計數器 */ public static Map\u0026lt;String, Integer\u0026gt; mergeCounters(List\u0026lt;Map\u0026lt;String, Integer\u0026gt;\u0026gt; counterMaps) { Map\u0026lt;String, Integer\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); for (Map\u0026lt;String, Integer\u0026gt; counterMap : counterMaps) { for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : counterMap.entrySet()) { result.merge(entry.getKey(), entry.getValue(), Integer::sum); } } return result; } /** * 字串合併：拼接文字 */ public static Map\u0026lt;String, String\u0026gt; mergeMessages(Map\u0026lt;String, String\u0026gt; base, Map\u0026lt;String, String\u0026gt; additional) { Map\u0026lt;String, String\u0026gt; result = new HashMap\u0026lt;\u0026gt;(base); for (Map.Entry\u0026lt;String, String\u0026gt; entry : additional.entrySet()) { result.merge(entry.getKey(), entry.getValue(), (old, new_) -\u0026gt; old + \u0026#34;; \u0026#34; + new_); } return result; } /** * 複雜對象合併：銷售資料聚合 */ public static class SalesData { private double revenue; private int quantity; public SalesData(double revenue, int quantity) { this.revenue = revenue; this.quantity = quantity; } public SalesData merge(SalesData other) { return new SalesData(this.revenue + other.revenue, this.quantity + other.quantity); } public double getAveragePrice() { return quantity \u0026gt; 0 ? revenue / quantity : 0; } @Override public String toString() { return String.format(\u0026#34;SalesData{revenue=%.2f, quantity=%d, avgPrice=%.2f}\u0026#34;, revenue, quantity, getAveragePrice()); } // getter 和 setter public double getRevenue() { return revenue; } public int getQuantity() { return quantity; } } public static Map\u0026lt;String, SalesData\u0026gt; mergeSalesData(List\u0026lt;Map\u0026lt;String, SalesData\u0026gt;\u0026gt; salesMaps) { Map\u0026lt;String, SalesData\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); for (Map\u0026lt;String, SalesData\u0026gt; salesMap : salesMaps) { for (Map.Entry\u0026lt;String, SalesData\u0026gt; entry : salesMap.entrySet()) { result.merge(entry.getKey(), entry.getValue(), SalesData::merge); } } return result; } /** * 集合合併：Set 和 List 的合併操作 */ public static Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; mergeSets(Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; map1, Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; map2) { Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); // 複製第一個 map for (Map.Entry\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; entry : map1.entrySet()) { result.put(entry.getKey(), new HashSet\u0026lt;\u0026gt;(entry.getValue())); } // 合併第二個 map for (Map.Entry\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; entry : map2.entrySet()) { result.merge(entry.getKey(), entry.getValue(), (set1, set2) -\u0026gt; { Set\u0026lt;String\u0026gt; merged = new HashSet\u0026lt;\u0026gt;(set1); merged.addAll(set2); return merged; }); } return result; } public static void main(String[] args) { // 測試計數器合併 List\u0026lt;Map\u0026lt;String, Integer\u0026gt;\u0026gt; counters = Arrays.asList( Map.of(\u0026#34;A\u0026#34;, 10, \u0026#34;B\u0026#34;, 20), Map.of(\u0026#34;A\u0026#34;, 5, \u0026#34;C\u0026#34;, 15), Map.of(\u0026#34;B\u0026#34;, 8, \u0026#34;C\u0026#34;, 12) ); Map\u0026lt;String, Integer\u0026gt; mergedCounters = mergeCounters(counters); System.out.println(\u0026#34;合併後計數器: \u0026#34; + mergedCounters); // 測試銷售資料合併 List\u0026lt;Map\u0026lt;String, SalesData\u0026gt;\u0026gt; salesList = Arrays.asList( Map.of(\u0026#34;Product1\u0026#34;, new SalesData(1000.0, 10)), Map.of(\u0026#34;Product1\u0026#34;, new SalesData(500.0, 5), \u0026#34;Product2\u0026#34;, new SalesData(800.0, 8)) ); Map\u0026lt;String, SalesData\u0026gt; mergedSales = mergeSalesData(salesList); System.out.println(\u0026#34;合併後銷售資料:\u0026#34;); mergedSales.forEach((product, data) -\u0026gt; System.out.println(\u0026#34; \u0026#34; + product + \u0026#34;: \u0026#34; + data)); } } 執行緒安全與 ConcurrentHashMap 1. 原子操作的重要性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 /** * 執行緒安全的計算操作 */ public class ThreadSafeComputeExample { private final ConcurrentHashMap\u0026lt;String, Integer\u0026gt; concurrentCounters = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final Map\u0026lt;String, Integer\u0026gt; unsafeCounters = new HashMap\u0026lt;\u0026gt;(); /** * 執行緒安全的計數器增量 */ public void incrementCounterSafe(String key) { concurrentCounters.compute(key, (k, v) -\u0026gt; v == null ? 1 : v + 1); } /** * 非執行緒安全的計數器增量（可能導致資料競爭） */ public synchronized void incrementCounterUnsafe(String key) { Integer current = unsafeCounters.get(key); unsafeCounters.put(key, current == null ? 1 : current + 1); } /** * 並發測試 */ public static void testConcurrency() throws InterruptedException { ThreadSafeComputeExample example = new ThreadSafeComputeExample(); int threadCount = 10; int incrementsPerThread = 1000; String testKey = \u0026#34;counter\u0026#34;; // 測試執行緒安全版本 Thread[] safeThreads = new Thread[threadCount]; for (int i = 0; i \u0026lt; threadCount; i++) { safeThreads[i] = new Thread(() -\u0026gt; { for (int j = 0; j \u0026lt; incrementsPerThread; j++) { example.incrementCounterSafe(testKey); } }); } long startTime = System.currentTimeMillis(); for (Thread thread : safeThreads) { thread.start(); } for (Thread thread : safeThreads) { thread.join(); } long safeTime = System.currentTimeMillis() - startTime; Integer safeResult = example.concurrentCounters.get(testKey); System.out.printf(\u0026#34;執行緒安全版本: 期望=%d, 實際=%d, 耗時=%dms\\n\u0026#34;, threadCount * incrementsPerThread, safeResult, safeTime); // 測試非執行緒安全版本 Thread[] unsafeThreads = new Thread[threadCount]; for (int i = 0; i \u0026lt; threadCount; i++) { unsafeThreads[i] = new Thread(() -\u0026gt; { for (int j = 0; j \u0026lt; incrementsPerThread; j++) { example.incrementCounterUnsafe(testKey); } }); } startTime = System.currentTimeMillis(); for (Thread thread : unsafeThreads) { thread.start(); } for (Thread thread : unsafeThreads) { thread.join(); } long unsafeTime = System.currentTimeMillis() - startTime; Integer unsafeResult = example.unsafeCounters.get(testKey); System.out.printf(\u0026#34;非執行緒安全版本: 期望=%d, 實際=%d, 耗時=%dms\\n\u0026#34;, threadCount * incrementsPerThread, unsafeResult, unsafeTime); } public static void main(String[] args) throws InterruptedException { testConcurrency(); } } 2. 高效能並發應用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 /** * 高效能並發統計系統 */ public class HighPerformanceStats { private final ConcurrentHashMap\u0026lt;String, Long\u0026gt; metrics = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final ConcurrentHashMap\u0026lt;String, Double\u0026gt; averages = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final ConcurrentHashMap\u0026lt;String, Integer\u0026gt; counts = new ConcurrentHashMap\u0026lt;\u0026gt;(); /** * 記錄指標值並更新平均值 */ public void recordMetric(String metricName, double value) { // 原子性更新計數 counts.compute(metricName, (k, v) -\u0026gt; v == null ? 1 : v + 1); // 原子性更新平均值 averages.compute(metricName, (k, currentAvg) -\u0026gt; { if (currentAvg == null) { return value; } int count = counts.get(metricName); return ((currentAvg * (count - 1)) + value) / count; }); } /** * 批量更新指標 */ public void recordBatch(Map\u0026lt;String, Double\u0026gt; batchMetrics) { batchMetrics.forEach(this::recordMetric); } /** * 獲取統計摘要 */ public Map\u0026lt;String, String\u0026gt; getStatsSummary() { Map\u0026lt;String, String\u0026gt; summary = new HashMap\u0026lt;\u0026gt;(); averages.forEach((metric, avg) -\u0026gt; { int count = counts.getOrDefault(metric, 0); summary.put(metric, String.format(\u0026#34;avg=%.2f, count=%d\u0026#34;, avg, count)); }); return summary; } /** * 重置特定指標 */ public void resetMetric(String metricName) { averages.remove(metricName); counts.remove(metricName); } /** * 條件式重置：僅重置低活躍度指標 */ public int cleanupLowActivityMetrics(int minCount) { int removed = 0; for (String metric : new HashSet\u0026lt;\u0026gt;(counts.keySet())) { Integer count = counts.computeIfPresent(metric, (k, v) -\u0026gt; v \u0026gt;= minCount ? v : null); if (count == null) { averages.remove(metric); removed++; } } return removed; } } 效能分析與優化 1. 效能比較測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 /** * Map 計算方法的效能比較 */ public class PerformanceComparison { private static final int OPERATIONS = 1_000_000; private static final String[] KEYS = IntStream.range(0, 1000) .mapToObj(i -\u0026gt; \u0026#34;key\u0026#34; + i) .toArray(String[]::new); /** * 傳統方式：檢查-計算-更新 */ public static long testTraditionalApproach() { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Random random = new Random(42); long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; OPERATIONS; i++) { String key = KEYS[random.nextInt(KEYS.length)]; Integer current = map.get(key); if (current == null) { map.put(key, 1); } else { map.put(key, current + 1); } } return System.nanoTime() - startTime; } /** * 使用 compute 方法 */ public static long testComputeApproach() { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Random random = new Random(42); long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; OPERATIONS; i++) { String key = KEYS[random.nextInt(KEYS.length)]; map.compute(key, (k, v) -\u0026gt; v == null ? 1 : v + 1); } return System.nanoTime() - startTime; } /** * 使用 merge 方法 */ public static long testMergeApproach() { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Random random = new Random(42); long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; OPERATIONS; i++) { String key = KEYS[random.nextInt(KEYS.length)]; map.merge(key, 1, Integer::sum); } return System.nanoTime() - startTime; } /** * 使用 computeIfAbsent + computeIfPresent 組合 */ public static long testComputeIfApproach() { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Random random = new Random(42); long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; OPERATIONS; i++) { String key = KEYS[random.nextInt(KEYS.length)]; if (map.computeIfAbsent(key, k -\u0026gt; 0) != null) { map.computeIfPresent(key, (k, v) -\u0026gt; v + 1); } } return System.nanoTime() - startTime; } public static void main(String[] args) { System.out.println(\u0026#34;Map 計算方法效能比較 (\u0026#34; + OPERATIONS + \u0026#34; 操作)\u0026#34;); System.out.println(\u0026#34;================================================\u0026#34;); // 預熱 JVM for (int i = 0; i \u0026lt; 5; i++) { testTraditionalApproach(); testComputeApproach(); testMergeApproach(); testComputeIfApproach(); } // 正式測試 long traditional = testTraditionalApproach(); long compute = testComputeApproach(); long merge = testMergeApproach(); long computeIf = testComputeIfApproach(); System.out.printf(\u0026#34;傳統方式: %8.2f ms\\n\u0026#34;, traditional / 1_000_000.0); System.out.printf(\u0026#34;compute 方法: %8.2f ms\\n\u0026#34;, compute / 1_000_000.0); System.out.printf(\u0026#34;merge 方法: %8.2f ms\\n\u0026#34;, merge / 1_000_000.0); System.out.printf(\u0026#34;computeIf 組合: %8.2f ms\\n\u0026#34;, computeIf / 1_000_000.0); System.out.println(\u0026#34;\\n相對效能 (以傳統方式為基準):\u0026#34;); System.out.printf(\u0026#34;compute 方法: %.2fx\\n\u0026#34;, (double) traditional / compute); System.out.printf(\u0026#34;merge 方法: %.2fx\\n\u0026#34;, (double) traditional / merge); System.out.printf(\u0026#34;computeIf 組合: %.2fx\\n\u0026#34;, (double) traditional / computeIf); } } 2. 記憶體使用分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 /** * 記憶體使用分析工具 */ public class MemoryAnalysis { /** * 分析不同實作方式的記憶體使用 */ public static void analyzeMemoryUsage() { Runtime runtime = Runtime.getRuntime(); // 測試資料大小 int dataSize = 100_000; System.out.println(\u0026#34;記憶體使用分析 (資料大小: \u0026#34; + dataSize + \u0026#34;)\u0026#34;); System.out.println(\u0026#34;=========================================\u0026#34;); // 測試 HashMap + compute System.gc(); long beforeHashMap = runtime.totalMemory() - runtime.freeMemory(); Map\u0026lt;String, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; dataSize; i++) { hashMap.compute(\u0026#34;key\u0026#34; + (i % 1000), (k, v) -\u0026gt; v == null ? 1 : v + 1); } long afterHashMap = runtime.totalMemory() - runtime.freeMemory(); long hashMapMemory = afterHashMap - beforeHashMap; // 測試 ConcurrentHashMap + compute System.gc(); long beforeConcurrent = runtime.totalMemory() - runtime.freeMemory(); ConcurrentHashMap\u0026lt;String, Integer\u0026gt; concurrentMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; dataSize; i++) { concurrentMap.compute(\u0026#34;key\u0026#34; + (i % 1000), (k, v) -\u0026gt; v == null ? 1 : v + 1); } long afterConcurrent = runtime.totalMemory() - runtime.freeMemory(); long concurrentMemory = afterConcurrent - beforeConcurrent; System.out.printf(\u0026#34;HashMap 記憶體使用: %.2f MB\\n\u0026#34;, hashMapMemory / (1024.0 * 1024.0)); System.out.printf(\u0026#34;ConcurrentHashMap 記憶體使用: %.2f MB\\n\u0026#34;, concurrentMemory / (1024.0 * 1024.0)); System.out.printf(\u0026#34;記憶體使用比例: %.2fx\\n\u0026#34;, (double) concurrentMemory / hashMapMemory); // 保持引用避免被垃圾回收 System.out.println(\u0026#34;HashMap 大小: \u0026#34; + hashMap.size()); System.out.println(\u0026#34;ConcurrentHashMap 大小: \u0026#34; + concurrentMap.size()); } public static void main(String[] args) { analyzeMemoryUsage(); } } 實際應用案例 1. 網站訪問統計系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 /** * 網站訪問統計系統 */ public class WebTrafficAnalyzer { private final ConcurrentHashMap\u0026lt;String, Long\u0026gt; pageViews = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final ConcurrentHashMap\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; uniqueVisitors = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final ConcurrentHashMap\u0026lt;String, Long\u0026gt; totalBandwidth = new ConcurrentHashMap\u0026lt;\u0026gt;(); /** * 記錄頁面訪問 */ public void recordPageView(String page, String visitorId, long bandwidthBytes) { // 增加頁面瀏覽量 pageViews.merge(page, 1L, Long::sum); // 記錄唯一訪客 uniqueVisitors.computeIfAbsent(page, k -\u0026gt; ConcurrentHashMap.newKeySet()).add(visitorId); // 累加頻寬使用 totalBandwidth.merge(page, bandwidthBytes, Long::sum); } /** * 獲取頁面統計報告 */ public Map\u0026lt;String, PageStats\u0026gt; getPageStats() { Map\u0026lt;String, PageStats\u0026gt; stats = new HashMap\u0026lt;\u0026gt;(); for (String page : pageViews.keySet()) { long views = pageViews.getOrDefault(page, 0L); int uniqueCount = uniqueVisitors.getOrDefault(page, Collections.emptySet()).size(); long bandwidth = totalBandwidth.getOrDefault(page, 0L); stats.put(page, new PageStats(views, uniqueCount, bandwidth)); } return stats; } /** * 清理低活躍度頁面數據 */ public int cleanupLowActivityPages(long minViews) { int removed = 0; Iterator\u0026lt;Map.Entry\u0026lt;String, Long\u0026gt;\u0026gt; iterator = pageViews.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry\u0026lt;String, Long\u0026gt; entry = iterator.next(); if (entry.getValue() \u0026lt; minViews) { String page = entry.getKey(); iterator.remove(); uniqueVisitors.remove(page); totalBandwidth.remove(page); removed++; } } return removed; } public static class PageStats { private final long pageViews; private final int uniqueVisitors; private final long totalBandwidth; public PageStats(long pageViews, int uniqueVisitors, long totalBandwidth) { this.pageViews = pageViews; this.uniqueVisitors = uniqueVisitors; this.totalBandwidth = totalBandwidth; } public double getAverageBandwidthPerView() { return pageViews \u0026gt; 0 ? (double) totalBandwidth / pageViews : 0; } @Override public String toString() { return String.format(\u0026#34;PageStats{views=%d, unique=%d, bandwidth=%d bytes, avg=%.2f bytes/view}\u0026#34;, pageViews, uniqueVisitors, totalBandwidth, getAverageBandwidthPerView()); } // getter 方法 public long getPageViews() { return pageViews; } public int getUniqueVisitors() { return uniqueVisitors; } public long getTotalBandwidth() { return totalBandwidth; } } } 2. 分散式快取管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 /** * 分散式快取管理系統 */ public class DistributedCacheManager { private final ConcurrentHashMap\u0026lt;String, CacheEntry\u0026gt; cache = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final long defaultTTL = 300_000; // 5 分鐘預設 TTL /** * 放入快取項目 */ public void put(String key, Object value, long ttlMillis) { long expireTime = System.currentTimeMillis() + ttlMillis; cache.put(key, new CacheEntry(value, expireTime)); } public void put(String key, Object value) { put(key, value, defaultTTL); } /** * 獲取快取項目（自動清理過期項目） */ public Object get(String key) { return cache.computeIfPresent(key, (k, entry) -\u0026gt; { if (entry.isExpired()) { return null; // 過期，移除 } entry.updateAccessTime(); return entry; })?.getValue(); } /** * 條件式更新：僅在值存在且未過期時更新 */ public boolean updateIfPresent(String key, Function\u0026lt;Object, Object\u0026gt; updater) { CacheEntry updated = cache.computeIfPresent(key, (k, entry) -\u0026gt; { if (entry.isExpired()) { return null; // 過期，移除 } Object newValue = updater.apply(entry.getValue()); return new CacheEntry(newValue, entry.getExpireTime()); }); return updated != null; } /** * 獲取或計算值（延遲載入模式） */ public Object getOrCompute(String key, Function\u0026lt;String, Object\u0026gt; valueComputer, long ttlMillis) { return cache.compute(key, (k, entry) -\u0026gt; { if (entry != null \u0026amp;\u0026amp; !entry.isExpired()) { entry.updateAccessTime(); return entry; } // 快取未命中或已過期，重新計算 Object newValue = valueComputer.apply(key); long expireTime = System.currentTimeMillis() + ttlMillis; return new CacheEntry(newValue, expireTime); }).getValue(); } /** * 批量清理過期項目 */ public int cleanupExpired() { int removed = 0; long now = System.currentTimeMillis(); Iterator\u0026lt;Map.Entry\u0026lt;String, CacheEntry\u0026gt;\u0026gt; iterator = cache.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry\u0026lt;String, CacheEntry\u0026gt; entry = iterator.next(); if (entry.getValue().getExpireTime() \u0026lt;= now) { iterator.remove(); removed++; } } return removed; } /** * 獲取快取統計資訊 */ public CacheStats getStats() { long now = System.currentTimeMillis(); int totalEntries = cache.size(); int expiredEntries = 0; long totalSize = 0; for (CacheEntry entry : cache.values()) { if (entry.getExpireTime() \u0026lt;= now) { expiredEntries++; } totalSize += entry.getEstimatedSize(); } return new CacheStats(totalEntries, expiredEntries, totalSize); } /** * 快取項目類別 */ public static class CacheEntry { private final Object value; private final long expireTime; private volatile long lastAccessTime; public CacheEntry(Object value, long expireTime) { this.value = value; this.expireTime = expireTime; this.lastAccessTime = System.currentTimeMillis(); } public boolean isExpired() { return System.currentTimeMillis() \u0026gt; expireTime; } public void updateAccessTime() { this.lastAccessTime = System.currentTimeMillis(); } public long getEstimatedSize() { // 簡單的大小估算 if (value instanceof String) { return ((String) value).length() * 2L; // Unicode 字元 } else if (value instanceof byte[]) { return ((byte[]) value).length; } else { return 100L; // 預設估算 } } // getter 方法 public Object getValue() { return value; } public long getExpireTime() { return expireTime; } public long getLastAccessTime() { return lastAccessTime; } } /** * 快取統計資訊 */ public static class CacheStats { private final int totalEntries; private final int expiredEntries; private final long totalSize; public CacheStats(int totalEntries, int expiredEntries, long totalSize) { this.totalEntries = totalEntries; this.expiredEntries = expiredEntries; this.totalSize = totalSize; } public int getActiveEntries() { return totalEntries - expiredEntries; } public double getHitRatio() { return totalEntries \u0026gt; 0 ? (double) getActiveEntries() / totalEntries : 0; } @Override public String toString() { return String.format(\u0026#34;CacheStats{total=%d, active=%d, expired=%d, size=%d bytes, hitRatio=%.2f%%}\u0026#34;, totalEntries, getActiveEntries(), expiredEntries, totalSize, getHitRatio() * 100); } // getter 方法 public int getTotalEntries() { return totalEntries; } public int getExpiredEntries() { return expiredEntries; } public long getTotalSize() { return totalSize; } } } 最佳實踐與建議 1. 方法選擇指南 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /** * Map 計算方法選擇指南 */ public class MethodSelectionGuide { /** * 基於使用場景選擇最適合的方法 */ public static void demonstrateMethodSelection() { System.out.println(\u0026#34;Map 計算方法選擇指南\u0026#34;); System.out.println(\u0026#34;==================\u0026#34;); // 場景 1: 簡單的 Key 存在性檢查與插入 System.out.println(\u0026#34;場景 1: 初始化集合元素\u0026#34;); System.out.println(\u0026#34;推薦: putIfAbsent 或 computeIfAbsent\u0026#34;); Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; groups = new ConcurrentHashMap\u0026lt;\u0026gt;(); // 使用 computeIfAbsent（推薦） groups.computeIfAbsent(\u0026#34;admins\u0026#34;, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(\u0026#34;alice\u0026#34;); // 場景 2: 累加計數器 System.out.println(\u0026#34;場景 2: 計數器累加\u0026#34;); System.out.println(\u0026#34;推薦: merge 或 compute\u0026#34;); Map\u0026lt;String, Integer\u0026gt; counters = new ConcurrentHashMap\u0026lt;\u0026gt;(); // 使用 merge（推薦） counters.merge(\u0026#34;clicks\u0026#34;, 1, Integer::sum); // 場景 3: 條件式更新現有值 System.out.println(\u0026#34;場景 3: 條件式更新\u0026#34;); System.out.println(\u0026#34;推薦: computeIfPresent\u0026#34;); Map\u0026lt;String, Integer\u0026gt; scores = new ConcurrentHashMap\u0026lt;\u0026gt;(); scores.put(\u0026#34;player1\u0026#34;, 100); // 使用 computeIfPresent（推薦） scores.computeIfPresent(\u0026#34;player1\u0026#34;, (k, v) -\u0026gt; v \u0026gt; 50 ? v + 10 : v); // 場景 4: 複雜的計算邏輯 System.out.println(\u0026#34;場景 4: 複雜計算\u0026#34;); System.out.println(\u0026#34;推薦: compute\u0026#34;); Map\u0026lt;String, String\u0026gt; stateMachine = new ConcurrentHashMap\u0026lt;\u0026gt;(); // 使用 compute（推薦） stateMachine.compute(\u0026#34;task1\u0026#34;, (k, currentState) -\u0026gt; { if (currentState == null) return \u0026#34;CREATED\u0026#34;; switch (currentState) { case \u0026#34;CREATED\u0026#34;: return \u0026#34;PROCESSING\u0026#34;; case \u0026#34;PROCESSING\u0026#34;: return \u0026#34;COMPLETED\u0026#34;; default: return currentState; } }); System.out.println(\u0026#34;結果展示:\u0026#34;); System.out.println(\u0026#34;群組: \u0026#34; + groups); System.out.println(\u0026#34;計數器: \u0026#34; + counters); System.out.println(\u0026#34;分數: \u0026#34; + scores); System.out.println(\u0026#34;狀態: \u0026#34; + stateMachine); } } 2. 常見陷阱與解決方案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 /** * 常見陷阱與解決方案 */ public class CommonPitfalls { /** * 陷阱 1: 在計算函數中執行耗時操作 */ public static void demonstrateExpensiveOperationPitfall() { System.out.println(\u0026#34;陷阱 1: 計算函數中的耗時操作\u0026#34;); ConcurrentHashMap\u0026lt;String, String\u0026gt; cache = new ConcurrentHashMap\u0026lt;\u0026gt;(); // ❌ 錯誤做法：在計算函數中執行耗時操作 String badResult = cache.computeIfAbsent(\u0026#34;user123\u0026#34;, key -\u0026gt; { try { Thread.sleep(1000); // 模擬耗時的資料庫查詢 return \u0026#34;User data for \u0026#34; + key; } catch (InterruptedException e) { Thread.currentThread().interrupt(); return null; } }); // ✅ 正確做法：預先計算或使用異步載入 CompletableFuture\u0026lt;String\u0026gt; futureResult = CompletableFuture.supplyAsync(() -\u0026gt; { try { Thread.sleep(1000); // 模擬耗時操作 return \u0026#34;User data for user456\u0026#34;; } catch (InterruptedException e) { Thread.currentThread().interrupt(); return null; } }); // 只在快取中存儲已計算的結果 try { String goodResult = cache.putIfAbsent(\u0026#34;user456\u0026#34;, futureResult.get()); System.out.println(\u0026#34;預計算結果: \u0026#34; + goodResult); } catch (Exception e) { System.err.println(\u0026#34;計算失敗: \u0026#34; + e.getMessage()); } } /** * 陷阱 2: 在計算函數中修改 Map 本身 */ public static void demonstrateRecursiveModificationPitfall() { System.out.println(\u0026#34;陷阱 2: 遞迴修改陷阱\u0026#34;); ConcurrentHashMap\u0026lt;String, Integer\u0026gt; map = new ConcurrentHashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;a\u0026#34;, 1); try { // ❌ 錯誤做法：在計算函數中修改同一個 Map map.compute(\u0026#34;a\u0026#34;, (key, value) -\u0026gt; { map.put(\u0026#34;b\u0026#34;, 2); // 這可能導致死鎖或異常 return value + 1; }); } catch (Exception e) { System.err.println(\u0026#34;遞迴修改錯誤: \u0026#34; + e.getMessage()); } // ✅ 正確做法：分離計算和修改操作 Integer currentValue = map.get(\u0026#34;a\u0026#34;); if (currentValue != null) { map.put(\u0026#34;a\u0026#34;, currentValue + 1); map.put(\u0026#34;b\u0026#34;, 2); } System.out.println(\u0026#34;安全修改後的 Map: \u0026#34; + map); } /** * 陷阱 3: 計算函數拋出異常 */ public static void demonstrateExceptionHandlingPitfall() { System.out.println(\u0026#34;陷阱 3: 異常處理陷阱\u0026#34;); ConcurrentHashMap\u0026lt;String, Integer\u0026gt; map = new ConcurrentHashMap\u0026lt;\u0026gt;(); // ❌ 可能有問題：未處理計算函數中的異常 try { map.compute(\u0026#34;risky\u0026#34;, (key, value) -\u0026gt; { if (Math.random() \u0026gt; 0.5) { throw new RuntimeException(\u0026#34;隨機失敗\u0026#34;); } return value == null ? 1 : value + 1; }); } catch (RuntimeException e) { System.err.println(\u0026#34;計算失敗: \u0026#34; + e.getMessage()); } // ✅ 正確做法：在計算函數內部處理異常 map.compute(\u0026#34;safe\u0026#34;, (key, value) -\u0026gt; { try { // 可能拋出異常的操作 if (Math.random() \u0026gt; 0.5) { throw new RuntimeException(\u0026#34;隨機失敗\u0026#34;); } return value == null ? 1 : value + 1; } catch (Exception e) { System.err.println(\u0026#34;內部處理異常: \u0026#34; + e.getMessage()); return value; // 返回原值或預設值 } }); System.out.println(\u0026#34;異常處理後的 Map: \u0026#34; + map); } /** * 陷阱 4: null 值處理不當 */ public static void demonstrateNullHandlingPitfall() { System.out.println(\u0026#34;陷阱 4: null 值處理陷阱\u0026#34;); ConcurrentHashMap\u0026lt;String, String\u0026gt; map = new ConcurrentHashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34;); map.put(\u0026#34;key2\u0026#34;, null); // ConcurrentHashMap 不允許 null 值，這會拋出異常 // ✅ 正確做法：避免 null 值 map.compute(\u0026#34;key3\u0026#34;, (key, value) -\u0026gt; { if (value == null) { return \u0026#34;default_value\u0026#34;; } return value.toUpperCase(); }); // 使用 Optional 處理可能的 null 值 String result = Optional.ofNullable(map.get(\u0026#34;key3\u0026#34;)) .map(String::toUpperCase) .orElse(\u0026#34;DEFAULT\u0026#34;); System.out.println(\u0026#34;安全處理 null 後的結果: \u0026#34; + result); } public static void main(String[] args) { demonstrateExpensiveOperationPitfall(); demonstrateRecursiveModificationPitfall(); demonstrateExceptionHandlingPitfall(); // demonstrateNullHandlingPitfall(); // 會拋出異常 } } 總結 Java Map 的計算方法為開發者提供了強大的工具來進行高效的資料操作：\n方法特性總結 方法 適用場景 執行條件 返回值 putIfAbsent 條件式插入 Key 不存在 現有值或 null compute 無條件計算 總是執行 計算結果 computeIfAbsent 延遲初始化 Key 不存在或值為 null 計算結果或現有值 computeIfPresent 條件式更新 Key 存在且值不為 null 計算結果或 null merge 值合併 總是執行合併邏輯 合併結果 最佳實踐要點 選擇合適的方法：根據具體需求選擇最合適的計算方法 避免耗時操作：在計算函數中避免執行耗時的 I/O 或網路操作 異常處理：妥善處理計算函數中可能出現的異常 執行緒安全：配合 ConcurrentHashMap 實現高效的併發操作 效能考量：合理使用這些方法可以顯著提升效能 關鍵優勢 原子性：避免 Check-Then-Act 競態條件 效能提升：減少重複的 Map 查找操作 程式碼簡潔：使用 Lambda 表達式簡化邏輯 執行緒安全：與併發集合完美配合 通過掌握這些 Map 計算方法，您可以寫出更高效、更安全、更簡潔的 Java 程式碼。\n","permalink":"https://xinqilin.github.io/post/backend/mapcompute/","tags":["Java","Map","HashMap","ConcurrentHashMap","Collections","Performance","Lambda","Atomic Operations","Thread Safety"],"title":"Java Map 計算方法完整指南：高效能數據操作與最佳實踐"},{"content":"概述 sed（Stream Editor，流編輯器）是 Unix/Linux 系統中功能強大的文本處理工具。它能夠對文本流進行非互動式的編輯操作，包括搜尋、替換、插入、刪除等功能。作為管道處理的重要工具，sed 在自動化腳本和批次文本處理中扮演關鍵角色。\n核心特徵 流式處理：逐行處理文本，適合大檔案操作 非互動式：可在腳本中自動執行 正規表達式：支援強大的模式匹配 原地編輯：可直接修改原始檔案 管道友好：適合與其他命令組合使用 基本語法 1 2 3 sed [選項] \u0026#39;地址定界command\u0026#39; file(s) sed [選項] -e \u0026#39;script1\u0026#39; -e \u0026#39;script2\u0026#39; file(s) sed [選項] -f script.sed file(s) 常用選項 1 2 3 4 5 6 7 -n # 安靜模式，不自動列印處理結果 -e script # 指定要執行的腳本命令 -f file # 從檔案讀取腳本命令 -i[suffix] # 直接修改檔案（可選備份後綴） -r 或 -E # 使用擴展正規表達式 -s # 將多個檔案視為獨立處理 --debug # 偵錯模式，顯示執行過程 基本範例 1 2 3 4 5 6 7 8 # 基本文本替換 sed \u0026#39;s/old/new/\u0026#39; file.txt # 替換每行第一個匹配 sed \u0026#39;s/old/new/g\u0026#39; file.txt # 替換所有匹配 sed \u0026#39;s/old/new/2\u0026#39; file.txt # 替換每行第二個匹配 # 直接修改檔案 sed -i \u0026#39;s/old/new/g\u0026#39; file.txt # 直接修改原檔案 sed -i.bak \u0026#39;s/old/new/g\u0026#39; file.txt # 修改前先備份 地址定界 地址定界用於指定 sed 命令作用的行範圍：\n基本地址類型 1 2 3 4 5 6 7 8 9 10 11 12 # 行號地址 sed \u0026#39;3d\u0026#39; file.txt # 刪除第3行 sed \u0026#39;1,5d\u0026#39; file.txt # 刪除第1到5行 sed \u0026#39;3,$d\u0026#39; file.txt # 刪除第3行到檔案結尾 # 模式地址 sed \u0026#39;/pattern/d\u0026#39; file.txt # 刪除包含pattern的行 sed \u0026#39;/start/,/end/d\u0026#39; file.txt # 刪除從start到end之間的行 # 特殊地址 sed \u0026#39;$d\u0026#39; file.txt # 刪除最後一行 sed \u0026#39;0,/pattern/d\u0026#39; file.txt # 刪除到第一個匹配pattern的行 進階地址定界 1 2 3 4 5 6 7 8 9 10 11 12 # 步進地址 sed -n \u0026#39;1~2p\u0026#39; file.txt # 列印奇數行（從第1行開始，每2行一次） sed -n \u0026#39;2~2p\u0026#39; file.txt # 列印偶數行 sed -n \u0026#39;1~3p\u0026#39; file.txt # 每三行列印一次 # 地址取反 sed \u0026#39;3!d\u0026#39; file.txt # 刪除除第3行外的所有行 sed \u0026#39;/pattern/!d\u0026#39; file.txt # 只保留包含pattern的行 # 複雜地址組合 sed \u0026#39;1,3d; 5,7d\u0026#39; file.txt # 刪除1-3行和5-7行 sed \u0026#39;/^#/d; /^$/d\u0026#39; file.txt # 刪除註釋行和空行 核心命令詳解 1. 替換命令 (s) sed 最常用的命令，語法：s/pattern/replacement/flags\n基本替換 1 2 3 4 5 6 7 8 9 10 # 基本替換語法 sed \u0026#39;s/pattern/replacement/\u0026#39; file.txt # 替換每行第一個匹配 sed \u0026#39;s/pattern/replacement/g\u0026#39; file.txt # 全域替換 sed \u0026#39;s/pattern/replacement/2\u0026#39; file.txt # 替換第二個匹配 sed \u0026#39;s/pattern/replacement/2g\u0026#39; file.txt # 從第二個開始全部替換 # 使用不同分隔符 sed \u0026#39;s#/old/path#/new/path#g\u0026#39; file.txt # 使用 # 作為分隔符 sed \u0026#39;s|old|new|g\u0026#39; file.txt # 使用 | 作為分隔符 sed \u0026#39;s@old@new@g\u0026#39; file.txt # 使用 @ 作為分隔符 進階替換功能 1 2 3 4 5 6 7 8 9 10 11 12 13 # 大小寫轉換 sed \u0026#39;s/.*/\\U\u0026amp;/\u0026#39; file.txt # 全部轉大寫 sed \u0026#39;s/.*/\\L\u0026amp;/\u0026#39; file.txt # 全部轉小寫 sed \u0026#39;s/\\([a-z]\\)/\\U\\1/g\u0026#39; file.txt # 每個字母轉大寫 sed \u0026#39;s/\\b\\w/\\U\u0026amp;/g\u0026#39; file.txt # 單詞首字母大寫 # 使用捕獲群組 sed \u0026#39;s/\\([0-9]*\\)-\\([0-9]*\\)/\\2-\\1/\u0026#39; file.txt # 交換數字順序 sed \u0026#39;s/\\(.*\\): \\(.*\\)/\\2 - \\1/\u0026#39; file.txt # 重新排列格式 # 條件替換 sed \u0026#39;/pattern/s/old/new/g\u0026#39; file.txt # 只在包含pattern的行中替換 sed \u0026#39;1,10s/old/new/g\u0026#39; file.txt # 只在第1-10行中替換 2. 刪除命令 (d) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 基本刪除 sed \u0026#39;3d\u0026#39; file.txt # 刪除第3行 sed \u0026#39;1,5d\u0026#39; file.txt # 刪除第1-5行 sed \u0026#39;$d\u0026#39; file.txt # 刪除最後一行 # 模式刪除 sed \u0026#39;/pattern/d\u0026#39; file.txt # 刪除包含pattern的行 sed \u0026#39;/^$/d\u0026#39; file.txt # 刪除空行 sed \u0026#39;/^#/d\u0026#39; file.txt # 刪除註釋行 sed \u0026#39;/^[[:space:]]*$/d\u0026#39; file.txt # 刪除空行和只有空白的行 # 範圍刪除 sed \u0026#39;/start/,/end/d\u0026#39; file.txt # 刪除start到end之間的行 sed \u0026#39;/BEGIN/,/END/d\u0026#39; file.txt # 刪除BEGIN到END區塊 3. 列印命令 (p) 1 2 3 4 5 6 7 8 9 10 11 12 # 基本列印（通常與-n一起使用） sed -n \u0026#39;3p\u0026#39; file.txt # 只列印第3行 sed -n \u0026#39;1,5p\u0026#39; file.txt # 只列印第1-5行 sed -n \u0026#39;$p\u0026#39; file.txt # 只列印最後一行 # 模式列印 sed -n \u0026#39;/pattern/p\u0026#39; file.txt # 只列印包含pattern的行 sed -n \u0026#39;/^#/p\u0026#39; file.txt # 只列印註釋行 # 複製列印 sed \u0026#39;p\u0026#39; file.txt # 每行列印兩次 sed \u0026#39;/pattern/p\u0026#39; file.txt # 匹配行列印兩次 4. 插入和附加命令 (i, a, c) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 插入命令 (i) - 在指定行前插入 sed \u0026#39;3i\\New line before line 3\u0026#39; file.txt # 在第3行前插入 sed \u0026#39;/pattern/i\\New line\u0026#39; file.txt # 在匹配行前插入 # 附加命令 (a) - 在指定行後附加 sed \u0026#39;3a\\New line after line 3\u0026#39; file.txt # 在第3行後附加 sed \u0026#39;/pattern/a\\New line\u0026#39; file.txt # 在匹配行後附加 sed \u0026#39;$a\\Last line\u0026#39; file.txt # 在檔案末尾附加 # 替換命令 (c) - 替換整行 sed \u0026#39;3c\\Replacement line\u0026#39; file.txt # 替換第3行 sed \u0026#39;/pattern/c\\New content\u0026#39; file.txt # 替換匹配行 # 多行操作 sed \u0026#39;3i\\Line 1\\nLine 2\\nLine 3\u0026#39; file.txt # 插入多行 5. 檔案操作命令 (r, w) 1 2 3 4 5 6 7 8 # 讀取檔案 (r) sed \u0026#39;3r insert.txt\u0026#39; file.txt # 在第3行後插入檔案內容 sed \u0026#39;/pattern/r header.txt\u0026#39; file.txt # 在匹配行後插入檔案 # 寫入檔案 (w) sed -n \u0026#39;1,10w output.txt\u0026#39; file.txt # 將第1-10行寫入檔案 sed -n \u0026#39;/pattern/w matches.txt\u0026#39; file.txt # 將匹配行寫入檔案 sed \u0026#39;/ERROR/w errors.log\u0026#39; file.txt # 將錯誤行寫入日誌 正規表達式進階應用 基本正規表達式 (BRE) 1 2 3 4 5 6 7 8 9 # 基本元字元 sed \u0026#39;s/^/\u0026gt; /\u0026#39; file.txt # 在每行開頭加上 \u0026#34;\u0026gt; \u0026#34; sed \u0026#39;s/$/!/\u0026#39; file.txt # 在每行結尾加上 \u0026#34;!\u0026#34; sed \u0026#39;s/./X/g\u0026#39; file.txt # 將每個字元替換為X # 字元類別 sed \u0026#39;s/[0-9]/X/g\u0026#39; file.txt # 替換所有數字 sed \u0026#39;s/[a-zA-Z]/X/g\u0026#39; file.txt # 替換所有字母 sed \u0026#39;s/[[:digit:]]/X/g\u0026#39; file.txt # 使用POSIX字元類別 擴展正規表達式 (ERE) 1 2 3 4 5 6 7 8 9 10 # 使用 -E 或 -r 選項 sed -E \u0026#39;s/([0-9]+)-([0-9]+)/\\2-\\1/\u0026#39; file.txt # 交換連字號分隔的數字 sed -E \u0026#39;s/\\b[a-z]+/\\U\u0026amp;/g\u0026#39; file.txt # 單詞首字母大寫 sed -E \u0026#39;s/(.*\\.)(jpg|png)/\\1webp/\u0026#39; file.txt # 改變檔案副檔名 # 量詞使用 sed -E \u0026#39;s/a+/A/g\u0026#39; file.txt # 一個或多個a sed -E \u0026#39;s/a?/A/g\u0026#39; file.txt # 零個或一個a sed -E \u0026#39;s/a{3}/AAA/g\u0026#39; file.txt # 恰好三個a sed -E \u0026#39;s/a{2,4}/A/g\u0026#39; file.txt # 2到4個a 實戰應用場景 1. 檔案內容清理 1 2 3 4 5 6 7 8 9 10 # 清理空行和註釋 sed \u0026#39;/^$/d; /^#/d\u0026#39; file.txt # 刪除空行和註釋行 sed \u0026#39;/^[[:space:]]*$/d\u0026#39; file.txt # 刪除空行和只有空白的行 sed \u0026#39;s/[[:space:]]*$//\u0026#39; file.txt # 刪除行尾空白 sed \u0026#39;s/^[[:space:]]*//\u0026#39; file.txt # 刪除行首空白 # 清理特殊字元 sed \u0026#39;s/\\r$//\u0026#39; file.txt # 刪除Windows換行符 sed \u0026#39;s/\\t/ /g\u0026#39; file.txt # 將tab替換為空格 sed \u0026#39;s/[[:cntrl:]]//g\u0026#39; file.txt # 刪除控制字元 2. 資料格式轉換 1 2 3 4 5 6 7 8 9 10 11 12 # CSV處理 sed \u0026#39;s/,/\\t/g\u0026#39; data.csv # CSV轉TSV sed \u0026#39;s/;/,/g\u0026#39; file.csv # 更改分隔符 sed \u0026#39;1d\u0026#39; data.csv # 刪除標題行 # 日期格式轉換 sed -E \u0026#39;s/([0-9]{4})-([0-9]{2})-([0-9]{2})/\\3\\/\\2\\/\\1/g\u0026#39; file.txt # 2023-12-25 -\u0026gt; 25/12/2023 # 電話號碼格式化 sed -E \u0026#39;s/([0-9]{3})([0-9]{3})([0-9]{4})/(\\1) \\2-\\3/\u0026#39; file.txt # 1234567890 -\u0026gt; (123) 456-7890 3. 程式碼處理 1 2 3 4 5 6 7 8 9 # 批次重構程式碼 find . -name \u0026#34;*.java\u0026#34; -exec sed -i \u0026#39;s/oldClassName/newClassName/g\u0026#39; {} \\; # 移除偵錯程式碼 sed \u0026#39;/console\\.log/d\u0026#39; script.js # 刪除console.log行 sed \u0026#39;/DEBUG/,/END_DEBUG/d\u0026#39; code.c # 刪除DEBUG區塊 # 添加授權標題 sed \u0026#39;1i\\// Copyright 2023 Company Name\u0026#39; *.js # 在每個JS檔案開頭添加版權 4. 日誌分析 1 2 3 4 5 6 7 8 9 10 # 提取特定時間範圍的日誌 sed -n \u0026#39;/2023-12-01/,/2023-12-31/p\u0026#39; access.log # 過濾錯誤日誌 sed -n \u0026#39;/ERROR\\|FATAL/p\u0026#39; application.log # 只顯示錯誤和致命錯誤 sed \u0026#39;/INFO\\|DEBUG/d\u0026#39; application.log # 隱藏資訊和偵錯訊息 # 日誌格式化 sed \u0026#39;s/\\[\\([^]]*\\)\\]/\\1/g\u0026#39; syslog # 移除方括號 sed -E \u0026#39;s/^([^ ]+) ([^ ]+)/[\\1] \\2:/\u0026#39; log.txt # 重新格式化時間戳 5. 設定檔管理 1 2 3 4 5 6 7 8 # 修改設定值 sed -i \u0026#39;s/^port=.*/port=8080/\u0026#39; config.ini # 修改連接埠設定 sed -i \u0026#39;/^#.*debug/s/^#//\u0026#39; config.conf # 取消註釋debug設定 sed -i \u0026#39;/^debug=/s/false/true/\u0026#39; config.conf # 啟用debug模式 # 添加設定項目 sed -i \u0026#39;/\\[database\\]/a\\timeout=30\u0026#39; config.ini # 在[database]段落後添加設定 sed -i \u0026#39;$a\\new_setting=value\u0026#39; config.conf # 在檔案末尾添加設定 進階技巧 1. 多命令處理 1 2 3 4 5 6 7 8 # 使用分號分隔命令 sed \u0026#39;1d; s/old/new/g; $a\\EOF\u0026#39; file.txt # 使用-e選項 sed -e \u0026#39;1d\u0026#39; -e \u0026#39;s/old/new/g\u0026#39; -e \u0026#39;$a\\EOF\u0026#39; file.txt # 使用大括號組合命令 sed \u0026#39;/pattern/{s/old/new/; p;}\u0026#39; file.txt 2. 條件處理 1 2 3 4 5 6 7 8 # 分支和標籤 sed \u0026#39;:label; s/\\([0-9]*\\),\\([0-9]\\)/\\1\\2,/; t label\u0026#39; file.txt # 移除數字中的逗號 # 測試命令 sed \u0026#39;s/old/new/; t end; s/fallback/replacement/; :end\u0026#39; file.txt # 複雜條件邏輯 sed \u0026#39;/pattern1/{s/old/new/; b}; /pattern2/s/old/different/\u0026#39; file.txt 3. 保持空間 (Hold Space) 1 2 3 4 5 6 # 基本保持空間操作 sed -n \u0026#39;1h; 2g; 2p\u0026#39; file.txt # 將第1行複製到第2行位置顯示 sed -n \u0026#39;1h; 1!H; $!d; x; p\u0026#39; file.txt # 反轉檔案行順序 # 複雜的保持空間範例 sed -n \u0026#39;/pattern/{h; n; s/old/new/; H; x; s/\\n/ - /; p;}\u0026#39; file.txt 4. 腳本檔案 建立 script.sed 檔案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 這是一個sed腳本檔案 # 刪除空行 /^$/d # 刪除註釋行 /^#/d # 替換特定模式 s/old_pattern/new_pattern/g # 在檔案末尾添加內容 $a\\ Processing completed. 使用腳本：\n1 sed -f script.sed input.txt 效能優化與最佳實踐 1. 效能優化技巧 1 2 3 4 5 6 7 8 9 10 # 使用quit命令提早退出 sed \u0026#39;10q\u0026#39; file.txt # 只處理前10行後退出 sed \u0026#39;/pattern/q\u0026#39; file.txt # 找到匹配後立即退出 # 避免不必要的處理 sed -n \u0026#39;/pattern/p\u0026#39; file.txt # 使用-n避免自動列印 sed \u0026#39;/pattern/!d\u0026#39; file.txt # 只保留匹配行 # 組合多個操作 sed \u0026#39;s/old1/new1/g; s/old2/new2/g\u0026#39; file.txt # 一次執行多個替換 2. 記憶體使用優化 1 2 3 4 5 6 # 處理大檔案時的注意事項 sed \u0026#39;1,1000d\u0026#39; hugefile.txt \u0026gt; output.txt # 分段處理大檔案 sed -n \u0026#39;1000,2000p\u0026#39; hugefile.txt # 只處理特定範圍 # 使用管道減少中間檔案 cat input.txt | sed \u0026#39;s/old/new/g\u0026#39; | sed \u0026#39;/pattern/d\u0026#39; \u0026gt; output.txt 3. 錯誤處理 1 2 3 4 5 6 7 8 9 # 備份重要檔案 sed -i.backup \u0026#39;s/old/new/g\u0026#39; important.txt # 自動備份 # 測試命令 sed \u0026#39;s/old/new/g\u0026#39; file.txt \u0026gt; test_output.txt # 先測試輸出 diff file.txt test_output.txt # 檢查差異 # 檢查檔案存在 [ -f file.txt ] \u0026amp;\u0026amp; sed -i \u0026#39;s/old/new/g\u0026#39; file.txt 常見錯誤與除錯 1. 常見錯誤 1 2 3 4 5 6 7 8 9 10 11 # 錯誤：未轉義特殊字元 sed \u0026#39;s/file.txt/newfile.txt/\u0026#39; file # 錯誤：.匹配任意字元 sed \u0026#39;s/file\\.txt/newfile.txt/\u0026#39; file # 正確：轉義.字元 # 錯誤：地址範圍問題 sed \u0026#39;1,$s/old/new/\u0026#39; file.txt # 可能造成混淆 sed \u0026#39;1,$ s/old/new/\u0026#39; file.txt # 更清楚的寫法 # 錯誤：忘記分隔符轉義 sed \u0026#39;s/http://old.com/http://new.com/\u0026#39; file # 錯誤：分隔符衝突 sed \u0026#39;s#http://old.com#http://new.com#\u0026#39; file # 正確：使用不同分隔符 2. 除錯技巧 1 2 3 4 5 6 7 8 9 # 使用偵錯模式 sed --debug \u0026#39;s/old/new/g\u0026#39; file.txt # 逐步測試 sed -n \u0026#39;l\u0026#39; file.txt # 顯示不可見字元 sed = file.txt | sed \u0026#39;N; s/\\n/\\t/\u0026#39; # 顯示行號 # 測試正規表達式 echo \u0026#34;test string\u0026#34; | sed \u0026#39;s/pattern/replacement/\u0026#39; 與其他工具整合 1. 與 find 組合 1 2 3 4 5 6 # 批次處理檔案 find . -name \u0026#34;*.txt\u0026#34; -exec sed -i \u0026#39;s/old/new/g\u0026#39; {} \\; find . -name \u0026#34;*.conf\u0026#34; -exec sed -i \u0026#39;/^#/d\u0026#39; {} \\; # 使用 xargs 提升效能 find . -name \u0026#34;*.txt\u0026#34; | xargs sed -i \u0026#39;s/old/new/g\u0026#39; 2. 與 awk 組合 1 2 3 4 5 # sed處理格式，awk處理邏輯 sed \u0026#39;s/,/ /g\u0026#39; data.csv | awk \u0026#39;{print $1, $3}\u0026#39; # 管道組合處理 cat log.txt | sed \u0026#39;/ERROR/!d\u0026#39; | awk \u0026#39;{print $1, $4}\u0026#39; 3. 與 grep 組合 1 2 3 4 5 # 先過濾再處理 grep \u0026#34;pattern\u0026#34; file.txt | sed \u0026#39;s/old/new/g\u0026#39; # 組合條件處理 sed -n \u0026#39;/start/,/end/p\u0026#39; file.txt | grep \u0026#34;important\u0026#34; 實用腳本範例 1. 日誌清理腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/bin/bash # log_cleanup.sh - 清理和格式化日誌檔案 LOG_FILE=\u0026#34;$1\u0026#34; OUTPUT_FILE=\u0026#34;${LOG_FILE}.clean\u0026#34; sed -e \u0026#39;/^$/d\u0026#39; \\ -e \u0026#39;/^#/d\u0026#39; \\ -e \u0026#39;s/[[:space:]]*$//\u0026#39; \\ -e \u0026#39;s/\\t/ /g\u0026#39; \\ -e \u0026#39;/DEBUG/d\u0026#39; \\ \u0026#34;$LOG_FILE\u0026#34; \u0026gt; \u0026#34;$OUTPUT_FILE\u0026#34; echo \u0026#34;清理完成：$OUTPUT_FILE\u0026#34; 2. 設定檔更新腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/bin/bash # config_update.sh - 批次更新設定檔 CONFIG_DIR=\u0026#34;/etc/myapp\u0026#34; BACKUP_DIR=\u0026#34;/etc/myapp/backup\u0026#34; # 備份設定檔 mkdir -p \u0026#34;$BACKUP_DIR\u0026#34; cp \u0026#34;$CONFIG_DIR\u0026#34;/*.conf \u0026#34;$BACKUP_DIR\u0026#34;/ # 更新設定 find \u0026#34;$CONFIG_DIR\u0026#34; -name \u0026#34;*.conf\u0026#34; -exec sed -i \\ -e \u0026#39;s/^port=.*/port=8080/\u0026#39; \\ -e \u0026#39;s/^debug=false/debug=true/\u0026#39; \\ -e \u0026#39;/^#.*logging/s/^#//\u0026#39; \\ {} \\; echo \u0026#34;設定更新完成\u0026#34; 3. 程式碼重構腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/bin/bash # refactor.sh - 批次重構程式碼 OLD_CLASS=\u0026#34;$1\u0026#34; NEW_CLASS=\u0026#34;$2\u0026#34; if [ $# -ne 2 ]; then echo \u0026#34;用法: $0 \u0026lt;舊類別名\u0026gt; \u0026lt;新類別名\u0026gt;\u0026#34; exit 1 fi # 更新Java檔案 find . -name \u0026#34;*.java\u0026#34; -exec sed -i \\ -e \u0026#34;s/class $OLD_CLASS/class $NEW_CLASS/g\u0026#34; \\ -e \u0026#34;s/new $OLD_CLASS(/new $NEW_CLASS(/g\u0026#34; \\ -e \u0026#34;s/$OLD_CLASS\\.class/$NEW_CLASS.class/g\u0026#34; \\ {} \\; echo \u0026#34;重構完成：$OLD_CLASS -\u0026gt; $NEW_CLASS\u0026#34; 總結 核心優勢 高效率：流式處理，記憶體使用量小 靈活性：支援複雜的文本操作 自動化：適合腳本和批次處理 標準化：跨平台一致性好 最佳實踐 測試先行：重要操作前先測試輸出 備份重要檔案：使用 -i.backup 選項 善用正規表達式：提升處理效率 組合工具：與其他命令協作使用 腳本化：將複雜操作封裝為腳本 學習建議 1 2 3 4 5 6 7 # 常用操作記憶口訣 sed \u0026#39;s/old/new/g\u0026#39; # 替換：substitute sed \u0026#39;3d\u0026#39; # 刪除：delete sed \u0026#39;3p\u0026#39; # 列印：print sed \u0026#39;3a\\text\u0026#39; # 附加：append sed \u0026#39;3i\\text\u0026#39; # 插入：insert sed \u0026#39;3c\\text\u0026#39; # 改變：change sed 是文本處理的瑞士軍刀，掌握其核心概念和常用操作，能夠大幅提升 Linux 系統管理和自動化腳本的效率。記住：實務中最重要的是理解模式空間的概念，並善用地址定界來精確控制操作範圍。\n參考資料 GNU sed Manual sed \u0026amp; awk by O\u0026rsquo;Reilly Advanced Bash-Scripting Guide Regular Expressions Info ","permalink":"https://xinqilin.github.io/post/tools/sed/","tags":["Linux","Sed","Stream Editor","Text Processing","Regular Expression","Shell","Unix"],"title":"Sed 流編輯器完整指南：Linux 文本處理的強大工具"},{"content":"Memento 當我們想要保存對象的狀態以便以後恢復它時，我們使用備忘錄設計模式。備忘錄模式有助於以這樣一種方式實現這一點，即對象的已保存狀態數據在對像外部無法訪問；這保護了已保存狀態數據的完整性。\n實現 Memento 模式的想法始於兩個對象—— Originator 和 Caretaker。Originator是需要保存和恢復狀態的對象，它使用一個內部類來保存Object的狀態。內部類稱為 Memento 及其私有，因此無法從其他對象訪問。\nCaretaker 是幫助類，負責通過 Memento 對象存儲和恢復 Originator 的狀態。由於 Memento 對 Originator 是私有的，因此 Caretaker 無法訪問它，並且它作為 Object 存儲在 caretaker 中。\n現實生活中最好的例子之一是 IDE, 我們可以隨時保存其數據並使用撤消將其恢復到以前保存的狀態。\n必須保存對象狀態（某些部分）的快照，以便以後可以將其恢復到該狀態，並且 獲取狀態的直接接口會暴露實現細節並破壞對象的封裝。 ","permalink":"https://xinqilin.github.io/post/architecture/memento/","tags":[],"title":"DesignPattern - Behavioral - Memento"},{"content":"Interpreter 用它來定義一種語言的語法表示，它提供了一個解釋器來處理語法。這種模式的最佳示例是 java 編譯器，它將 java 源代碼解釋為 JVM 可以理解的字節碼。google translation 也是Interpreter 的一個例子，其中輸入可以是任何語言，我們可以得到另一種語言的解釋輸出。\n為了 Interpreter，我們需要創建 Interpreter 上下文引擎來完成解釋工作。然後，我們需要創建不同的 Expression 實現，這些實現將使用解釋器上下文提供的功能。最後，我們需要創建客戶端，該客戶端將從用戶那裡獲取輸入並決定使用哪個表達式，然後為用戶生成輸出。\n語法很簡單。對於復雜的語法，語法的類層次結構變得龐大且難以管理。在這種情況下，解析器生成器等工具是更好的選擇。他們可以在不構建抽象語法樹 (AST) 的情況下解釋表達式，這也可以節省空間和時間。 效率不是關鍵問題。最有效的解釋器通常不是通過直接解釋解析樹來實現，而是首先將它們翻譯成另一種形式。例如，正則表達式經常被轉換為狀態機。但即便如此，我們也可以藉助解釋器模式來實現翻譯器，因此該模式仍然適用。 ","permalink":"https://xinqilin.github.io/post/architecture/interpreter/","tags":[],"title":"DesignPattern - Behavioral - Interpreter"},{"content":"Iterator Iterator 是一種行為模式，使用它來提供一種標準的方式來遍歷一組對象。我們在 Java 集合框架中廣泛使用 Iterator，其中迭代器接口提供了遍歷集合的方法。 迭代的邏輯嵌入在集合本身中，它可以幫助客戶端程序輕鬆地對其進行迭代。Iterator 對象包含公共方法，以允許客戶端對像在容器內的對象列表迭代。\nIterator 定義 interface 用來迭代或存取的接口\nConcreteIterator implement Iterator interface tracking the current position in the traversal of the aggregate.\nAggregate 定義用於創建 Iterator 對象的接口。\nConcreteAggregate 實現 Iterator 創建接口以返回正確的 ConcreteIterator 的實例。\n當想提供一種標準方法來迭代集合併隱藏客戶端程序的實現邏輯時。 當您需要訪問聚合對象的內容而不暴露其內部表示時。 支持聚合對象的多次遍歷。 為遍歷不同的聚合結構提供統一的接口（即支持多態迭代）。 ","permalink":"https://xinqilin.github.io/post/architecture/iterator/","tags":[],"title":"DesignPattern - Behavioral - Iterator"},{"content":"Visitor 當必須對一組相似類型的對象執行操作時，我們使用訪問者模式。借助 visitor pattern，我們可以將操作邏輯從對象轉移到另一個類。例如，考慮一個購物車，我們可以在其中添加不同類型的商品（元素），當我們點擊結帳按鈕時，它會計算出我們需要支付的總金額。現在，我們可以在項目類中包含計算邏輯，或者我們可以使用 visitor pattern 將此邏輯移到另一個類中。因此，使用 visitor pattern，我們可以將邏輯移到另一個類。\nvisitor pattern 允許在不更改集合中任何對象的類的情況下定義操作。為此，visitor pattern 建議在稱為 visitor類的單獨類中定義操作。這將操作與其操作的對象集合分開。對於要定義的每個新操作，都會創建一個新的訪問者類。由於操作將在一組對像上執行，因此訪問者需要一種訪問這些對象的公共成員的方法。\nVisitor：為對象結構中的每個 ConcreteElement 類聲明一個訪問操作。操作的名稱和簽名標識向訪問者發送訪問請求的類。這讓訪問者可以確定被訪問元素的具體類。然後訪問者可以通過其特定的界面直接訪問該元素。 ConcreteVisitor：實現訪問者聲明的每個操作。每個操作都實現了為結構中的相應對像類定義的算法片段。ConcreteVisitor 為算法提供上下文並存儲其本地狀態。這種狀態通常會在結構的遍歷過程中累積結果。 Element：定義一個接受訪問者作為參數的操作。 ConcreteElement：實現以訪問者為參數的 Accept 操作。 ObjectStructure:\n可以枚舉它的元素。 可以提供高級界面以允許訪問者訪問其元素。 可以是組合或集合，例如列表或集合。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public interface ShoppingCartElement { public int accept(ShoppingCartVisitor visitor); } public class Beef implements ShoppingCartElement { private int price; private double weight; // constructor , getter , setter @Override //Notice the implementation of accept() method in concrete classes, //its calling visit() method of Visitor and passing itself as argument. public int accept(ShoppingCartVisitor visitor) { return visitor.visit(this); } } public class Fruit implements ShoppingCartElement { private int pricePerKg; private int weight; private String name; // constructor , getter , setter @Override public int accept(ShoppingCartVisitor visitor) { return visitor.visit(this); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public interface ShoppingCartVisitor { int visit(Beef book); int visit(Fruit fruit); } public class ShoppingCartVisitorImpl implements ShoppingCartVisitor { @Override public int visit(Beef beef) { var cost = 0; //apply 5$ discount if book price is greater than 50 if(beef.getPrice() \u0026gt; 50){ cost = beef.getPrice() - 5; } else { cost = beef.getPrice(); } log.info(\u0026#34;beef: {}\u0026#34;, beef); return cost; } @Override public int visit(Fruit fruit) { var cost = fruit.getPricePerKg() * fruit.getWeight(); log.info(\u0026#34;cost: \u0026#34; + cost); return cost; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public static void main(String[] args) { var items = new ShoppingCartElement[]{ new Beef(20, 2.0), new Beef(100, 3.0), new Fruit(10, 2, \u0026#34;Apple\u0026#34;), new Fruit(5, 5, \u0026#34;Banana\u0026#34;) }; int total = calculatePrice(items); log.info(\u0026#34;total: \u0026#34; + total); } private static int calculatePrice(ShoppingCartElement[] items) { var visitor = new ShoppingCartVisitorImpl(); int sum = 0; for(ShoppingCartElement item : items){ sum += item.accept(visitor); } return sum; } 一個對象結構包含許多具有不同接口的對像類，並且您希望對這些對象執行依賴於它們的具體類的操作。 當我們需要對對象結構中的對象執行許多不同且不相關的操作時，我們希望避免這些操作 \u0026ldquo;污染\u0026rdquo; 它們的 class。訪問者允許您通過在一個類中定義相關操作來將它們保持在一起。當我們需要與許多應用程序共享對象結構時，使用訪問者將操作放在那些需要它們的應用程序中。 定義對象結構的類很少更改，但您經常希望在該結構上定義新操作。但是，更改對象結構類需要重新定義所有訪問者的接口，這可能是昂貴的。如果對象結構類經常更改，那麼最好在這些類中定義操作。 ","permalink":"https://xinqilin.github.io/post/architecture/visitor/","tags":[],"title":"DesignPattern - Behavioral - Visitor"},{"content":"State 當對像在其內部狀態改變時改變其行為時，我們使用狀態設計模式。我們可以將對象的狀態定義為其在任何給定時間點的確切條件，具體取決於其屬性或屬性的值。一個類實現的一組方法構成了它的實例的行為。每當其屬性值發生變化時，我們就說對象的狀態發生了變化。\n首次創建 Context 對象時，它會使用其初始 State 對像對其自身進行初始化。此 State 對象成為上下文的當前 State 對象。通過用新的 State 對象替換當前的 State 對象，上下文轉換到新的狀態。當應用程序對象調用 Context 方法（行為）時，它會將方法調用轉發到其當前的 State 對象。\n上下文：定義客戶感興趣的接口。此外，它維護了一個定義當前狀態的 ConcreteState 子類的實例。 State： 定義一個接口，用於封裝與 Context 的特定狀態相關的行為。 ConcreteState 子類：每個子類實現與上下文狀態相關聯的行為。 在狀態模式中，我們有一個 Context 類，並且這個類有一個對具體狀態實例的狀態引用。State 接口聲明了表示特定狀態行為的特定方法。具體國家實施這些行為。通過改變上下文的具體狀態，我們改變了它的行為。本質上，在狀態模式中，一個類（上下文）應該根據其狀態表現得像不同的類。狀態模式避免使用 switch 和 if 語句來改變行為。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public interface MacState { public void getState(); } public class Lighting implements MacState { @Override public void getState() { System.out.println(\u0026#34;mac bright!\u0026#34;); } } public class Close implements MacState { @Override public void getState() { System.out.println(\u0026#34;Mac is shut down\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 public class MacContext implements MacState { private MacState macState; // constructor , setter , getter public void getState(){ macState.getState(); } } 1 2 3 4 5 6 7 8 9 10 11 public static void main(String[] args) { var ctx = new MacContext(new Lighting()); ctx.getState(); ctx.getState(); ctx.setMacState(new Close()); ctx.getState(); ctx.getState(); ctx.getState(); } 狀態模式的好處之一是多態行為的實現，這是清晰可見的。因此，出錯的可能性較小。此外，很容易為其他行為添加更多狀態，使其更加健壯、易於維護和靈活。此外，在這種情況下，狀態模式有助於避免 if-else 或 switch-case 條件邏輯。\n當對象的行為取決於其狀態時，它必須在運行時根據其狀態改變其行為。 當操作具有依賴於對象狀態的大型、多部分條件語句時。這種狀態通常由一個或多個枚舉常量表示。通常，多個操作將包含相同的條件結構。狀態模式將條件的每個分支放在一個單獨的類中。 這讓我們可以將對象的狀態視為一個可以獨立於其他對像變化的對象。 ","permalink":"https://xinqilin.github.io/post/architecture/state/","tags":[],"title":"DesignPattern - Behavioral - State"},{"content":"Command Command Pattern 是一種行為對象設計模式。在 Command Pattern 中，命令接口聲明了用於執行特定操作的方法。具體的 Command 類實現了 Command interface 的 execute()方法，這個execute()方法調用了具體 Command 類所包含的 Receiver 類的相應動作方法。此外，Receiver 類執行特定的操作。但是，客戶端類負責創建具體命令並設置具體命令的接收者。此外，Invoker 類包含對 Command 的引用，並具有執行 Command 的方法。\n在命令模式中，調用者與接收者執行的動作分離。調用者不知道接收者。調用者調用命令，命令執行接收者的適當動作。因此，調用者可以在不知道要執行的動作的細節的情況下調用命令。此外，這種解耦意味著對接收者動作的更改不會直接影響動作的調用。\n我們甚至可以使用命令模式來執行“撤消”功能。在這種情況下，Command 接口應該包含一個方法，例如 unexecuted() 方法。\n不用說，它還幫助我們在請求-響應模型中實現松耦合。簡而言之，請求被發送給調用者，調用者將其傳遞給封裝的 命令對象。命令對象將請求傳遞給 Receiver的適當方法以執行特定操作。客戶端程序創建接收器對象，然後將其附加到命令。然後，它創建調用程序對象並附加命令對像以執行操作。現在，當客戶端程序執行動作時，它會根據命令和接收器對象進行處理。\nCommand是一個帶有 execute() 方法的接口。它是契約的核心。 Client 創建一個命令實現的實例並將其與接收器相關聯。 Invoker指示命令執行操作。 命令實現的實例在接收者和動作之間創建一個綁定。 Receiver 是知道執行操作的實際步驟的對象。任何類都可以作為接收者。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // command pattern 起手式 public interface Command { public void execute(); } public class Homework { public void writeHomework(){ System.out.println(\u0026#34;write HW right now!\u0026#34;); } } // Receiver public class HomeworkCommand implements Command { Homework homework; public HomeworkCommand(Homework homework) { this.homework = homework; } @Override public void execute() { homework.writeHomework(); } } // Receiver public class ClassmateCommand implements Command { Classmate classmate; public ClassmateCommand(Classmate classmate) { this.classmate = classmate; } @Override public void execute() { classmate.writeHomeworkTogether(); } } // Invoker public class Invoker { Command command; public Invoker(Command command) { this.command = command; } public void setCommand(Command command) { this.command = command; } public void invoke() { command.execute(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static void main(String[] args) { var homework = new Homework(); // receiver Command homeworkCommand = new HomeworkCommand(homework); // concrete command var classmate = new Classmate(); // receiver Command classmateCommand = new ClassmateCommand(classmate); // concrete command Invoker invoker = new Invoker(); // invoker invoker.setCommand(homeworkCommand); invoker.invoke(); invoker.setCommand(classmateCommand); invoker.invoke(); } 通過要執行的操作參數化對象。 圍繞基於原語操作的高級操作構建系統。這種結構在支持事務的信息系統中很常見。此外，命令模式提供了一種對事務建模的方法。命令有一個通用接口，讓您以相同的方式調用所有事務。該模式還使得使用新事務擴展系統變得容易。 命令的執行操作可以存儲狀態以在命令本身中反轉其效果。Command 接口必須有一個添加的 Un-execute 操作，它可以逆轉先前調用 Execute 的效果。我們可以將執行的命令存儲在歷史列表中。此外，我們可以通過分別調用 Un-execute 和 Execute 來回遍歷這個列表來實現無限級別的撤消和重做。它也支持撤消。 ","permalink":"https://xinqilin.github.io/post/architecture/command/","tags":[],"title":"DesignPattern - Behavioral - Command"},{"content":"Strategy 當存在一組相關算法並且客戶端對象需要能夠從該組中動態挑選適合其當前需求的算法時，策略設計模式很有用。策略模式建議將每個算法的實現保留在一個單獨的類中。封裝在單獨類中的每個此類算法稱為策略。使用 Strategy 對象的對象通常稱為上下文對象。\n當我們為特定任務有多種算法並且客戶端決定在運行時使用的實際實現時，我們使用策略模式。策略模式也稱為策略模式。我們定義了多種算法，並讓客戶端應用程序傳遞算法以用作參數。例如，此模式的最佳示例之一是 Collections.sort () 方法，該方法採用 Comparator 參數。基於 Comparator 接口的不同實現，對像以不同的方式排序。\n策略模式是我們可以使用組合作為子分類的替代方法的一種方式。策略模式不是通過子類覆蓋父類中的方法來提供不同的行為，而是允許將不同的行為放置在共享公共策略接口的具體策略類中。Context 對象包含對 Strategy 的引用。通過改變上下文的策略，我們可以獲得不同的行為。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public interface CreditCardStrategy { public void pay(BigDecimal money); } public class CTBC implements CreditCardStrategy { @Override public void pay(BigDecimal money) { System.out.println(\u0026#34;CTBC pay\u0026#34;); } } public class MEGA implements CreditCardStrategy { @Override public void pay(BigDecimal money) { System.out.println(\u0026#34;MEGA pay\u0026#34;); } } public class NCCC implements CreditCardStrategy { @Override public void pay(BigDecimal money) { System.out.println(\u0026#34;NCCC pay\u0026#34;); } } // base public class Context { private CreditCardStrategy strategy; public Context(CreditCardStrategy strategy){ this.strategy = strategy; } public void apply(BigDecimal money){ strategy.pay(money); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) { var money = new BigDecimal(\u0026#34;100\u0026#34;); // DI 注入 （constructor or setter） Context ctx = new Context(new CTBC()); ctx.pay(money); // change strategy ctx = new Context(new MEGA()); ctx.apu(money); } 為策略提供了一種使用多種行為之一配置類的方法。 算法使用客戶不應該知道的數據。使用策略模式來避免暴露複雜的、特定於算法的數據結構。 （封裝時做的細節） 一個類定義了許多行為，這些行為在其操作中表現為多個條件語句。將相關的條件分支移到它們自己的 Strategy 類中，而不是許多條件。 ","permalink":"https://xinqilin.github.io/post/architecture/strategy/","tags":[],"title":"DesignPattern - Behavioral - Strategy"},{"content":"Observer (pub-sub) 在觀察者設計模式中，多個觀察者對象向一個主題註冊以獲取通知中的任何更改。當主題的狀態發生變化時，它會通知觀察者。監聽或觀察變化的對象稱為觀察者，被觀察的對象稱為主體。\n主題為觀察者提供了一個接口，可以在主題中註冊和註銷自己。 主題知道它的訂閱者是誰。 多個觀察者可以訂閱通知。 主題發布通知。 主題只是發送通知說狀態已更改。它不傳遞任何狀態信息。 一旦收到來自主題的通知，觀察者就會調用主題並獲取更改的數據。\nSubject， 註冊觀察者。對象使用此接口註冊為觀察者，也可以將自己從觀察者中移除。 Observer為對象定義了一個更新接口，這些接口應該被通知主題的變化。但是，所有的觀察者都需要實現 Observer 接口。該接口有一個方法 update()，當 Subject 的狀態發生變化時會調用該方法。 ConcreteSubject，將感興趣的狀態存儲到 ConcreteObserver 對象。當它的狀態改變時，它會向它的觀察者發送一個通知。此外，一個具體的主題總是實現主題接口。我們使用 * notifyObservers() 方法在狀態發生變化時更新所有當前的觀察者。 ConcreateObserver 維護對 ConcreteSubject 對象的引用並實現 Observer 接口。每個觀察者註冊一個具體的主題以接收更新。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 public interface Subject { public void registerObserver(Observer observer); public void notifyObserver(); public void unregisterObserver(Observer observer); public Object getUpdate(); } public interface Observer { public void update(); public void setSubject(Subject sub); } //Concrete Subject public class Blog implements Subject { List\u0026lt;Observer\u0026gt; observersList; private boolean stateChange; public Blog() { this.observersList = new ArrayList(); stateChange = false; } @Override public void registerObserver(Observer observer) { observersList.add(observer); } @Override public void notifyObserver() { if (stateChange) { for(Observer observer : observersList) { observer.update(); System.out.println(\u0026#34;Observer notified !\u0026#34;); } } } @Override public void unregisterObserver(Observer observer) { observersList.remove(observer); } @Override public Object getUpdate() { Object changedState = null; // should have logic to send the state change to querying observer if (stateChange) { changedState = \u0026#34;Observer Design Pattern\u0026#34;; } return changedState; } public void postNewArticle() { stateChange = true; notifyObserver(); } } //Concrete Observer public class User implements Observer { private String article; private Subject blog; @Override public void update() { System.out.println(\u0026#34;State change reported by Subject.\u0026#34;); article = (String) blog.getUpdate(); } @Override public void setSubject(Subject blog) { this.blog = blog; article = \u0026#34;No New Article!\u0026#34;; } public String getArticle() { return article; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) { Blog blog = new Blog(); User user1 = new User(); User user2 = new User(); blog.registerObserver(user1); blog.registerObserver(user2); user1.setSubject(blog); user2.setSubject(blog); System.out.println(user1.getArticle()); blog.postNewArticle(); System.out.println(user1.getArticle()); } 當一個抽像有兩個方面時，一個依賴於另一個。將這些方面封裝在單獨的對像中可以讓您獨立地改變和重用它們。 當對一個對象的更改需要更改其他對象時，您不知道需要更改多少個對象？ 當一個對象應該能夠通知其他對象而不假設這些對像是誰。換句話說，您不希望這些對象緊密耦合。 reference: https://javatechonline.com/behavioral-design-patterns-in-java/#Template_Method_Design_Pattern\n","permalink":"https://xinqilin.github.io/post/architecture/observer/","tags":[],"title":"DesignPattern - Behavioral - Observer"},{"content":"Chain Of Responsibility 當有多個對象可以處理或滿足客戶端請求時，責任鏈模式建議給這些對像中的每一個以某種順序處理請求的機會。在這種情況下應用該模式，這些潛在的處理程序中的每一個都可以以鏈的形式排列，每個對像都具有對鏈中下一個對象的引用。鏈中的第一個對象接收請求並決定處理請求或將其傳遞給鏈中的下一個對象。請求一個接一個地流過鏈中的所有對象，直到請求被鏈中的一個處理程序處理或請求到達鏈的末端而沒有得到處理。\n顯然，責任鏈模式用於在軟件設計中實現鬆散耦合，其中來自客戶端的請求被傳遞到對象鏈以處理它們。然後鏈中的對象將自行決定誰將處理請求以及是否需要將請求發送到鏈中的下一個對象。\n多個類別繼承或實作抽象, 並使用, 實作中不是自己的就 next 下去, 是自己的就 action 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // This\u0026#39;s the request object. public class Number { private int number; public int getNumber() { return number; } public Number(int num){ number=num; } } // interface that acts as a chain link. public interface Chain { public void setNext(Chain nextInChain); public void process(Number request); } public class PositiveNumberProcessor implements Chain { private Chain nextInChain; @Override public void setNext(Chain c) { nextInChain = c; } @Override public void process(Number request) { if (request.getNumber() \u0026gt; 0) { System.out.println(\u0026#34;PositiveNumberProcessor : \u0026#34; + request.getNumber()); } else { nextInChain.process(request); } } } public class NegativeNumberProcessor implements Chain { private Chain nextInChain; @Override public void setNext(Chain c) { nextInChain = c; } @Override public void process(Number request) { if (request.getNumber() \u0026lt; 0) { System.out.println(\u0026#34;NegativeNumberProcessor : \u0026#34; + request.getNumber()); } else { nextInChain.process(request); } } } public class ZeroProcessor implements Chain { private Chain nextInChain; @Override public void setNext(Chain c) { nextInChain = c; } @Override public void process(Number request) { if (request.getNumber() == 0) { System.out.println(\u0026#34;ZeroProcessor : \u0026#34; + request.getNumber()); } else { nextInChain.process(request); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public static void main(String[] args) { // Chain c1 = new NegativeNumberProcessor(); // Chain c2 = new ZeroProcessor(); // Chain c3 = new PositiveNumberProcessor(); // c1.setNext(c2); // c2.setNext(c3); // chain Chain c = new Chain(new NegativeNumberProcessor(new ZeroProcessor(new PositiveNumberProcessor()))) //calling chain of responsibility c1.process(new Number(99)); c1.process(new Number(-30)); c1.process(new Number(0)); c1.process(new Number(100)); } 多個對象可以處理一個請求，並且處理程序是先驗未知的。應自動確定處理程序。 您想向多個對象之一發出請求，而不明確指定接收者。 應該動態指定可以處理請求的對象集。 ","permalink":"https://xinqilin.github.io/post/architecture/chainofresponsibility/","tags":[],"title":"DesignPattern - Behavioral - Chain Of Responsibility"},{"content":"Mediator Mediator 通過阻止對象顯式地相互引用來促進鬆散耦合，並且它允許您獨立地改變它們的交互。 我們使用中介者設計模式在系統中的不同對象之間提供集中的通信媒介。\n中介者模式專注於在對象之間提供一個中介者進行互動，並幫助實現對象之間的丟失耦合。對像要求中介者代表它們進行交互，而不是直接相互交互。它導致可重用性和鬆散耦合。此外，它封裝了對象之間的交互，使它們相互獨立。這也允許他們通過實現不同的中介以完全不同的方式改變與其他對象的交互。調解器有助於降低類的複雜性。此外，每個對像不再需要詳細了解如何與其他對象交互。對象之間的耦合從緊緻僵硬到鬆散優雅。 中介者設計模式在多個對象相互交互的企業應用程序中非常有用。如果對象直接相互交互，系統組件就會相互緊密耦合。它們還使可維護性成本更高，並且不能靈活地輕鬆擴展。\n例如，空中交通管制員是調解員模式的一個很好的例子，其中機場控制室充當不同航班之間通信的調解員。中介作為對象之間的路由器工作，它可以有自己的邏輯來提供通信方式。\nMediator: 定義一個與同事對象通信的 interface ConcreteMediator: 通過協調 Colleague 對象來實現協作行為。它還了解並維護其同事。 Colleague Classes: 每個 Colleague class 都知道它的 Mediator 對象。每位同事在本應與另一位同事溝通時都會與其調解員溝通。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public interface IMediator { public void talk(); public void fight(); public void registerA(ColleagueA a); public void registerB(ColleagueB b); } public class ConcreteMediator implements IMediator { ColleagueA talk; ColleagueB fight; @Override public void talk() { System.out.println(\u0026#34;Mediator is talking\u0026#34;); } @Override public void fight() { System.out.println(\u0026#34;Mediator is fighting\u0026#34;); } @Override public void registerA(ColleagueA a) { this.talk = a; } @Override public void registerB(ColleagueB b) { this.fight = b; } } // =========== public abstract class Colleague { IMediator mediator; public abstract void doSomething(); } public class ColleagueA extends Colleague { public ColleagueA(IMediator mediator) { this.mediator = mediator; this.mediator.registerA(this); } @Override public void doSomething() { this.mediator.talk(); } } public class ColleagueB extends Colleague { public ColleagueB(IMediator mediator) { this.mediator = mediator; this.mediator.registerB(this); } @Override public void doSomething() { this.mediator.fight(); } } 1 2 3 4 5 6 7 8 9 10 public static void main(String[] args) { IMediator mediator = new ConcreteMediator(); ColleagueA talkColleague= new ColleagueA(mediator); talkColleague.doSomething(); ColleagueB fightColleague = new ColleagueB(mediator); fightColleague.doSomething(); } 一組對像以定義明確但複雜的方式進行互動。由此產生的相互依賴是非結構化的並且難以理解。 重用一個對像很困難，因為它引用了許多其他對象並與之互動。 分佈在多個類之間的行為應該是可定制的，無需大量子類化。 ","permalink":"https://xinqilin.github.io/post/architecture/mediator/","tags":[],"title":"DesignPattern - Behavioral - Mediator"},{"content":"Template Method Template Method pattern 定義了操作中算法的骨架，將一些步驟推遲到子類。 Template Method讓子類在不改變算法結構的情況下重新定義算法的某些步驟。 可以在有算法的情況下使用Template Method pattern，其中一些步驟可以以多種不同的方式實現。在這種情況下，Template Method pattern 建議將算法的大綱保留在一個單獨的方法中，該方法稱為類中的Template方法。我們可以將其稱為Template類，將算法的變體部分（可以以多種不同方式實現的步驟）的具體實現留給該類的不同子類。\nTemplate 類不必將實現完全留給它的子類。相反，作為提供算法大綱的一部分，Template 類還可以提供一些實現，我們可以認為這些實現在不同的實現中是不變的。如果合適，它甚至可以為可變部分提供默認實現。我們只在不同的子類中實現特定的細節。這種類型的實現消除了重複代碼的需要，這意味著要編寫的代碼量最少。\n大多數都是子類別呼叫父類別方法, 但在Template Method中，父類別 Template 調用子類的方法 =\u0026gt; 好萊塢原則—— \u0026ldquo;Don’t call us, we’ll call you.\u0026rdquo; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 public abstract class OrderTemplate { // 定義是否要覆寫 public abstract boolean hook(){ return true; // 是否複寫 } // 只開放 overwrite 給會變的 public abstract void doSelect(); public abstract void doPayment(); public abstract void doDelivery(); // 樣板中不變的 （重複的） public final void doPack(){ System.out.println(\u0026#34;Gift wrap done.\u0026#34;); } public final void processOrder() { doSelect(); doPayment(); doPack(); doDelivery(); } } public class PhysicalStoreOrder extends OrderTemplate { @Override public void doSelect() { System.out.println(\u0026#34;David buy it \u0026#34;); } @Override public void doPayment() { System.out.println(\u0026#34;David pay it by credit card\u0026#34;); } @Override public void doDelivery() { System.out.println(\u0026#34;David call Paul to delivery\u0026#34;); } } public class OnlineOrder extends OrderTemplate { @Override public void doSelect() { System.out.println(\u0026#34;select item on website\u0026#34;); System.out.println(\u0026#34;add to cart\u0026#34;); } @Override public void doPayment() { System.out.println(\u0026#34;Online pay\u0026#34;); } @Override public void doDelivery() { System.out.println(\u0026#34;write the address\u0026#34;); System.out.println(\u0026#34;pay delivery fee online\u0026#34;); } } 1 2 3 4 5 6 7 8 public static void main(String[] args) { var online = new OnlineOrder(); online.processOrder(); var store = new StoreOrder(); store.processOrder(); } 減少複製貼上（寫重複code） 的機會 一次實現算法的不變部分並將其留給子類來實現可以變化的行為。 當子類之間的共同行為應該在一個共同的類中被分解和本地化以避免代碼重複時。應該先識別現有 code 中的差異，然後區分新操作中的差異。最後，用調用這些新操作之一的模板方法替換不同的代碼。 ","permalink":"https://xinqilin.github.io/post/architecture/templatemethod/","tags":[],"title":"DesignPattern - Behavioral - Template Method"},{"content":"Decorator Decorator 的主要目的是動態地為對象附加額外的職責。Decorator 為擴展功能提供了一種靈活的替代子類的方法。\n當我們需要動態擴展對象的功能而無需更改原始類源或使用繼承時，Decorator 為我們提供了便利。這是通過在實際對象周圍創建一個稱為裝飾器的對象包裝器來實現的。\nDecorator 對象與底層對象具有相同的接口。這允許客戶端對像以與底層實際對象完全相同的方式與裝飾器對象交互。Decorator 對象包含對實際對象的引用。Decorator 對象接收來自客戶端的所有請求（調用）。反過來，它將這些調用轉發到底層對象。Decorator 對像在將請求轉發到底層對象之前或之後添加了一些附加功能。這確保了附加功能可以在運行時從外部添加到給定對象，而無需修改其結構。\n使用繼承或組合來擴展對象的行為，但這是在編譯時完成的，它適用於類的所有實例。不能在運行時添加任何新功能或刪除任何現有行為——這就是裝飾器模式出現的時候。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public interface Pc { public String buyPc(); } public class SimplePc implements Pc { @Override public String buyPc() { return \u0026#34;spend 1000\u0026#34;; } } // 裝飾器類實現了組件接口，它與組件接口具有HAS-A關係。 // 子裝飾器類應該可以訪問組件變量，因此保護這個變量。例如，下面的 IcecreamDecorator 類將在我們的例子中用作裝飾器。 public class PcDecorator implements Pc { protected Pc specialPc; public PcDecorator(Pc specialPc){ this.specialPc = specialPc; } @Override public String buyPc() { return specialPc.buyPc(); } } public class UsaDecorator extends PcDecorator { public UsaDecorator(Pc specialPc) { super(specialPc); } public String buyPc(){ return specialPc.buyPc() + addFee(); } private String addFee() { return \u0026#34; + 2000\u0026#34;; } } // 在裝飾一層 public class TaiwanDecorator extends PcDecorator { public TaiwanDecorator(Pc specialPc) { super(specialPc); } public String buyPc(){ return specialPc.buyPc() + addFee(); } private String addFee() { return \u0026#34; + 5000\u0026#34;; } } 1 2 3 4 5 public static void main(String[] args) { Pc pc = new TaiwanDecorator(new UsaDecorator(new SimplePc())); System.out.println(pc.buyPc()); } 動態且透明地向單個對象添加職責，即不影響其他對象。 對於可以撤回的責任。 當通過子分類擴展是不切實際的。有時大量的獨立擴展是可能的，並且會產生大量的子類來支持每種組合。或者一個類定義可能被隱藏或不能用於子分類。 當選擇的數量更多時，它很容易維護和擴展。 ","permalink":"https://xinqilin.github.io/post/architecture/decorator/","tags":[],"title":"DesignPattern - Structural - Decorator"},{"content":"Bridge 在接口和實現中都有接口層次結構時，使用 Bridge 設計模式將接口與實現分離，並對客戶端程序隱藏實現細節。\n根據 GoF 橋的設計模式是：將抽象與其實現分離，以便兩者可以獨立變化。\n將抽象及其實現分開，並為抽象和實現者開發單獨的繼承結構。抽像是接口或抽像類，同樣實現者是接口或抽像類。抽象包含對實現者的引用。抽象的孩子被稱為精煉抽象，實現者的孩子是具體的實現者。由於我們可以在抽像中更改對實現者的引用，因此我們可以在運行時更改抽象的實現者。但是，對實現者的更改不會影響客戶端代碼。\nBridge 的目的是將抽象和實現放入兩個不同的類層次結構中，以便兩者都可以獨立擴展。 Bridge 幫助兩個不兼容的 類一起工作。但是 Bridge 通過創建兩個不同的層次結構來分離抽象和實現。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 /** * abstraction in Bridge pattern * */ public abstract class Vehicle { protected VehicleType type1; protected VehicleType type2; public Vehicle(VehicleType type1, VehicleType type2) { this.type1 = type1; this.type2 = type2; } abstract public void purchase(); } /** * Implementor for Bridge pattern * */ public interface VehicleType { abstract public void book(); } /** * Refine abstraction 1 in Bridge pattern */ public class Car extends Vehicle { public Car(VehicleType type1, VehicleType type2) { super(type1, type2); } @Override public void purchase() { System.out.print(\u0026#34;Car\u0026#34;); type1.book(); type2.book(); } } /** * Refine abstraction 2 in Bridge pattern */ public class Bike extends Vehicle { public Bike(VehicleType type1, VehicleType type2) { super(type1, type2); } @Override public void purchase() { System.out.print(\u0026#34;Bike\u0026#34;); type1.book(); type2.book(); } } /** * Concrete implementation 1 for Bridge pattern * */ public class NewVehicle implements VehicleType { @Override public void book() { System.out.print(\u0026#34; : New Vehicle\u0026#34;); } } /** * Concrete implementation 2 for Bridge pattern * */ public class OldVehicle implements VehicleType { @Override public void book() { System.out.println(\u0026#34; : Old Vehicle\u0026#34;); } } 1 2 3 4 5 6 7 8 9 public static void main(String[] args) { Vehicle vehicle1= new Car(new NewVehicle(),new OldVehicle()); vehicle1.purchase(); Bike vehicle2 = new Bike(new NewVehicle(),new OldVehicle()); vehicle2.purchase(); } 多個實現時最好使用。 需要在運行時切換實現時應該使用。 如果抽象的實現有修改，客戶端不應該受到影響。 創建兩個不同的層次結構。一個用於抽象，另一個用於實現。 通過消除抽象和實現之間的依賴關係來避免永久綁定, 創建了一個在抽象和實現之間協調的橋樑。 抽象和實現可以分開擴展。 ","permalink":"https://xinqilin.github.io/post/architecture/bridge/","tags":[],"title":"DesignPattern - Structural - Bridge"},{"content":"Facade 為子系統中的一組 interface 提供統一的入口。Facade Pattern 定義了一個更高級別的接口，使子系統更易於使用 Facade 並沒有封裝子系統類或接口；它只是為其功能提供了一個簡化的界面。 此外，客戶端可以直接訪問這些類。它仍然為可能需要它的客戶公開系統的全部功能。簡而言之，它只是為子系統的複雜接口提供了一層，使其更易於使用。\n外觀設計模式是促進鬆散耦合的其他設計模式之一。它強調了設計中最重要的一個方面，即抽象。通過隱藏它背後的複雜性並暴露一個簡單的接口，它實現了抽象。 Facade 和 Adapter 一樣可以封裝多個類，但是 Facade 使用接口來簡化複雜接口的使用，而 Adapter 用於將接口轉換為客戶端期望的接口。 在抽象方面，中介者設計模式可能看起來與外觀設計模式非常相似。Mediator 以類似於外觀模式的方式抽象子系統的功能。然而，在中介者模式的實現中，子系統或對等點的組件都知道中介者並與之交互。但是在外觀模式的情況下，子系統不知道外觀的存在。只有外觀與子系統對話。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class Service1 { public int doSth(int x) { // 複雜的業務邏輯... return x + x; } } public class Service2 { public int doSth2(int x, int y) { // 複雜的業務邏輯... return x + y; } } public class Service3 { public int doSth3(int x, int y, double z) { // 複雜的業務邏輯... return x + y + Integer.parseInt(z); } } public class Facade { public int sum(int x) { Service1 s = new Service1(); return s.doSth(x + 1); } public int cut(int x) { Service1 s = new Service1(); Service2 s2 = new Service2(); return s.doSth(x) + s3.doSth(x, 0); } public int multiply(int x) { return Service3.doSth3(x, 2, 3.0); } } 1 2 3 4 5 6 7 8 public static void main(String[] args) { Facade facade = new Facade(); int x = 3; System.out.println(\u0026#34;Cube of \u0026#34; + x + \u0026#34;:\u0026#34; + facade.sum(100)); System.out.println(\u0026#34;Cube of \u0026#34; + x + \u0026#34; times 2:\u0026#34; + facade.cut(100)); System.out.println(x + \u0026#34; multiply class1 \u0026amp; class2 :\u0026#34; + facade.multiply(100)); } 子系統接口不知道 Facade，它們不應該有任何 Facade 接口的引用。 子系統可以相互依賴。在這種情況下，外觀可以充當協調器並解耦子系統之間的依賴關係。 外觀模式更像是客戶端應用程序的助手；它不會對客戶端隱藏子系統接口。是否使用 Facade 完全取決於客戶端代碼。 外觀模式可以應用於任何開發點，通常是在接口數量增加和系統變得複雜時。 外觀模式應該應用於類似類型的接口；它的目的是提供一個接口而不是多個接口來完成類似的工作。 可以使用帶有 Facade 的工廠模式來為客戶端系統提供更好的接口。 ","permalink":"https://xinqilin.github.io/post/architecture/facade/","tags":[],"title":"DesignPattern - Structural - Facade"},{"content":"Flyweight Flyweight 中，我們重複使用對象，而不是創建大量相似的對象。我們可以使用它來減少內存需求和實例化時間以及相關成本。\n在我們應用 Flyweight 之前，我們需要考慮以下因素：\n如果應用程序中所需的對像數量巨大。 如果對象創建佔用大量內存並且也可能很耗時。 太多的對象會降低應用程序的性能。顯然，太多的對象可能會消耗更大的內存。此外，它們可能會降低應用程序的速度，甚至可能導致內存不足問題。 在應用程序中控制它。當我們有很多相似的對象並且池中的兩個對象之間沒有太多差異時，尤其如此。 有時，應用程序中的對象可能具有很大的相似性並且屬於相似類型（此處的相似類型意味著它們的大多數屬性具有相似的值，並且只有少數屬性值不同）。如果它們也是要創建的重物，應用程序開發人員應該控制它們。否則，它們可能會消耗大量內存並最終減慢整個應用程序的速度。\nFlyweight 旨在控制此類對象的創建，並為您提供基本的緩存機制。它允許您為每種類型創建一個對象（此處的類型因該對象的屬性而異），如果您請求具有相同屬性的對象（已創建），它將返回相同的對象而不是創建一個新的對象一。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public interface Msg { public void show(String msg); } public class EmergentMsg implements Msg { private String key; EmergentMsg(String key) { this.key = key; System.out.println(\u0026#34;send \u0026#34; + key + \u0026#34; emergent msg\u0026#34;); } public void show(String msg) { System.out.println(msg); } } public class MsgFactory { private static MsgFactory FACTORY = new MsgFactory(); private static Map\u0026lt;String, Msg\u0026gt; msgs = new HashMap\u0026lt;\u0026gt;(); public static MsgFactory getInstance() { // 看要不要 double lock check return FACTORY; } public Msg getMsg(String key) { Msg msg = (Msg)msgs.get(key); if (msg != null) { System.out.println(\u0026#34;msg \u0026#34; + key + \u0026#34; exist\u0026#34;); } else { msg = new EmergentMsg(key); msgs.put(key, msg); } return msg; } } 有點像資源重複使用 maybe, service locator pattern !?\n","permalink":"https://xinqilin.github.io/post/architecture/flyweight/","tags":[],"title":"DesignPattern - Structural - Flyweight"},{"content":"Proxy Proxy pattern 為另一個對象 create a representative object that controls access to another object。 事實上，Proxy pattern 是用來創建一個代表對象來控制對另一個對象的訪問。成本高或需要保護以至於存取消費較大。\n控制對對象的訪問的一個原因是將其創建和初始化的全部成本推遲到我們真正需要使用它時。另一個原因可能是充當位於不同 JVM 中的對象的本地代表。此外，代理在控制對原始對象的訪問方面非常有用，尤其是當對象應該具有不同的訪問權限時。\n在代理設計模式中，客戶端不直接與原始對像對話，它將調用委託給代理對象，代理對象調用原始對象的方法。此外，重要的一點是客戶端不知道代理。代理充當客戶端的原始對象。但是這種方法有很多變體，我們很快就會看到。\n代理模式有三種主要變體：\nproxy 為不同 remote address 的對象提供 local access (跳板)。 A virtual proxy creates expensive objects on demand. 保護代理控制對原始對象的訪問。當對象應該具有不同的訪問權限時，保護代理很有用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class User { String userName; String password; // Getter, Setter, Constructor } public interface IFolder { public void performOperations(); } public class Folder implements IFolder { @Override public void performOperations() { // 訪問 folder 並執行各種操作 System.out.println(\u0026#34;execute sth in folder\u0026#34;); } } public class FolderProxy implements IFolder { Folder folder; User user; public FolderProxy(User user){ this.user = user; } @Override public void performOperations() { if ((\u0026#34;dev\u0026#34;).equals(user.getUserName()) \u0026amp;\u0026amp; (\u0026#34;dev\u0026#34;).equals(user.getPassword())) { folder = new Folder(); folder.performOperations(); } else { System.out.println(\u0026#34;can\u0026#39;t access this folder\u0026#34;); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) { var user = new User(\u0026#34;dev\u0026#34;, \u0026#34;dev\u0026#34;); FolderProxy folderProxy = new FolderProxy(user); folderProxy.performOperations(); System.out.println(\u0026#34;------------------------------------\u0026#34;); // if we give wrong userName and Password var userWrong = new User(\u0026#34;staging\u0026#34;, \u0026#34;staging\u0026#34;); FolderProxy folderProxyWrong = new FolderProxy(userWrong); folderProxyWrong.performOperations(); } 有一個現有的類，它的接口與您需要的不匹配。 想創建一個可重用的類，它與不相關或不可預見的類（即不一定具有兼容接口的類）協作。 有幾個現有的子類可供使用，但通過對每個子類進行子類化來調整它們的接口是不切實際的。對象 adapter 可以適配其父類的接口。 ","permalink":"https://xinqilin.github.io/post/architecture/proxy/","tags":[],"title":"DesignPattern - Structural - Proxy"},{"content":"Composite Composite 讓客戶可以統一處理單個對象和對象的組合，這就是 Composite Pattern 的意圖。 在復合模式中，存在一個樹結構，可以在葉子和節點上執行相同的操作。樹中的節點是可以有孩子的類。節點類是“複合”類。樹上的葉子是沒有孩子的“原始”類。 組合的子節點可以是葉子或其他組合。 葉類和復合類共享一個通用的 \u0026ldquo;Composite\u0026rdquo; interface，該接口定義了可以在葉和復合上執行的通用操作。當對組合執行操作時，將對組合的所有子節點執行此操作，無論它們是葉子還是組合。因此，複合模式可用於對組成樹的對象執行常見操作。\nBase Component: 是組合中所有對象的接口。客戶端程序使用基本組件來處理組合中的對象。此外，它可以是一個 interface 或 abstract class，其中包含所有對象共有的一些方法。 Leaf: 定義組合中元素的行為。它是組合的構建塊並實現基本組件。雖然，它沒有對其他組件的引用。 Composite: 它由葉元素組成，並在基本組件中實現操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 /** * Manager(Composite) * Developer(Leaf) * Employee(Component) */ public interface Employee { public void add(Employee emp); public void remove(Employee emp); public Employee getChild(int i); public String getName(); public double getSalary(); public void print(); } // 現在我們將創建 Manager (Composite)。這裡的關鍵點是所有通用方法都將其操作委託給子對象。它具有訪問和修改其子級的方法。 public class Manager implements Employee { private String name; private double salary; public Manager(String name, double salary) { this.name = name; this.salary = salary; } var employees = new ArrayList\u0026lt;Employee\u0026gt;(); @Override public void add(Employee emp) { employees.add(emp); } @Override public void remove(Employee emp) { employees.remove(emp); } @Override public Employee getChild(int i) { return employees.get(i); } @Override public String getName() { return name; } @Override public double getSalary() { return salary; } @Override public void print() { System.out.println(\u0026#34;Name = \u0026#34; + getName()); System.out.println(\u0026#34;Salary = \u0026#34; + getSalary()); System.out.println(\u0026#34;-------------\u0026#34;); Iterator\u0026lt;Employee\u0026gt; empIterator = employees.iterator(); while(empIterator.hasNext()){ var emp = empIterator.next(); emp.print(); } } } public class Manager implements Employee { private String name; private double salary; public Manager(String name, double salary) { this.name = name; this.salary = salary; } var employees = new ArrayList\u0026lt;Employee\u0026gt;(); @Override public void add(Employee emp) { employees.add(emp); } @Override public void remove(Employee emp) { employees.remove(emp); } @Override public Employee getChild(int i) { return employees.get(i); } @Override public String getName() { return name; } @Override public double getSalary() { return salary; } @Override public void print() { System.out.println(\u0026#34;Name = \u0026#34; + getName()); System.out.println(\u0026#34;Salary = \u0026#34; + getSalary()); System.out.println(\u0026#34;-------------\u0026#34;); Iterator\u0026lt;Employee\u0026gt; empIterator = employees.iterator(); while(empIterator.hasNext()){ Employee emp= empIterator.next(); emp.print(); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class CompositePatternTest { public static void main(String[] args) { Employee emp1 = new Developer(\u0026#34;Bill\u0026#34;, 10000); Employee emp2 = new Developer(\u0026#34;David\u0026#34;, 15000); Employee manager1 = new Manager(\u0026#34;Paul\u0026#34;, 25000); manager1.add(emp1); manager1.add(emp2); Employee emp3 = new Developer(\u0026#34;Lag\u0026#34;, 20000); Manager generalManager = new Manager(\u0026#34;Howard\u0026#34;, 50000); generalManager.add(emp3); generalManager.add(manager1); generalManager.print(); } } 當我們想要表示對象的部分整體層次結構時。 當我們希望客戶能夠忽略對象組合和單個對象之間的差異時。客戶端將統一對待複合結構中的所有對象。 ","permalink":"https://xinqilin.github.io/post/architecture/composite/","tags":[],"title":"DesignPattern - Structural - Composite"},{"content":"Adapter 將一個類別的介面 轉換成另一個類別的介面供客戶使用 讓介面不相容的類別可以合作\n有時，可能會出現兩個對像不適合在一起的情況，或者在代碼中更改第 3 方 API 時，可能會出現這種情況。 顯然，這是由於兩個不適合在一起的對象的接口不兼容造成的。\n正如適配器一詞所暗示的那樣，適配器設計模式 是 使兩個不相關的接口協同工作的結構設計模式之一。此外，連接這些不相關接口的對象稱為適配器，就像中介一樣。\n在適配器模式中，一個包裝類（adapter）用於將請求從它轉換到另一個類（adoptee）。實際上，適配器提供了與被收養者不直接提供的特定交互。\n適配器模式可以採用兩種形式：繼承或組合形式。在第一種形式中，“類適配器”利用繼承。類適配器擴展了被收養類並將所需的方法添加到適配器中。 這些方法可以在接口（即“目標”接口）中聲明。但是，在第二種形式中；\u0026ldquo;對象 adapter\u0026rdquo; 利用組合。對象 adapter 包含被收養者並實現目標接口以與被收養者交互。\nClient: 你使用Target介面 Target: 定義 User 所呼叫的 interface Adaptor(core): 將 Adaptee 轉換成要用的介面 Adaptee: 需要被轉換的介面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Apple { public void getAppleColor(String color){ System.out.println(\u0026#34;Apple color is : \u0026#34; +color); } } public class Orange { public void getOrangeColor(String color){ System.out.println(\u0026#34;Orange color is : \u0026#34; +color); } } public class AppleAdapter extends Apple { //The purpose of the sample problem is to adapt an orange as an apple. private Orange orange; // This is the main logic of Adapter pattern public AppleAdapter(Orange orange){ this.orange = orange; } public void getColor(String color){ orange.getOrangeColor(color); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 public class AdapterPatternTest { public static void main(String[] args) { Apple apple = new Apple(); apple.getAppleColor(\u0026#34;green\u0026#34;); Orange orange = new Orange(); AppleAdapter adapter = new AppleAdapter(orange); adapter.getAppleColor(\u0026#34;red\u0026#34;); } } 有一個現有的類，它的接口與需要的不匹配。 想要創建一個可重用的類，它與不相關或不可預見的類（即不一定具有兼容接口的類）協作。 有幾個現有的子類可供使用，但通過對每個子類進行子類化來調整它們的接口是不切實際的。對象適配器可以適配其父類的接口。 more sample Adapter 模式將 Adaptee 類別的 specificRequest() 方法包裝成 Target 接口的 request() 方法。\nClient 類別可以通過呼叫 Target 接口的 request() 方法來發送請求，而不用知道底層使用的是 Adaptee 類別的 specificRequest() 方法。\n通過使用 Adapter 模式，我們可以讓不兼容的類別一起工作，這對於在現有系統中加入新功能非常有用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // Target interface public interface Target { void request(); } // Adaptee class public class Adaptee { public void specificRequest() { // Perform some specific request } } // Adapter class public class Adapter implements Target { private Adaptee adaptee; public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } @Override public void request() { adaptee.specificRequest(); } } // Client public class Client { public void makeRequest(Target target) { target.request(); } } // Usage Adaptee adaptee = new Adaptee(); Target target = new Adapter(adaptee); Client client = new Client(); client.makeRequest(target); ","permalink":"https://xinqilin.github.io/post/architecture/adapter/","tags":[],"title":"DesignPattern - Structural - Adapter"},{"content":"Prototype 一種對象創建機制。\n假設有一個從 DB 加載數據的對象。現在，我們需要在程序中多次修改這些數據。因此，使用 new 關鍵字創建對象並再次從數據庫中加載所有數據並不是一個好主意。因此，更好的方法是將現有對象 clone 為新對象，然後進行數據操作。\n但是，原型設計模式要求您正在復制的對象應提供複製功能。顯然，它不應該由任何其他類來完成。但是，是使用 Object 屬性的淺拷貝還是深拷貝取決於需求，這是一個設計決定。\n例如，讓我們看看這有什麼用處。如果創建原始對象時使用的資源（例如數據流）在需要對象克隆時可能不可用。另一個例子是，如果原始對象創建涉及大量時間投入，例如從數據庫或通過網絡讀取數據。\nobject clone 利用 clone() 方法和 implements Cloneable interface。默認情況下，clone() 執行淺拷貝。此外，Serializable 可用於簡化深度複製。 BTW, 可以實現自己的原型模式。為此，創建一個具有 doClone () 方法的 Prototype 接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Pc implements Cloneable { private String keyboard; private String mouse; private String screen; public Pc() { keyboard = \u0026#34;機械\u0026#34;; mouse = \u0026#34;羅技\u0026#34;; screen = \u0026#34;Dell\u0026#34;; } public Pc clone(){ return new Pc(); } public void makeAmericaStyle(){ keyboard = \u0026#34;Magic Keyboard\u0026#34;; mouse = \u0026#34;Apple Mouse\u0026#34;; screen = \u0026#34;Apple Screen\u0026#34;; } public String getMouse(){ return mouse; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class PrototypeTest { public Bike getUSAPc(Pc basicPc){ pc.makeAmericaStyle(); return basicBike; } public static void main(String[] args) { Pc pc = new Pc(); Pc basicPc = pc.clone(); PrototypeTest prototype = new PrototypeTest(); Pc americaPc = prototype.getUSAPc(basicPc); System.out.println(\u0026#34;overwrite method \u0026#34; + americaPc.getMouse()); System.out.println(\u0026#34;all attribute\u0026#34; + americaPc.toString()); } } 當在運行時指定要實例化的類時，例如，通過動態加載 避免建立與產品類層次結構平行的工廠類層次結構 當類的實例可以具有僅有的幾種不同狀態組合之一時。但是，安裝相應數量的原型並克隆它們可能更方便，而不是每次使用適當的狀態手動實例化類。 ","permalink":"https://xinqilin.github.io/post/architecture/prototype/","tags":[],"title":"DesignPattern - Basic - Prototype"},{"content":"Builder 對象構造的細節，實例化和初始化構成對象的組件，都保存在對像中，通常作為其構造函數的一部分。這種類型的設計將對象構造過程與構成對象的組件緊密聯繫在一起。但是，只要構造對像簡單，對象構造過程明確，並且總是產生對象的相同表示，這種方法就適用。\n此外，當被創建的對像很複雜並且構成對象創建過程的一系列步驟可以以不同的方式實現時，這種設計可能無效。因此，產生對象的不同表示。因為構造過程的不同實現都保存在對像中，所以對象可能變得龐大（構造膨脹）並且模塊化程度較低。隨後，添加新實現或更改現有實現需要更改現有代碼。\nBuilder 的目的是將復雜對象的構造與其表示分離，以便相同的構造過程可以創建不同的表示。這種類型的分離減小了對象的大小。該設計變得更加模塊化，每個實現都包含在不同的構建器對像中。因此，添加一個新的實現（即添加一個新的構建器）變得更容易了。此外，對象構造過程變得獨立於構成對象的組件。這提供了對對象構造過程的更多控制。\n它指定了一個抽象接口，用於創建 Product 對象的各個部分。構建器模式建議將構建邏輯從對像類移到一個單獨的類，稱為構建器類。但是，可以有多個這樣的構建器類，每個構建器類對於構建對象的一系列步驟都有不同的實現。此外，每個構建器實現都會導致對象的不同表示。\nConcreteBuilder 通過實現 Builder 接口來構造和組裝產品的各個部分。 定義並跟踪它創建的表示。 提供用於檢索產品的接口。 Director 它使用 Builder 接口構造一個對象。Builder 模式建議使用稱為 Director 的專用對象，它負責調用構建最終對象所需的不同構建器方法。此外，不同的客戶端對象可以利用 Director 對象來創建所需的對象。一旦構造了對象，客戶端對象就可以直接向構造器請求完整構造的對象。為了方便這個過程，可以在公共Builder接口中聲明一個新方法getObject()，由不同的具體builder實現。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public interface PcBuilder { public void buildKeyboard(); public void buildMouse(); public void buildScreen(); public Pc getPc(); } public class Pc { private String keyboard; private String mouse; private String screen; // Getter / Setter / toString method } public class AcerPcBuilder implements PcBuilder { Pc pc; public AcerPcBuilder(){ pc = new Pc(); } @Override public void buildKeyboard() { pc.setKeyboard(\u0026#34;Acer keyyyyyyyyy\u0026#34;); } @Override public void buildMouse() { pc.setMouse(\u0026#34;Acer micky mouse\u0026#34;); } @Override public void buildScreen() { pc.setScreen(\u0026#34;Acer 24 inch screen\u0026#34;); } @Override public Pc getPc() { return pc; } } Director\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class PcDirector { private PcDirector pcDirector = null; public PcDirector(PcBuilder pcBuilder) { this.pcBuilder = pcBuilder; } public void constructPc() { pcBuilder.buildKeyboard(); pcBuilder.buildMouse(); pcBuilder.buildScreen(); } public Meal getPc(){ return pcBuilder.getPc(); } } 1 2 3 4 5 6 7 8 9 10 public static void main(String[] args) { PcBuilder acerPcBuilder = new AcerPcBuilder(); PcDirector pcDirector = new PcDirector(acerPcBuilder); pcDirector.constructPc(); Pc pc = pcDirector.getPc(); log.info(\u0026#34;acer pc builder ~\u0026#34;); } 其他版本 Builder 有一個具有一長串屬性的對象。這些屬性中的大多數都是可選的。 用戶不是直接創建所需的對象，而是調用具有所有必需參數的構造函數並獲取構建器對象。然後，用戶在構建器對像上調用類似 setter 的方法來設置每個感興趣的可選參數。最後，用戶調用無參數構建方法來生成對象。\n需要創建一個靜態類，然後將所有參數從外部類複製到 Builder 類。 接下來，Builder 類應該有一個公共構造函數，其中包含所有必需的屬性作為參數。 Builder 類應該具有設置可選參數的方法，並且在設置可選屬性後它應該返回相同的 Builder 對象。 最後，我們需要在構建器類中提供一個 build() 方法，該方法將返回客戶端程序所需的 Object。 為了做到這一點，需要在 Class 中有一個以 Builder 類作為參數的私有構造函數。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class Pc{ private final String keyboard; private final String mouse; private final String screen; private final int screenCount; private final double price; // in real case, you should use BigDecimal XD public static class Builder { private String keyboard; private String mouse; private String screen; private int screenCount; private double price; //builder methods for setter public Builder keyboard(String keyboard){this.keyboard = keyboard; return this; } public Builder mouse(String mouse){this.butter = cup; return this; } public Builder screen(String screen){this.eggs = number; return this; } public Builder screenCount(int screenCount){this.vanila = spoon; return this; } public Builder price(double price){this.flour = cup; return this; } // already build object public Pc build() { return new Pc(this); } } //private constructor to enforce object creation through builder private Pc(Builder builder) { this.keyboard = builder.keyboard; this.mouse = builder.mouse; this.screen = builder.screen; this.screenCount = builder.screenCount; this.price = builder.price; } } 1 2 3 4 5 6 7 8 public static void main(String[] args) { Pc pc = new Pc.Builder().keyboard(\u0026#34;機械鍵盤\u0026#34;).mouse(\u0026#34;羅技\u0026#34;).screen(\u0026#34;Dell\u0026#34;).build(); log.info(\u0026#34;pc: {}\u0026#34;, pc); } 何時創建複雜對象的算法應該獨立於構成對象的部分以及它們的組裝方式。 當構造過程必須允許構造對象的不同表示時。 ","permalink":"https://xinqilin.github.io/post/architecture/builder/","tags":[],"title":"DesignPattern  - Basic - Builder"},{"content":"Factory 一個具有多個子類的父類別並且基於輸入，我們需要返回其中一個子類時，使用工廠設計模式。這種模式將類從客戶端程序實例化到工廠類的責任。 工廠模式中的超類可以是 interface，也可以是 abstract class，也可以是普通的 Java class。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public interface ICellPhone { public void open(); public void close(); public void call(); } public class ApplePhone implements ICellPhone { @Override public void open() { System.out.println(\u0026#34;apple open\u0026#34;); } @Override public void close() { System.out.println(\u0026#34;apple close\u0026#34;); } @Override public void call() { System.out.println(\u0026#34;apple phone call David\u0026#34;); } } public class SamsungPhone implements ICellPhone { @Override public void open() { // ... } @Override public void close() { // ... } @Override public void call() { // ... } } Factory\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class CellPhoneFactory { public CellPhoneFactory(){ } ICellPhone createCellPhone(String type){ ICellPhone cellPhone = null; if(\u0026#34;apple\u0026#34;.equalsIgnoreCase(type)){ cellPhone = new ApplePhone(); System.out.println(\u0026#34;apple cell phone created\u0026#34;); }else if(\u0026#34;samsung\u0026#34;.equalsIgnoreCase(type)){ cellPhone = new SamsungPhone(); System.out.println(\u0026#34;three start cell phone created\u0026#34;); } return cellPhone; } } 1 2 3 4 5 6 7 8 9 10 public static void main(String[] args) { var factory = new CellPhoneFactory(); ApplePhone apple = (ApplePhone)factory.createCellPhone(\u0026#34;apple\u0026#34;); len.open(); SamsungPhone threeStarts = (SamsungPhone)factory.createCellPhone(\u0026#34;samsung\u0026#34;); sam.close(); } 小節\n工廠模式為接口而不是實現提供了一種代碼方法。 工廠模式從客戶端代碼中刪除了實際實現類的實例化，使其更健壯、耦合更少且易於擴展。例如，我們可以很容易地更改類的實現，因為客戶端不知道它。 工廠模式還通過繼承在實現類和客戶端類之間提供抽象。 Abstract Factory 幾乎類似於 工廠模式，除了它更像工廠的工廠。 一個 Factory 類，它根據提供的輸入返回不同的子類。通常，工廠類使用 if-else 或 switch-case 語句來實現這一點。 但是，在抽象工廠模式中，擺脫了 if-else 塊，並為每個子類創建了一個工廠類，然後是一個抽象工廠類，該類將根據輸入工廠類返回子類。\n實際上，抽象工廠就是返回工廠的工廠。為什麼這個抽象層有用？普通工廠可用於創建相關對象集。抽象工廠返回工廠。因此，抽象工廠用於返回可用於創建相關對象集的工廠。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public interface ICellPhoneFactory { ICellPhoneFactory createPhone(String type); } // 抽象工廠 =\u0026gt; 生產工廠 public class CellPhoneFactory implements ICellPhoneFactory { @Override ICellPhoneFactory createPhone(String type){ ICellPhoneFactory cellPhoneFactory = null; if(\u0026#34;apple\u0026#34;.equalsIgnoreCase(type)){ cellPhoneFactory = new AppleCellPhoneFactory(); System.out.println(\u0026#34;apple factory created\u0026#34;); }else if(\u0026#34;samsung\u0026#34;.equalsIgnoreCase(type)){ cellPhoneFactory = new AppleCellPhoneFactory(); System.out.println(\u0026#34;three start factory created\u0026#34;); } return cellPhone; } } 1 2 3 4 5 6 7 public class AppleCellPhoneFactory extends CellPhoneFactory { AppleCellPhone createApplePhone(){ return new AppleCellPhone(); } } 1 2 3 4 5 6 7 8 9 10 public class AbstractFactoryTest { public static void main(String[] args) { CellPhoneFactory factory = new CellPhoneFactory(); AppleCellPhoneFactory apple = (AppleCellPhoneFactory)factory.createPhone(\u0026#34;apple\u0026#34;); AppleCellPhone apple = (AppleCellPhone)apple.createApplePhone(); apple.call(); } } 抽象工廠模式還提供了一種為接口而不是實現編寫代碼的方法。 工廠模式是 \u0026ldquo;工廠中的工廠\u0026rdquo;，可以輕鬆擴展以容納更多產品。例如，可以添加另一個子類 \u0026ldquo;HTC\u0026rdquo; 和工廠 \u0026ldquo;TwCellPhoneFactory\u0026rdquo;。 抽象工廠模式是強大的，它消除了與工廠模式不同的條件邏輯。 ","permalink":"https://xinqilin.github.io/post/architecture/factory/","tags":[],"title":"DesignPattern - Basic - Factory"},{"content":"概述 Singleton（單例模式）是最常見的創建型設計模式之一，它確保一個類別在整個應用程式生命週期中只有一個實例存在，並提供全域訪問點。這個模式廣泛應用於資料庫連線池、日志記錄器、快取管理器、設定管理器等場景。\n單例模式的核心特徵 唯一實例：確保類別只有一個實例 全域訪問：提供全域訪問該實例的方法 自我實例化：類別自己負責創建和管理實例 延遲初始化：通常在首次需要時才創建實例 傳統實作方式 1. 餓漢式（Eager Initialization） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * 餓漢式單例 - 類別載入時立即創建實例 * 優點：執行緒安全、實作簡單 * 缺點：不管是否使用都會創建實例，可能造成資源浪費 */ public class EagerSingleton { // 在類別載入時就創建實例 private static final EagerSingleton INSTANCE = new EagerSingleton(); // 私有建構子防止外部實例化 private EagerSingleton() { // 防止反射攻擊 if (INSTANCE != null) { throw new IllegalStateException(\u0026#34;單例已存在，不能創建新實例\u0026#34;); } System.out.println(\u0026#34;EagerSingleton 實例創建\u0026#34;); } public static EagerSingleton getInstance() { return INSTANCE; } // 業務方法範例 public void doSomething() { System.out.println(\u0026#34;執行 EagerSingleton 業務邏輯\u0026#34;); } // 防止克隆攻擊 @Override protected Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(\u0026#34;單例不支援克隆\u0026#34;); } // 防止序列化攻擊 private Object readResolve() { return INSTANCE; } } 2. 懶漢式（Lazy Initialization） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 懶漢式單例 - 延遲創建實例 * 問題：執行緒不安全 */ public class LazySingleton { private static LazySingleton instance; private LazySingleton() { System.out.println(\u0026#34;LazySingleton 實例創建\u0026#34;); } // ❌ 執行緒不安全的實作 public static LazySingleton getInstance() { if (instance == null) { instance = new LazySingleton(); } return instance; } } 3. 執行緒安全的懶漢式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * 執行緒安全的懶漢式單例 * 優點：執行緒安全、延遲初始化 * 缺點：性能開銷大（每次訪問都需要同步） */ public class ThreadSafeLazySingleton { private static ThreadSafeLazySingleton instance; private ThreadSafeLazySingleton() { System.out.println(\u0026#34;ThreadSafeLazySingleton 實例創建\u0026#34;); } // ❌ 性能較差的同步方法 public static synchronized ThreadSafeLazySingleton getInstance() { if (instance == null) { instance = new ThreadSafeLazySingleton(); } return instance; } } 推薦的現代化實作方式 1. Double-Checked Locking（雙重檢查鎖定） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 /** * 雙重檢查鎖定單例 * 優點：執行緒安全、性能好、延遲初始化 * 推薦：現代 Java 應用的標準實作 */ public class DoubleCheckedSingleton { // volatile 關鍵字確保可見性和禁止指令重排序 private static volatile DoubleCheckedSingleton instance; private DoubleCheckedSingleton() { // 防止反射攻擊 if (instance != null) { throw new IllegalStateException(\u0026#34;單例已存在，不能創建新實例\u0026#34;); } // 模擬複雜的初始化過程 try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } System.out.println(\u0026#34;DoubleCheckedSingleton 實例創建\u0026#34;); } public static DoubleCheckedSingleton getInstance() { // 第一次檢查：避免不必要的同步 if (instance == null) { synchronized (DoubleCheckedSingleton.class) { // 第二次檢查：確保只創建一個實例 if (instance == null) { instance = new DoubleCheckedSingleton(); } } } return instance; } public void performOperation() { System.out.println(\u0026#34;執行 DoubleCheckedSingleton 操作\u0026#34;); } // 防止克隆攻擊 @Override protected Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(\u0026#34;單例不支援克隆\u0026#34;); } // 防止序列化攻擊 private Object readResolve() { return instance; } } 2. 靜態內部類別（Initialization-on-demand Holder） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * 靜態內部類別單例 * 優點：執行緒安全、延遲初始化、性能最佳、程式碼簡潔 * 推薦：最優雅的實作方式 */ public class StaticHolderSingleton { private StaticHolderSingleton() { System.out.println(\u0026#34;StaticHolderSingleton 實例創建\u0026#34;); } // 靜態內部類別，只有在被引用時才會載入 private static class SingletonHolder { private static final StaticHolderSingleton INSTANCE = new StaticHolderSingleton(); } public static StaticHolderSingleton getInstance() { return SingletonHolder.INSTANCE; } public void executeTask() { System.out.println(\u0026#34;執行 StaticHolderSingleton 任務\u0026#34;); } } 3. 枚舉單例（推薦） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * 枚舉單例 * 優點：執行緒安全、防止反射和序列化攻擊、程式碼最簡潔 * 推薦：Joshua Bloch 推薦的最佳實作方式 */ public enum EnumSingleton { INSTANCE; // 實例變數 private String data; // 建構子（枚舉的建構子總是私有的） EnumSingleton() { this.data = \u0026#34;EnumSingleton 初始化資料\u0026#34;; System.out.println(\u0026#34;EnumSingleton 實例創建\u0026#34;); } // 業務方法 public void setData(String data) { this.data = data; } public String getData() { return data; } public void processData() { System.out.println(\u0026#34;處理資料: \u0026#34; + data); } // 可以實作介面 public void performAction() { System.out.println(\u0026#34;執行 EnumSingleton 動作\u0026#34;); } } // 使用範例 class EnumSingletonExample { public static void main(String[] args) { EnumSingleton singleton = EnumSingleton.INSTANCE; singleton.setData(\u0026#34;更新的資料\u0026#34;); singleton.processData(); } } 實際應用範例 1. 資料庫連線管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /** * 資料庫連線管理器單例 * 使用靜態內部類別實作 */ public class DatabaseManager { private final HikariDataSource dataSource; private DatabaseManager() { // 初始化連線池配置 HikariConfig config = new HikariConfig(); config.setJdbcUrl(\u0026#34;jdbc:mysql://localhost:3306/mydb\u0026#34;); config.setUsername(\u0026#34;user\u0026#34;); config.setPassword(\u0026#34;password\u0026#34;); config.setMaximumPoolSize(20); config.setMinimumIdle(5); config.setConnectionTimeout(30000); config.setIdleTimeout(600000); config.setMaxLifetime(1800000); this.dataSource = new HikariDataSource(config); System.out.println(\u0026#34;資料庫連線池初始化完成\u0026#34;); } private static class Holder { private static final DatabaseManager INSTANCE = new DatabaseManager(); } public static DatabaseManager getInstance() { return Holder.INSTANCE; } public Connection getConnection() throws SQLException { return dataSource.getConnection(); } public void closeDataSource() { if (dataSource != null \u0026amp;\u0026amp; !dataSource.isClosed()) { dataSource.close(); System.out.println(\u0026#34;資料庫連線池已關閉\u0026#34;); } } // JVM 關閉時清理資源 static { Runtime.getRuntime().addShutdownHook(new Thread(() -\u0026gt; { DatabaseManager.getInstance().closeDataSource(); })); } } 2. 應用程式設定管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 /** * 應用程式設定管理器 * 使用枚舉實作，支援動態設定更新 */ public enum ConfigurationManager { INSTANCE; private final Properties properties; private final Map\u0026lt;String, Object\u0026gt; runtimeConfig; private final ReadWriteLock lock; ConfigurationManager() { this.properties = new Properties(); this.runtimeConfig = new ConcurrentHashMap\u0026lt;\u0026gt;(); this.lock = new ReentrantReadWriteLock(); loadConfiguration(); } private void loadConfiguration() { try (InputStream input = getClass().getClassLoader() .getResourceAsStream(\u0026#34;application.properties\u0026#34;)) { if (input != null) { properties.load(input); System.out.println(\u0026#34;設定檔載入完成\u0026#34;); } else { System.out.println(\u0026#34;找不到設定檔，使用預設設定\u0026#34;); loadDefaultConfiguration(); } } catch (IOException e) { System.err.println(\u0026#34;載入設定檔失敗: \u0026#34; + e.getMessage()); loadDefaultConfiguration(); } } private void loadDefaultConfiguration() { properties.setProperty(\u0026#34;app.name\u0026#34;, \u0026#34;MyApplication\u0026#34;); properties.setProperty(\u0026#34;app.version\u0026#34;, \u0026#34;1.0.0\u0026#34;); properties.setProperty(\u0026#34;app.environment\u0026#34;, \u0026#34;development\u0026#34;); properties.setProperty(\u0026#34;database.pool.max\u0026#34;, \u0026#34;20\u0026#34;); properties.setProperty(\u0026#34;cache.ttl\u0026#34;, \u0026#34;3600\u0026#34;); } public String getProperty(String key) { lock.readLock().lock(); try { return properties.getProperty(key); } finally { lock.readLock().unlock(); } } public String getProperty(String key, String defaultValue) { lock.readLock().lock(); try { return properties.getProperty(key, defaultValue); } finally { lock.readLock().unlock(); } } public void setProperty(String key, String value) { lock.writeLock().lock(); try { properties.setProperty(key, value); System.out.println(\u0026#34;設定已更新: \u0026#34; + key + \u0026#34; = \u0026#34; + value); } finally { lock.writeLock().unlock(); } } public int getIntProperty(String key, int defaultValue) { try { String value = getProperty(key); return value != null ? Integer.parseInt(value) : defaultValue; } catch (NumberFormatException e) { return defaultValue; } } public boolean getBooleanProperty(String key, boolean defaultValue) { String value = getProperty(key); return value != null ? Boolean.parseBoolean(value) : defaultValue; } // 執行時設定（不會持久化） public void setRuntimeConfig(String key, Object value) { runtimeConfig.put(key, value); } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T\u0026gt; T getRuntimeConfig(String key, Class\u0026lt;T\u0026gt; type, T defaultValue) { Object value = runtimeConfig.get(key); return type.isInstance(value) ? (T) value : defaultValue; } public void reloadConfiguration() { lock.writeLock().lock(); try { properties.clear(); loadConfiguration(); System.out.println(\u0026#34;設定已重新載入\u0026#34;); } finally { lock.writeLock().unlock(); } } public Map\u0026lt;String, String\u0026gt; getAllProperties() { lock.readLock().lock(); try { Map\u0026lt;String, String\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); for (String key : properties.stringPropertyNames()) { result.put(key, properties.getProperty(key)); } return result; } finally { lock.readLock().unlock(); } } } 3. 日志管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 /** * 自訂日志管理器單例 * 使用雙重檢查鎖定實作 */ public class LoggerManager { private static volatile LoggerManager instance; private final Map\u0026lt;String, Logger\u0026gt; loggers; private final String logLevel; private final boolean enableConsoleOutput; private final String logFilePath; private LoggerManager() { this.loggers = new ConcurrentHashMap\u0026lt;\u0026gt;(); // 從設定管理器獲取設定 ConfigurationManager config = ConfigurationManager.INSTANCE; this.logLevel = config.getProperty(\u0026#34;log.level\u0026#34;, \u0026#34;INFO\u0026#34;); this.enableConsoleOutput = config.getBooleanProperty(\u0026#34;log.console.enabled\u0026#34;, true); this.logFilePath = config.getProperty(\u0026#34;log.file.path\u0026#34;, \u0026#34;logs/application.log\u0026#34;); initializeLoggers(); System.out.println(\u0026#34;日志管理器初始化完成\u0026#34;); } public static LoggerManager getInstance() { if (instance == null) { synchronized (LoggerManager.class) { if (instance == null) { instance = new LoggerManager(); } } } return instance; } private void initializeLoggers() { // 初始化預設日志記錄器 createLogger(\u0026#34;DEFAULT\u0026#34;); createLogger(\u0026#34;DATABASE\u0026#34;); createLogger(\u0026#34;SECURITY\u0026#34;); createLogger(\u0026#34;PERFORMANCE\u0026#34;); } public Logger getLogger(String name) { return loggers.computeIfAbsent(name, this::createLogger); } private Logger createLogger(String name) { Logger logger = LoggerFactory.getLogger(name); // 這裡可以根據需要配置 logger 的 appender 和 level // 實際應用中通常使用 logback.xml 或 log4j2.xml 配置 System.out.println(\u0026#34;創建 Logger: \u0026#34; + name); return logger; } public void logInfo(String loggerName, String message) { getLogger(loggerName).info(message); } public void logError(String loggerName, String message, Throwable throwable) { getLogger(loggerName).error(message, throwable); } public void logDebug(String loggerName, String message) { getLogger(loggerName).debug(message); } public void logWarn(String loggerName, String message) { getLogger(loggerName).warn(message); } // 獲取所有 logger 的統計資訊 public Map\u0026lt;String, String\u0026gt; getLoggerStats() { Map\u0026lt;String, String\u0026gt; stats = new HashMap\u0026lt;\u0026gt;(); stats.put(\u0026#34;totalLoggers\u0026#34;, String.valueOf(loggers.size())); stats.put(\u0026#34;logLevel\u0026#34;, logLevel); stats.put(\u0026#34;consoleOutput\u0026#34;, String.valueOf(enableConsoleOutput)); stats.put(\u0026#34;logFilePath\u0026#34;, logFilePath); return stats; } } Spring 框架中的單例模式 1. Spring Bean 的單例作用域 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /** * Spring 中的單例 Bean * Spring 預設使用單例作用域管理 Bean */ @Component @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON) // 預設值，可省略 public class SpringSingletonService { private final String instanceId; private final LocalDateTime createdAt; public SpringSingletonService() { this.instanceId = UUID.randomUUID().toString(); this.createdAt = LocalDateTime.now(); System.out.println(\u0026#34;SpringSingletonService 實例創建: \u0026#34; + instanceId); } public String getInstanceInfo() { return String.format(\u0026#34;實例ID: %s, 創建時間: %s\u0026#34;, instanceId, createdAt); } @PostConstruct private void init() { System.out.println(\u0026#34;SpringSingletonService 初始化完成\u0026#34;); } @PreDestroy private void destroy() { System.out.println(\u0026#34;SpringSingletonService 銷毀: \u0026#34; + instanceId); } } /** * 使用 @Configuration 和 @Bean 註解創建單例 */ @Configuration public class SingletonBeanConfiguration { @Bean @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON) public CacheManager cacheManager() { return new ConcurrentMapCacheManager(\u0026#34;users\u0026#34;, \u0026#34;products\u0026#34;, \u0026#34;orders\u0026#34;); } @Bean public TaskExecutor taskExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(5); executor.setMaxPoolSize(20); executor.setQueueCapacity(100); executor.setThreadNamePrefix(\u0026#34;App-\u0026#34;); executor.initialize(); return executor; } } 2. Spring Boot 中的單例服務 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Spring Boot 中的單例服務範例 */ @Service public class UserService { private final UserRepository userRepository; private final CacheManager cacheManager; private final String serviceId; public UserService(UserRepository userRepository, CacheManager cacheManager) { this.userRepository = userRepository; this.cacheManager = cacheManager; this.serviceId = UUID.randomUUID().toString(); System.out.println(\u0026#34;UserService 單例創建: \u0026#34; + serviceId); } @Cacheable(\u0026#34;users\u0026#34;) public User findById(Long id) { System.out.println(\u0026#34;從資料庫載入用戶: \u0026#34; + id); return userRepository.findById(id).orElse(null); } @CacheEvict(value = \u0026#34;users\u0026#34;, key = \u0026#34;#user.id\u0026#34;) public User save(User user) { return userRepository.save(user); } public String getServiceInfo() { return \u0026#34;UserService 實例ID: \u0026#34; + serviceId; } } 單例模式的潛在問題與解決方案 1. 反射攻擊防護 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /** * 防範反射攻擊的單例實作 */ public class ReflectionSafeSingleton { private static volatile ReflectionSafeSingleton instance; private static boolean instanceCreated = false; private ReflectionSafeSingleton() { synchronized (ReflectionSafeSingleton.class) { if (instanceCreated) { throw new IllegalStateException(\u0026#34;單例已存在，禁止透過反射創建新實例\u0026#34;); } instanceCreated = true; } System.out.println(\u0026#34;ReflectionSafeSingleton 實例創建\u0026#34;); } public static ReflectionSafeSingleton getInstance() { if (instance == null) { synchronized (ReflectionSafeSingleton.class) { if (instance == null) { instance = new ReflectionSafeSingleton(); } } } return instance; } } // 測試反射攻擊 class ReflectionAttackTest { public static void main(String[] args) { try { ReflectionSafeSingleton singleton1 = ReflectionSafeSingleton.getInstance(); Constructor\u0026lt;ReflectionSafeSingleton\u0026gt; constructor = ReflectionSafeSingleton.class.getDeclaredConstructor(); constructor.setAccessible(true); // 這裡會拋出 IllegalStateException ReflectionSafeSingleton singleton2 = constructor.newInstance(); } catch (Exception e) { System.out.println(\u0026#34;反射攻擊被阻止: \u0026#34; + e.getMessage()); } } } 2. 序列化攻擊防護 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * 防範序列化攻擊的單例實作 */ public class SerializationSafeSingleton implements Serializable { private static final long serialVersionUID = 1L; private static volatile SerializationSafeSingleton instance; private SerializationSafeSingleton() { System.out.println(\u0026#34;SerializationSafeSingleton 實例創建\u0026#34;); } public static SerializationSafeSingleton getInstance() { if (instance == null) { synchronized (SerializationSafeSingleton.class) { if (instance == null) { instance = new SerializationSafeSingleton(); } } } return instance; } // 防止序列化攻擊的關鍵方法 private Object readResolve() { return getInstance(); } // 可選：自訂序列化邏輯 private void writeObject(ObjectOutputStream out) throws IOException { out.defaultWriteObject(); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); } } 3. 多執行緒測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * 多執行緒環境下的單例測試 */ public class SingletonThreadTest { public static void main(String[] args) throws InterruptedException { final int threadCount = 1000; final CountDownLatch startLatch = new CountDownLatch(1); final CountDownLatch endLatch = new CountDownLatch(threadCount); final Set\u0026lt;Integer\u0026gt; instanceHashCodes = ConcurrentHashMap.newKeySet(); // 創建多個執行緒同時獲取單例 for (int i = 0; i \u0026lt; threadCount; i++) { new Thread(() -\u0026gt; { try { startLatch.await(); // 等待開始信號 // 測試不同的單例實作 DoubleCheckedSingleton instance1 = DoubleCheckedSingleton.getInstance(); StaticHolderSingleton instance2 = StaticHolderSingleton.getInstance(); EnumSingleton instance3 = EnumSingleton.INSTANCE; instanceHashCodes.add(System.identityHashCode(instance1)); instanceHashCodes.add(System.identityHashCode(instance2)); instanceHashCodes.add(System.identityHashCode(instance3)); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } finally { endLatch.countDown(); } }).start(); } System.out.println(\u0026#34;開始多執行緒單例測試...\u0026#34;); startLatch.countDown(); // 發出開始信號 endLatch.await(); // 等待所有執行緒完成 System.out.println(\u0026#34;測試完成\u0026#34;); System.out.println(\u0026#34;DoubleCheckedSingleton 不同實例數量: \u0026#34; + (instanceHashCodes.size() \u0026gt;= 3 ? \u0026#34;3 個（正常）\u0026#34; : \u0026#34;異常\u0026#34;)); } } 單例模式的效能比較 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /** * 不同單例實作的效能測試 */ public class SingletonPerformanceTest { private static final int ITERATIONS = 10_000_000; public static void main(String[] args) { // 預熱 JVM warmUp(); // 測試不同實作的效能 testEagerSingleton(); testDoubleCheckedSingleton(); testStaticHolderSingleton(); testEnumSingleton(); } private static void warmUp() { for (int i = 0; i \u0026lt; 100_000; i++) { EagerSingleton.getInstance(); DoubleCheckedSingleton.getInstance(); StaticHolderSingleton.getInstance(); EnumSingleton.INSTANCE.getData(); } } private static void testEagerSingleton() { long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; ITERATIONS; i++) { EagerSingleton.getInstance(); } long endTime = System.nanoTime(); System.out.printf(\u0026#34;EagerSingleton: %.2f ms%n\u0026#34;, (endTime - startTime) / 1_000_000.0); } private static void testDoubleCheckedSingleton() { long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; ITERATIONS; i++) { DoubleCheckedSingleton.getInstance(); } long endTime = System.nanoTime(); System.out.printf(\u0026#34;DoubleCheckedSingleton: %.2f ms%n\u0026#34;, (endTime - startTime) / 1_000_000.0); } private static void testStaticHolderSingleton() { long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; ITERATIONS; i++) { StaticHolderSingleton.getInstance(); } long endTime = System.nanoTime(); System.out.printf(\u0026#34;StaticHolderSingleton: %.2f ms%n\u0026#34;, (endTime - startTime) / 1_000_000.0); } private static void testEnumSingleton() { long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; ITERATIONS; i++) { EnumSingleton.INSTANCE.getData(); } long endTime = System.nanoTime(); System.out.printf(\u0026#34;EnumSingleton: %.2f ms%n\u0026#34;, (endTime - startTime) / 1_000_000.0); } } 總結與最佳實踐 推薦的實作方式 枚舉單例：適合大多數情況，最安全、最簡潔 靜態內部類別：適合需要延遲初始化的場景 雙重檢查鎖定：適合複雜初始化邏輯的場景 選擇指南 場景 推薦實作 原因 一般用途 枚舉單例 最安全、最簡潔 Spring 應用 Spring Bean 框架管理生命週期 延遲初始化 靜態內部類別 性能最佳、執行緒安全 複雜初始化 雙重檢查鎖定 靈活性高 簡單場景 餓漢式 實作簡單 注意事項 避免過度使用：單例會增加程式碼的耦合度 考慮測試性：單例可能影響單元測試的獨立性 執行緒安全：確保在多執行緒環境下的正確性 資源清理：適當時候釋放單例持有的資源 序列化考慮：實作 readResolve() 方法防止序列化攻擊 現代替代方案 在現代應用開發中，可以考慮以下替代方案：\n依賴注入容器：如 Spring IoC 容器 靜態工廠方法：提供更好的測試性 Builder 模式：適合複雜對象的創建 Registry 模式：管理多個相關的單例 單例模式雖然簡單，但在實際應用中需要謹慎考慮其適用性和實作方式。選擇合適的實作方案能夠確保程式碼的健壯性和可維護性。\n參考資料 Effective Java by Joshua Bloch Design Patterns: Elements of Reusable Object-Oriented Software Java Concurrency in Practice Spring Framework Documentation ","permalink":"https://xinqilin.github.io/post/architecture/singleton/","tags":["Design Pattern","Singleton","Java","Thread Safety","Best Practices","Creational Pattern"],"title":"Singleton 設計模式完整指南：單例實作與現代化最佳實踐"}]