[{"content":"👋 歡迎來到 Bill.Lin\u0026rsquo;s Notes 這裡是我的技術學習筆記和心得分享空間。主要記錄程式開發過程中遇到的問題、解決方案，以及對各種技術的理解和實踐經驗。\n📚 主要內容 🧮 演算法與資料結構 經典演算法實作與分析 LeetCode 解題思路與技巧 資料結構的應用場景 💻 後端開發 Java: 語言特性、集合框架、並發程式設計 Kotlin: 語法糖、協程、與 Java 互操作 Spring: IoC/DI、AOP、MVC、Security、Boot 🏗️ 架構設計 設計模式: GoF 23 種設計模式的理論與實踐 SOLID 原則: 物件導向設計的五大原則 分散式系統: 微服務、訊息佇列、分散式鎖 🐳 DevOps Docker: 容器化部署與最佳實踐 CI/CD: 自動化建構與部署流程 監控: 應用效能監控與日誌管理 🛠️ 開發工具 Linux: 常用指令與腳本編寫 Git: 版本控制與協作工作流 Hugo: 靜態網站生成器的使用心得 🎯 寫作目標 記錄學習過程: 將學習到的知識點整理成筆記，加深理解 分享實踐經驗: 分享在實際專案中遇到的問題和解決方案 建立知識體系: 透過持續寫作，建立完整的技術知識架構 幫助他人學習: 希望這些筆記能對其他開發者有所幫助 📖 文章特色 理論與實踐並重: 不僅說明原理，更著重實際應用 程式碼範例豐富: 提供完整可執行的程式碼示例 循序漸進: 從基礎概念到進階應用，逐步深入 持續更新: 根據新的學習心得和技術發展持續更新內容 🤝 聯絡方式 如果您對文章內容有任何問題或建議，歡迎透過以下方式聯絡：\nGitHub: xinqilin Email: 請透過 GitHub 聯絡 🙏 致謝 感謝所有在技術學習路上給予幫助的同事、朋友和開源社群。特別感謝那些無私分享技術知識的部落格作者和教程創作者，您們的分享讓我受益良多。\n「學而時習之，不亦說乎」- 論語\n希望這個小小的技術筆記空間，能成為知識分享和交流的平台。讓我們一起在技術的海洋中探索和成長！\n","permalink":"https://xinqilin.github.io/about/","tags":null,"title":"關於 Bill.Lin's Notes"},{"content":"概述 FTP（File Transfer Protocol）是企業環境中常用的檔案傳輸協定。本文提供一個完整、安全且可靠的 FTP 工具類實作，適用於生產環境的檔案上傳、下載和管理需求。\n核心特性 ✅ 配置外部化：所有連線資訊透過配置檔案管理 ✅ 連線池管理：支援連線複用，提升效能 ✅ 完整錯誤處理：詳細的異常處理和重試機制 ✅ 檔案操作：上傳、下載、刪除、列表等完整功能 ✅ 安全考量：密碼加密、連線超時、資源釋放 ✅ 日誌記錄：完整的操作日誌和監控 依賴配置 Maven 依賴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;dependencies\u0026gt; \u0026lt;!-- Apache Commons Net --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-net\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-net\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.9.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot Starter --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 配置處理 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Gradle 依賴 1 2 3 4 5 dependencies { implementation \u0026#39;commons-net:commons-net:3.9.0\u0026#39; implementation \u0026#39;org.springframework.boot:spring-boot-starter\u0026#39; annotationProcessor \u0026#39;org.springframework.boot:spring-boot-configuration-processor\u0026#39; } 配置類設計 FTP 配置屬性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package com.example.config; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; @Component @ConfigurationProperties(prefix = \u0026#34;ftp\u0026#34;) public class FtpProperties { private String host; private int port = 21; private String username; private String password; private String basePath = \u0026#34;/\u0026#34;; private int connectTimeout = 30000; // 30 秒 private int dataTimeout = 60000; // 60 秒 private int bufferSize = 8192; // 8KB private String encoding = \u0026#34;UTF-8\u0026#34;; private boolean passiveMode = true; private int maxConnections = 10; // Getters and Setters public String getHost() { return host; } public void setHost(String host) { this.host = host; } public int getPort() { return port; } public void setPort(int port) { this.port = port; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getBasePath() { return basePath; } public void setBasePath(String basePath) { this.basePath = basePath; } public int getConnectTimeout() { return connectTimeout; } public void setConnectTimeout(int connectTimeout) { this.connectTimeout = connectTimeout; } public int getDataTimeout() { return dataTimeout; } public void setDataTimeout(int dataTimeout) { this.dataTimeout = dataTimeout; } public int getBufferSize() { return bufferSize; } public void setBufferSize(int bufferSize) { this.bufferSize = bufferSize; } public String getEncoding() { return encoding; } public void setEncoding(String encoding) { this.encoding = encoding; } public boolean isPassiveMode() { return passiveMode; } public void setPassiveMode(boolean passiveMode) { this.passiveMode = passiveMode; } public int getMaxConnections() { return maxConnections; } public void setMaxConnections(int maxConnections) { this.maxConnections = maxConnections; } } 應用配置檔案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # application.yml ftp: host: ${FTP_HOST:ftp.example.com} port: ${FTP_PORT:21} username: ${FTP_USERNAME:} password: ${FTP_PASSWORD:} base-path: ${FTP_BASE_PATH:/uploads} connect-timeout: 30000 data-timeout: 60000 buffer-size: 8192 encoding: UTF-8 passive-mode: true max-connections: 10 # 生產環境建議使用環境變數 # export FTP_HOST=your-ftp-server.com # export FTP_USERNAME=your-username # export FTP_PASSWORD=your-secure-password 核心工具類實作 FTP 連線工廠 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 package com.example.util; import org.apache.commons.net.ftp.FTPClient; import org.apache.commons.net.ftp.FTPReply; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import com.example.config.FtpProperties; import java.io.IOException; import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; @Component public class FtpConnectionFactory { private static final Logger logger = LoggerFactory.getLogger(FtpConnectionFactory.class); @Autowired private FtpProperties ftpProperties; private final BlockingQueue\u0026lt;FTPClient\u0026gt; connectionPool = new LinkedBlockingQueue\u0026lt;\u0026gt;(); /** * 建立 FTP 連線 */ public FTPClient createConnection() throws IOException { FTPClient ftpClient = new FTPClient(); try { // 設定連線參數 ftpClient.setConnectTimeout(ftpProperties.getConnectTimeout()); ftpClient.setDataTimeout(ftpProperties.getDataTimeout()); ftpClient.setControlEncoding(ftpProperties.getEncoding()); ftpClient.setBufferSize(ftpProperties.getBufferSize()); // 建立連線 ftpClient.connect(ftpProperties.getHost(), ftpProperties.getPort()); // 檢查連線回應 int replyCode = ftpClient.getReplyCode(); if (!FTPReply.isPositiveCompletion(replyCode)) { ftpClient.disconnect(); throw new IOException(\u0026#34;FTP 伺服器拒絕連線，回應碼：\u0026#34; + replyCode); } // 登入 boolean loginSuccess = ftpClient.login(ftpProperties.getUsername(), ftpProperties.getPassword()); if (!loginSuccess) { ftpClient.disconnect(); throw new IOException(\u0026#34;FTP 登入失敗，請檢查使用者名稱和密碼\u0026#34;); } // 設定檔案傳輸模式 ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); // 設定被動/主動模式 if (ftpProperties.isPassiveMode()) { ftpClient.enterLocalPassiveMode(); } else { ftpClient.enterLocalActiveMode(); } logger.info(\u0026#34;FTP 連線建立成功：{}:{}\u0026#34;, ftpProperties.getHost(), ftpProperties.getPort()); return ftpClient; } catch (IOException e) { logger.error(\u0026#34;建立 FTP 連線失敗：{}\u0026#34;, e.getMessage()); if (ftpClient.isConnected()) { try { ftpClient.disconnect(); } catch (IOException ex) { logger.warn(\u0026#34;關閉失敗的 FTP 連線時發生錯誤：{}\u0026#34;, ex.getMessage()); } } throw e; } } /** * 歸還連線到連線池 */ public void returnConnection(FTPClient ftpClient) { if (ftpClient != null \u0026amp;\u0026amp; ftpClient.isConnected()) { if (connectionPool.size() \u0026lt; ftpProperties.getMaxConnections()) { connectionPool.offer(ftpClient); } else { closeConnection(ftpClient); } } } /** * 從連線池獲取連線 */ public FTPClient getConnection() throws IOException { FTPClient ftpClient = connectionPool.poll(); if (ftpClient == null || !ftpClient.isConnected()) { return createConnection(); } return ftpClient; } /** * 關閉連線 */ public void closeConnection(FTPClient ftpClient) { if (ftpClient != null) { try { if (ftpClient.isConnected()) { ftpClient.logout(); ftpClient.disconnect(); } } catch (IOException e) { logger.warn(\u0026#34;關閉 FTP 連線時發生錯誤：{}\u0026#34;, e.getMessage()); } } } } 主要 FTP 工具類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 package com.example.util; import org.apache.commons.net.ftp.FTPClient; import org.apache.commons.net.ftp.FTPFile; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import com.example.config.FtpProperties; import java.io.*; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import java.util.ArrayList; import java.util.List; @Component public class FtpUtil { private static final Logger logger = LoggerFactory.getLogger(FtpUtil.class); @Autowired private FtpConnectionFactory connectionFactory; @Autowired private FtpProperties ftpProperties; /** * 上傳檔案 * * @param localFile 本地檔案 * @param remotePath 遠端路徑（相對於 basePath） * @return 上傳是否成功 */ public boolean uploadFile(File localFile, String remotePath) { if (!localFile.exists() || !localFile.isFile()) { logger.error(\u0026#34;本地檔案不存在或不是檔案：{}\u0026#34;, localFile.getAbsolutePath()); return false; } try (FileInputStream fis = new FileInputStream(localFile)) { return uploadFile(fis, remotePath, localFile.getName()); } catch (IOException e) { logger.error(\u0026#34;讀取本地檔案失敗：{}\u0026#34;, e.getMessage()); return false; } } /** * 上傳檔案流 * * @param inputStream 輸入流 * @param remotePath 遠端路徑 * @param fileName 檔案名稱 * @return 上傳是否成功 */ public boolean uploadFile(InputStream inputStream, String remotePath, String fileName) { FTPClient ftpClient = null; try { ftpClient = connectionFactory.getConnection(); // 確保遠端目錄存在 String fullPath = buildFullPath(remotePath); createDirectoryIfNotExists(ftpClient, fullPath); // 切換到目標目錄 if (!ftpClient.changeWorkingDirectory(fullPath)) { logger.error(\u0026#34;無法切換到目錄：{}\u0026#34;, fullPath); return false; } // 上傳檔案 boolean result = ftpClient.storeFile(fileName, inputStream); if (result) { logger.info(\u0026#34;檔案上傳成功：{}/{}\u0026#34;, fullPath, fileName); } else { logger.error(\u0026#34;檔案上傳失敗：{}/{}\u0026#34;, fullPath, fileName); } return result; } catch (IOException e) { logger.error(\u0026#34;上傳檔案時發生錯誤：{}\u0026#34;, e.getMessage()); return false; } finally { connectionFactory.returnConnection(ftpClient); closeQuietly(inputStream); } } /** * 下載檔案 * * @param remotePath 遠端路徑 * @param fileName 檔案名稱 * @param localFile 本地檔案 * @return 下載是否成功 */ public boolean downloadFile(String remotePath, String fileName, File localFile) { FTPClient ftpClient = null; try { ftpClient = connectionFactory.getConnection(); String fullPath = buildFullPath(remotePath); if (!ftpClient.changeWorkingDirectory(fullPath)) { logger.error(\u0026#34;遠端目錄不存在：{}\u0026#34;, fullPath); return false; } // 確保本地目錄存在 File parentDir = localFile.getParentFile(); if (!parentDir.exists()) { parentDir.mkdirs(); } try (FileOutputStream fos = new FileOutputStream(localFile)) { boolean result = ftpClient.retrieveFile(fileName, fos); if (result) { logger.info(\u0026#34;檔案下載成功：{}/{} -\u0026gt; {}\u0026#34;, fullPath, fileName, localFile.getAbsolutePath()); } else { logger.error(\u0026#34;檔案下載失敗：{}/{}\u0026#34;, fullPath, fileName); } return result; } } catch (IOException e) { logger.error(\u0026#34;下載檔案時發生錯誤：{}\u0026#34;, e.getMessage()); return false; } finally { connectionFactory.returnConnection(ftpClient); } } /** * 刪除檔案 * * @param remotePath 遠端路徑 * @param fileName 檔案名稱 * @return 刪除是否成功 */ public boolean deleteFile(String remotePath, String fileName) { FTPClient ftpClient = null; try { ftpClient = connectionFactory.getConnection(); String fullPath = buildFullPath(remotePath); if (!ftpClient.changeWorkingDirectory(fullPath)) { logger.error(\u0026#34;遠端目錄不存在：{}\u0026#34;, fullPath); return false; } boolean result = ftpClient.deleteFile(fileName); if (result) { logger.info(\u0026#34;檔案刪除成功：{}/{}\u0026#34;, fullPath, fileName); } else { logger.error(\u0026#34;檔案刪除失敗：{}/{}\u0026#34;, fullPath, fileName); } return result; } catch (IOException e) { logger.error(\u0026#34;刪除檔案時發生錯誤：{}\u0026#34;, e.getMessage()); return false; } finally { connectionFactory.returnConnection(ftpClient); } } /** * 列出目錄中的檔案 * * @param remotePath 遠端路徑 * @return 檔案列表 */ public List\u0026lt;FtpFileInfo\u0026gt; listFiles(String remotePath) { FTPClient ftpClient = null; List\u0026lt;FtpFileInfo\u0026gt; fileList = new ArrayList\u0026lt;\u0026gt;(); try { ftpClient = connectionFactory.getConnection(); String fullPath = buildFullPath(remotePath); if (!ftpClient.changeWorkingDirectory(fullPath)) { logger.error(\u0026#34;遠端目錄不存在：{}\u0026#34;, fullPath); return fileList; } FTPFile[] ftpFiles = ftpClient.listFiles(); for (FTPFile ftpFile : ftpFiles) { FtpFileInfo fileInfo = new FtpFileInfo(); fileInfo.setName(ftpFile.getName()); fileInfo.setSize(ftpFile.getSize()); fileInfo.setDirectory(ftpFile.isDirectory()); fileInfo.setModifyTime(ftpFile.getTimestamp()); fileList.add(fileInfo); } logger.info(\u0026#34;成功列出目錄 {} 中的 {} 個檔案\u0026#34;, fullPath, fileList.size()); } catch (IOException e) { logger.error(\u0026#34;列出檔案時發生錯誤：{}\u0026#34;, e.getMessage()); } finally { connectionFactory.returnConnection(ftpClient); } return fileList; } /** * 檢查檔案是否存在 * * @param remotePath 遠端路徑 * @param fileName 檔案名稱 * @return 檔案是否存在 */ public boolean fileExists(String remotePath, String fileName) { FTPClient ftpClient = null; try { ftpClient = connectionFactory.getConnection(); String fullPath = buildFullPath(remotePath); if (!ftpClient.changeWorkingDirectory(fullPath)) { return false; } FTPFile[] files = ftpClient.listFiles(fileName); return files != null \u0026amp;\u0026amp; files.length \u0026gt; 0; } catch (IOException e) { logger.error(\u0026#34;檢查檔案存在性時發生錯誤：{}\u0026#34;, e.getMessage()); return false; } finally { connectionFactory.returnConnection(ftpClient); } } /** * 建立完整路徑 */ private String buildFullPath(String remotePath) { String basePath = ftpProperties.getBasePath(); if (!StringUtils.hasText(remotePath)) { return basePath; } // 規範化路徑 String normalizedBasePath = basePath.endsWith(\u0026#34;/\u0026#34;) ? basePath : basePath + \u0026#34;/\u0026#34;; String normalizedRemotePath = remotePath.startsWith(\u0026#34;/\u0026#34;) ? remotePath.substring(1) : remotePath; return normalizedBasePath + normalizedRemotePath; } /** * 遞迴建立目錄 */ private void createDirectoryIfNotExists(FTPClient ftpClient, String path) throws IOException { String[] pathElements = path.split(\u0026#34;/\u0026#34;); StringBuilder currentPath = new StringBuilder(); for (String element : pathElements) { if (StringUtils.hasText(element)) { currentPath.append(\u0026#34;/\u0026#34;).append(element); if (!ftpClient.changeWorkingDirectory(currentPath.toString())) { if (ftpClient.makeDirectory(currentPath.toString())) { logger.debug(\u0026#34;建立目錄：{}\u0026#34;, currentPath.toString()); } else { throw new IOException(\u0026#34;無法建立目錄：\u0026#34; + currentPath.toString()); } } } } } /** * 安靜地關閉資源 */ private void closeQuietly(Closeable closeable) { if (closeable != null) { try { closeable.close(); } catch (IOException e) { // 忽略關閉時的錯誤 } } } } 檔案資訊實體類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.example.util; import java.util.Calendar; public class FtpFileInfo { private String name; private long size; private boolean isDirectory; private Calendar modifyTime; // Getters and Setters public String getName() { return name; } public void setName(String name) { this.name = name; } public long getSize() { return size; } public void setSize(long size) { this.size = size; } public boolean isDirectory() { return isDirectory; } public void setDirectory(boolean directory) { isDirectory = directory; } public Calendar getModifyTime() { return modifyTime; } public void setModifyTime(Calendar modifyTime) { this.modifyTime = modifyTime; } @Override public String toString() { return String.format(\u0026#34;FtpFileInfo{name=\u0026#39;%s\u0026#39;, size=%d, isDirectory=%s}\u0026#34;, name, size, isDirectory); } } 使用範例 基本使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @Service public class FileService { @Autowired private FtpUtil ftpUtil; /** * 上傳使用者頭像 */ public boolean uploadAvatar(MultipartFile file, String userId) { try { String remotePath = \u0026#34;avatars/\u0026#34; + userId; String fileName = generateFileName(file.getOriginalFilename()); return ftpUtil.uploadFile(file.getInputStream(), remotePath, fileName); } catch (IOException e) { logger.error(\u0026#34;上傳頭像失敗：{}\u0026#34;, e.getMessage()); return false; } } /** * 批量上傳檔案 */ public List\u0026lt;String\u0026gt; batchUpload(List\u0026lt;MultipartFile\u0026gt; files, String category) { List\u0026lt;String\u0026gt; successFiles = new ArrayList\u0026lt;\u0026gt;(); String remotePath = \u0026#34;uploads/\u0026#34; + category + \u0026#34;/\u0026#34; + getCurrentDate(); for (MultipartFile file : files) { try { String fileName = generateFileName(file.getOriginalFilename()); if (ftpUtil.uploadFile(file.getInputStream(), remotePath, fileName)) { successFiles.add(fileName); } } catch (IOException e) { logger.error(\u0026#34;批量上傳檔案失敗：{}\u0026#34;, file.getOriginalFilename()); } } return successFiles; } private String generateFileName(String originalName) { String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\u0026#34;yyyyMMddHHmmss\u0026#34;)); String extension = originalName.substring(originalName.lastIndexOf(\u0026#34;.\u0026#34;)); return timestamp + \u0026#34;_\u0026#34; + UUID.randomUUID().toString().substring(0, 8) + extension; } private String getCurrentDate() { return LocalDateTime.now().format(DateTimeFormatter.ofPattern(\u0026#34;yyyy/MM/dd\u0026#34;)); } } 進階功能：檔案同步 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @Component public class FtpSyncService { @Autowired private FtpUtil ftpUtil; /** * 同步本地目錄到 FTP */ public void syncDirectoryToFtp(String localDirPath, String remotePath) { File localDir = new File(localDirPath); if (!localDir.exists() || !localDir.isDirectory()) { logger.error(\u0026#34;本地目錄不存在：{}\u0026#34;, localDirPath); return; } syncDirectoryRecursive(localDir, remotePath); } private void syncDirectoryRecursive(File localDir, String remotePath) { File[] files = localDir.listFiles(); if (files == null) return; for (File file : files) { if (file.isDirectory()) { // 遞迴處理子目錄 String subRemotePath = remotePath + \u0026#34;/\u0026#34; + file.getName(); syncDirectoryRecursive(file, subRemotePath); } else { // 上傳檔案 if (!ftpUtil.fileExists(remotePath, file.getName())) { ftpUtil.uploadFile(file, remotePath); logger.info(\u0026#34;同步檔案：{} -\u0026gt; {}/{}\u0026#34;, file.getAbsolutePath(), remotePath, file.getName()); } } } } } 安全最佳實踐 1. 配置安全 1 2 3 4 5 # 使用環境變數或加密配置 ftp: host: ${FTP_HOST} username: ${FTP_USERNAME} password: ${FTP_PASSWORD:#{null}} # 可以為空，使用 SSH Key 2. 檔案驗證 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class FileValidator { private static final List\u0026lt;String\u0026gt; ALLOWED_EXTENSIONS = Arrays.asList(\u0026#34;.jpg\u0026#34;, \u0026#34;.png\u0026#34;, \u0026#34;.pdf\u0026#34;, \u0026#34;.doc\u0026#34;, \u0026#34;.docx\u0026#34;, \u0026#34;.xls\u0026#34;, \u0026#34;.xlsx\u0026#34;); private static final long MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB public boolean isValidFile(MultipartFile file) { // 檢查檔案大小 if (file.getSize() \u0026gt; MAX_FILE_SIZE) { return false; } // 檢查檔案副檔名 String fileName = file.getOriginalFilename(); if (fileName == null) return false; String extension = fileName.substring(fileName.lastIndexOf(\u0026#34;.\u0026#34;)).toLowerCase(); return ALLOWED_EXTENSIONS.contains(extension); } } 3. 存取控制 1 2 3 4 5 6 7 8 9 10 11 12 @Component public class FtpAccessControl { /** * 檢查使用者是否有權限存取指定路徑 */ public boolean hasAccess(String userId, String remotePath) { // 實作存取控制邏輯 // 例如：使用者只能存取自己的目錄 return remotePath.startsWith(\u0026#34;users/\u0026#34; + userId + \u0026#34;/\u0026#34;); } } 監控與維護 健康檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Component public class FtpHealthIndicator implements HealthIndicator { @Autowired private FtpConnectionFactory connectionFactory; @Override public Health health() { try { FTPClient ftpClient = connectionFactory.getConnection(); boolean isConnected = ftpClient.isConnected(); connectionFactory.returnConnection(ftpClient); return isConnected ? Health.up().withDetail(\u0026#34;status\u0026#34;, \u0026#34;FTP connection available\u0026#34;).build() : Health.down().withDetail(\u0026#34;status\u0026#34;, \u0026#34;FTP connection failed\u0026#34;).build(); } catch (Exception e) { return Health.down().withDetail(\u0026#34;error\u0026#34;, e.getMessage()).build(); } } } 效能監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Aspect @Component public class FtpPerformanceAspect { private static final Logger logger = LoggerFactory.getLogger(FtpPerformanceAspect.class); @Around(\u0026#34;execution(* com.example.util.FtpUtil.*(..))\u0026#34;) public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable { long startTime = System.currentTimeMillis(); try { Object result = joinPoint.proceed(); long endTime = System.currentTimeMillis(); logger.info(\u0026#34;FTP 操作 {} 執行時間：{}ms\u0026#34;, joinPoint.getSignature().getName(), endTime - startTime); return result; } catch (Exception e) { long endTime = System.currentTimeMillis(); logger.error(\u0026#34;FTP 操作 {} 失敗，執行時間：{}ms，錯誤：{}\u0026#34;, joinPoint.getSignature().getName(), endTime - startTime, e.getMessage()); throw e; } } } 常見問題與解決方案 1. 連線逾時問題 1 2 3 4 5 // 增加重試機制 @Retryable(value = {IOException.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000)) public boolean uploadFileWithRetry(InputStream inputStream, String remotePath, String fileName) { return uploadFile(inputStream, remotePath, fileName); } 2. 中文檔名問題 1 2 3 4 5 // 在 FTP 配置中設定正確的編碼 ftpClient.setControlEncoding(\u0026#34;UTF-8\u0026#34;); // 或者對檔名進行編碼處理 String encodedFileName = new String(fileName.getBytes(\u0026#34;UTF-8\u0026#34;), \u0026#34;ISO-8859-1\u0026#34;); 3. 防火牆問題 1 2 3 # 使用被動模式避免防火牆問題 ftp: passive-mode: true 測試範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @SpringBootTest class FtpUtilTest { @Autowired private FtpUtil ftpUtil; @Test void testUploadFile() { // 建立測試檔案 File testFile = createTestFile(); // 執行上傳 boolean result = ftpUtil.uploadFile(testFile, \u0026#34;test\u0026#34;, \u0026#34;test.txt\u0026#34;); // 驗證結果 assertTrue(result); assertTrue(ftpUtil.fileExists(\u0026#34;test\u0026#34;, \u0026#34;test.txt\u0026#34;)); // 清理 ftpUtil.deleteFile(\u0026#34;test\u0026#34;, \u0026#34;test.txt\u0026#34;); } private File createTestFile() { try { File tempFile = File.createTempFile(\u0026#34;test\u0026#34;, \u0026#34;.txt\u0026#34;); Files.write(tempFile.toPath(), \u0026#34;測試內容\u0026#34;.getBytes()); return tempFile; } catch (IOException e) { throw new RuntimeException(e); } } } 總結 本文提供的 FTP 工具類具備以下優勢：\n安全性：配置外部化，避免硬編碼敏感資訊 可靠性：完整的錯誤處理和重試機制 效能：連線池管理，支援併發操作 可維護性：模組化設計，易於擴展和維護 生產就緒：包含監控、日誌和健康檢查 在實際使用時，請根據具體需求調整配置參數和安全設定，確保符合您的業務場景和安全要求。\n參考資料 Apache Commons Net 官方文檔 Spring Boot Configuration Properties FTP RFC 959 協定規範 Java FTP 最佳實踐 ","permalink":"https://xinqilin.github.io/post/backend/ftputil/","tags":["Java","FTP","FileTransfer","Spring","Commons-Net","Security"],"title":"FTP 工具類實作指南：安全、可靠的檔案傳輸解決方案"},{"content":"概述 在企業級應用程式開發中，Enum（列舉）是表示有限狀態集合的理想選擇，如訂單狀態、使用者角色、審核狀態等。本文深入探討如何在 JPA/Hibernate 中有效處理 Enum 型別，包含各種映射策略、效能考量和實際應用場景。\n基本 Enum 映射 1. @Enumerated 註解 JPA 提供 @Enumerated 註解來處理 Enum 映射，支援兩種策略：\nEnumType.ORDINAL（數字映射） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 定義狀態列舉 public enum OrderStatus { PENDING, // 0 CONFIRMED, // 1 SHIPPED, // 2 DELIVERED, // 3 CANCELLED // 4 } // 實體類使用 @Entity @Table(name = \u0026#34;orders\u0026#34;) public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Enumerated(EnumType.ORDINAL) @Column(name = \u0026#34;status\u0026#34;, nullable = false) private OrderStatus status = OrderStatus.PENDING; // 其他屬性... } 資料庫儲存：\n1 2 3 4 5 6 7 CREATE TABLE orders ( id BIGINT PRIMARY KEY AUTO_INCREMENT, status TINYINT NOT NULL DEFAULT 0, -- 其他欄位 ); -- 儲存的值：0=PENDING, 1=CONFIRMED, 2=SHIPPED, 3=DELIVERED, 4=CANCELLED EnumType.STRING（字串映射） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Entity @Table(name = \u0026#34;orders\u0026#34;) public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Enumerated(EnumType.STRING) @Column(name = \u0026#34;status\u0026#34;, length = 20, nullable = false) private OrderStatus status = OrderStatus.PENDING; // 其他屬性... } 資料庫儲存：\n1 2 3 4 5 6 7 CREATE TABLE orders ( id BIGINT PRIMARY KEY AUTO_INCREMENT, status VARCHAR(20) NOT NULL DEFAULT \u0026#39;PENDING\u0026#39;, -- 其他欄位 ); -- 儲存的值：\u0026#39;PENDING\u0026#39;, \u0026#39;CONFIRMED\u0026#39;, \u0026#39;SHIPPED\u0026#39;, \u0026#39;DELIVERED\u0026#39;, \u0026#39;CANCELLED\u0026#39; 2. 映射策略比較 特性 ORDINAL STRING 儲存空間 小（1-4 bytes） 大（字串長度） 可讀性 差（數字） 好（文字） 順序變更風險 高（破壞性） 無 新增項目 只能追加 任意位置 資料庫查詢 快速 較慢 除錯友善 困難 容易 建議：生產環境通常使用 EnumType.STRING，因為其具備更好的可維護性和可讀性。\n進階 Enum 處理 1. 自訂 Enum 值 當需要更具語意的資料庫值時，可以為 Enum 添加自訂屬性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public enum OrderStatus { PENDING(\u0026#34;PND\u0026#34;, \u0026#34;訂單待處理\u0026#34;), CONFIRMED(\u0026#34;CNF\u0026#34;, \u0026#34;訂單已確認\u0026#34;), SHIPPED(\u0026#34;SHP\u0026#34;, \u0026#34;商品已出貨\u0026#34;), DELIVERED(\u0026#34;DLV\u0026#34;, \u0026#34;商品已送達\u0026#34;), CANCELLED(\u0026#34;CXL\u0026#34;, \u0026#34;訂單已取消\u0026#34;); private final String code; private final String description; OrderStatus(String code, String description) { this.code = code; this.description = description; } public String getCode() { return code; } public String getDescription() { return description; } // 從代碼查找 Enum public static OrderStatus fromCode(String code) { return Arrays.stream(values()) .filter(status -\u0026gt; status.code.equals(code)) .findFirst() .orElseThrow(() -\u0026gt; new IllegalArgumentException(\u0026#34;未知的訂單狀態代碼: \u0026#34; + code)); } // 取得所有代碼 public static List\u0026lt;String\u0026gt; getAllCodes() { return Arrays.stream(values()) .map(OrderStatus::getCode) .collect(Collectors.toList()); } } 2. 自訂 AttributeConverter 使用 JPA 2.1 的 @Converter 註解來實現自訂轉換：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Converter(autoApply = true) public class OrderStatusConverter implements AttributeConverter\u0026lt;OrderStatus, String\u0026gt; { @Override public String convertToDatabaseColumn(OrderStatus orderStatus) { if (orderStatus == null) { return null; } return orderStatus.getCode(); } @Override public OrderStatus convertToEntityAttribute(String code) { if (code == null || code.isEmpty()) { return null; } return OrderStatus.fromCode(code); } } 實體類使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Entity @Table(name = \u0026#34;orders\u0026#34;) public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Convert(converter = OrderStatusConverter.class) @Column(name = \u0026#34;status\u0026#34;, length = 3, nullable = false) private OrderStatus status = OrderStatus.PENDING; // 其他屬性... } 資料庫儲存結果：\n1 2 -- 儲存的值：\u0026#39;PND\u0026#39;, \u0026#39;CNF\u0026#39;, \u0026#39;SHP\u0026#39;, \u0026#39;DLV\u0026#39;, \u0026#39;CXL\u0026#39; INSERT INTO orders (status) VALUES (\u0026#39;PND\u0026#39;); 3. 通用 Enum 轉換器 建立通用的 Enum 轉換器基類：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public interface CodedEnum { String getCode(); static \u0026lt;T extends Enum\u0026lt;T\u0026gt; \u0026amp; CodedEnum\u0026gt; T fromCode(Class\u0026lt;T\u0026gt; enumClass, String code) { return Arrays.stream(enumClass.getEnumConstants()) .filter(e -\u0026gt; e.getCode().equals(code)) .findFirst() .orElseThrow(() -\u0026gt; new IllegalArgumentException( \u0026#34;未知的 \u0026#34; + enumClass.getSimpleName() + \u0026#34; 代碼: \u0026#34; + code)); } } // 通用轉換器基類 public abstract class CodedEnumConverter\u0026lt;T extends Enum\u0026lt;T\u0026gt; \u0026amp; CodedEnum\u0026gt; implements AttributeConverter\u0026lt;T, String\u0026gt; { private final Class\u0026lt;T\u0026gt; enumClass; protected CodedEnumConverter(Class\u0026lt;T\u0026gt; enumClass) { this.enumClass = enumClass; } @Override public String convertToDatabaseColumn(T attribute) { return attribute != null ? attribute.getCode() : null; } @Override public T convertToEntityAttribute(String dbData) { return dbData != null ? CodedEnum.fromCode(enumClass, dbData) : null; } } 具體實作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 實作 CodedEnum 介面 public enum Priority implements CodedEnum { LOW(\u0026#34;L\u0026#34;), MEDIUM(\u0026#34;M\u0026#34;), HIGH(\u0026#34;H\u0026#34;), URGENT(\u0026#34;U\u0026#34;); private final String code; Priority(String code) { this.code = code; } @Override public String getCode() { return code; } } // 具體轉換器 @Converter(autoApply = true) public class PriorityConverter extends CodedEnumConverter\u0026lt;Priority\u0026gt; { public PriorityConverter() { super(Priority.class); } } 複雜應用場景 1. 多狀態 Enum 設計 設計包含狀態轉換邏輯的 Enum：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public enum OrderStatus implements CodedEnum { DRAFT(\u0026#34;DFT\u0026#34;, \u0026#34;草稿\u0026#34;, Set.of()), PENDING(\u0026#34;PND\u0026#34;, \u0026#34;待處理\u0026#34;, Set.of(DRAFT)), CONFIRMED(\u0026#34;CNF\u0026#34;, \u0026#34;已確認\u0026#34;, Set.of(PENDING)), PAID(\u0026#34;PAD\u0026#34;, \u0026#34;已付款\u0026#34;, Set.of(CONFIRMED)), SHIPPED(\u0026#34;SHP\u0026#34;, \u0026#34;已出貨\u0026#34;, Set.of(PAID)), DELIVERED(\u0026#34;DLV\u0026#34;, \u0026#34;已送達\u0026#34;, Set.of(SHIPPED)), CANCELLED(\u0026#34;CXL\u0026#34;, \u0026#34;已取消\u0026#34;, Set.of(DRAFT, PENDING, CONFIRMED, PAID)), REFUNDED(\u0026#34;RFD\u0026#34;, \u0026#34;已退款\u0026#34;, Set.of(PAID, SHIPPED, DELIVERED)); private final String code; private final String description; private final Set\u0026lt;OrderStatus\u0026gt; allowedPreviousStatuses; OrderStatus(String code, String description, Set\u0026lt;OrderStatus\u0026gt; allowedPreviousStatuses) { this.code = code; this.description = description; this.allowedPreviousStatuses = allowedPreviousStatuses; } @Override public String getCode() { return code; } public String getDescription() { return description; } // 檢查狀態轉換是否合法 public boolean canTransitionFrom(OrderStatus currentStatus) { return allowedPreviousStatuses.contains(currentStatus); } // 取得可轉換到的狀態 public Set\u0026lt;OrderStatus\u0026gt; getNextPossibleStatuses() { return Arrays.stream(values()) .filter(status -\u0026gt; status.canTransitionFrom(this)) .collect(Collectors.toSet()); } // 檢查是否為終結狀態 public boolean isFinalStatus() { return this == DELIVERED || this == CANCELLED || this == REFUNDED; } // 檢查是否可取消 public boolean isCancellable() { return CANCELLED.canTransitionFrom(this); } } 2. 業務邏輯整合 在 Service 層中整合狀態轉換邏輯：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @Service @Transactional public class OrderService { @Autowired private OrderRepository orderRepository; @Autowired private OrderStatusHistoryService statusHistoryService; public void updateOrderStatus(Long orderId, OrderStatus newStatus, String reason) { Order order = orderRepository.findById(orderId) .orElseThrow(() -\u0026gt; new EntityNotFoundException(\u0026#34;訂單不存在: \u0026#34; + orderId)); OrderStatus currentStatus = order.getStatus(); // 驗證狀態轉換 if (!newStatus.canTransitionFrom(currentStatus)) { throw new IllegalStateException(String.format( \u0026#34;無法從 %s 轉換到 %s\u0026#34;, currentStatus.getDescription(), newStatus.getDescription() )); } // 更新狀態 order.setStatus(newStatus); order.setLastModified(LocalDateTime.now()); // 記錄狀態變更歷史 statusHistoryService.recordStatusChange(orderId, currentStatus, newStatus, reason); // 觸發相關業務邏輯 handleStatusChange(order, currentStatus, newStatus); orderRepository.save(order); } private void handleStatusChange(Order order, OrderStatus from, OrderStatus to) { switch (to) { case CONFIRMED: // 發送確認郵件 emailService.sendOrderConfirmation(order); break; case SHIPPED: // 發送出貨通知 emailService.sendShippingNotification(order); // 減少庫存 inventoryService.decreaseStock(order.getItems()); break; case DELIVERED: // 發送送達通知 emailService.sendDeliveryNotification(order); break; case CANCELLED: // 恢復庫存 inventoryService.restoreStock(order.getItems()); // 處理退款 if (from == OrderStatus.PAID) { paymentService.processRefund(order); } break; } } // 批量狀態查詢 public List\u0026lt;Order\u0026gt; findOrdersByStatuses(Set\u0026lt;OrderStatus\u0026gt; statuses) { return orderRepository.findByStatusIn(statuses); } // 取得可操作的訂單 public List\u0026lt;Order\u0026gt; findOrdersReadyForShipping() { return orderRepository.findByStatus(OrderStatus.PAID); } } 3. 狀態歷史追蹤 建立狀態變更歷史表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Entity @Table(name = \u0026#34;order_status_history\u0026#34;) public class OrderStatusHistory { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = \u0026#34;order_id\u0026#34;, nullable = false) private Long orderId; @Convert(converter = OrderStatusConverter.class) @Column(name = \u0026#34;from_status\u0026#34;, length = 3) private OrderStatus fromStatus; @Convert(converter = OrderStatusConverter.class) @Column(name = \u0026#34;to_status\u0026#34;, length = 3, nullable = false) private OrderStatus toStatus; @Column(name = \u0026#34;reason\u0026#34;, length = 500) private String reason; @Column(name = \u0026#34;changed_by\u0026#34;) private String changedBy; @Column(name = \u0026#34;changed_at\u0026#34;, nullable = false) private LocalDateTime changedAt; // 建構子、Getter、Setter... } 4. Repository 查詢方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Repository public interface OrderRepository extends JpaRepository\u0026lt;Order, Long\u0026gt; { // 基本狀態查詢 List\u0026lt;Order\u0026gt; findByStatus(OrderStatus status); List\u0026lt;Order\u0026gt; findByStatusIn(Collection\u0026lt;OrderStatus\u0026gt; statuses); List\u0026lt;Order\u0026gt; findByStatusNot(OrderStatus status); // 複合查詢 List\u0026lt;Order\u0026gt; findByStatusAndCreatedAtBetween( OrderStatus status, LocalDateTime start, LocalDateTime end ); // 統計查詢 @Query(\u0026#34;SELECT o.status, COUNT(o) FROM Order o GROUP BY o.status\u0026#34;) List\u0026lt;Object[]\u0026gt; countOrdersByStatus(); // 自訂查詢 @Query(\u0026#34;SELECT o FROM Order o WHERE o.status IN :statuses AND o.totalAmount \u0026gt; :minAmount\u0026#34;) List\u0026lt;Order\u0026gt; findHighValueOrdersByStatuses( @Param(\u0026#34;statuses\u0026#34;) Collection\u0026lt;OrderStatus\u0026gt; statuses, @Param(\u0026#34;minAmount\u0026#34;) BigDecimal minAmount ); // 原生 SQL 查詢 @Query(value = \u0026#34;SELECT * FROM orders WHERE status IN :statusCodes AND DATE(created_at) = CURDATE()\u0026#34;, nativeQuery = true) List\u0026lt;Order\u0026gt; findTodayOrdersByStatusCodes(@Param(\u0026#34;statusCodes\u0026#34;) Collection\u0026lt;String\u0026gt; statusCodes); } 效能優化 1. 索引設計 1 2 3 4 5 6 7 8 9 -- 狀態欄位索引 CREATE INDEX idx_orders_status ON orders(status); -- 複合索引 CREATE INDEX idx_orders_status_created ON orders(status, created_at); -- 部分索引（針對特定狀態） CREATE INDEX idx_orders_active_status ON orders(status) WHERE status IN (\u0026#39;PND\u0026#39;, \u0026#39;CNF\u0026#39;, \u0026#39;PAD\u0026#39;, \u0026#39;SHP\u0026#39;); 2. 查詢優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Service public class OrderQueryService { // 使用 Specification 進行動態查詢 public Page\u0026lt;Order\u0026gt; findOrdersWithCriteria(OrderSearchCriteria criteria, Pageable pageable) { return orderRepository.findAll(Specification .where(hasStatus(criteria.getStatuses())) .and(createdBetween(criteria.getStartDate(), criteria.getEndDate())) .and(hasCustomer(criteria.getCustomerId())), pageable); } private static Specification\u0026lt;Order\u0026gt; hasStatus(Set\u0026lt;OrderStatus\u0026gt; statuses) { return (root, query, cb) -\u0026gt; statuses == null || statuses.isEmpty() ? cb.conjunction() : root.get(\u0026#34;status\u0026#34;).in(statuses); } // 快取常用統計 @Cacheable(\u0026#34;orderStatusStats\u0026#34;) public Map\u0026lt;OrderStatus, Long\u0026gt; getOrderStatusStatistics() { List\u0026lt;Object[]\u0026gt; results = orderRepository.countOrdersByStatus(); return results.stream() .collect(Collectors.toMap( row -\u0026gt; (OrderStatus) row[0], row -\u0026gt; (Long) row[1] )); } } 3. 快取策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Service public class OrderStatusCacheService { private final Cache\u0026lt;String, List\u0026lt;Order\u0026gt;\u0026gt; orderCache; public OrderStatusCacheService() { this.orderCache = Caffeine.newBuilder() .maximumSize(1000) .expireAfterWrite(Duration.ofMinutes(5)) .build(); } public List\u0026lt;Order\u0026gt; getCachedOrdersByStatus(OrderStatus status) { return orderCache.get(status.getCode(), code -\u0026gt; orderRepository.findByStatus(status)); } @EventListener public void handleOrderStatusChanged(OrderStatusChangedEvent event) { // 清除相關快取 orderCache.invalidate(event.getOldStatus().getCode()); orderCache.invalidate(event.getNewStatus().getCode()); } } 測試策略 1. 單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @ExtendWith(MockitoExtension.class) class OrderServiceTest { @Mock private OrderRepository orderRepository; @Mock private OrderStatusHistoryService statusHistoryService; @InjectMocks private OrderService orderService; @Test void testValidStatusTransition() { // Given Order order = createOrderWithStatus(OrderStatus.PENDING); when(orderRepository.findById(1L)).thenReturn(Optional.of(order)); // When orderService.updateOrderStatus(1L, OrderStatus.CONFIRMED, \u0026#34;客戶確認\u0026#34;); // Then assertEquals(OrderStatus.CONFIRMED, order.getStatus()); verify(statusHistoryService).recordStatusChange( eq(1L), eq(OrderStatus.PENDING), eq(OrderStatus.CONFIRMED), eq(\u0026#34;客戶確認\u0026#34;)); } @Test void testInvalidStatusTransition() { // Given Order order = createOrderWithStatus(OrderStatus.DELIVERED); when(orderRepository.findById(1L)).thenReturn(Optional.of(order)); // When \u0026amp; Then assertThatThrownBy(() -\u0026gt; orderService.updateOrderStatus(1L, OrderStatus.PENDING, \u0026#34;無效轉換\u0026#34;)) .isInstanceOf(IllegalStateException.class) .hasMessageContaining(\u0026#34;無法從\u0026#34;); } @Test void testOrderStatusEnumProperties() { // 測試狀態轉換邏輯 assertTrue(OrderStatus.CONFIRMED.canTransitionFrom(OrderStatus.PENDING)); assertFalse(OrderStatus.PENDING.canTransitionFrom(OrderStatus.DELIVERED)); // 測試終結狀態 assertTrue(OrderStatus.DELIVERED.isFinalStatus()); assertFalse(OrderStatus.PENDING.isFinalStatus()); // 測試可取消狀態 assertTrue(OrderStatus.PENDING.isCancellable()); assertFalse(OrderStatus.DELIVERED.isCancellable()); } } 2. 整合測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @SpringBootTest @TestPropertySource(properties = \u0026#34;spring.jpa.hibernate.ddl-auto=create-drop\u0026#34;) class OrderStatusIntegrationTest { @Autowired private OrderService orderService; @Autowired private OrderRepository orderRepository; @Test @Transactional void testCompleteOrderWorkflow() { // 建立訂單 Order order = createTestOrder(); order = orderRepository.save(order); // 確認訂單 orderService.updateOrderStatus(order.getId(), OrderStatus.CONFIRMED, \u0026#34;自動確認\u0026#34;); // 付款 orderService.updateOrderStatus(order.getId(), OrderStatus.PAID, \u0026#34;信用卡付款\u0026#34;); // 出貨 orderService.updateOrderStatus(order.getId(), OrderStatus.SHIPPED, \u0026#34;物流出貨\u0026#34;); // 送達 orderService.updateOrderStatus(order.getId(), OrderStatus.DELIVERED, \u0026#34;客戶簽收\u0026#34;); // 驗證最終狀態 Order finalOrder = orderRepository.findById(order.getId()).orElseThrow(); assertEquals(OrderStatus.DELIVERED, finalOrder.getStatus()); } @Test void testDatabaseEnumPersistence() { // 測試 Enum 值正確儲存和讀取 Order order = createTestOrder(); order.setStatus(OrderStatus.CONFIRMED); order = orderRepository.save(order); // 清除 JPA 快取 orderRepository.flush(); entityManager.clear(); // 重新讀取 Order reloadedOrder = orderRepository.findById(order.getId()).orElseThrow(); assertEquals(OrderStatus.CONFIRMED, reloadedOrder.getStatus()); } } 最佳實踐與建議 1. 設計原則 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // ✅ 好的實踐：使用有意義的名稱和描述 public enum UserRole implements CodedEnum { ADMIN(\u0026#34;ADM\u0026#34;, \u0026#34;系統管理員\u0026#34;, Set.of(\u0026#34;*\u0026#34;)), MANAGER(\u0026#34;MGR\u0026#34;, \u0026#34;部門主管\u0026#34;, Set.of(\u0026#34;USER_MANAGE\u0026#34;, \u0026#34;REPORT_VIEW\u0026#34;)), USER(\u0026#34;USR\u0026#34;, \u0026#34;一般使用者\u0026#34;, Set.of(\u0026#34;PROFILE_EDIT\u0026#34;)); private final String code; private final String description; private final Set\u0026lt;String\u0026gt; permissions; // 建構子和方法... } // ❌ 避免：過於簡單或不清楚的列舉 public enum Status { A, B, C, D // 不清楚的含義 } 2. 版本管理策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 支援向後相容的 Enum 設計 public enum OrderStatus implements CodedEnum { // 新版本可以安全添加新狀態 PENDING(\u0026#34;PND\u0026#34;, \u0026#34;待處理\u0026#34;), CONFIRMED(\u0026#34;CNF\u0026#34;, \u0026#34;已確認\u0026#34;), SHIPPED(\u0026#34;SHP\u0026#34;, \u0026#34;已出貨\u0026#34;), DELIVERED(\u0026#34;DLV\u0026#34;, \u0026#34;已送達\u0026#34;), CANCELLED(\u0026#34;CXL\u0026#34;, \u0026#34;已取消\u0026#34;), // 新增狀態（向後相容） PARTIAL_SHIPPED(\u0026#34;PSH\u0026#34;, \u0026#34;部分出貨\u0026#34;), // v2.0 新增 RETURNED(\u0026#34;RET\u0026#34;, \u0026#34;已退貨\u0026#34;); // v2.1 新增 // 處理未知狀態的安全機制 public static OrderStatus fromCodeSafely(String code, OrderStatus defaultValue) { try { return fromCode(code); } catch (IllegalArgumentException e) { logger.warn(\u0026#34;遇到未知的訂單狀態代碼: {}, 使用預設值: {}\u0026#34;, code, defaultValue); return defaultValue; } } } 3. 國際化支援 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Component public class OrderStatusI18nService { @Autowired private MessageSource messageSource; public String getLocalizedDescription(OrderStatus status, Locale locale) { String key = \u0026#34;order.status.\u0026#34; + status.name().toLowerCase(); return messageSource.getMessage(key, null, status.getDescription(), locale); } public Map\u0026lt;OrderStatus, String\u0026gt; getAllLocalizedStatuses(Locale locale) { return Arrays.stream(OrderStatus.values()) .collect(Collectors.toMap( status -\u0026gt; status, status -\u0026gt; getLocalizedDescription(status, locale) )); } } 監控與維護 1. 狀態分佈監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Component public class OrderStatusMetrics { private final MeterRegistry meterRegistry; private final OrderRepository orderRepository; public OrderStatusMetrics(MeterRegistry meterRegistry, OrderRepository orderRepository) { this.meterRegistry = meterRegistry; this.orderRepository = orderRepository; // 註冊度量 Gauge.builder(\u0026#34;orders.by.status\u0026#34;) .description(\u0026#34;訂單狀態分佈\u0026#34;) .tag(\u0026#34;status\u0026#34;, \u0026#34;all\u0026#34;) .register(meterRegistry, this, OrderStatusMetrics::getTotalOrderCount); } @EventListener public void handleOrderStatusChanged(OrderStatusChangedEvent event) { // 記錄狀態轉換次數 Counter.builder(\u0026#34;order.status.transitions\u0026#34;) .description(\u0026#34;訂單狀態轉換次數\u0026#34;) .tag(\u0026#34;from\u0026#34;, event.getOldStatus().getCode()) .tag(\u0026#34;to\u0026#34;, event.getNewStatus().getCode()) .register(meterRegistry) .increment(); } private double getTotalOrderCount() { return orderRepository.count(); } } 2. 效能監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Aspect @Component public class OrderStatusPerformanceAspect { @Around(\u0026#34;execution(* com.example.service.OrderService.updateOrderStatus(..))\u0026#34;) public Object measureStatusUpdate(ProceedingJoinPoint joinPoint) throws Throwable { Timer.Sample sample = Timer.start(meterRegistry); try { return joinPoint.proceed(); } finally { sample.stop(Timer.builder(\u0026#34;order.status.update.duration\u0026#34;) .description(\u0026#34;訂單狀態更新耗時\u0026#34;) .register(meterRegistry)); } } } 總結 JPA 中的 Enum 處理是企業級應用程式開發的重要技能。透過本文的深入探討，我們了解到：\n核心要點 選擇適當的映射策略：生產環境建議使用 EnumType.STRING 或自訂轉換器 設計可擴展的 Enum：考慮未來需求，支援狀態轉換邏輯 效能優化：合理使用索引、快取和查詢優化 測試完整性：涵蓋狀態轉換邏輯和持久化測試 監控維護：建立適當的監控機制 實際應用建議 對於簡單狀態，使用基本的 @Enumerated(EnumType.STRING) 對於複雜業務邏輯，實作 CodedEnum 介面和自訂轉換器 建立狀態轉換規則和歷史追蹤機制 考慮國際化和向後相容性 實施適當的監控和效能優化策略 正確處理 Enum 型別不僅能提升程式碼的可讀性和維護性，還能確保資料的一致性和業務邏輯的正確執行。\n參考資料 JPA 2.2 Specification Hibernate ORM Documentation Spring Data JPA Reference Java Enum Best Practices Database Design Patterns ","permalink":"https://xinqilin.github.io/post/backend/ormenumtype/","tags":["Java","JPA","Hibernate","Enum","ORM","Database","Spring","MySQL"],"title":"JPA Enum 型別處理完整指南：映射策略與最佳實踐"},{"content":"概述 xargs（eXtended ARGuments）是 Unix/Linux 系統中的強大工具，用於從標準輸入讀取資料並將其作為參數傳遞給其他命令。它解決了命令行參數長度限制的問題，並提供了並行處理能力，是管道操作和批次處理的重要工具。\n核心特徵 參數轉換：將輸入流轉換為命令參數 批次處理：支援分批執行大量操作 並行執行：可同時執行多個程序提升效率 安全處理：正確處理包含空格的檔案名稱 靈活控制：豐富的選項控制執行行為 基本語法 1 xargs [選項] [命令 [初始參數]] 工作原理 1 2 3 4 5 # 基本概念 command1 | xargs command2 # 等同於 command2 arg1 arg2 arg3 ... 簡單範例 1 2 3 4 5 6 7 8 9 10 11 # 預設行為（使用 echo） echo \u0026#34;a b c d\u0026#34; | xargs # 輸出: a b c d # 指定命令 echo \u0026#34;file1 file2 file3\u0026#34; | xargs ls -l # 從檔案讀取 cat filelist.txt | xargs rm -f # 與 find 組合 find . -name \u0026#34;*.tmp\u0026#34; | xargs rm -f 核心選項詳解 基本控制選項 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # -t (--verbose) - 顯示執行的命令 echo \u0026#34;a b c\u0026#34; | xargs -t rm # 輸出: rm a b c # 然後執行 rm a b c # -p (--interactive) - 交互式確認 echo \u0026#34;file1 file2\u0026#34; | xargs -p rm # 輸出: rm file1 file2?... # 等待使用者輸入 y/n # -r (--no-run-if-empty) - 空輸入時不執行 echo \u0026#34;\u0026#34; | xargs -r echo \u0026#34;執行了\u0026#34; # 不會執行 echo \u0026#34;\u0026#34; | xargs echo \u0026#34;執行了\u0026#34; # 會執行 # --help - 顯示幫助資訊 xargs --help 參數分組選項 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # -n max-args - 限制每次執行的參數數量 echo \u0026#34;1 2 3 4 5 6\u0026#34; | xargs -n 2 echo # 輸出: # 1 2 # 3 4 # 5 6 # -L max-lines - 限制每次處理的行數 printf \u0026#34;a\\nb\\nc\\nd\\n\u0026#34; | xargs -L 2 echo # 輸出: # a b # c d # -s max-chars - 限制命令行長度 echo \u0026#34;very long arguments here\u0026#34; | xargs -s 20 echo 分隔符處理 1 2 3 4 5 6 7 8 9 # -d delimiter - 自訂分隔符 echo \u0026#34;a,b,c,d\u0026#34; | xargs -d, echo # 輸出: a b c d # -0 (--null) - 使用 null 字元作分隔符 find . -name \u0026#34;*.txt\u0026#34; -print0 | xargs -0 ls -l # 處理包含空格的檔案名 echo -e \u0026#34;file 1.txt\\nfile 2.txt\u0026#34; | xargs -d\u0026#39;\\n\u0026#39; ls -l 替換字串選項 1 2 3 4 5 6 7 8 # -I replace-str - 指定替換字串 echo \u0026#34;file1 file2 file3\u0026#34; | xargs -I {} cp {} {}.backup # -i 或 -I{} - 使用 {} 作為替換字串 ls *.txt | xargs -I{} cp {} backup/{} # 複雜替換範例 find . -name \u0026#34;*.log\u0026#34; | xargs -I{} sh -c \u0026#39;echo \u0026#34;Processing: {}\u0026#34;; gzip {}\u0026#39; 並行處理選項 1 2 3 4 5 6 7 8 9 # -P max-procs - 並行執行 echo \u0026#34;1 2 3 4 5\u0026#34; | xargs -n 1 -P 3 sleep # 同時執行最多 3 個 sleep 命令 # -P 0 - 無限制並行 seq 1 10 | xargs -n 1 -P 0 echo # 實際並行範例 find . -name \u0026#34;*.jpg\u0026#34; | xargs -n 1 -P 4 -I{} convert {} {}.thumb.jpg 實戰應用場景 1. 檔案管理操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 批次刪除檔案 find /tmp -name \u0026#34;*.tmp\u0026#34; -mtime +7 | xargs rm -f # 批次複製檔案 ls *.txt | xargs -I{} cp {} backup/ # 批次移動檔案 find . -name \u0026#34;*.old\u0026#34; | xargs -I{} mv {} archive/ # 批次重命名 ls *.jpeg | xargs -I{} sh -c \u0026#39;mv \u0026#34;$1\u0026#34; \u0026#34;${1%.jpeg}.jpg\u0026#34;\u0026#39; _ {} # 建立多個目錄 echo \u0026#34;dir1 dir2 dir3\u0026#34; | xargs mkdir -p # 修改檔案權限 find /var/www -name \u0026#34;*.php\u0026#34; | xargs chmod 644 find /var/www -type d | xargs chmod 755 # 批次壓縮檔案 find . -name \u0026#34;*.log\u0026#34; -size +100M | xargs -I{} gzip {} 2. 文本處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 批次搜尋文本 find . -name \u0026#34;*.txt\u0026#34; | xargs grep -l \u0026#34;pattern\u0026#34; # 批次替換文本 find . -name \u0026#34;*.conf\u0026#34; | xargs sed -i \u0026#39;s/old/new/g\u0026#39; # 統計行數 find . -name \u0026#34;*.py\u0026#34; | xargs wc -l # 批次編碼轉換 find . -name \u0026#34;*.txt\u0026#34; | xargs -I{} iconv -f gbk -t utf8 {} -o {}.utf8 # 批次格式化程式碼 find . -name \u0026#34;*.js\u0026#34; | xargs prettier --write # 批次檢查語法 find . -name \u0026#34;*.sh\u0026#34; | xargs -I{} bash -n {} 3. 系統管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 批次殺死程序 ps aux | grep \u0026#34;process_name\u0026#34; | awk \u0026#39;{print $2}\u0026#39; | xargs kill # 批次服務重啟 echo \u0026#34;nginx apache2 mysql\u0026#34; | xargs -n 1 systemctl restart # 批次安裝軟體包 cat package_list.txt | xargs apt-get install -y # 磁碟使用統計 find /var/log -name \u0026#34;*.log\u0026#34; | xargs du -sh # 批次下載檔案 cat urls.txt | xargs -n 1 -P 5 wget # 批次備份 echo \u0026#34;/etc /var/log /home\u0026#34; | xargs -I{} tar -czf {//}.tar.gz {} 4. 開發與部署 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 批次編譯 find . -name \u0026#34;*.c\u0026#34; | xargs gcc -o output # 批次測試 find . -name \u0026#34;*_test.py\u0026#34; | xargs -I{} python {} # 批次部署 cat server_list.txt | xargs -I{} scp deploy.sh user@{}:/tmp/ # 批次執行遠程命令 cat servers.txt | xargs -I{} ssh {} \u0026#34;uptime\u0026#34; # 批次 Git 操作 find . -name \u0026#34;.git\u0026#34; -type d | xargs -I{} sh -c \u0026#39;cd {} \u0026amp;\u0026amp; git pull\u0026#39; # 批次建構 Docker 映像 ls */Dockerfile | xargs -I{} sh -c \u0026#39;cd $(dirname {}) \u0026amp;\u0026amp; docker build -t $(basename $(pwd)) .\u0026#39; 5. 監控與日誌 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 批次監控檔案變化 find /var/log -name \u0026#34;*.log\u0026#34; | xargs -I{} tail -f {} # 批次日誌分析 find . -name \u0026#34;access.log*\u0026#34; | xargs zcat | grep \u0026#34;ERROR\u0026#34; # 批次清理日誌 find /var/log -name \u0026#34;*.log\u0026#34; -size +100M | xargs truncate -s 0 # 系統資訊收集 echo \u0026#34;/proc/cpuinfo /proc/meminfo /proc/loadavg\u0026#34; | xargs -I{} sh -c \u0026#39;echo \u0026#34;=== {} ===\u0026#34;; cat {}\u0026#39; # 批次檢查服務狀態 echo \u0026#34;nginx mysql redis\u0026#34; | xargs -I{} systemctl status {} 進階技巧 1. 複雜命令組合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 多命令執行 find . -name \u0026#34;*.log\u0026#34; | xargs -I{} sh -c \u0026#39;echo \u0026#34;Processing {}\u0026#34;; wc -l {}; echo \u0026#34;Done\u0026#34;\u0026#39; # 條件執行 find . -name \u0026#34;*.txt\u0026#34; | xargs -I{} sh -c \u0026#39;if [ -s \u0026#34;{}\u0026#34; ]; then echo \u0026#34;Non-empty: {}\u0026#34;; fi\u0026#39; # 錯誤處理 find . -name \u0026#34;*.sh\u0026#34; | xargs -I{} sh -c \u0026#39;bash -n \u0026#34;{}\u0026#34; || echo \u0026#34;Syntax error in {}\u0026#34;\u0026#39; # 結果收集 find . -name \u0026#34;*.py\u0026#34; | xargs -I{} sh -c \u0026#39;echo \u0026#34;{}: $(wc -l \u0026lt; \u0026#34;{}\u0026#34;)\u0026#34;\u0026#39; | sort -k2 -nr # 管道組合 find . -name \u0026#34;*.log\u0026#34; | xargs -I{} sh -c \u0026#39;cat \u0026#34;{}\u0026#34; | grep ERROR | wc -l\u0026#39; | awk \u0026#39;{sum+=$1} END {print sum}\u0026#39; 2. 並行處理最佳化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # CPU 密集型任務 seq 1 100 | xargs -n 1 -P $(nproc) sh -c \u0026#39;echo \u0026#34;Processing $1\u0026#34;; sleep 1; echo \u0026#34;Done $1\u0026#34;\u0026#39; _ # I/O 密集型任務 cat urls.txt | xargs -n 1 -P 10 -I{} sh -c \u0026#39;echo \u0026#34;Downloading {}\u0026#34;; wget -q {}\u0026#39; # 記憶體管理 find . -name \u0026#34;*.big\u0026#34; | xargs -n 1 -P 2 -I{} process_large_file {} # 並行日誌處理 find /var/log -name \u0026#34;*.log\u0026#34; | xargs -n 1 -P 4 -I{} sh -c \u0026#39;gzip \u0026#34;{}\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;Compressed {}\u0026#34;\u0026#39; # 負載均衡 seq 1 1000 | xargs -n 10 -P 8 -I{} process_batch {} 3. 安全性考慮 1 2 3 4 5 6 7 8 9 10 11 # 處理特殊字元 find . -name \u0026#34;*.txt\u0026#34; -print0 | xargs -0 ls -l # 避免命令注入 echo \u0026#34;file; rm -rf /\u0026#34; | xargs -I{} sh -c \u0026#39;ls \u0026#34;$1\u0026#34;\u0026#39; _ {} # 參數驗證 cat files.txt | xargs -I{} sh -c \u0026#39;if [ -f \u0026#34;$1\u0026#34; ]; then process \u0026#34;$1\u0026#34;; fi\u0026#39; _ {} # 路徑安全 find . -name \u0026#34;*.conf\u0026#34; | xargs -I{} sh -c \u0026#39;realpath \u0026#34;$1\u0026#34; | grep \u0026#34;^/safe/path\u0026#34; \u0026amp;\u0026amp; process \u0026#34;$1\u0026#34;\u0026#39; _ {} 4. 效能優化 1 2 3 4 5 6 7 8 9 10 11 # 批次大小優化 find . -name \u0026#34;*.txt\u0026#34; | xargs -n 100 process_files # 記憶體限制 find . -name \u0026#34;*.log\u0026#34; | xargs -s 4096 process_with_memory_limit # 並行數調整 find . -name \u0026#34;*.jpg\u0026#34; | xargs -n 1 -P $(nproc) optimize_image # 緩衝區優化 find . -name \u0026#34;*.data\u0026#34; | xargs -n 50 -P 4 process_data_batch 錯誤處理與除錯 1. 常見問題 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 問題：參數過長 # 解決：使用 -s 限制或分批處理 find . -name \u0026#34;*.txt\u0026#34; | xargs -s 1000 rm # 問題：檔案名包含空格 # 解決：使用 -0 和 -print0 find . -name \u0026#34;*.txt\u0026#34; -print0 | xargs -0 rm # 問題：空輸入執行 # 解決：使用 -r 選項 echo \u0026#34;\u0026#34; | xargs -r echo \u0026#34;不會執行\u0026#34; # 問題：並行競爭 # 解決：使用適當的鎖機制 find . -name \u0026#34;*.log\u0026#34; | xargs -n 1 -P 4 -I{} flock /tmp/lock process {} 2. 除錯技巧 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 使用 -t 查看執行命令 find . -name \u0026#34;*.txt\u0026#34; | xargs -t rm # 使用 -p 交互式確認 find . -name \u0026#34;*.tmp\u0026#34; | xargs -p rm # 逐步測試 echo \u0026#34;test1 test2\u0026#34; | xargs -n 1 echo # 檢查參數 find . -name \u0026#34;*.txt\u0026#34; | xargs -I{} echo \u0026#34;Will process: {}\u0026#34; # 錯誤日誌 find . -name \u0026#34;*.sh\u0026#34; | xargs -I{} sh -c \u0026#39;bash -n \u0026#34;{}\u0026#34; 2\u0026gt;\u0026gt;error.log || echo \u0026#34;Error in {}\u0026#34;\u0026#39; 3. 效能監控 1 2 3 4 5 6 7 8 9 # 執行時間測量 time find . -name \u0026#34;*.txt\u0026#34; | xargs wc -l # 並行效能比較 time seq 1 100 | xargs -n 1 sleep 0.1 # 串行 time seq 1 100 | xargs -n 1 -P 10 sleep 0.1 # 並行 # 資源使用監控 find . -name \u0026#34;*.big\u0026#34; | xargs -n 1 -P 4 -I{} sh -c \u0026#39;echo \u0026#34;Processing {}\u0026#34;; /usr/bin/time -v process {}\u0026#39; 與其他工具整合 1. 與 find 組合 1 2 3 4 5 6 7 8 9 10 11 # 基本組合 find /path -name \u0026#34;pattern\u0026#34; | xargs command # 安全處理 find /path -name \u0026#34;pattern\u0026#34; -print0 | xargs -0 command # 條件過濾 find /path -name \u0026#34;*.txt\u0026#34; -size +1M | xargs -I{} sh -c \u0026#39;echo \u0026#34;Large file: {}\u0026#34;\u0026#39; # 複雜搜尋 find /path -type f -mtime -7 \\( -name \u0026#34;*.log\u0026#34; -o -name \u0026#34;*.txt\u0026#34; \\) | xargs grep \u0026#34;pattern\u0026#34; 2. 與 grep 組合 1 2 3 4 5 6 7 8 9 10 11 # 檔案內容搜尋 find . -name \u0026#34;*.py\u0026#34; | xargs grep -l \u0026#34;import numpy\u0026#34; # 多模式搜尋 find . -name \u0026#34;*.conf\u0026#34; | xargs grep -E \u0026#34;(error|warning|critical)\u0026#34; # 統計匹配 find . -name \u0026#34;*.log\u0026#34; | xargs grep \u0026#34;ERROR\u0026#34; | wc -l # 結果處理 find . -name \u0026#34;*.txt\u0026#34; | xargs grep -H \u0026#34;pattern\u0026#34; | cut -d: -f1 | sort | uniq 3. 與 ssh 組合 1 2 3 4 5 6 7 8 9 10 11 # 遠程並行執行 cat servers.txt | xargs -n 1 -P 5 -I{} ssh {} \u0026#34;command\u0026#34; # 批次檔案傳輸 cat servers.txt | xargs -I{} scp file.txt user@{}:/tmp/ # 遠程監控 cat servers.txt | xargs -I{} ssh {} \u0026#34;uptime; df -h\u0026#34; # 分布式處理 cat servers.txt | xargs -n 1 -P 10 -I{} ssh {} \u0026#34;process_data input.txt\u0026#34; 實用腳本範例 1. 批次檔案處理腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/bin/bash # batch_process.sh - 批次處理檔案 SCRIPT_DIR=\u0026#34;$(cd \u0026#34;$(dirname \u0026#34;${BASH_SOURCE[0]}\u0026#34;)\u0026#34; \u0026amp;\u0026amp; pwd)\u0026#34; INPUT_DIR=\u0026#34;${1:-./input}\u0026#34; OUTPUT_DIR=\u0026#34;${2:-./output}\u0026#34; MAX_PARALLEL=\u0026#34;${3:-4}\u0026#34; # 建立輸出目錄 mkdir -p \u0026#34;$OUTPUT_DIR\u0026#34; # 批次處理 find \u0026#34;$INPUT_DIR\u0026#34; -name \u0026#34;*.txt\u0026#34; -print0 | \\ xargs -0 -n 1 -P \u0026#34;$MAX_PARALLEL\u0026#34; -I{} \\ sh -c \u0026#39; input_file=\u0026#34;$1\u0026#34; output_file=\u0026#34;\u0026#39;\u0026#34;$OUTPUT_DIR\u0026#34;\u0026#39;/$(basename \u0026#34;$1\u0026#34; .txt).processed.txt\u0026#34; echo \u0026#34;Processing: $input_file\u0026#34; # 處理邏輯 sed \u0026#34;s/old/new/g\u0026#34; \u0026#34;$input_file\u0026#34; \u0026gt; \u0026#34;$output_file\u0026#34; echo \u0026#34;Completed: $output_file\u0026#34; \u0026#39; _ {} echo \u0026#34;批次處理完成\u0026#34; 2. 系統清理腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #!/bin/bash # system_cleanup.sh - 系統清理腳本 LOG_FILE=\u0026#34;/var/log/cleanup.log\u0026#34; DRY_RUN=\u0026#34;${1:-false}\u0026#34; log() { echo \u0026#34;$(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;) - $1\u0026#34; | tee -a \u0026#34;$LOG_FILE\u0026#34; } cleanup_logs() { log \u0026#34;開始清理日誌檔案\u0026#34; if [ \u0026#34;$DRY_RUN\u0026#34; = \u0026#34;true\u0026#34; ]; then find /var/log -name \u0026#34;*.log\u0026#34; -size +100M | xargs -I{} echo \u0026#34;Will compress: {}\u0026#34; else find /var/log -name \u0026#34;*.log\u0026#34; -size +100M | \\ xargs -n 1 -P 4 -I{} sh -c \u0026#39;gzip \u0026#34;$1\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;Compressed: $1\u0026#34;\u0026#39; _ {} | \\ tee -a \u0026#34;$LOG_FILE\u0026#34; fi } cleanup_temp() { log \u0026#34;開始清理臨時檔案\u0026#34; if [ \u0026#34;$DRY_RUN\u0026#34; = \u0026#34;true\u0026#34; ]; then find /tmp -type f -mtime +7 | xargs -I{} echo \u0026#34;Will remove: {}\u0026#34; else find /tmp -type f -mtime +7 | \\ xargs -r rm -f fi } cleanup_cache() { log \u0026#34;開始清理快取檔案\u0026#34; if [ \u0026#34;$DRY_RUN\u0026#34; = \u0026#34;true\u0026#34; ]; then find /var/cache -name \u0026#34;*.cache\u0026#34; -mtime +30 | xargs -I{} echo \u0026#34;Will remove: {}\u0026#34; else find /var/cache -name \u0026#34;*.cache\u0026#34; -mtime +30 | \\ xargs -r rm -f fi } # 主執行 log \u0026#34;開始系統清理 (DRY_RUN: $DRY_RUN)\u0026#34; cleanup_logs cleanup_temp cleanup_cache log \u0026#34;系統清理完成\u0026#34; 3. 並行下載腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #!/bin/bash # parallel_download.sh - 並行下載腳本 URL_FILE=\u0026#34;${1:-urls.txt}\u0026#34; DOWNLOAD_DIR=\u0026#34;${2:-./downloads}\u0026#34; MAX_PARALLEL=\u0026#34;${3:-5}\u0026#34; TIMEOUT=\u0026#34;${4:-30}\u0026#34; # 檢查輸入檔案 if [ ! -f \u0026#34;$URL_FILE\u0026#34; ]; then echo \u0026#34;錯誤：找不到 URL 檔案 $URL_FILE\u0026#34; exit 1 fi # 建立下載目錄 mkdir -p \u0026#34;$DOWNLOAD_DIR\u0026#34; # 並行下載 cat \u0026#34;$URL_FILE\u0026#34; | \\ xargs -n 1 -P \u0026#34;$MAX_PARALLEL\u0026#34; -I{} \\ sh -c \u0026#39; url=\u0026#34;$1\u0026#34; dir=\u0026#34;$2\u0026#34; timeout=\u0026#34;$3\u0026#34; filename=$(basename \u0026#34;$url\u0026#34;) output_path=\u0026#34;$dir/$filename\u0026#34; echo \u0026#34;開始下載: $url\u0026#34; if timeout \u0026#34;$timeout\u0026#34; wget -q -O \u0026#34;$output_path\u0026#34; \u0026#34;$url\u0026#34;; then echo \u0026#34;下載成功: $filename\u0026#34; else echo \u0026#34;下載失敗: $url\u0026#34; rm -f \u0026#34;$output_path\u0026#34; fi \u0026#39; _ {} \u0026#34;$DOWNLOAD_DIR\u0026#34; \u0026#34;$TIMEOUT\u0026#34; echo \u0026#34;下載任務完成\u0026#34; # 統計結果 total_files=$(wc -l \u0026lt; \u0026#34;$URL_FILE\u0026#34;) downloaded_files=$(find \u0026#34;$DOWNLOAD_DIR\u0026#34; -type f | wc -l) echo \u0026#34;總計: $total_files 個檔案，成功下載: $downloaded_files 個檔案\u0026#34; 效能最佳化 1. 並行度調整 1 2 3 4 5 6 7 8 9 10 11 # CPU 綁定任務 CPU_CORES=$(nproc) find . -name \u0026#34;*.c\u0026#34; | xargs -n 1 -P \u0026#34;$CPU_CORES\u0026#34; gcc -c # I/O 綁定任務 IO_PARALLEL=$(($(nproc) * 2)) cat urls.txt | xargs -n 1 -P \u0026#34;$IO_PARALLEL\u0026#34; wget # 混合負載 MIXED_PARALLEL=$(($(nproc) + 2)) find . -name \u0026#34;*.log\u0026#34; | xargs -n 1 -P \u0026#34;$MIXED_PARALLEL\u0026#34; process_log 2. 記憶體管理 1 2 3 4 5 6 7 8 9 10 11 # 限制批次大小 find . -name \u0026#34;*.big\u0026#34; | xargs -n 1 process_large_file # 限制命令行長度 find . -name \u0026#34;*.txt\u0026#34; | xargs -s 4096 process_files # 分段處理 find . -name \u0026#34;*.data\u0026#34; | split -l 1000 - batch_ for batch in batch_*; do cat \u0026#34;$batch\u0026#34; | xargs -n 10 -P 4 process_data done 3. 網路優化 1 2 3 4 5 6 7 8 # 連接池 cat servers.txt | xargs -n 1 -P 10 -I{} ssh -o ControlMaster=auto -o ControlPath=/tmp/ssh-%r@%h:%p {} \u0026#34;command\u0026#34; # 重試機制 cat urls.txt | xargs -n 1 -I{} sh -c \u0026#39;for i in {1..3}; do wget \u0026#34;{}\u0026#34; \u0026amp;\u0026amp; break; sleep 5; done\u0026#39; # 頻寬限制 cat large_files.txt | xargs -n 1 -P 2 -I{} rsync --bwlimit=1000 {} destination/ 總結 核心優勢 參數處理：解決命令行參數長度限制 批次操作：高效處理大量檔案和資料 並行執行：充分利用多核心系統資源 管道友好：與其他 Unix 工具完美整合 靈活控制：豐富的選項滿足各種需求 最佳實踐 安全第一：處理包含空格的檔案名使用 -0 和 -print0 適當並行：根據任務類型調整並行度 錯誤處理：使用 -r 避免空輸入執行 測試先行：使用 -t 和 -p 選項測試命令 效能監控：測量並優化批次大小和並行度 常用模式記憶 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 基本模式 find . -name \u0026#34;pattern\u0026#34; | xargs command # 安全模式 find . -name \u0026#34;pattern\u0026#34; -print0 | xargs -0 command # 並行模式 command | xargs -n 1 -P 4 process # 替換模式 echo \u0026#34;files\u0026#34; | xargs -I{} cp {} backup/{} # 交互模式 find . -name \u0026#34;*.tmp\u0026#34; | xargs -p rm xargs 是命令行批次處理和並行執行的瑞士軍刀，掌握其核心概念和常用技巧，能夠大幅提升 Linux 系統管理和自動化任務的效率。記住：合理使用並行處理能夠顯著提升效能，但要注意資源管理和錯誤處理。\n參考資料 GNU Findutils Manual - xargs Linux man xargs Advanced Bash-Scripting Guide Unix Power Tools ","permalink":"https://xinqilin.github.io/post/tools/xargs/","tags":["Linux","Xargs","Command Line","Parallel Processing","Pipe","Shell","Unix"],"title":"Xargs 命令完整指南：Linux 參數處理與並行執行的強大工具"},{"content":"概述 find 是 Linux/Unix 系統中最強大且最常用的檔案搜尋命令之一。它不僅能夠根據各種條件搜尋檔案和目錄，還能對搜尋結果執行各種操作，是系統管理員和開發者必備的核心工具。\n核心特徵 遞歸搜尋：可深入子目錄進行搜尋 多重條件：支援檔名、類型、大小、時間等多種搜尋條件 動作執行：可對搜尋結果執行各種操作 邏輯組合：支援 AND、OR、NOT 等邏輯運算 高效能：針對大型檔案系統優化 基本語法 1 find [搜尋路徑] [搜尋條件] [動作] 基本使用範例 1 2 3 4 5 6 7 8 9 10 11 # 在當前目錄搜尋檔案 find . -name \u0026#34;test.txt\u0026#34; # 在指定目錄搜尋 find /home/user -name \u0026#34;*.log\u0026#34; # 忽略大小寫搜尋 find . -iname \u0026#34;README.md\u0026#34; # 搜尋多個目錄 find /var/log /tmp -name \u0026#34;*.tmp\u0026#34; 依據檔案名稱搜尋 基本檔名搜尋 1 2 3 4 5 6 7 8 9 10 11 # 精確檔名匹配 find /home -name \u0026#34;config.conf\u0026#34; # 萬用字元搜尋 find . -name \u0026#34;*.txt\u0026#34; # 所有 .txt 檔案 find . -name \u0026#34;test*\u0026#34; # 以 test 開頭的檔案 find . -name \u0026#34;*backup*\u0026#34; # 包含 backup 的檔案 # 忽略大小寫 find . -iname \u0026#34;*.PDF\u0026#34; # 不分大小寫搜尋 PDF 檔案 find . -iname \u0026#34;readme*\u0026#34; # 不分大小寫搜尋 readme 開頭的檔案 進階檔名搜尋 1 2 3 4 5 6 7 8 9 10 11 # 使用正規表達式 find . -regex \u0026#34;.*\\.\\(jpg\\|png\\|gif\\)$\u0026#34; # 搜尋圖片檔案 find . -iregex \u0026#34;.*\\.\\(mp3\\|mp4\\|avi\\)$\u0026#34; # 不分大小寫搜尋媒體檔案 # 排除特定檔案 find . -name \u0026#34;*.txt\u0026#34; ! -name \u0026#34;temp*\u0026#34; # 搜尋 txt 但排除 temp 開頭 find . ! -name \u0026#34;.*\u0026#34; # 排除隱藏檔案 # 多個條件組合 find . \\( -name \u0026#34;*.log\u0026#34; -o -name \u0026#34;*.tmp\u0026#34; \\) # OR 條件 find . -name \u0026#34;*.txt\u0026#34; -a -size +1M # AND 條件 依據檔案類型搜尋 基本檔案類型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 檔案類型參數說明 # f: 一般檔案 d: 目錄 # l: 符號連結 p: 命名管道 (FIFO) # s: socket b: 區塊裝置 # c: 字元裝置 # 搜尋目錄 find /var -type d -name \u0026#34;log*\u0026#34; # 搜尋一般檔案 find . -type f -name \u0026#34;*.sh\u0026#34; # 搜尋符號連結 find /usr/bin -type l # 搜尋空檔案 find /tmp -type f -empty # 搜尋空目錄 find /home -type d -empty 實際應用範例 1 2 3 4 5 6 7 8 # 找出所有 shell 腳本 find /usr/local/bin -type f -name \u0026#34;*.sh\u0026#34; -executable # 找出所有損壞的符號連結 find /usr -type l ! -exec test -e {} \\; -print # 找出包含特定副檔名的目錄 find . -type d -exec sh -c \u0026#39;ls \u0026#34;$1\u0026#34;/*.log \u0026gt;/dev/null 2\u0026gt;\u0026amp;1\u0026#39; _ {} \\; -print 依據檔案大小搜尋 基本大小搜尋 1 2 3 4 5 6 7 8 9 10 # 大小單位說明 # c: bytes k: KB (1024 bytes) # M: MB G: GB # +: 大於 -: 小於 精確值: 等於 # 基本大小搜尋 find . -size 50M # 等於 50MB find . -size +100M # 大於 100MB find . -size -1G # 小於 1GB find /var/log -size +10M -size -100M # 10MB 到 100MB 之間 進階大小操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 找出最大的檔案（前 10 個） find /home -type f -exec ls -la {} \\; | sort -k5 -nr | head -10 # 找出超過 1GB 的檔案並顯示大小 find / -size +1G -type f -exec du -h {} \\; 2\u0026gt;/dev/null # 找出空檔案並刪除 find /tmp -type f -empty -delete # 找出大檔案並詢問是否刪除 find /var/log -size +100M -type f -ok rm {} \\; # 按大小範圍分類顯示 find . -type f -size +10M -size -100M -printf \u0026#34;%s %p\\n\u0026#34; | sort -nr 依據時間搜尋 時間類型說明 1 2 3 4 5 6 7 8 9 10 # 時間類型 # mtime: 修改時間 (modify time) # atime: 存取時間 (access time) # ctime: 狀態改變時間 (change time) # 時間單位 # 預設單位: 天 (24小時) # +n: n天之前 # -n: n天之內 # n: 恰好n天前 基本時間搜尋 1 2 3 4 5 6 7 8 9 10 11 12 # 修改時間搜尋 find . -mtime 3 # 恰好 3 天前修改 find . -mtime -7 # 7 天內修改 find . -mtime +30 # 30 天前修改 find . -mtime +7 -mtime -30 # 7-30 天前修改 # 存取時間搜尋 find /home -atime -1 # 1 天內被存取 find /tmp -atime +7 # 7 天以上未被存取 # 狀態改變時間 find . -ctime -1 # 1 天內狀態改變 精確時間搜尋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 分鐘為單位的時間搜尋 find /var/log -mmin -60 # 60 分鐘內修改 find . -amin +120 # 120 分鐘前存取 find /tmp -cmin -30 # 30 分鐘內狀態改變 # 比較檔案時間 find . -newer reference.txt # 比 reference.txt 新的檔案 find . -cnewer backup.tar # 狀態比 backup.tar 新 # 指定日期範圍 find /var/log -newermt \u0026#34;2023-01-01\u0026#34; ! -newermt \u0026#34;2023-12-31\u0026#34; # 今天修改的檔案 find . -daystart -mtime 0 # 昨天修改的檔案 find . -daystart -mtime 1 依據權限搜尋 基本權限搜尋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 精確權限匹配 find /home -perm 755 # 權限恰好是 755 find . -perm 644 # 權限恰好是 644 # 包含指定權限 find /usr/bin -perm -755 # 至少有 755 權限 find . -perm -u+x # 擁有者有執行權限 # 任一符合權限 find /tmp -perm /222 # 任何人有寫入權限 find . -perm /u+w,g+w,o+w # 任何人有寫入權限 # 可執行檔案 find /usr/local/bin -type f -executable find . -type f -perm -u+x # 擁有者可執行 進階權限搜尋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 找出 SUID 檔案 find /usr -perm -4000 -type f 2\u0026gt;/dev/null # 找出 SGID 檔案 find /usr -perm -2000 -type f 2\u0026gt;/dev/null # 找出 sticky bit 目錄 find /tmp -perm -1000 -type d # 找出可寫的檔案（安全檢查） find /etc -type f -writable 2\u0026gt;/dev/null # 找出無權限讀取的檔案 find /home -type f ! -readable 2\u0026gt;/dev/null 依據擁有者搜尋 基本擁有者搜尋 1 2 3 4 5 6 7 8 9 10 11 12 # 依據使用者搜尋 find /home -user john # 屬於 john 的檔案 find /var -user root # 屬於 root 的檔案 find . -user $(whoami) # 屬於當前使用者的檔案 # 依據群組搜尋 find /home -group developers # 屬於 developers 群組 find /var/www -group www-data # 屬於 www-data 群組 # 依據 UID/GID 搜尋 find /home -uid 1000 # UID 為 1000 的檔案 find /var -gid 100 # GID 為 100 的檔案 進階擁有者搜尋 1 2 3 4 5 6 7 8 9 10 # 找出無主檔案（孤兒檔案） find /home -nouser # 沒有對應使用者的檔案 find /var -nogroup # 沒有對應群組的檔案 # 組合條件搜尋 find /home -user john -group staff # 屬於 john 且群組是 staff find /tmp -user root ! -group root # 屬於 root 但群組不是 root # 找出特定使用者的大檔案 find /home -user john -size +100M -type f 執行動作 (-exec 和 -ok) 基本 -exec 用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 基本語法：-exec command {} \\; # {} 代表找到的檔案 # \\; 表示命令結束 # 刪除找到的檔案 find /tmp -name \u0026#34;*.tmp\u0026#34; -exec rm {} \\; # 複製檔案 find . -name \u0026#34;*.txt\u0026#34; -exec cp {} backup/ \\; # 移動檔案 find . -name \u0026#34;*.log\u0026#34; -exec mv {} /var/log/ \\; # 修改權限 find /var/www -type f -exec chmod 644 {} \\; find /var/www -type d -exec chmod 755 {} \\; 進階 -exec 用法 1 2 3 4 5 6 7 8 9 10 11 12 # 使用 -exec {} + 提高效能（批次處理） find . -name \u0026#34;*.txt\u0026#34; -exec grep \u0026#34;pattern\u0026#34; {} + find /tmp -name \u0026#34;*.tmp\u0026#34; -exec rm {} + # 執行複雜命令 find . -type f -name \u0026#34;*.sh\u0026#34; -exec sh -c \u0026#39;echo \u0026#34;Processing: $1\u0026#34;; chmod +x \u0026#34;$1\u0026#34;\u0026#39; _ {} \\; # 在找到的目錄中執行命令 find /var/log -type d -exec sh -c \u0026#39;echo \u0026#34;Directory: $1\u0026#34;; ls -la \u0026#34;$1\u0026#34;\u0026#39; _ {} \\; # 條件執行 find . -name \u0026#34;*.txt\u0026#34; -exec test -s {} \\; -exec echo \u0026#34;Non-empty: {}\u0026#34; \\; 互動式 -ok 用法 1 2 3 4 5 6 7 8 # -ok 會在執行前詢問確認 find /tmp -name \u0026#34;*.old\u0026#34; -ok rm {} \\; # 互動式移動檔案 find . -name \u0026#34;*.bak\u0026#34; -ok mv {} backup/ \\; # 互動式權限修改 find /home -name \u0026#34;*.sh\u0026#34; -ok chmod +x {} \\; 邏輯運算符 基本邏輯運算 1 2 3 4 5 6 7 8 9 10 11 # AND 運算（預設） find . -name \u0026#34;*.txt\u0026#34; -size +1M # 名稱是 *.txt 且大小 \u0026gt; 1M find . -type f -user john # 是檔案且屬於 john # OR 運算 find . \\( -name \u0026#34;*.txt\u0026#34; -o -name \u0026#34;*.md\u0026#34; \\) # txt 或 md 檔案 find . -type f \\( -name \u0026#34;*.log\u0026#34; -o -name \u0026#34;*.tmp\u0026#34; \\) # NOT 運算 find . -type f ! -name \u0026#34;*.txt\u0026#34; # 不是 txt 的檔案 find . ! -path \u0026#34;*/.*\u0026#34; # 排除隱藏目錄 複雜邏輯組合 1 2 3 4 5 6 7 8 # 複雜條件組合 find . \\( -name \u0026#34;*.txt\u0026#34; -o -name \u0026#34;*.md\u0026#34; \\) -a -size +1k -a ! -path \u0026#34;*/tmp/*\u0026#34; # 多重排除條件 find /var/log \\( ! -name \u0026#34;*.gz\u0026#34; ! -name \u0026#34;*.old\u0026#34; \\) -type f -mtime -7 # 巢狀邏輯條件 find . \\( \\( -name \u0026#34;*.c\u0026#34; -o -name \u0026#34;*.h\u0026#34; \\) -a -mtime -7 \\) -o \\( -name \u0026#34;*.py\u0026#34; -a -size +10k \\) 輸出格式化 使用 -printf 格式化輸出 1 2 3 4 5 6 7 8 9 10 11 # 基本格式化 find . -type f -printf \u0026#34;%f\\n\u0026#34; # 只顯示檔名 find . -type f -printf \u0026#34;%p\\t%s\\n\u0026#34; # 路徑和大小 find . -type f -printf \u0026#34;%M %u %g %s %p\\n\u0026#34; # 權限、擁有者、群組、大小、路徑 # 時間格式化 find . -type f -printf \u0026#34;%TY-%Tm-%Td %TH:%TM %p\\n\u0026#34; # 修改時間和路徑 find . -type f -printf \u0026#34;%Ac %p\\n\u0026#34; # 存取時間 # 大小格式化 find . -type f -printf \u0026#34;%10s %p\\n\u0026#34; | sort -nr # 按大小排序 格式化參數說明 1 2 3 4 5 6 7 8 9 10 # 常用格式化參數 # %p: 檔案路徑 # %f: 檔案名稱 # %s: 檔案大小（bytes） # %M: 檔案權限 # %u: 擁有者名稱 # %g: 群組名稱 # %T: 時間相關（需配合時間格式） # %h: 目錄路徑 # %d: 檔案深度 實戰應用場景 系統清理與維護 1 2 3 4 5 6 7 8 9 # 清理臨時檔案 find /tmp -type f -atime +7 -delete # 刪除 7 天未存取的檔案 find /var/log -name \u0026#34;*.log\u0026#34; -size +100M -delete # 刪除大日誌檔案 # 清理快取檔案 find ~/.cache -type f -atime +30 -delete # 清理舊快取 # 備份前清理 find /backup -name \u0026#34;*.tar.gz\u0026#34; -mtime +30 -delete # 刪除 30 天前的備份 檔案整理與歸檔 1 2 3 4 5 6 7 8 # 按日期歸檔檔案 find /data -type f -name \u0026#34;*.log\u0026#34; -mtime +1 -exec gzip {} \\; # 按大小分類檔案 find /home -type f -size +1G -exec ls -lh {} \\; # 移動舊檔案到歸檔目錄 find /project -type f -mtime +90 -exec mv {} /archive/ \\; 安全檢查 1 2 3 4 5 6 7 8 9 10 11 # 檢查 SUID/SGID 檔案 find /usr -type f \\( -perm -4000 -o -perm -2000 \\) -exec ls -l {} \\; # 檢查可寫檔案 find /etc -type f -writable 2\u0026gt;/dev/null # 檢查無主檔案 find /home -nouser -o -nogroup # 檢查異常權限 find /var/www -type f ! -perm 644 -o -type d ! -perm 755 開發與除錯 1 2 3 4 5 6 7 8 9 10 11 12 # 搜尋程式碼 find . -name \u0026#34;*.java\u0026#34; -exec grep -l \u0026#34;className\u0026#34; {} \\; # 找出編譯產生的檔案 find . \\( -name \u0026#34;*.class\u0026#34; -o -name \u0026#34;*.o\u0026#34; -o -name \u0026#34;*.pyc\u0026#34; \\) -delete # 統計不同類型檔案數量 find . -type f -name \u0026#34;*.java\u0026#34; | wc -l find . -type f -name \u0026#34;*.py\u0026#34; -exec wc -l {} + | tail -1 # 檢查程式碼行數 find . -name \u0026#34;*.py\u0026#34; -exec wc -l {} + | sort -nr | head -10 監控與分析 1 2 3 4 5 6 7 8 9 10 11 # 找出最近修改的檔案 find /var/log -type f -mmin -60 -exec ls -lt {} \\; # 監控檔案系統變化 find /etc -newer /tmp/baseline -type f # 分析磁碟使用 find /home -type f -printf \u0026#34;%s %p\\n\u0026#34; | sort -nr | head -20 # 找出重複檔案（基於大小） find /data -type f -printf \u0026#34;%s %p\\n\u0026#34; | sort | uniq -d -w 10 效能優化技巧 提升搜尋效能 1 2 3 4 5 6 7 8 9 10 11 12 13 # 限制搜尋深度 find /usr -maxdepth 3 -name \u0026#34;*.conf\u0026#34; # 排除不必要的目錄 find / -path /proc -prune -o -path /sys -prune -o -name \u0026#34;*.txt\u0026#34; -print # 使用更具體的路徑 find /var/log -name \u0026#34;*.log\u0026#34; # 好 find / -name \u0026#34;*.log\u0026#34; # 較慢 # 將最具選擇性的條件放在前面 find . -name \u0026#34;*.txt\u0026#34; -size +1M # 好 find . -size +1M -name \u0026#34;*.txt\u0026#34; # 也可以，但順序影響效能 批次處理優化 1 2 3 4 5 6 7 8 9 # 使用 {} + 而非 {} \\; 提升效能 find . -name \u0026#34;*.txt\u0026#34; -exec wc -l {} + # 快 find . -name \u0026#34;*.txt\u0026#34; -exec wc -l {} \\; # 慢 # 使用管道處理大量結果 find /var/log -name \u0026#34;*.log\u0026#34; -print0 | xargs -0 grep \u0026#34;ERROR\u0026#34; # 並行處理 find . -name \u0026#34;*.jpg\u0026#34; -print0 | xargs -0 -P 4 -I {} convert {} {}.thumb.jpg 常見錯誤與解決方案 權限錯誤處理 1 2 3 4 5 6 7 8 # 忽略權限錯誤 find /var -name \u0026#34;*.log\u0026#34; 2\u0026gt;/dev/null # 只搜尋有權限的目錄 find /var -readable -name \u0026#34;*.log\u0026#34; # 使用 sudo 搜尋受保護的目錄 sudo find /root -name \u0026#34;*.conf\u0026#34; 特殊字元處理 1 2 3 4 5 6 # 處理檔名中的空格 find . -name \u0026#34;* *\u0026#34; -print0 | xargs -0 ls -l # 處理特殊字元 find . -name \u0026#34;file[1-3].txt\u0026#34; find . -name \u0026#34;*.txt\u0026#34; -not -name \u0026#34;*\\\u0026amp;*\u0026#34; 記憶體使用優化 1 2 3 4 5 6 7 8 9 10 # 避免一次載入過多結果 find /large_dir -name \u0026#34;*.txt\u0026#34; | head -100 # 使用 -quit 在找到第一個結果後停止 find . -name \u0026#34;target.txt\u0026#34; -quit # 分段處理大目錄 find /huge_dir -maxdepth 1 -type d | while read dir; do find \u0026#34;$dir\u0026#34; -name \u0026#34;*.txt\u0026#34; done 與其他工具組合 與 grep 組合 1 2 3 4 5 6 7 8 9 # 在檔案中搜尋內容 find . -name \u0026#34;*.txt\u0026#34; -exec grep -l \u0026#34;pattern\u0026#34; {} \\; # 搜尋並顯示匹配行 find . -name \u0026#34;*.log\u0026#34; -exec grep -Hn \u0026#34;ERROR\u0026#34; {} \\; # 使用 xargs 提升效能 find . -name \u0026#34;*.txt\u0026#34; | xargs grep \u0026#34;pattern\u0026#34; find . -name \u0026#34;*.txt\u0026#34; -print0 | xargs -0 grep \u0026#34;pattern\u0026#34; 與 tar 組合 1 2 3 4 5 # 備份找到的檔案 find /home -name \u0026#34;*.doc\u0026#34; -print0 | tar -czf backup.tar.gz --null -T - # 歸檔舊檔案 find /data -mtime +30 -print0 | tar -czf old_files.tar.gz --null -T - 與 rsync 組合 1 2 # 同步找到的檔案 find /source -name \u0026#34;*.txt\u0026#34; -print0 | rsync -av --files-from=- --from0 /source/ /destination/ 總結 核心優勢 強大的搜尋能力：支援多種條件組合搜尋 批次操作：可對搜尋結果執行各種動作 高度可配置：豐富的參數和選項 跨平台相容：在各種 Unix-like 系統中一致 最佳實踐 明確搜尋範圍：使用具體的路徑而非根目錄 合理使用條件：將最具選擇性的條件放在前面 善用邏輯運算：合理組合 AND、OR、NOT 條件 注意效能：大目錄搜尋時考慮使用 -maxdepth 限制 安全操作：使用 -ok 而非 -exec 進行危險操作 常用技巧記憶 1 2 3 4 5 6 # 日常最常用的模式 find . -name \u0026#34;*.txt\u0026#34; # 基本檔名搜尋 find . -type f -size +100M # 大檔案搜尋 find . -mtime -7 # 最近修改檔案 find . -name \u0026#34;*.tmp\u0026#34; -delete # 清理臨時檔案 find . -name \u0026#34;*.sh\u0026#34; -exec chmod +x {} \\; # 批次修改權限 find 命令的強大之處在於其靈活性和可組合性。熟練掌握這個工具，能夠大幅提升 Linux 系統管理和日常工作的效率。記住：實務中最重要的是理解各種條件的組合邏輯，並根據實際需求選擇最適合的搜尋策略。\n參考資料 GNU Findutils Manual Linux man find Advanced Bash-Scripting Guide Unix Power Tools ","permalink":"https://xinqilin.github.io/post/tools/find/","tags":["Linux","Find","Command Line","File Search","System Administration","Shell","Unix"],"title":"Find 命令完整指南：Linux 檔案搜尋與管理的瑞士軍刀"},{"content":"概述 Ubuntu 是基於 Debian 的 Linux 發行版，以其穩定性、易用性和豐富的軟體生態系統而聞名。它是雲端運算、伺服器部署和開發環境的首選平台，提供長期支援（LTS）版本和定期更新的標準版本。\n核心特徵 穩定可靠：基於 Debian 穩定分支，經過嚴格測試 套件豐富：APT 套件管理系統，數萬個軟體包 社群支援：活躍的開發者和使用者社群 容器友好：優秀的 Docker 和容器化支援 雲端整合：原生支援各大雲端平台 系統安裝與初始設置 基本安裝 1 2 3 4 5 6 7 8 9 10 11 12 13 # 檢查系統版本 lsb_release -a cat /etc/os-release # 檢查硬體資訊 uname -a lscpu free -h df -h # 檢查網路狀態 ip addr show netstat -tuln 系統更新 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 更新套件列表 sudo apt update # 升級已安裝的套件 sudo apt upgrade -y # 完整系統升級 sudo apt full-upgrade -y # 清理不需要的套件 sudo apt autoremove -y sudo apt autoclean # 檢查可升級的套件 apt list --upgradable 時區和語言設定 1 2 3 4 5 6 7 8 9 10 # 設定時區 sudo timedatectl set-timezone Asia/Taipei timedatectl status # 語言和地區設定 sudo locale-gen zh_TW.UTF-8 sudo update-locale LANG=zh_TW.UTF-8 # 檢查當前語言設定 locale 套件管理系統 APT 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 搜尋套件 apt search keyword apt-cache search keyword # 查看套件資訊 apt show package-name apt-cache show package-name # 安裝套件 sudo apt install package-name sudo apt install package1 package2 package3 # 重新安裝套件 sudo apt reinstall package-name # 移除套件 sudo apt remove package-name # 保留配置檔案 sudo apt purge package-name # 完全移除 # 檢查依賴關係 apt depends package-name apt rdepends package-name # 列出已安裝套件 dpkg -l apt list --installed 套件庫管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 添加 PPA 套件庫 sudo add-apt-repository ppa:user/ppa-name sudo apt update # 移除 PPA sudo add-apt-repository --remove ppa:user/ppa-name # 管理套件庫金鑰 wget -qO - https://example.com/key.gpg | sudo apt-key add - sudo apt-key list sudo apt-key del KEY_ID # 編輯套件來源 sudo nano /etc/apt/sources.list ls /etc/apt/sources.list.d/ DEB 套件處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 安裝本地 DEB 套件 sudo dpkg -i package.deb # 修復依賴問題 sudo apt install -f # 移除 DEB 套件 sudo dpkg -r package-name # 查詢 DEB 套件內容 dpkg -L package-name dpkg -c package.deb # 查詢檔案屬於哪個套件 dpkg -S /path/to/file 必備軟體安裝 開發工具 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 基本開發工具 sudo apt install build-essential git vim curl wget htop tree # 程式語言環境 sudo apt install python3 python3-pip nodejs npm default-jdk # 版本控制 sudo apt install git subversion # 編輯器和 IDE sudo apt install vim neovim emacs code # 資料庫工具 sudo apt install mysql-client postgresql-client redis-tools 系統監控工具 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 系統監控 sudo apt install htop iotop iftop nethogs # 系統資訊 sudo apt install neofetch screenfetch inxi # 網路工具 sudo apt install net-tools traceroute nmap tcpdump wireshark # 效能分析 sudo apt install sysstat dstat glances # 日誌分析 sudo apt install logwatch fail2ban 媒體和辦公軟體 1 2 3 4 5 6 7 8 9 10 11 # 媒體播放 sudo apt install vlc audacity gimp # 辦公軟體 sudo apt install libreoffice thunderbird firefox # 壓縮工具 sudo apt install zip unzip rar unrar 7zip # 文件處理 sudo apt install pandoc texlive-full Docker 環境設置 Docker 安裝與配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 移除舊版本 sudo apt remove docker docker-engine docker.io containerd runc # 安裝依賴 sudo apt update sudo apt install apt-transport-https ca-certificates curl gnupg lsb-release # 添加 Docker 官方 GPG 金鑰 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg # 添加套件庫 echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null # 安裝 Docker Engine sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io docker-compose-plugin # 啟動並啟用 Docker 服務 sudo systemctl start docker sudo systemctl enable docker # 將使用者加入 docker 群組 sudo usermod -aG docker $USER newgrp docker # 驗證安裝 docker --version docker run hello-world Ubuntu Docker 容器設置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # 拉取 Ubuntu 映像 docker pull ubuntu:latest docker pull ubuntu:20.04 docker pull ubuntu:22.04 # 建立 Docker 網路 docker network create ubuntu-network # 啟動 Ubuntu 容器 docker run -dit \\ --name ubuntu-container \\ --network ubuntu-network \\ -p 2222:22 \\ -p 8080:8080 \\ -v $(pwd)/workspace:/workspace \\ ubuntu:latest # 進入容器 docker exec -it ubuntu-container bash # 容器內初始化 apt update \u0026amp;\u0026amp; apt upgrade -y yes | unminimize # 安裝基本工具 apt install -y \\ curl \\ wget \\ git \\ vim \\ nano \\ htop \\ tree \\ less \\ man-db \\ openssh-server \\ sudo \\ zip \\ unzip \\ jq \\ python3 \\ python3-pip \\ nodejs \\ npm # 設定 SSH 服務 echo \u0026#39;PermitRootLogin yes\u0026#39; \u0026gt;\u0026gt; /etc/ssh/sshd_config echo \u0026#39;PasswordAuthentication yes\u0026#39; \u0026gt;\u0026gt; /etc/ssh/sshd_config service ssh start # 建立使用者 useradd -m -s /bin/bash developer echo \u0026#39;developer:password\u0026#39; | chpasswd usermod -aG sudo developer 容器管理腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #!/bin/bash # ubuntu_container_manager.sh - Ubuntu 容器管理腳本 CONTAINER_NAME=\u0026#34;ubuntu-dev\u0026#34; NETWORK_NAME=\u0026#34;ubuntu-network\u0026#34; IMAGE=\u0026#34;ubuntu:22.04\u0026#34; start_container() { echo \u0026#34;Starting Ubuntu development container...\u0026#34; # 檢查網路是否存在 if ! docker network ls | grep -q \u0026#34;$NETWORK_NAME\u0026#34;; then echo \u0026#34;Creating network: $NETWORK_NAME\u0026#34; docker network create \u0026#34;$NETWORK_NAME\u0026#34; fi # 檢查容器是否已存在 if docker ps -a | grep -q \u0026#34;$CONTAINER_NAME\u0026#34;; then echo \u0026#34;Starting existing container...\u0026#34; docker start \u0026#34;$CONTAINER_NAME\u0026#34; else echo \u0026#34;Creating new container...\u0026#34; docker run -dit \\ --name \u0026#34;$CONTAINER_NAME\u0026#34; \\ --network \u0026#34;$NETWORK_NAME\u0026#34; \\ -p 2222:22 \\ -p 8080:8080 \\ -p 3000:3000 \\ -v \u0026#34;$(pwd)/workspace:/workspace\u0026#34; \\ -v \u0026#34;$(pwd)/config:/config\u0026#34; \\ \u0026#34;$IMAGE\u0026#34; # 初始化容器 echo \u0026#34;Initializing container...\u0026#34; docker exec \u0026#34;$CONTAINER_NAME\u0026#34; bash -c \u0026#34; apt update \u0026amp;\u0026amp; apt upgrade -y yes | unminimize apt install -y curl wget git vim htop tree less man-db openssh-server sudo zip unzip jq python3 python3-pip nodejs npm echo \u0026#39;PermitRootLogin yes\u0026#39; \u0026gt;\u0026gt; /etc/ssh/sshd_config echo \u0026#39;PasswordAuthentication yes\u0026#39; \u0026gt;\u0026gt; /etc/ssh/sshd_config service ssh start useradd -m -s /bin/bash developer echo \u0026#39;developer:developer\u0026#39; | chpasswd usermod -aG sudo developer \u0026#34; fi echo \u0026#34;Container started successfully!\u0026#34; echo \u0026#34;SSH: ssh -p 2222 developer@localhost\u0026#34; echo \u0026#34;Enter: docker exec -it $CONTAINER_NAME bash\u0026#34; } stop_container() { echo \u0026#34;Stopping container...\u0026#34; docker stop \u0026#34;$CONTAINER_NAME\u0026#34; } remove_container() { echo \u0026#34;Removing container...\u0026#34; docker stop \u0026#34;$CONTAINER_NAME\u0026#34; 2\u0026gt;/dev/null || true docker rm \u0026#34;$CONTAINER_NAME\u0026#34; 2\u0026gt;/dev/null || true } status_container() { echo \u0026#34;Container status:\u0026#34; docker ps -a | grep \u0026#34;$CONTAINER_NAME\u0026#34; || echo \u0026#34;Container not found\u0026#34; } case \u0026#34;$1\u0026#34; in start) start_container ;; stop) stop_container ;; remove) remove_container ;; status) status_container ;; restart) stop_container sleep 2 start_container ;; *) echo \u0026#34;Usage: $0 {start|stop|remove|status|restart}\u0026#34; exit 1 ;; esac 系統管理與維護 服務管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 檢查服務狀態 sudo systemctl status service-name sudo systemctl list-units --type=service # 啟動/停止/重啟服務 sudo systemctl start service-name sudo systemctl stop service-name sudo systemctl restart service-name sudo systemctl reload service-name # 啟用/停用服務 sudo systemctl enable service-name sudo systemctl disable service-name # 檢查服務日誌 sudo journalctl -u service-name sudo journalctl -u service-name -f # 即時日誌 # 檢查開機啟動的服務 sudo systemctl list-unit-files --state=enabled 使用者和權限管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 使用者管理 sudo useradd -m -s /bin/bash username sudo passwd username sudo userdel username sudo usermod -aG group username # 群組管理 sudo groupadd groupname sudo groupdel groupname groups username # 權限管理 chmod 755 file chmod u+x file chown user:group file sudo chown -R user:group directory/ # 查看使用者資訊 id username who w last 系統監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # CPU 和記憶體使用率 top htop free -h cat /proc/meminfo # 磁碟使用情況 df -h du -sh directory/ lsblk fdisk -l # 網路狀態 netstat -tuln ss -tuln iftop nethogs # 系統負載 uptime cat /proc/loadavg vmstat 1 5 iostat 1 5 日誌管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 系統日誌 sudo journalctl sudo journalctl -f # 即時日誌 sudo journalctl --since \u0026#34;1 hour ago\u0026#34; sudo journalctl --until \u0026#34;2023-01-01\u0026#34; # 日誌大小管理 sudo journalctl --disk-usage sudo journalctl --vacuum-size=100M sudo journalctl --vacuum-time=30d # 傳統日誌檔案 tail -f /var/log/syslog tail -f /var/log/auth.log tail -f /var/log/apache2/access.log # 日誌輪轉 sudo logrotate -d /etc/logrotate.conf sudo logrotate -f /etc/logrotate.conf 網路配置 網路接口管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 檢查網路接口 ip addr show ip link show ifconfig # 網路配置（Netplan） sudo nano /etc/netplan/00-installer-config.yaml # 範例 Netplan 配置 network: version: 2 renderer: networkd ethernets: enp0s3: dhcp4: true enp0s8: addresses: - 192.168.1.100/24 gateway4: 192.168.1.1 nameservers: addresses: [8.8.8.8, 1.1.1.1] # 應用網路配置 sudo netplan try sudo netplan apply # 重啟網路服務 sudo systemctl restart networking sudo systemctl restart systemd-networkd 防火牆設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # UFW 防火牆 sudo ufw status sudo ufw enable sudo ufw disable # 開放連接埠 sudo ufw allow 22/tcp sudo ufw allow 80/tcp sudo ufw allow 443/tcp sudo ufw allow from 192.168.1.0/24 # 拒絕連接 sudo ufw deny 23/tcp sudo ufw deny from 192.168.2.100 # 檢查規則 sudo ufw status numbered sudo ufw delete 1 # 重設防火牆 sudo ufw --force reset SSH 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 安裝和啟動 SSH sudo apt install openssh-server sudo systemctl start ssh sudo systemctl enable ssh # SSH 配置 sudo nano /etc/ssh/sshd_config # 重要 SSH 設定 Port 22 PermitRootLogin no PasswordAuthentication yes PubkeyAuthentication yes AllowUsers username # 重啟 SSH 服務 sudo systemctl restart ssh # SSH 金鑰管理 ssh-keygen -t rsa -b 4096 ssh-copy-id user@host 安全加固 系統安全設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 更新系統 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y # 安裝安全工具 sudo apt install fail2ban ufw rkhunter chkrootkit # 設定 fail2ban sudo nano /etc/fail2ban/jail.local [DEFAULT] bantime = 3600 findtime = 600 maxretry = 3 [sshd] enabled = true port = ssh filter = sshd logpath = /var/log/auth.log sudo systemctl restart fail2ban # 檢查安全狀態 sudo rkhunter --check sudo chkrootkit 檔案系統安全 1 2 3 4 5 6 7 8 9 10 11 12 13 # 設定適當的檔案權限 sudo chmod 644 /etc/passwd sudo chmod 600 /etc/shadow sudo chmod 644 /etc/group # 查找具有特殊權限的檔案 find / -perm -4000 -type f 2\u0026gt;/dev/null # SUID find / -perm -2000 -type f 2\u0026gt;/dev/null # SGID find / -perm -1000 -type d 2\u0026gt;/dev/null # Sticky bit # 檔案系統掃描 sudo find / -nouser -print 2\u0026gt;/dev/null sudo find / -nogroup -print 2\u0026gt;/dev/null 效能調整與最佳化 系統效能監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 系統效能監控腳本 #!/bin/bash # system_monitor.sh echo \u0026#34;=== System Performance Monitor ===\u0026#34; echo \u0026#34;Timestamp: $(date)\u0026#34; echo echo \u0026#34;=== CPU Information ===\u0026#34; echo \u0026#34;CPU Usage:\u0026#34; top -bn1 | grep \u0026#34;Cpu(s)\u0026#34; | awk \u0026#39;{print \u0026#34;CPU Load: \u0026#34; $2}\u0026#39; echo -e \u0026#34;\\nCPU Cores:\u0026#34; nproc echo \u0026#34;=== Memory Information ===\u0026#34; free -h echo -e \u0026#34;\\n=== Disk Usage ===\u0026#34; df -h | grep -E \u0026#39;^/dev/\u0026#39; echo -e \u0026#34;\\n=== Network Statistics ===\u0026#34; ss -tuln | wc -l | awk \u0026#39;{print \u0026#34;Active Connections: \u0026#34; $1}\u0026#39; echo -e \u0026#34;\\n=== System Load ===\u0026#34; uptime echo -e \u0026#34;\\n=== Top Processes by CPU ===\u0026#34; ps aux --sort=-%cpu | head -6 echo -e \u0026#34;\\n=== Top Processes by Memory ===\u0026#34; ps aux --sort=-%mem | head -6 系統清理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/bin/bash # system_cleanup.sh - 系統清理腳本 echo \u0026#34;Starting system cleanup...\u0026#34; # 清理套件快取 echo \u0026#34;Cleaning package cache...\u0026#34; sudo apt autoclean sudo apt autoremove -y # 清理日誌檔案 echo \u0026#34;Cleaning log files...\u0026#34; sudo journalctl --vacuum-time=30d # 清理暫存檔案 echo \u0026#34;Cleaning temporary files...\u0026#34; sudo rm -rf /tmp/* sudo rm -rf /var/tmp/* # 清理使用者暫存 echo \u0026#34;Cleaning user cache...\u0026#34; rm -rf ~/.cache/* rm -rf ~/.local/share/Trash/* # 清理舊核心 echo \u0026#34;Cleaning old kernels...\u0026#34; dpkg -l | grep linux-image | awk \u0026#39;{print $2}\u0026#39; | sort -V | head -n -2 | xargs sudo apt purge -y # 檢查磁碟空間 echo \u0026#34;Disk space after cleanup:\u0026#34; df -h echo \u0026#34;System cleanup completed!\u0026#34; 備份與恢復 系統備份 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #!/bin/bash # backup_system.sh - 系統備份腳本 BACKUP_DIR=\u0026#34;/backup\u0026#34; DATE=$(date +%Y%m%d_%H%M%S) HOSTNAME=$(hostname) mkdir -p \u0026#34;$BACKUP_DIR\u0026#34; echo \u0026#34;Starting system backup...\u0026#34; # 備份重要配置檔案 echo \u0026#34;Backing up configuration files...\u0026#34; tar -czf \u0026#34;$BACKUP_DIR/config_$HOSTNAME_$DATE.tar.gz\u0026#34; \\ /etc \\ /var/log \\ /home \\ --exclude=/home/*/.cache \\ --exclude=/home/*/Downloads # 備份已安裝套件列表 echo \u0026#34;Backing up package list...\u0026#34; dpkg --get-selections \u0026gt; \u0026#34;$BACKUP_DIR/packages_$HOSTNAME_$DATE.txt\u0026#34; apt-mark showmanual \u0026gt; \u0026#34;$BACKUP_DIR/manual_packages_$HOSTNAME_$DATE.txt\u0026#34; # 備份系統資訊 echo \u0026#34;Backing up system information...\u0026#34; { echo \u0026#34;=== System Information ===\u0026#34; uname -a lsb_release -a echo -e \u0026#34;\\n=== Hardware Information ===\u0026#34; lscpu free -h df -h echo -e \u0026#34;\\n=== Network Configuration ===\u0026#34; ip addr show } \u0026gt; \u0026#34;$BACKUP_DIR/system_info_$HOSTNAME_$DATE.txt\u0026#34; echo \u0026#34;Backup completed: $BACKUP_DIR\u0026#34; ls -la \u0026#34;$BACKUP_DIR\u0026#34;/*$DATE* 系統恢復 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/bin/bash # restore_system.sh - 系統恢復腳本 BACKUP_FILE=\u0026#34;$1\u0026#34; if [ -z \u0026#34;$BACKUP_FILE\u0026#34; ]; then echo \u0026#34;Usage: $0 \u0026lt;backup_file.tar.gz\u0026gt;\u0026#34; exit 1 fi if [ ! -f \u0026#34;$BACKUP_FILE\u0026#34; ]; then echo \u0026#34;Backup file not found: $BACKUP_FILE\u0026#34; exit 1 fi echo \u0026#34;WARNING: This will restore system files from backup.\u0026#34; echo \u0026#34;Backup file: $BACKUP_FILE\u0026#34; read -p \u0026#34;Continue? (y/N): \u0026#34; confirm if [[ $confirm != [yY] ]]; then echo \u0026#34;Restore cancelled.\u0026#34; exit 0 fi echo \u0026#34;Starting system restore...\u0026#34; # 備份當前配置 echo \u0026#34;Backing up current configuration...\u0026#34; sudo tar -czf \u0026#34;/tmp/current_config_$(date +%Y%m%d_%H%M%S).tar.gz\u0026#34; /etc # 恢復檔案 echo \u0026#34;Restoring files...\u0026#34; sudo tar -xzf \u0026#34;$BACKUP_FILE\u0026#34; -C / echo \u0026#34;Restore completed. Please reboot the system.\u0026#34; 自動化腳本 系統初始化腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #!/bin/bash # ubuntu_setup.sh - Ubuntu 系統初始化腳本 set -e echo \u0026#34;=== Ubuntu System Setup Script ===\u0026#34; # 更新系統 echo \u0026#34;Updating system...\u0026#34; sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y # 安裝基本工具 echo \u0026#34;Installing essential tools...\u0026#34; sudo apt install -y \\ curl \\ wget \\ git \\ vim \\ htop \\ tree \\ unzip \\ zip \\ jq \\ build-essential \\ software-properties-common \\ apt-transport-https \\ ca-certificates \\ gnupg \\ lsb-release # 安裝開發工具 echo \u0026#34;Installing development tools...\u0026#34; sudo apt install -y \\ python3 \\ python3-pip \\ nodejs \\ npm \\ default-jdk \\ golang-go # 安裝 Docker echo \u0026#34;Installing Docker...\u0026#34; curl -fsSL https://get.docker.com | sh sudo usermod -aG docker $USER # 配置 Git echo \u0026#34;Configuring Git...\u0026#34; read -p \u0026#34;Enter your Git username: \u0026#34; git_username read -p \u0026#34;Enter your Git email: \u0026#34; git_email git config --global user.name \u0026#34;$git_username\u0026#34; git config --global user.email \u0026#34;$git_email\u0026#34; # 設定 SSH echo \u0026#34;Setting up SSH...\u0026#34; sudo systemctl enable ssh sudo systemctl start ssh # 安裝常用軟體 echo \u0026#34;Installing common applications...\u0026#34; sudo apt install -y \\ firefox \\ vlc \\ gimp \\ libreoffice \\ thunderbird # 清理 echo \u0026#34;Cleaning up...\u0026#34; sudo apt autoremove -y sudo apt autoclean echo \u0026#34;=== Setup completed! ===\u0026#34; echo \u0026#34;Please reboot the system to ensure all changes take effect.\u0026#34; 故障排除 常見問題解決 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 套件管理問題 sudo apt update --fix-missing sudo dpkg --configure -a sudo apt install -f # 網路連接問題 sudo systemctl restart networking sudo systemctl restart systemd-resolved sudo dhclient -r \u0026amp;\u0026amp; sudo dhclient # SSH 連接問題 sudo systemctl status ssh sudo systemctl restart ssh sudo tail -f /var/log/auth.log # 磁碟空間不足 sudo du -sh /* | sort -hr sudo find / -type f -size +100M sudo apt autoremove sudo apt autoclean # 記憶體不足 free -h sudo swapoff -a \u0026amp;\u0026amp; sudo swapon -a echo 3 | sudo tee /proc/sys/vm/drop_caches 總結 核心優勢 穩定可靠：企業級穩定性和長期支援 易於使用：友好的使用者介面和豐富的文檔 套件豐富：強大的 APT 套件管理系統 社群支援：活躍的開發者和使用者社群 容器化友好：優秀的 Docker 和雲端支援 最佳實踐 定期更新：保持系統和軟體包的最新狀態 安全加固：配置防火牆、fail2ban 和適當的使用者權限 監控系統：定期檢查系統效能和資源使用情況 備份重要資料：建立定期備份策略 文檔記錄：記錄系統配置和變更 學習路徑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 初學者階段 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade # 系統更新 sudo apt install package-name # 軟體安裝 systemctl status service-name # 服務管理 # 進階階段 docker run -it ubuntu:latest # 容器化應用 sudo ufw allow 80/tcp # 防火牆配置 sudo journalctl -u service-name # 日誌分析 # 專家階段 netplan apply # 網路配置 systemctl edit service-name # 服務自定義 crontab -e # 自動化任務 Ubuntu 是現代 Linux 發行版的代表，掌握其使用技巧能夠大幅提升系統管理和開發效率。記住：理解 Linux 基礎概念是有效使用 Ubuntu 的關鍵，善用社群資源和文檔可以解決大部分問題。\n參考資料 Ubuntu Official Documentation Ubuntu Community Help Wiki APT User\u0026rsquo;s Guide systemd Documentation Docker on Ubuntu ","permalink":"https://xinqilin.github.io/post/tools/ubuntu/","tags":["Ubuntu","Linux","System Administration","Package Management","Docker","Server","Command Line"],"title":"Ubuntu 系統管理完整指南：Linux 入門到進階實戰"},{"content":"TreeSet TreeSet使用是紅黑樹。\n自訂排序\nSet treeSet = new TreeSet\u0026lt;\u0026gt;(Comparator.comparing(String::length));\n1 2 3 4 5 6 7 8 9 10 11 12 Set\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); treeSet.add(1); treeSet.add(2); treeSet.add(3); Iterator\u0026lt;Integer\u0026gt; itr = treeSet.iterator(); // Iterator\u0026lt;String\u0026gt; itr = treeSet.descendingIterator(); // 降冪 while (itr.hasNext()) { log.info(itr.next()); } .first() =\u0026gt; 返回第一個元素, last() =\u0026gt; 返回最後一個元素 1 2 3 4 5 6 7 8 9 10 TreeSet\u0026lt;String\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); treeSet.add(1); treeSet.add(2); treeSet.add(3); treeSet.add(4); treeSet.add(5); assertEquals(1, treeSet.first()); assertEquals(5, treeSet.last()); subSet(fromKey, toKey) =\u0026gt; fromElement 到 toElement的元素 (跟 substring 一樣 包頭不包尾) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 SortedSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); treeSet.add(1); treeSet.add(2); treeSet.add(3); treeSet.add(4); treeSet.add(5); treeSet.add(6); Set\u0026lt;Integer\u0026gt; expectedSet = new TreeSet\u0026lt;\u0026gt;(); expectedSet.add(2); expectedSet.add(3); expectedSet.add(4); expectedSet.add(5); assertEquals(expectedSet, treeSet.subSet(2, 6)); headSet() =\u0026gt; 返回小於指定 key 的 element, tailSet() =\u0026gt; 返回大於等於指定 key 的 element 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 SortedSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); treeSet.add(1); treeSet.add(2); treeSet.add(3); treeSet.add(4); treeSet.add(5); treeSet.add(6); System.out.println(treeSet.headSet(6)); // [1, 2, 3, 4, 5] System.out.println(treeSet.tailSet(3)); // [3, 4, 5, 6] System.out.println( treeSet.subSet(3, 7)); // [3, 4, 5, 6] assertEquals(treeSet.headSet(6), treeSet.subSet(1, 6)); assertEquals(treeSet.tailSet(3), treeSet.subSet(3, 7)); issue: LC issue\n","permalink":"https://xinqilin.github.io/post/backend/treeset/","tags":["Java","TreeSet","Data Structure","Red-Black Tree","Collections","Sorting"],"title":"Java TreeSet 資料結構詳解：排序集合與紅黑樹實作原理"},{"content":"概述 在撰寫 Shell Script 時，我們經常需要對檔案、目錄或字串的狀態進行判斷，例如檢查檔案是否存在、是否可讀，或判斷字串是否為空。這時就需要使用測試表達式 [ ... ] 或 test 指令。本文將詳細介紹這些常用的表達式及其用法。\n檔案測試表達式 檔案測試表達式用於判斷檔案的類型或權限狀態。其回傳值為布林值（true 或 false），可搭配 if 條件式使用。\n語法 1 2 3 if [ -\u0026lt;operator\u0026gt; \u0026lt;filename\u0026gt; ]; then # do something fi 常用運算子 運算子 說明 範例 -e 如果檔案存在 (exist)，則為 true [ -e /etc/hosts ] -d 如果檔案是目錄 (directory)，則為 true [ -d /home/user ] -f 如果檔案是常規檔案 (regular file)，則為 true [ -f /etc/passwd ] -L 如果檔案是符號連結 (symbolic link)，則為 true [ -L /usr/bin/python ] -h 與 -L 相同，如果檔案是符號連結，則為 true [ -h /usr/bin/python ] -r 如果檔案可讀 (readable)，則為 true [ -r /etc/shadow ] -w 如果檔案可寫 (writable)，則為 true [ -w /tmp/test.log ] -x 如果檔案可執行 (executable)，則為 true [ -x ./deploy.sh ] -s 如果檔案大小不為 0，則為 true [ -s /var/log/syslog ] 檔案比較運算子 用於比較兩個檔案的新舊關係。\n運算子 說明 範例 f1 -nt f2 如果檔案 f1 比 f2 新 (newer than)，則為 true [ file1.log -nt file2.log ] f1 -ot f2 如果檔案 f1 比 f2 舊 (older than)，則為 true [ file1.log -ot file2.log ] 字串與數值測試表達式 除了檔案，測試表達式也常用於比較數值或判斷字串狀態。\n數值比較 運算子 說明 等價符號 -eq 等於 (equal) == -ne 不等於 (not equal) != -gt 大於 (greater than) \u0026gt; -ge 大於或等於 (greater or equal) \u0026gt;= -lt 小於 (less than) \u0026lt; -le 小於或等於 (less or equal) \u0026lt;= 字串比較 運算子 說明 範例 -n 如果字串長度不為 0，則為 true [ -n \u0026quot;$my_var\u0026quot; ] -z 如果字串長度為 0 (zero)，則為 true [ -z \u0026quot;$my_var\u0026quot; ] $string 如果字串不為空，則為 true (與 -n 效果相同) [ \u0026quot;$my_var\u0026quot; ] 邏輯運算子 用於組合多個表達式。\n運算子 說明 範例 ! NOT：反轉表達式的結果 [ ! -d /tmp/non_existent ] -a AND：兩個表達式都為 true 時，結果才為 true [ -r \u0026quot;$file\u0026quot; -a -s \u0026quot;$file\u0026quot; ] -o OR：兩個表達式只要有一個為 true，結果就為 true [ -d \u0026quot;$dir\u0026quot; -o -f \u0026quot;$dir\u0026quot; ] 注意：建議使用 \u0026amp;\u0026amp; 和 || 來取代 -a 和 -o，因為它們更符合現代 Shell 的標準且更安全。\n1 2 3 4 5 6 7 8 9 # 使用 \u0026amp;\u0026amp; (AND) if [ -r \u0026#34;$file\u0026#34; ] \u0026amp;\u0026amp; [ -s \u0026#34;$file\u0026#34; ]; then echo \u0026#34;檔案可讀且內容不為空\u0026#34; fi # 使用 || (OR) if [ -d \u0026#34;$path\u0026#34; ] || [ -f \u0026#34;$path\u0026#34; ]; then echo \u0026#34;路徑是一個目錄或檔案\u0026#34; fi 實用範例 範例 1：檢查目錄是否存在，若不存在則建立 1 2 3 4 5 6 7 8 9 10 #!/bin/bash LOG_DIR=\u0026#34;/var/log/myapp\u0026#34; if [ ! -d \u0026#34;$LOG_DIR\u0026#34; ]; then echo \u0026#34;日誌目錄不存在，正在建立: $LOG_DIR\u0026#34; mkdir -p \u0026#34;$LOG_DIR\u0026#34; else echo \u0026#34;日誌目錄已存在。\u0026#34; fi 範例 2：檢查字串變數是否為空 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/bash USERNAME=\u0026#34;\u0026#34; # ... 從某處讀取使用者名稱 ... if [ -z \u0026#34;$USERNAME\u0026#34; ]; then echo \u0026#34;錯誤：使用者名稱不能為空！\u0026#34; exit 1 fi # 另一種寫法 if [ ! \u0026#34;$USERNAME\u0026#34; ]; then echo \u0026#34;錯誤：使用者名稱不能為空！\u0026#34; exit 1 fi 範例 3：結合多個條件 1 2 3 4 5 6 7 8 9 10 #!/bin/bash CONFIG_FILE=\u0026#34;config.conf\u0026#34; if [ -f \u0026#34;$CONFIG_FILE\u0026#34; ] \u0026amp;\u0026amp; [ -r \u0026#34;$CONFIG_FILE\u0026#34; ]; then echo \u0026#34;設定檔存在且可讀取，載入設定...\u0026#34; source \u0026#34;$CONFIG_FILE\u0026#34; else echo \u0026#34;警告：找不到設定檔或無法讀取。\u0026#34; fi ","permalink":"https://xinqilin.github.io/post/tools/fileexpress/","tags":["Shell","Bash","File System","Scripting"],"title":"Shell 檔案與字串表達式詳解"},{"content":"概述 鏈表反轉是數據結構與演算法中的經典問題，要求將單向鏈表的指向關係完全反轉。這個問題看似簡單，但涉及到指標操作的細節，是考驗編程基本功的重要題型。\n問題定義 給定一個單向鏈表，將其反轉並回傳新的頭節點。\n範例：\n1 2 輸入：1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; NULL 輸出：5 -\u0026gt; 4 -\u0026gt; 3 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; NULL 鏈表節點定義 1 2 3 4 5 6 7 8 9 10 11 public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } 解法一：迭代實作 基本思路 使用三個指標 prev、current、next 來逐步改變每個節點的指向關係。\n算法步驟 初始化 prev = null，current = head 當 current != null 時： 保存 current.next 到 next 將 current.next 指向 prev 移動 prev 和 current 指標 回傳 prev（新的頭節點） 實作代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode current = head; while (current != null) { ListNode next = current.next; // 保存下一個節點 current.next = prev; // 反轉指標 prev = current; // 移動 prev current = next; // 移動 current } return prev; // prev 現在是新的頭節點 } } 圖解過程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 初始狀態： prev = null, current = 1 null 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null 第一步： next = 2, current.next = prev null \u0026lt;- 1 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null prev current 第二步： next = 3, current.next = prev null \u0026lt;- 1 \u0026lt;- 2 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null prev current ... 最終狀態： null \u0026lt;- 1 \u0026lt;- 2 \u0026lt;- 3 \u0026lt;- 4 \u0026lt;- 5 null prev current 解法二：遞歸實作 基本思路 使用遞歸的方式，從鏈表尾部開始反轉，利用遞歸回溯的特性來改變指標指向。\n算法步驟 遞歸到鏈表最後一個節點 在回溯過程中，逐步反轉每個節點的指向 回傳原鏈表的尾節點（新的頭節點） 實作代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Solution { public ListNode reverseList(ListNode head) { // 基礎情況：空節點或只有一個節點 if (head == null || head.next == null) { return head; } // 遞歸反轉子鏈表 ListNode newHead = reverseList(head.next); // 反轉當前節點的指向 head.next.next = head; head.next = null; return newHead; } } 遞歸過程分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 原鏈表：1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; null 遞歸調用棧： reverseList(1) -\u0026gt; reverseList(2) -\u0026gt; ... -\u0026gt; reverseList(5) 回溯階段： 1. reverseList(5) 回傳 5 2. reverseList(4)： - newHead = 5 - 4.next.next = 4 (即 5.next = 4) - 4.next = null - 回傳 5 3. reverseList(3)： - newHead = 5 - 3.next.next = 3 (即 4.next = 3) - 3.next = null - 回傳 5 ... 最終結果：5 -\u0026gt; 4 -\u0026gt; 3 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; null 時間與空間複雜度分析 方法 時間複雜度 空間複雜度 優點 缺點 迭代 O(n) O(1) 空間效率高，直觀易懂 需要處理多個指標 遞歸 O(n) O(n) 代碼簡潔，邏輯清晰 使用額外堆疊空間 進階應用 1. 反轉鏈表的前 N 個節點 問題：反轉鏈表的前 N 個節點。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Solution { private ListNode successor = null; // 後驅節點 public ListNode reverseN(ListNode head, int n) { if (n == 1) { // 記錄第 n+1 個節點 successor = head.next; return head; } // 以 head.next 為起點，需要反轉前 n-1 個節點 ListNode last = reverseN(head.next, n - 1); head.next.next = head; head.next = successor; // 讓反轉之後的 head 節點和後面的節點連起來 return last; } } 2. 反轉鏈表的指定區間（LeetCode 92） 問題：反轉從位置 m 到 n 的鏈表。請使用一趟掃描完成反轉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { // 創建虛擬頭節點 ListNode dummy = new ListNode(0); dummy.next = head; // 找到 left 的前一個節點 ListNode prev = dummy; for (int i = 0; i \u0026lt; left - 1; i++) { prev = prev.next; } // 開始反轉 ListNode current = prev.next; ListNode next = null; for (int i = 0; i \u0026lt; right - left; i++) { next = current.next; current.next = next.next; next.next = prev.next; prev.next = next; } return dummy.next; } } 3. K 個一組反轉鏈表（LeetCode 25） 問題：給定一個鏈表，每 k 個節點一組進行反轉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class Solution { public ListNode reverseKGroup(ListNode head, int k) { if (head == null) return null; // 檢查剩餘節點是否足夠 k 個 ListNode a = head, b = head; for (int i = 0; i \u0026lt; k; i++) { if (b == null) return head; // 不足 k 個，直接返回 b = b.next; } // 反轉前 k 個元素 ListNode newHead = reverse(a, b); // 遞歸反轉後續的鏈表並連接 a.next = reverseKGroup(b, k); return newHead; } // 反轉 [a, b) 區間的鏈表 private ListNode reverse(ListNode a, ListNode b) { ListNode prev = null; ListNode current = a; while (current != b) { ListNode next = current.next; current.next = prev; prev = current; current = next; } return prev; } } 實作技巧與注意事項 1. 邊界條件處理 1 2 3 4 // 檢查空鏈表和單節點鏈表 if (head == null || head.next == null) { return head; } 2. 使用虛擬頭節點 在處理鏈表頭部變化的問題時，虛擬頭節點可以簡化邏輯：\n1 2 3 4 ListNode dummy = new ListNode(0); dummy.next = head; // ... 操作 return dummy.next; 3. 指標操作的順序 在改變指標指向時，必須先保存下一個節點：\n1 2 ListNode next = current.next; // 先保存 current.next = prev; // 再修改 4. 遞歸終止條件 確保遞歸有明確的終止條件：\n1 2 3 if (head == null || head.next == null) { return head; // 基礎情況 } 常見變體問題 1. 判斷鏈表是否為回文 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public boolean isPalindrome(ListNode head) { if (head == null) return true; // 找到中點 ListNode slow = head, fast = head; while (fast.next != null \u0026amp;\u0026amp; fast.next.next != null) { slow = slow.next; fast = fast.next.next; } // 反轉後半部分 ListNode secondHalf = reverseList(slow.next); // 比較前後兩部分 ListNode p1 = head, p2 = secondHalf; while (p2 != null) { if (p1.val != p2.val) return false; p1 = p1.next; p2 = p2.next; } return true; } 2. 兩兩交換鏈表中的節點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode prev = dummy; while (prev.next != null \u0026amp;\u0026amp; prev.next.next != null) { ListNode first = prev.next; ListNode second = prev.next.next; // 交換 prev.next = second; first.next = second.next; second.next = first; // 移動 prev prev = first; } return dummy.next; } 最佳實踐 選擇合適的方法：對於簡單的鏈表反轉，推薦使用迭代方法 注意空間複雜度：在空間受限的環境下避免使用遞歸 處理邊界情況：始終檢查空鏈表和單節點情況 使用虛擬節點：簡化頭節點的處理邏輯 測試充分：測試各種邊界情況和特殊輸入 總結 鏈表反轉是一個看似簡單但細節豐富的問題。掌握這個問題的關鍵在於：\n理解指標操作：正確處理節點間的指向關係 選擇合適方法：根據場景選擇迭代或遞歸實作 處理邊界情況：確保算法在各種輸入下都能正確運行 靈活應用：將基本技巧應用到更複雜的變體問題中 通過反復練習和理解，鏈表反轉將成為解決更複雜鏈表問題的基礎技能。\n參考資料 LeetCode 206. Reverse Linked List LeetCode 92. Reverse Linked List II LeetCode 25. Reverse Nodes in k-Group LeetCode 234. Palindrome Linked List 演算法導論 - 鏈表操作 ","permalink":"https://xinqilin.github.io/post/algorithm/reverselinkedlist/","tags":["Algorithm","LinkedList","Recursion","Java","Pointer"],"title":"鏈表反轉（Reverse Linked List）完整解析"},{"content":"概述 並查集（Union-Find）又稱為不相交集合（Disjoint Set），是一種用來處理不相交集合的合併和查詢問題的數據結構。它支援兩種主要操作：\nFind：查找元素所屬的集合（返回集合的代表元素） Union：合併兩個不同的集合 並查集在圖論演算法中應用廣泛，特別適用於解決連通性問題。\n基本原理 核心概念 並查集將每個集合表示為一棵樹，樹的根節點作為該集合的代表元素。初始狀態下，每個元素都是獨立的集合（自己是自己的父節點）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 初始狀態： 0 1 2 3 4 ↓ ↓ ↓ ↓ ↓ 0 1 2 3 4 合併 0 和 1 後： 0 2 3 4 ↙ ↓ ↓ ↓ 1 2 3 4 合併 2 和 3 後： 0 2 4 ↙ ↙ ↓ 1 3 4 基本實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 public class UnionFind { private int[] parent; // parent[i] 表示元素 i 的父節點 private int[] rank; // rank[i] 表示以 i 為根的樹的高度 private int components; // 連通分量的數量 public UnionFind(int n) { parent = new int[n]; rank = new int[n]; components = n; // 初始化：每個元素都是獨立的集合 for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; // 自己是自己的父節點 rank[i] = 0; // 初始高度為 0 } } /** * 查找元素 x 所屬集合的代表元素 */ public int find(int x) { if (parent[x] != x) { // 路徑壓縮：將路徑上所有節點直接連接到根節點 parent[x] = find(parent[x]); } return parent[x]; } /** * 合併元素 x 和 y 所屬的集合 */ public boolean union(int x, int y) { int rootX = find(x); int rootY = find(y); // 如果已經在同一個集合中，返回 false if (rootX == rootY) { return false; } // 按秩合併：將較矮的樹合併到較高的樹下 if (rank[rootX] \u0026lt; rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] \u0026gt; rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; // 高度相同時，合併後高度加 1 } components--; // 連通分量減 1 return true; } /** * 檢查兩個元素是否在同一個集合中 */ public boolean connected(int x, int y) { return find(x) == find(y); } /** * 獲取連通分量的數量 */ public int getComponentCount() { return components; } } 優化技巧 1. 路徑壓縮（Path Compression） 在 find 操作中，將查找路徑上的所有節點直接連接到根節點，使樹變得更加扁平。\n1 2 3 4 5 6 public int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); // 遞歸壓縮路徑 } return parent[x]; } 2. 按秩合併（Union by Rank） 總是將較矮的樹合併到較高的樹下，避免樹變得過高。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public boolean union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) return false; // 按秩合併 if (rank[rootX] \u0026lt; rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] \u0026gt; rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; } return true; } 3. 按大小合併（Union by Size） 另一種優化策略是將較小的集合合併到較大的集合中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class UnionFindBySize { private int[] parent; private int[] size; // size[i] 表示以 i 為根的集合大小 public UnionFindBySize(int n) { parent = new int[n]; size = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i; size[i] = 1; // 初始每個集合大小為 1 } } public boolean union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) return false; // 按大小合併：將小集合合併到大集合 if (size[rootX] \u0026lt; size[rootY]) { parent[rootX] = rootY; size[rootY] += size[rootX]; } else { parent[rootY] = rootX; size[rootX] += size[rootY]; } return true; } } 時間複雜度 操作 時間複雜度 說明 初始化 O(n) 建立 n 個獨立集合 Find（無優化） O(n) 最壞情況下需要遍歷整條鏈 Union（無優化） O(n) 需要調用 Find 操作 Find（路徑壓縮） O(α(n)) α(n) 是阿克曼函數的反函數 Union（按秩合併） O(α(n)) 近似常數時間 其中 α(n) 是阿克曼函數的反函數，在實際應用中可視為常數。\n經典應用題型 1. 等式方程的可滿足性（LeetCode 990） 問題描述：給定一個由表示變數之間關係的字串組成的陣列 equations，每個字串 equations[i] 的長度為 4，有兩種形式：\u0026quot;a==b\u0026quot; 或 \u0026quot;a!=b\u0026quot;。判斷是否所有等式都能同時滿足。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { private int[] parent = new int[26]; // 26 個字母 public boolean equationsPossible(String[] equations) { // 初始化並查集 for (int i = 0; i \u0026lt; 26; i++) { parent[i] = i; } // 第一遍：處理所有等式，合併相等的變數 for (String equation : equations) { if (equation.charAt(1) == \u0026#39;=\u0026#39;) { union(equation.charAt(0) - \u0026#39;a\u0026#39;, equation.charAt(3) - \u0026#39;a\u0026#39;); } } // 第二遍：檢查不等式是否違反了等式的結果 for (String equation : equations) { if (equation.charAt(1) == \u0026#39;!\u0026#39;) { int x = equation.charAt(0) - \u0026#39;a\u0026#39;; int y = equation.charAt(3) - \u0026#39;a\u0026#39;; if (find(x) == find(y)) { return false; // 不等式矛盾 } } } return true; } private int find(int x) { if (parent[x] != x) { parent[x] = find(parent[x]); } return parent[x]; } private void union(int x, int y) { parent[find(x)] = find(y); } } 2. 朋友圈數量（LeetCode 547） 問題描述：班上有 N 名學生。其中有些人是朋友，有些則不是。他們的友誼具有傳遞性。找出朋友圈的總數。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int findCircleNum(int[][] isConnected) { int n = isConnected.length; UnionFind uf = new UnionFind(n); // 遍歷所有學生對，如果是朋友就合併 for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (isConnected[i][j] == 1) { uf.union(i, j); } } } return uf.getComponentCount(); } } 3. 島嶼數量（LeetCode 200） 問題描述：給定一個由 \u0026lsquo;1\u0026rsquo;（陸地）和 \u0026lsquo;0\u0026rsquo;（水）組成的二維網格，計算島嶼的數量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) return 0; int rows = grid.length; int cols = grid[0].length; UnionFind uf = new UnionFind(rows * cols); int waterCells = 0; // 方向陣列：上、下、左、右 int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; cols; j++) { if (grid[i][j] == \u0026#39;0\u0026#39;) { waterCells++; } else { // 檢查四個方向的相鄰陸地 for (int[] dir : directions) { int newRow = i + dir[0]; int newCol = j + dir[1]; if (newRow \u0026gt;= 0 \u0026amp;\u0026amp; newRow \u0026lt; rows \u0026amp;\u0026amp; newCol \u0026gt;= 0 \u0026amp;\u0026amp; newCol \u0026lt; cols \u0026amp;\u0026amp; grid[newRow][newCol] == \u0026#39;1\u0026#39;) { uf.union(i * cols + j, newRow * cols + newCol); } } } } } return uf.getComponentCount() - waterCells; } } 4. 冗余連接（LeetCode 684） 問題描述：在無向圖中找到一條邊，移除它後圖將變成樹。如果有多個答案，返回最後出現在給定二維陣列中的邊。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int[] findRedundantConnection(int[][] edges) { UnionFind uf = new UnionFind(edges.length + 1); for (int[] edge : edges) { // 如果兩個節點已經連通，這條邊就是冗余的 if (!uf.union(edge[0], edge[1])) { return edge; } } return new int[0]; // 理論上不會到達這裡 } } 5. 賬戶合併（LeetCode 721） 問題描述：給定一個賬戶列表，每個元素 accounts[i] 是一個字串列表，其中第一個元素是名字，其餘元素是 emails。合併屬於同一人的賬戶。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accountsMerge(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accounts) { Map\u0026lt;String, Integer\u0026gt; emailToIndex = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;String, String\u0026gt; emailToName = new HashMap\u0026lt;\u0026gt;(); int emailCount = 0; // 為每個 email 分配唯一索引 for (List\u0026lt;String\u0026gt; account : accounts) { String name = account.get(0); for (int i = 1; i \u0026lt; account.size(); i++) { String email = account.get(i); if (!emailToIndex.containsKey(email)) { emailToIndex.put(email, emailCount++); } emailToName.put(email, name); } } UnionFind uf = new UnionFind(emailCount); // 合併同一賬戶下的所有 email for (List\u0026lt;String\u0026gt; account : accounts) { String firstEmail = account.get(1); for (int i = 2; i \u0026lt; account.size(); i++) { uf.union(emailToIndex.get(firstEmail), emailToIndex.get(account.get(i))); } } // 根據並查集結果分組 email Map\u0026lt;Integer, List\u0026lt;String\u0026gt;\u0026gt; groups = new HashMap\u0026lt;\u0026gt;(); for (String email : emailToIndex.keySet()) { int root = uf.find(emailToIndex.get(email)); groups.computeIfAbsent(root, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(email); } // 構建最終結果 List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (List\u0026lt;String\u0026gt; emails : groups.values()) { Collections.sort(emails); List\u0026lt;String\u0026gt; account = new ArrayList\u0026lt;\u0026gt;(); account.add(emailToName.get(emails.get(0))); account.addAll(emails); result.add(account); } return result; } } 高級應用 動態連通性問題 並查集特別適用於處理動態連通性問題，即在線回答「兩個節點是否連通」的查詢。\n最小生成樹（Kruskal 演算法） Kruskal 演算法使用並查集來檢測環的存在：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class KruskalMST { public int kruskalMST(int n, int[][] edges) { // 按權重排序邊 Arrays.sort(edges, (a, b) -\u0026gt; a[2] - b[2]); UnionFind uf = new UnionFind(n); int mstWeight = 0; int edgesUsed = 0; for (int[] edge : edges) { int u = edge[0], v = edge[1], weight = edge[2]; // 如果不會形成環，加入 MST if (uf.union(u, v)) { mstWeight += weight; edgesUsed++; // MST 有 n-1 條邊 if (edgesUsed == n - 1) { break; } } } return mstWeight; } } 實作技巧與注意事項 路徑壓縮：在 find 操作中使用路徑壓縮可以顯著提升性能 按秩合併：避免樹變得過高，保持操作的高效性 元素映射：當元素不是連續整數時，需要建立映射關係 連通分量計數：維護連通分量的數量可以快速回答相關查詢 總結 並查集是解決動態連通性問題的高效數據結構，在圖論、網路分析、集合劃分等領域有廣泛應用。掌握並查集的關鍵在於：\n理解基本原理：樹形結構表示集合，根節點作為代表元素 掌握優化技巧：路徑壓縮和按秩/按大小合併 靈活應用：根據問題特點選擇合適的實作方式 注意細節：邊界條件處理和元素映射 參考資料 LeetCode 990. Satisfiability of Equality Equations LeetCode 547. Number of Provinces LeetCode 200. Number of Islands LeetCode 684. Redundant Connection LeetCode 721. Accounts Merge 演算法導論 - 不相交集合的數據結構 ","permalink":"https://xinqilin.github.io/post/algorithm/unionfind/","tags":["Algorithm","UnionFind","DisjointSet","Graph","Java"],"title":"並查集（Union-Find）演算法完整指南"},{"content":"Snowflake - Distribution Key 單體式 ID 一般單體式 UUID(Universally Unique identifier) 8-4-4-4-12 總共 32 個 16 進位\n1 UUID.randomUUID() // 80e06459-942d-4a63-9fd4-81691b127363 優點 性能高 本地生成 無網路延遲 缺點 無順序性 字串不適合存 db 當 index or PK 且 32 長度太長 因無序 所以對 b+ Tree 來說 插入時效能低 極小機會但 會重複 =\u0026gt; ＤＢ 解法: replace into 跟insert功能類似, 但 replace into 會檢查是否存在, 如存在則先刪除, 再插入, 否则直接插入 分佈式 ID twitter 開發的 雪花算法 - snowflake 總共 64 bit\n1bit 不用，因為二進制中最高位是符號位，1表示負數，0表示正數。 生成的id一般都是用整數，所以最高位固定為0。\n41bit-時間戳，用來記錄時間戳，亳秒級。 41位可以表示 2^41-1個數字， 如果只用來表示正整數(計算機中正數包含0)，可以表示的數值範圍是: 0 至 2^41 - 1， 減1是因為可表示的數值範圍是從0開始算的，而不是1.也就是說41位可以表示 2^41 - 1 個毫秒的值，轉化成單位年則是( 2^41 - 1 )/ (1000* 60 * 60 * 24 *365)= 69年\n10bit-工作機器id,用來記錄工作機器id. 可以部署在 2^10 = 1024 個節點，包括5位 dataCenterId 和 15 位 workerId 5位(bit) 可以表示的最大正整數是 2^5-1 = 31，即可以用 0, 1, 2, 3\u0026hellip; 這 32 個數字來表示不同的 dataCenterId 或 workerId\n12bit, 序列號，序列號，用來記錄同毫秒內產生的不同id. 12位(bit) 可以表示的最大正整數是 2^12 - 1 = 4095，即可以用 0, 1, 2, 3\u0026hellip; 4094 這 4095 個數字, 來表示同一機器同一時間截(毫秒)內產生的 4095 個ID序號。\n優點 全局唯一性 递增性, 確保生成 ID 對於用户或業務是递增的。 高可用性, 確保任何時候都能生成正確的 ID 高性能, 在高併發下依然 ok 亳秒数在高位，自增序列在低位，整個 ID 都是遞增的。 缺點 依賴機器時鐘，如果機器時鐘回撥，會導致重複 ID 生成 在單機上是遞增的，但是由於設計到分佈式環境，每台機器上的時鐘不可能完全同步，有時候會出現不是全局遞增的情況(此缺點可以認為無所謂，- .般分佈式ID只要求趨勢遞增，並不會嚴格要求遞增，90%的需求都只要求趨勢遞增) additional 解決機器時鐘回撥問題 Leaf - 美團點評分佈式ID生成系統 百度 open source - UidGenerator java sample code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 public class SnowflakeIdWorker { /** * 开始时间截 (2015-01-01) */ private final long twepoch = 1420041600000L; /** * 机器id所占的位数 */ private final long workerIdBits = 5L; /** * 数据标识id所占的位数 */ private final long datacenterIdBits = 5L; /** * 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */ private final long maxWorkerId = -1L ^ (-1L \u0026lt;\u0026lt; workerIdBits); /** * 支持的最大数据标识id，结果是31 */ private final long maxDatacenterId = -1L ^ (-1L \u0026lt;\u0026lt; datacenterIdBits); /** * 序列在id中占的位数 */ private final long sequenceBits = 12L; /** * 机器ID向左移12位 */ private final long workerIdShift = sequenceBits; /** * 数据标识id向左移17位(12+5) */ private final long datacenterIdShift = sequenceBits + workerIdBits; /** * 时间截向左移22位(5+5+12) */ private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; /** * 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */ private final long sequenceMask = -1L ^ (-1L \u0026lt;\u0026lt; sequenceBits); /** * 工作机器ID(0~31) */ private long workerId; /** * 数据中心ID(0~31) */ private long datacenterId; /** * 毫秒内序列(0~4095) */ private long sequence = 0L; /** * 上次生成ID的时间截 */ private long lastTimestamp = -1L; /** * 构造函数 * @param workerId 工作ID (0~31) * @param datacenterId 数据中心ID (0~31) */ public SnowflakeIdWorker(long workerId, long datacenterId) { if (workerId \u0026gt; maxWorkerId || workerId \u0026lt; 0) { throw new IllegalArgumentException(String.format(\u0026#34;worker Id can\u0026#39;t be greater than %d or less than 0\u0026#34;, maxWorkerId)); } if (datacenterId \u0026gt; maxDatacenterId || datacenterId \u0026lt; 0) { throw new IllegalArgumentException(String.format(\u0026#34;datacenter Id can\u0026#39;t be greater than %d or less than 0\u0026#34;, maxDatacenterId)); } this.workerId = workerId; this.datacenterId = datacenterId; } /** * 获得下一个ID (该方法是线程安全的) * @return SnowflakeId */ public synchronized long nextId() { long timestamp = timeGen(); // 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常 if (timestamp \u0026lt; lastTimestamp) { throw new RuntimeException( String.format(\u0026#34;Clock moved backwards. Refusing to generate id for %d milliseconds\u0026#34;, lastTimestamp - timestamp)); } // 如果是同一时间生成的，则进行毫秒内序列 if (lastTimestamp == timestamp) { sequence = (sequence + 1) \u0026amp; sequenceMask; // 毫秒内序列溢出 if (sequence == 0) { //阻塞到下一个毫秒,获得新的时间戳 timestamp = tilNextMillis(lastTimestamp); } } // 时间戳改变，毫秒内序列重置 else { sequence = 0L; } // 上次生成ID的时间截 lastTimestamp = timestamp; // 移位并通过或运算拼到一起组成64位的ID return ((timestamp - twepoch) \u0026lt;\u0026lt; timestampLeftShift) // | (datacenterId \u0026lt;\u0026lt; datacenterIdShift) // | (workerId \u0026lt;\u0026lt; workerIdShift) // | sequence; } /** * 阻塞到下一个毫秒，直到获得新的时间戳 * @param lastTimestamp 上次生成ID的时间截 * @return 当前时间戳 */ protected long tilNextMillis(long lastTimestamp) { long timestamp = timeGen(); while (timestamp \u0026lt;= lastTimestamp) { timestamp = timeGen(); } return timestamp; } /** * 返回以毫秒为单位的当前时间 * @return 当前时间(毫秒) */ protected long timeGen() { return System.currentTimeMillis(); } public static void main(String[] args) throws InterruptedException { SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0); for (int i = 0; i \u0026lt; 10; i++) { long id = idWorker.nextId(); Thread.sleep(1); System.out.println(id); } } } reference: https://github.com/twitter-archive/snowflake https://github.com/beyondfengyu/SnowFlake/blob/master/SnowFlake.java https://blog.csdn.net/qq_45408390/article/details/119793810 ","permalink":"https://xinqilin.github.io/post/architecture/snowflake-distributionkey/","tags":[],"title":"SnowFlake DistributionKey"},{"content":"概述 回溯演算法（Backtracking）是一種透過試錯來尋找問題解決方案的算法策略。它系統性地搜尋所有可能的候選解，當發現候選解不可能完成有效解時，會放棄該候選解並「回溯」到上一步。\n基本原理 回溯演算法遵循三個核心步驟：\n選擇（Choose）：從當前狀態的可選項中做出選擇 探索（Explore）：Recursion地探索這個選擇的後果 撤銷（Un-choose）：撤銷選擇，恢復到選擇前的狀態 演算法模板 1 2 3 4 5 6 7 8 9 10 11 12 void backtrack(路徑, 選擇列表) { if (滿足結束條件) { result.add(路徑); return; } for (選擇 : 選擇列表) { 做選擇; // Choose backtrack(路徑, 選擇列表); // Explore 撤銷選擇; // Un-choose } } 時間複雜度 一般情況下，回溯演算法的時間複雜度為 O(b^d)，其中：\nb 是分支因子（每個節點的平均子節點數） d 是搜尋深度 經典應用題型 1. 子集問題（Subsets） 問題描述：給定一個整數陣列 nums，回傳該陣列所有可能的子集（冪集合）。\n解題思路：\n對於每個元素，我們都有「選擇」或「不選擇」兩種決策 使用回溯法遍歷所有可能的組合 每次Recursion都將當前路徑加入結果集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); // 排序便於處理 backtrack(result, new ArrayList\u0026lt;\u0026gt;(), nums, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] nums, int startIndex) { // 每個狀態都是一個有效的子集 result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); // 從 startIndex 開始遍歷，避免重複組合 for (int i = startIndex; i \u0026lt; nums.length; i++) { // 做選擇：將當前元素加入路徑 currentPath.add(nums[i]); // Recursion探索：繼續選擇下一個元素 backtrack(result, currentPath, nums, i + 1); // 撤銷選擇：移除當前元素，回溯 currentPath.remove(currentPath.size() - 1); } } 時間複雜度：O(2^n)，其中 n 是陣列長度，因為每個元素都有選或不選兩種狀態。\n2. 子集問題 II（Subsets II - 含重複元素） 問題描述：給定一個可能包含重複整數的陣列 nums，回傳該陣列所有可能的子集（不包含重複的子集）。\n解題思路：\n基於子集問題的解法，但需要處理重複元素 先排序陣列，讓相同元素相鄰 透過跳過重複元素來避免產生重複的子集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); // 排序是關鍵，讓重複元素相鄰 backtrack(result, new ArrayList\u0026lt;\u0026gt;(), nums, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] nums, int startIndex) { // 每個狀態都是一個有效的子集 result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); for (int i = startIndex; i \u0026lt; nums.length; i++) { // 跳過重複元素：當前元素與前一個元素相同，且不是起始位置 if (i \u0026gt; startIndex \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; // 跳過重複元素避免產生重複子集 } // 做選擇 currentPath.add(nums[i]); // Recursion探索 backtrack(result, currentPath, nums, i + 1); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); } } 去重關鍵：i \u0026gt; startIndex \u0026amp;\u0026amp; nums[i] == nums[i-1] 這個條件確保在同一層Recursion中跳過重複元素。\n3. 全排列（Permutations） 問題描述：給定一個不含重複數字的陣列 nums，回傳其所有可能的全排列。\n解題思路：\n全排列需要用到陣列中的每一個元素，且順序不同結果不同 使用 contains 檢查避免重複使用同一個元素 當路徑長度等於陣列長度時，找到一個完整的排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); backtrack(result, new ArrayList\u0026lt;\u0026gt;(), nums); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] nums) { // 達到目標長度，找到一個完整的排列 if (currentPath.size() == nums.length) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } // 嘗試添加每一個元素 for (int i = 0; i \u0026lt; nums.length; i++) { // 跳過已經使用的元素 if (currentPath.contains(nums[i])) { continue; // 該元素已在當前路徑中，跳過 } // 做選擇 currentPath.add(nums[i]); // Recursion探索 backtrack(result, currentPath, nums); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); } } 效能優化：使用 boolean[] used 陣列取代 contains 方法可以提升效能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private void backtrackOptimized(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] nums, boolean[] used) { if (currentPath.size() == nums.length) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (used[i]) continue; // O(1) 時間檢查 used[i] = true; currentPath.add(nums[i]); backtrackOptimized(result, currentPath, nums, used); currentPath.remove(currentPath.size() - 1); used[i] = false; } } 時間複雜度：O(n × n!)，其中 n! 是排列的數量，n 是複製每個排列所需的時間。\n4. 全排列 II（Permutations II - 含重複元素） 問題描述：給定一個可包含重複數字的序列 nums，按任意順序回傳所有不重複的全排列。\n解題思路：\n在全排列的基礎上增加去重邏輯 先排序讓相同元素相鄰 使用剪枝條件避免產生重複的排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); // 排序是去重的關鍵 boolean[] used = new boolean[nums.length]; backtrack(result, new ArrayList\u0026lt;\u0026gt;(), nums, used); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] nums, boolean[] used) { // 達到目標長度，找到一個完整的排列 if (currentPath.size() == nums.length) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { // 跳過已使用的元素 if (used[i]) continue; // 去重關鍵：跳過重複元素 // 當前元素與前一個元素相同，且前一個元素未被使用 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !used[i - 1]) { continue; } // 做選擇 used[i] = true; currentPath.add(nums[i]); // Recursion探索 backtrack(result, currentPath, nums, used); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); used[i] = false; } } 去重原理：!used[i-1] 確保在同一層Recursion中，相同的元素只會被選擇一次，從而避免重複排列。\n5. 組合總和（Combination Sum - 可重複使用元素） 問題描述：給定一個無重複元素的陣列 candidates 和一個目標數 target，找出所有使元素和為 target 的組合。同一個數字可以被重複選擇。\n解題思路：\n每個元素都可以被無限次重複使用 使用 startIndex 避免產生重複組合（如 [2,3] 和 [3,2]） 當剩餘目標值為 0 時找到一個有效組合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(candidates); // 排序便於剪枝 backtrack(result, new ArrayList\u0026lt;\u0026gt;(), candidates, target, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] candidates, int remainingTarget, int startIndex) { // 剪枝：剩餘目標值小於 0，無效路徑 if (remainingTarget \u0026lt; 0) { return; } // 找到一個有效組合 if (remainingTarget == 0) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } for (int i = startIndex; i \u0026lt; candidates.length; i++) { // 剪枝優化：如果當前元素已經大於剩餘目標值，後面的元素也會更大 if (candidates[i] \u0026gt; remainingTarget) { break; } // 做選擇 currentPath.add(candidates[i]); // Recursion探索：注意這裡傳入 i 而不是 i+1，因為可以重複使用同一元素 backtrack(result, currentPath, candidates, remainingTarget - candidates[i], i); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); } } 關鍵點：\nRecursion時傳入 i 而非 i+1，允許重複使用當前元素 排序後可以進行剪枝優化，提早終止無效分支 6. 組合總和 II（Combination Sum II - 含重複元素但不可重複使用） 問題描述：給定一個陣列 candidates 和一個目標數 target，找出所有使元素和為 target 的組合。陣列中每個元素只能使用一次，但陣列中可能包含重複元素。\n解題思路：\n每個元素只能使用一次，需要跳過重複元素避免重複組合 排序後使用去重邏輯 Recursion時傳入 i+1 確保每個位置的元素只能使用一次 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(candidates); // 排序是去重的前提 backtrack(result, new ArrayList\u0026lt;\u0026gt;(), candidates, target, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result, List\u0026lt;Integer\u0026gt; currentPath, int[] candidates, int remainingTarget, int startIndex) { // 剪枝：剩餘目標值小於 0 if (remainingTarget \u0026lt; 0) { return; } // 找到一個有效組合 if (remainingTarget == 0) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } for (int i = startIndex; i \u0026lt; candidates.length; i++) { // 跳過重複元素：避免在同一層Recursion中使用相同的元素 if (i \u0026gt; startIndex \u0026amp;\u0026amp; candidates[i] == candidates[i - 1]) { continue; // 跳過重複元素 } // 剪枝優化 if (candidates[i] \u0026gt; remainingTarget) { break; } // 做選擇 currentPath.add(candidates[i]); // Recursion探索：傳入 i+1 確保每個元素只使用一次 backtrack(result, currentPath, candidates, remainingTarget - candidates[i], i + 1); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); } } 與 Combination Sum 的差異：\nRecursion時傳入 i+1 而非 i，每個元素只能使用一次 增加去重邏輯處理陣列中的重複元素 7. 回文字串分割（Palindrome Partitioning） 問題描述：給定一個字串 s，將 s 分割成一些子字串，使得每個子字串都是回文字串。回傳所有可能的分割方案。\n解題思路：\n透過回溯法嘗試所有可能的分割點 對於每個分割點，檢查子字串是否為回文 只有當子字串是回文時，才繼續Recursion分割 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; partition(String s) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); backtrack(result, new ArrayList\u0026lt;\u0026gt;(), s, 0); return result; } private void backtrack(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; result, List\u0026lt;String\u0026gt; currentPath, String s, int startIndex) { // 達到字串結尾，找到一個完整的分割方案 if (startIndex == s.length()) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); return; } // 嘗試所有可能的分割點 for (int endIndex = startIndex; endIndex \u0026lt; s.length(); endIndex++) { // 檢查當前子字串是否為回文 if (isPalindrome(s, startIndex, endIndex)) { // 做選擇：將回文子字串加入路徑 currentPath.add(s.substring(startIndex, endIndex + 1)); // Recursion探索：繼續分割剩餘部分 backtrack(result, currentPath, s, endIndex + 1); // 撤銷選擇 currentPath.remove(currentPath.size() - 1); } } } /** * 檢查字串的指定範圍是否為回文 */ private boolean isPalindrome(String s, int left, int right) { while (left \u0026lt; right) { if (s.charAt(left) != s.charAt(right)) { return false; } left++; right--; } return true; } 優化技巧：可以預處理回文判斷結果，使用動態規劃建立回文查詢表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 預處理優化版本 private boolean[][] precomputePalindromes(String s) { int n = s.length(); boolean[][] isPalin = new boolean[n][n]; // 單個字元都是回文 for (int i = 0; i \u0026lt; n; i++) { isPalin[i][i] = true; } // 檢查長度為 2 的子字串 for (int i = 0; i \u0026lt; n - 1; i++) { isPalin[i][i + 1] = (s.charAt(i) == s.charAt(i + 1)); } // 檢查長度大於 2 的子字串 for (int len = 3; len \u0026lt;= n; len++) { for (int i = 0; i \u0026lt;= n - len; i++) { int j = i + len - 1; isPalin[i][j] = (s.charAt(i) == s.charAt(j)) \u0026amp;\u0026amp; isPalin[i + 1][j - 1]; } } return isPalin; } 最佳實踐與技巧 1. 剪枝優化 提早終止：當發現當前路徑不可能產生有效解時，立即返回 排序優化：對輸入進行排序，便於跳過重複元素和進行範圍剪枝 邊界檢查：在Recursion前檢查邊界條件，避免無效Recursion 2. 去重技巧 回溯問題中的去重通常有兩種情況：\n樹枝去重：避免在同一條路徑上重複使用同一個元素 樹層去重：避免在同一層Recursion中產生重複的選擇 1 2 3 4 5 // 樹層去重（適用於有重複元素的組合問題） if (i \u0026gt; startIndex \u0026amp;\u0026amp; nums[i] == nums[i-1]) continue; // 樹枝去重（適用於排列問題） if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] \u0026amp;\u0026amp; !used[i-1]) continue; 3. 效能優化 使用 boolean[] 取代 List.contains() 進行元素查找 預處理計算結果（如回文判斷表） 合理選擇資料結構（如使用 StringBuilder 處理字串） 常見錯誤與陷阱 忘記撤銷選擇：這是回溯演算法最常見的錯誤 重複解處理不當：沒有正確實現去重邏輯 邊界條件錯誤：Recursion終止條件設置不正確 索引使用錯誤：在組合和排列問題中混淆 i 和 i+1 的使用 總結 回溯演算法是解決組合、排列、分割等問題的重要工具。掌握以下要點：\n理解模板：Choose → Explore → Un-choose 三步驟 識別問題類型：子集、排列、組合、分割等不同類型有不同的處理方式 掌握去重技巧：樹層去重和樹枝去重的區別和應用 善用剪枝：透過剪枝大幅提升演算法效能 細心實作：注意邊界條件和索引使用 透過大量練習和理解這些經典題型，能夠幫助我們更好地掌握回溯演算法的精髓。\n","permalink":"https://xinqilin.github.io/post/algorithm/backtracking/","tags":["Algorithm","Backtracking","Recursion"],"title":"回溯演算法（Backtracking）完整指南"},{"content":"Rigidity, 難以變更 任何變更, 都需要去改其他的東西, 造成一個小小的需求就要去更改另個很大的東西\nFragility, 容易壞掉 任何變更都會導致其他有相依或無相依的東西超出想象的破壞, 改一個小東西, 結果其他重要的東西壞掉\nImmobility, 難以複用 系統中相依情況嚴重, 造成想要移出code 寫成 function 的成本 高於打掉重寫的成本\nViscosity, 難以正確修改 系統變更時, 因成本考量大多會以 治標不治本的方式改完需求,而非從源頭處修改\n","permalink":"https://xinqilin.github.io/post/architecture/badsmell/","tags":[],"title":"BadSmell"},{"content":"GitHub SSH Setting 1 2 3 4 5 6 7 8 9 10 11 12 cd ~/ mkdir .ssh ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; (是否要用預設檔名) enter \u0026gt;\u0026gt; (密碼) enter \u0026gt;\u0026gt; (密碼確認) enter cat .ssh/id_ed25519.pub \u0026gt;\u0026gt; 跑出公鑰 貼到 github 上 ssh -T git@github.com \u0026gt;\u0026gt; 測試連線 \u0026gt;\u0026gt; \u0026#34;Hi xinqilin! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access.\u0026#34; 重設 remote url =\u0026gt; https 改 ssh 1 2 git remote rm origin git remote add origin [url] 應用程式要用的 token setting -\u0026gt; developer setting -\u0026gt; personal access token -\u0026gt; generate new token\nGitHub 教學 ","permalink":"https://xinqilin.github.io/post/tools/github-ssh/","tags":[],"title":"Github Ssh"},{"content":"概述 在現代開發流程中，使用 Docker 部署資料庫已成為主流。將 MySQL 運行在 Docker 容器中，可以帶來許多好處：環境隔離、快速部署、版本控制、以及方便的遷移。這篇文章將引導您如何在 Docker 中設定和管理 MySQL 容器。\n啟動 MySQL 容器 使用 docker run 指令可以快速啟動一個 MySQL 容器。以下是一個常用的範例，包含了密碼設定、埠映射和字元集設定。\n1 2 3 4 5 6 7 8 9 docker run \\ --name mysql-server \\ -e MYSQL_ROOT_PASSWORD=your_strong_password \\ -p 3306:3306 \\ -d \\ mysql/mysql-server \\ --character-set-server=utf8mb4 \\ --collation-server=utf8mb4_unicode_ci \\ --skip-character-set-client-handshake 指令參數說明 --name mysql-server: 為容器指定一個易於識別的名稱，這裡命名為 mysql-server。 -e MYSQL_ROOT_PASSWORD=your_strong_password: 設定 MySQL root 使用者的密碼。請務必將 your_strong_password 替換為您自己的強密碼。 -p 3306:3306: 將主機的 3306 埠映射到容器的 3306 埠。這樣您就可以從主機透過 3306 埠連接到容器內的 MySQL 服務。 -d: 以背景模式 (detached mode) 運行容器，讓容器在背景執行。 mysql/mysql-server: 指定要使用的 Docker 映像檔。mysql/mysql-server 是 MySQL 官方提供的映像檔。 --character-set-server=utf8mb4: 設定 MySQL 伺服器的預設字元集為 utf8mb4，以支援更廣泛的字元，包括表情符號。 --collation-server=utf8mb4_unicode_ci: 設定伺服器的預設排序規則為 utf8mb4_unicode_ci，這是一種不區分大小寫和重音的排序規則。 --skip-character-set-client-handshake: 禁用客戶端字元集握手。這有助於確保客戶端和伺服器之間的字元集一致性，避免亂碼問題。 字元集設定的等效配置 上述字元集相關的 docker run 參數，在 MySQL 的配置檔 (my.cnf) 中，等效於以下設定：\n1 2 3 4 5 6 7 8 9 [client] default-character-set=utf8mb4 [mysql] default-character-set=utf8mb4 [mysqld] collation-server = utf8mb4_unicode_ci character-set-server = utf8mb4 資料持久化 (Data Persistence) 對於資料庫容器，資料持久化是至關重要的。如果沒有將資料儲存到主機上，一旦容器被移除，所有資料都將丟失。Docker 提供了兩種主要方式來實現資料持久化：綁定掛載 (Bind Mounts) 和 具名儲存卷 (Named Volumes)。\n使用具名儲存卷 (推薦) 具名儲存卷由 Docker 管理，是持久化資料的最佳方式。\n1 2 3 4 5 6 7 8 9 10 docker run \\ --name mysql-server \\ -e MYSQL_ROOT_PASSWORD=your_strong_password \\ -p 3306:3306 \\ -d \\ -v mysql_data:/var/lib/mysql \\ mysql/mysql-server \\ --character-set-server=utf8mb4 \\ --collation-server=utf8mb4_unicode_ci \\ --skip-character-set-client-handshake -v mysql_data:/var/lib/mysql: 這裡 mysql_data 是一個具名儲存卷。Docker 會自動創建並管理這個儲存卷，將容器內 /var/lib/mysql (MySQL 資料預設儲存路徑) 的資料持久化到這個儲存卷中。 您可以透過 docker volume ls 查看所有具名儲存卷，並透過 docker volume inspect mysql_data 查看其詳細資訊。\n使用綁定掛載 綁定掛載允許您將主機上的任意目錄直接掛載到容器中。\n1 2 3 4 5 6 7 8 9 10 docker run \\ --name mysql-server \\ -e MYSQL_ROOT_PASSWORD=your_strong_password \\ -p 3306:3306 \\ -d \\ -v /path/to/your/mysql_data:/var/lib/mysql \\ mysql/mysql-server \\ --character-set-server=utf8mb4 \\ --collation-server=utf8mb4_unicode_ci \\ --skip-character-set-client-handshake -v /path/to/your/mysql_data:/var/lib/mysql: 將主機上的 /path/to/your/mysql_data 目錄掛載到容器內的 /var/lib/mysql。請將 /path/to/your/mysql_data 替換為您主機上的實際路徑。 連接到 MySQL 容器 一旦 MySQL 容器運行起來，您有多種方式可以連接到它。\n從主機連接 如果您的主機上安裝了 MySQL 客戶端，可以直接透過 localhost 和映射的埠連接：\n1 mysql -h 127.0.0.1 -P 3306 -u root -p 然後輸入您在 docker run 指令中設定的 MYSQL_ROOT_PASSWORD。\n進入容器內部連接 您可以使用 docker exec 指令進入運行中的容器，然後在容器內部使用 MySQL 客戶端：\n1 2 3 4 5 # 進入容器的 bash shell docker exec -it mysql-server /bin/bash # 在容器內部執行 MySQL 客戶端 mysql -u root -p 然後輸入密碼。\n最佳實踐與考量 密碼安全：在生產環境中，請勿將密碼直接寫在 docker run 指令中。考慮使用 Docker Secrets 或環境變數檔案 (.env) 來管理敏感資訊。 資源限制：對於生產環境，建議為 MySQL 容器設定 CPU 和記憶體限制，以避免其佔用過多主機資源。 日誌管理：監控 MySQL 容器的日誌 (docker logs mysql-server) 對於故障排除非常重要。 Docker Compose：對於多服務應用程式，強烈建議使用 Docker Compose 來定義和管理 MySQL 服務，這會讓整個應用程式的部署和管理更加便捷。 透過 Docker 容器化部署 MySQL，您可以更高效、更靈活地管理您的資料庫環境。\n","permalink":"https://xinqilin.github.io/post/devops/docker-mysql/","tags":["Docker","MySQL","DevOps","Database","Containerization"],"title":"Docker MySQL：容器化部署與設定"},{"content":"Basic u: All Users +: add permission x: execute chmod u+x *.sh\nHomebrew /usr/bin/ruby -e \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026quot; brew install cask brew install wget\nSDKMAN curl -s \u0026quot;https://get.sdkman.io\u0026quot; | bash source \u0026quot;$HOME/.sdkman/bin/sdkman-init.sh\u0026quot;\nOPENJDK /Library/Java/JavaVirtualMachines/ 下面 /usr/libexec/java_home --verbose\nremove\n1 2 cd /Library/Java/JavaVirtualMachines/ sudo rm -rf amazon-corretto-11.jdk MAVEN \u0026amp; GRADLE 1 2 3 4 5 6 7 8 9 10 sdk list java sdk current java sdk list java sdk list gradle sdk install gradle \u0026#39;version\u0026#39; sdk list maven sdk list java history| grep sdk sdk list maven sdk install maven \u0026#39;version\u0026#39; NVM curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash\nCheatSheet Fig brew install --cask fig\nleave end of file to change userName 1 2 3 4 5 prompt_context() { if [[ \u0026#34;$USER\u0026#34; != \u0026#34;$DEFAULT_USER\u0026#34; || -n \u0026#34;$SSH_CLIENT\u0026#34; ]]; then prompt_segment black default \u0026#34;%(!.%{%F{yellow}%}.)Bill\u0026#34; fi } zsh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 # Fig pre block. Keep at the top of this file. [[ -f \u0026#34;$HOME/.fig/shell/zshrc.pre.zsh\u0026#34; ]] \u0026amp;\u0026amp; builtin source \u0026#34;$HOME/.fig/shell/zshrc.pre.zsh\u0026#34; # Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc. # Initialization code that may require console input (password prompts, [y/n] # confirmations, etc.) must go above this block; everything else may go below. if [[ -r \u0026#34;${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh\u0026#34; ]]; then source \u0026#34;${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh\u0026#34; fi # 懶人指令 alias hist=\u0026#39;history\u0026#39; alias d=\u0026#39;docker\u0026#39; alias gs=\u0026#39;git status\u0026#39; alias g=\u0026#39;git\u0026#39; # JDK # JAVA_HOME=/Library/Java/JavaVirtualMachines/amazon-corretto-11.jdk/Contents/Home JAVA_HOME=/Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home # JAVA_HOME=/Library/Java/JavaVirtualMachines/graalvm-ce-lts-java11-20.3.4/Contents/Home # JAVA_HOME=/Library/Java/JavaVirtualMachines/graalvm-ce-java17-22.1.0/Contents/Home PATH=$JAVA_HOME/bin:$PATH:. CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:. export JAVA_HOME export PATH export CLASSPATH #THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!! export SDKMAN_DIR=\u0026#34;$HOME/.sdkman\u0026#34; [[ -s \u0026#34;$HOME/.sdkman/bin/sdkman-init.sh\u0026#34; ]] \u0026amp;\u0026amp; source \u0026#34;$HOME/.sdkman/bin/sdkman-init.sh\u0026#34; # homebrew # x86_64 version brew path # 這邊會把舊版本取為 brow (o for old) export PATH=/opt/homebrew/bin:$PATH alias brow=\u0026#39;arch --x86_64 /usr/local/Homebrew/bin/brew\u0026#39; # nvm export NVM_DIR=\u0026#34;$([ -z \u0026#34;${XDG_CONFIG_HOME-}\u0026#34; ] \u0026amp;\u0026amp; printf %s \u0026#34;${HOME}/.nvm\u0026#34; || printf %s \u0026#34;${XDG_CONFIG_HOME}/nvm\u0026#34;)\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm # If you come from bash you might have to change your $PATH. # export PATH=$HOME/bin:/usr/local/bin:$PATH # Path to your oh-my-zsh installation. export ZSH=\u0026#34;$HOME/.oh-my-zsh\u0026#34; # Set name of the theme to load --- if set to \u0026#34;random\u0026#34;, it will # load a random theme each time oh-my-zsh is loaded, in which case, # to know which specific one was loaded, run: echo $RANDOM_THEME # See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes ZSH_THEME=\u0026#34;agnoster\u0026#34; # ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; # Set list of themes to pick from when loading at random # Setting this variable when ZSH_THEME=random will cause zsh to load # a theme from this variable instead of looking in $ZSH/themes/ # If set to an empty array, this variable will have no effect. # ZSH_THEME_RANDOM_CANDIDATES=( \u0026#34;robbyrussell\u0026#34; \u0026#34;agnoster\u0026#34; ) # Uncomment the following line to use case-sensitive completion. # CASE_SENSITIVE=\u0026#34;true\u0026#34; # Uncomment the following line to use hyphen-insensitive completion. # Case-sensitive completion must be off. _ and - will be interchangeable. # HYPHEN_INSENSITIVE=\u0026#34;true\u0026#34; # Uncomment one of the following lines to change the auto-update behavior # zstyle \u0026#39;:omz:update\u0026#39; mode disabled # disable automatic updates # zstyle \u0026#39;:omz:update\u0026#39; mode auto # update automatically without asking # zstyle \u0026#39;:omz:update\u0026#39; mode reminder # just remind me to update when it\u0026#39;s time # Uncomment the following line to change how often to auto-update (in days). # zstyle \u0026#39;:omz:update\u0026#39; frequency 13 # Uncomment the following line if pasting URLs and other text is messed up. # DISABLE_MAGIC_FUNCTIONS=\u0026#34;true\u0026#34; # Uncomment the following line to disable colors in ls. # DISABLE_LS_COLORS=\u0026#34;true\u0026#34; # Uncomment the following line to disable auto-setting terminal title. # DISABLE_AUTO_TITLE=\u0026#34;true\u0026#34; # Uncomment the following line to enable command auto-correction. # ENABLE_CORRECTION=\u0026#34;true\u0026#34; # Uncomment the following line to display red dots whilst waiting for completion. # You can also set it to another string to have that shown instead of the default red dots. # e.g. COMPLETION_WAITING_DOTS=\u0026#34;%F{yellow}waiting...%f\u0026#34; # Caution: this setting can cause issues with multiline prompts in zsh \u0026lt; 5.7.1 (see #5765) # COMPLETION_WAITING_DOTS=\u0026#34;true\u0026#34; # Uncomment the following line if you want to disable marking untracked files # under VCS as dirty. This makes repository status check for large repositories # much, much faster. # DISABLE_UNTRACKED_FILES_DIRTY=\u0026#34;true\u0026#34; # Uncomment the following line if you want to change the command execution time # stamp shown in the history command output. # You can set one of the optional three formats: # \u0026#34;mm/dd/yyyy\u0026#34;|\u0026#34;dd.mm.yyyy\u0026#34;|\u0026#34;yyyy-mm-dd\u0026#34; # or set a custom format using the strftime function format specifications, # see \u0026#39;man strftime\u0026#39; for details. # HIST_STAMPS=\u0026#34;mm/dd/yyyy\u0026#34; # Would you like to use another custom folder than $ZSH/custom? # ZSH_CUSTOM=/path/to/new-custom-folder # Which plugins would you like to load? # Standard plugins can be found in $ZSH/plugins/ # Custom plugins may be added to $ZSH_CUSTOM/plugins/ # Example format: plugins=(rails git textmate ruby lighthouse) # Add wisely, as too many plugins slow down shell startup. plugins=(git) source $ZSH/oh-my-zsh.sh # User configuration # export MANPATH=\u0026#34;/usr/local/man:$MANPATH\u0026#34; # You may need to manually set your language environment # export LANG=en_US.UTF-8 # Preferred editor for local and remote sessions # if [[ -n $SSH_CONNECTION ]]; then # export EDITOR=\u0026#39;vim\u0026#39; # else # export EDITOR=\u0026#39;mvim\u0026#39; # fi # Compilation flags # export ARCHFLAGS=\u0026#34;-arch x86_64\u0026#34; # Set personal aliases, overriding those provided by oh-my-zsh libs, # plugins, and themes. Aliases can be placed here, though oh-my-zsh # users are encouraged to define aliases within the ZSH_CUSTOM folder. # For a full list of active aliases, run `alias`. # # Example aliases # alias zshconfig=\u0026#34;mate ~/.zshrc\u0026#34; # alias ohmyzsh=\u0026#34;mate ~/.oh-my-zsh\u0026#34; code () { VSCODE_CWD=\u0026#34;$PWD\u0026#34; open -n -b \u0026#34;com.microsoft.VSCode\u0026#34; --args $* ;} plugins=( git zsh-syntax-highlighting zsh-autosuggestions ) # To customize prompt, run `p10k configure` or edit ~/.p10k.zsh. [[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh # 這行控制 userName prompt_context() { if [[ \u0026#34;$USER\u0026#34; != \u0026#34;$DEFAULT_USER\u0026#34; || -n \u0026#34;$SSH_CLIENT\u0026#34; ]]; then prompt_segment black default \u0026#34;%(!.%{%F{yellow}%}.)Bill\u0026#34; fi } # Fig post block. Keep at the bottom of this file. [[ -f \u0026#34;$HOME/.fig/shell/zshrc.post.zsh\u0026#34; ]] \u0026amp;\u0026amp; builtin source \u0026#34;$HOME/.fig/shell/zshrc.post.zsh\u0026#34; ","permalink":"https://xinqilin.github.io/post/tools/env/","tags":[],"title":"Env"},{"content":"概述 拓撲排序（Topological Sort）是對**有向無環圖（DAG, Directed Acyclic Graph）**進行排序的演算法。排序結果是一個線性序列，使得對於圖中任意有向邊 (u, v)，在排序結果中 u 都出現在 v 之前。\n基本概念 應用場景 課程排課：某些課程有先修課程的要求 編譯依賴：程式模組間的編譯順序 任務調度：有依賴關係的任務執行順序 Makefile 建構：檔案間的依賴關係 前提條件 圖必須是有向無環圖（DAG） 如果圖中存在環，則無法進行拓撲排序 演算法實作 方法一：Kahn 演算法（BFS 基礎） 基本思路 計算所有節點的入度 將入度為 0 的節點加入佇列 不斷從佇列中取出節點，並減少其相鄰節點的入度 如果相鄰節點的入度變為 0，則加入佇列 重複直到佇列為空 實作代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public class TopologicalSort { public List\u0026lt;Integer\u0026gt; topologicalSort(int numNodes, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; edges) { // 建立鄰接表和入度陣列 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] indegree = new int[numNodes]; for (int i = 0; i \u0026lt; numNodes; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } // 建構圖並計算入度 for (List\u0026lt;Integer\u0026gt; edge : edges) { int from = edge.get(0); int to = edge.get(1); graph.get(from).add(to); indegree[to]++; } // 將入度為 0 的節點加入佇列 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numNodes; i++) { if (indegree[i] == 0) { queue.offer(i); } } List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // BFS 處理 while (!queue.isEmpty()) { int node = queue.poll(); result.add(node); // 減少相鄰節點的入度 for (int neighbor : graph.get(node)) { indegree[neighbor]--; if (indegree[neighbor] == 0) { queue.offer(neighbor); } } } // 檢查是否存在環 if (result.size() != numNodes) { return new ArrayList\u0026lt;\u0026gt;(); // 存在環，無法拓撲排序 } return result; } } 方法二：DFS 基礎 基本思路 對每個未訪問的節點進行 DFS 在 DFS 回溯時將節點加入結果 反轉結果得到拓撲排序 實作代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 public class TopologicalSortDFS { private static final int WHITE = 0; // 未訪問 private static final int GRAY = 1; // 正在訪問 private static final int BLACK = 2; // 已完成 public List\u0026lt;Integer\u0026gt; topologicalSort(int numNodes, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; edges) { // 建立鄰接表 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numNodes; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (List\u0026lt;Integer\u0026gt; edge : edges) { graph.get(edge.get(0)).add(edge.get(1)); } int[] color = new int[numNodes]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 對每個未訪問的節點進行 DFS for (int i = 0; i \u0026lt; numNodes; i++) { if (color[i] == WHITE) { if (!dfs(graph, i, color, stack)) { return new ArrayList\u0026lt;\u0026gt;(); // 存在環 } } } // 反轉結果 List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); while (!stack.isEmpty()) { result.add(stack.pop()); } return result; } private boolean dfs(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph, int node, int[] color, Stack\u0026lt;Integer\u0026gt; stack) { color[node] = GRAY; // 標記為正在訪問 for (int neighbor : graph.get(node)) { if (color[neighbor] == GRAY) { return false; // 發現後向邊，存在環 } if (color[neighbor] == WHITE \u0026amp;\u0026amp; !dfs(graph, neighbor, color, stack)) { return false; } } color[node] = BLACK; // 標記為已完成 stack.push(node); // 後序遍歷順序 return true; } } 實際應用題型 1. 課程安排（LeetCode 207 \u0026amp; 210） 問題 207：判斷是否可以完成所有課程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public boolean canFinish(int numCourses, int[][] prerequisites) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] indegree = new int[numCourses]; // 初始化圖 for (int i = 0; i \u0026lt; numCourses; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } // 建構圖 for (int[] prereq : prerequisites) { graph.get(prereq[1]).add(prereq[0]); indegree[prereq[0]]++; } // Kahn 演算法 Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } int completedCourses = 0; while (!queue.isEmpty()) { int course = queue.poll(); completedCourses++; for (int nextCourse : graph.get(course)) { indegree[nextCourse]--; if (indegree[nextCourse] == 0) { queue.offer(nextCourse); } } } return completedCourses == numCourses; } 問題 210：返回課程安排的順序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public int[] findOrder(int numCourses, int[][] prerequisites) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); int[] indegree = new int[numCourses]; // 建構圖（同上） for (int i = 0; i \u0026lt; numCourses; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] prereq : prerequisites) { graph.get(prereq[1]).add(prereq[0]); indegree[prereq[0]]++; } Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } int[] result = new int[numCourses]; int index = 0; while (!queue.isEmpty()) { int course = queue.poll(); result[index++] = course; for (int nextCourse : graph.get(course)) { indegree[nextCourse]--; if (indegree[nextCourse] == 0) { queue.offer(nextCourse); } } } return index == numCourses ? result : new int[0]; } 2. 所有可能的菜譜（LeetCode 2115） 問題描述：給定可製作的菜譜、所需原料以及現有原料，找出所有可能製作的菜譜。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Solution { private static final int NOT_VISITED = 0; private static final int VISITING = 1; private static final int VISITED = 2; public List\u0026lt;String\u0026gt; findAllRecipes(String[] recipes, List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; ingredients, String[] supplies) { Map\u0026lt;String, Integer\u0026gt; status = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; prereqs = new HashMap\u0026lt;\u0026gt;(); // 初始化食譜和其所需原料 for (int i = 0; i \u0026lt; recipes.length; i++) { status.put(recipes[i], NOT_VISITED); prereqs.put(recipes[i], ingredients.get(i)); } // 將現有原料標記為已訪問 for (String supply : supplies) { status.put(supply, VISITED); } List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // 對每個食譜進行 DFS for (String recipe : recipes) { dfs(recipe, prereqs, status, result); } return result; } private boolean dfs(String item, Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; prereqs, Map\u0026lt;String, Integer\u0026gt; status, List\u0026lt;String\u0026gt; result) { if (!status.containsKey(item)) { return false; // 不存在此原料或食譜 } if (status.get(item) == VISITING) { return false; // 發現環，無法製作 } if (status.get(item) == VISITED) { return true; // 已經可以製作 } // 標記為正在訪問 status.put(item, VISITING); // 檢查所有前置條件 if (prereqs.containsKey(item)) { for (String ingredient : prereqs.get(item)) { if (!dfs(ingredient, prereqs, status, result)) { return false; } } } // 標記為已完成 status.put(item, VISITED); result.add(item); return true; } } 複雜度分析 演算法 時間複雜度 空間複雜度 優點 缺點 Kahn (BFS) O(V + E) O(V) 實作簡單，易於理解 需要額外的入度陣列 DFS O(V + E) O(V) 可以檢測環，記憶體使用較少 實作稍複雜 其中 V 是節點數，E 是邊數。\n實作技巧 1. 環的檢測 1 2 3 4 5 6 7 8 9 10 // Kahn 演算法：如果處理的節點數不等於總節點數，則存在環 if (processedNodes != totalNodes) { // 存在環 } // DFS：使用三色標記法檢測後向邊 if (color[neighbor] == GRAY) { // 發現後向邊，存在環 return false; } 2. 多個拓撲排序解 如果需要找出所有可能的拓撲排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public void findAllTopologicalSorts(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph, int[] indegree, List\u0026lt;Integer\u0026gt; current, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; allResults) { Queue\u0026lt;Integer\u0026gt; available = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; indegree.length; i++) { if (indegree[i] == 0) { available.offer(i); } } if (available.isEmpty()) { if (current.size() == indegree.length) { allResults.add(new ArrayList\u0026lt;\u0026gt;(current)); } return; } // 嘗試所有可能的下一個節點 for (int node : available) { // 選擇 current.add(node); int[] newIndegree = indegree.clone(); newIndegree[node] = -1; // 標記為已使用 for (int neighbor : graph.get(node)) { newIndegree[neighbor]--; } // 遞歸 findAllTopologicalSorts(graph, newIndegree, current, allResults); // 撤銷選擇 current.remove(current.size() - 1); } } 總結 拓撲排序是處理有依賴關係問題的重要演算法。掌握要點：\n適用條件：只能用於有向無環圖 兩種方法：Kahn 演算法（BFS）和 DFS 方法 環的檢測：兩種方法都能檢測圖中是否存在環 實際應用：課程安排、任務調度、編譯依賴等 選擇演算法時：\nKahn 演算法：邏輯直觀，適合初學者 DFS 方法：更靈活，能提供更多信息（如完成時間） 參考資料 LeetCode 207. Course Schedule LeetCode 210. Course Schedule II LeetCode 2115. Find All Possible Recipes from Given Supplies 演算法導論 - 圖的拓撲排序 ","permalink":"https://xinqilin.github.io/post/algorithm/topologicalsort/","tags":["Algorithm","Graph","TopologicalSort","DFS","BFS","Java"],"title":"拓撲排序（Topological Sort）演算法詳解"},{"content":"概述 Reactive Programming（響應式程式設計）是一種基於資料流和變化傳播的程式設計模式。在 Java 生態系統中，Project Reactor 是實現響應式程式設計的核心函式庫，而 Spring WebFlux 則建立在其之上，提供非阻塞式的 Web 應用程式開發能力。\n核心概念 什麼是 Reactive Programming？ 響應式程式設計的核心特徵：\n非阻塞（Non-blocking）：執行緒不會被 I/O 操作阻塞 事件驅動（Event-driven）：基於事件流處理資料 背壓支援（Backpressure）：自動處理生產者和消費者之間的速度差異 彈性（Resilient）：具備錯誤處理和恢復能力 響應性（Responsive）：快速回應使用者請求 Reactive Streams 規範 Reactive Streams 定義了四個核心介面：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public interface Publisher\u0026lt;T\u0026gt; { void subscribe(Subscriber\u0026lt;? super T\u0026gt; s); } public interface Subscriber\u0026lt;T\u0026gt; { void onSubscribe(Subscription s); void onNext(T t); void onError(Throwable t); void onComplete(); } public interface Subscription { void request(long n); void cancel(); } public interface Processor\u0026lt;T, R\u0026gt; extends Subscriber\u0026lt;T\u0026gt;, Publisher\u0026lt;R\u0026gt; { } Project Reactor 基礎 Mono 與 Flux Project Reactor 提供兩個核心類型：\nMono：發出 0 或 1 個元素的響應式流 Flux：發出 0 到 N 個元素的響應式流 創建響應式流 Mono 創建方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 創建包含單一值的 Mono Mono\u0026lt;String\u0026gt; mono1 = Mono.just(\u0026#34;Hello Reactive\u0026#34;); // 創建空的 Mono Mono\u0026lt;String\u0026gt; empty = Mono.empty(); // 從 Optional 創建 Mono\u0026lt;String\u0026gt; mono2 = Mono.justOrEmpty(Optional.of(\u0026#34;Optional Value\u0026#34;)); // 延遲創建 Mono\u0026lt;String\u0026gt; lazy = Mono.fromSupplier(() -\u0026gt; { // 複雜的計算邏輯 return \u0026#34;Computed Value\u0026#34;; }); // 從 Callable 創建 Mono\u0026lt;String\u0026gt; callable = Mono.fromCallable(() -\u0026gt; { Thread.sleep(1000); // 模擬耗時操作 return \u0026#34;Delayed Value\u0026#34;; }); // 錯誤 Mono Mono\u0026lt;String\u0026gt; error = Mono.error(new RuntimeException(\u0026#34;Something went wrong\u0026#34;)); Flux 創建方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 從可變參數創建 Flux\u0026lt;String\u0026gt; flux1 = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;); // 從集合創建 List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Cherry\u0026#34;); Flux\u0026lt;String\u0026gt; flux2 = Flux.fromIterable(list); // 創建數字範圍 Flux\u0026lt;Integer\u0026gt; range = Flux.range(1, 10); // 1 到 10 // 定時發射 Flux\u0026lt;Long\u0026gt; interval = Flux.interval(Duration.ofSeconds(1)); // 每秒發射一個遞增數字 // 從陣列創建 String[] array = {\u0026#34;X\u0026#34;, \u0026#34;Y\u0026#34;, \u0026#34;Z\u0026#34;}; Flux\u0026lt;String\u0026gt; flux3 = Flux.fromArray(array); // 從 Stream 創建 Flux\u0026lt;String\u0026gt; flux4 = Flux.fromStream(Stream.of(\u0026#34;Stream1\u0026#34;, \u0026#34;Stream2\u0026#34;)); 訂閱與消費 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 基本訂閱 Flux\u0026lt;Integer\u0026gt; numbers = Flux.range(1, 5); // 只處理數據 numbers.subscribe(System.out::println); // 處理數據和錯誤 numbers.subscribe( data -\u0026gt; System.out.println(\u0026#34;Data: \u0026#34; + data), error -\u0026gt; System.err.println(\u0026#34;Error: \u0026#34; + error) ); // 完整的訂閱處理 numbers.subscribe( data -\u0026gt; System.out.println(\u0026#34;Next: \u0026#34; + data), // onNext error -\u0026gt; System.err.println(\u0026#34;Error: \u0026#34; + error), // onError () -\u0026gt; System.out.println(\u0026#34;Completed!\u0026#34;) // onComplete ); // 使用自訂 Subscriber numbers.subscribe(new BaseSubscriber\u0026lt;Integer\u0026gt;() { @Override protected void hookOnSubscribe(Subscription subscription) { System.out.println(\u0026#34;Subscribed\u0026#34;); request(1); // 請求第一個元素 } @Override protected void hookOnNext(Integer value) { System.out.println(\u0026#34;Value: \u0026#34; + value); if (value \u0026lt; 3) { request(1); // 繼續請求下一個 } else { cancel(); // 取消訂閱 } } }); 核心操作符詳解 轉換操作符 map - 元素轉換 1 2 3 4 5 6 7 8 9 Flux\u0026lt;String\u0026gt; names = Flux.just(\u0026#34;alice\u0026#34;, \u0026#34;bob\u0026#34;, \u0026#34;charlie\u0026#34;); // 轉換為大寫 Flux\u0026lt;String\u0026gt; upperNames = names.map(String::toUpperCase); upperNames.subscribe(System.out::println); // ALICE, BOB, CHARLIE // 轉換為長度 Flux\u0026lt;Integer\u0026gt; lengths = names.map(String::length); lengths.subscribe(System.out::println); // 5, 3, 7 flatMap - 扁平化處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Flux\u0026lt;String\u0026gt; sentences = Flux.just(\u0026#34;Hello World\u0026#34;, \u0026#34;Reactive Programming\u0026#34;); // 將每個句子拆分為單詞 Flux\u0026lt;String\u0026gt; words = sentences.flatMap(sentence -\u0026gt; Flux.fromArray(sentence.split(\u0026#34; \u0026#34;)) ); words.subscribe(System.out::println); // Hello, World, Reactive, Programming // 非同步處理 Flux\u0026lt;String\u0026gt; urls = Flux.just(\u0026#34;url1\u0026#34;, \u0026#34;url2\u0026#34;, \u0026#34;url3\u0026#34;); Flux\u0026lt;String\u0026gt; responses = urls.flatMap(url -\u0026gt; Mono.fromCallable(() -\u0026gt; { // 模擬 HTTP 請求 Thread.sleep(100); return \u0026#34;Response from \u0026#34; + url; }).subscribeOn(Schedulers.boundedElastic()) ); concatMap - 順序處理 1 2 3 4 5 // 與 flatMap 不同，concatMap 保持順序 Flux\u0026lt;String\u0026gt; ordered = urls.concatMap(url -\u0026gt; Mono.fromCallable(() -\u0026gt; \u0026#34;Response from \u0026#34; + url) .subscribeOn(Schedulers.boundedElastic()) ); 過濾操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Flux\u0026lt;Integer\u0026gt; numbers = Flux.range(1, 10); // 過濾偶數 Flux\u0026lt;Integer\u0026gt; evenNumbers = numbers.filter(n -\u0026gt; n % 2 == 0); // 取前 3 個元素 Flux\u0026lt;Integer\u0026gt; first3 = numbers.take(3); // 跳過前 5 個元素 Flux\u0026lt;Integer\u0026gt; skip5 = numbers.skip(5); // 去重 Flux\u0026lt;String\u0026gt; duplicates = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;B\u0026#34;); Flux\u0026lt;String\u0026gt; distinct = duplicates.distinct(); // 取不重複元素直到遇到重複 Flux\u0026lt;String\u0026gt; distinctUntilChanged = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .distinctUntilChanged(); 組合操作符 merge - 合併多個流 1 2 3 4 5 6 7 8 9 Flux\u0026lt;String\u0026gt; flux1 = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;).delayElements(Duration.ofMillis(100)); Flux\u0026lt;String\u0026gt; flux2 = Flux.just(\u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;).delayElements(Duration.ofMillis(150)); // 合併（順序不保證） Flux\u0026lt;String\u0026gt; merged = Flux.merge(flux1, flux2); merged.subscribe(System.out::println); // 可能輸出: A, C, B, D // 使用 mergeWith Flux\u0026lt;String\u0026gt; merged2 = flux1.mergeWith(flux2); concat - 連接流 1 2 3 4 5 6 // 連接（保持順序） Flux\u0026lt;String\u0026gt; concatenated = Flux.concat(flux1, flux2); concatenated.subscribe(System.out::println); // 輸出: A, B, C, D // 使用 concatWith Flux\u0026lt;String\u0026gt; concatenated2 = flux1.concatWith(flux2); zip - 配對元素 1 2 3 4 5 6 7 8 9 10 11 Flux\u0026lt;String\u0026gt; names = Flux.just(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;); Flux\u0026lt;Integer\u0026gt; ages = Flux.just(25, 30, 35); // 配對元素 Flux\u0026lt;String\u0026gt; people = Flux.zip(names, ages, (name, age) -\u0026gt; name + \u0026#34; is \u0026#34; + age + \u0026#34; years old\u0026#34; ); people.subscribe(System.out::println); // Alice is 25 years old // Bob is 30 years old // Charlie is 35 years old 錯誤處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Flux\u0026lt;String\u0026gt; source = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .map(s -\u0026gt; { if (\u0026#34;B\u0026#34;.equals(s)) { throw new RuntimeException(\u0026#34;Error on B\u0026#34;); } return s; }); // 提供預設值 Flux\u0026lt;String\u0026gt; withDefault = source.onErrorReturn(\u0026#34;DEFAULT\u0026#34;); // 繼續其他流 Flux\u0026lt;String\u0026gt; fallback = source.onErrorResume(error -\u0026gt; Flux.just(\u0026#34;FALLBACK1\u0026#34;, \u0026#34;FALLBACK2\u0026#34;) ); // 重試 Flux\u0026lt;String\u0026gt; withRetry = source.retry(3); // 重試且延遲 Flux\u0026lt;String\u0026gt; withRetryDelay = source.retryWhen( Retry.backoff(3, Duration.ofSeconds(1)) ); // 捕獲錯誤並繼續 Flux\u0026lt;String\u0026gt; continueOnError = source.onErrorContinue((error, item) -\u0026gt; { System.err.println(\u0026#34;Error on item \u0026#34; + item + \u0026#34;: \u0026#34; + error.getMessage()); }); 背壓（Backpressure）處理 背壓是響應式程式設計中的重要概念，用於處理生產者速度超過消費者處理能力的情況：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 背壓策略示例 Flux\u0026lt;Integer\u0026gt; fastProducer = Flux.range(1, 1000) .delayElements(Duration.ofMillis(1)); // 消費者處理較慢 fastProducer .onBackpressureBuffer(10) // 緩衝區大小為 10 .subscribe(new BaseSubscriber\u0026lt;Integer\u0026gt;() { @Override protected void hookOnSubscribe(Subscription subscription) { request(1); } @Override protected void hookOnNext(Integer value) { try { Thread.sleep(100); // 模擬慢處理 System.out.println(\u0026#34;Processed: \u0026#34; + value); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } request(1); } }); // 其他背壓策略 Flux\u0026lt;Integer\u0026gt; dropped = fastProducer.onBackpressureDrop(); Flux\u0026lt;Integer\u0026gt; latest = fastProducer.onBackpressureLatest(); Flux\u0026lt;Integer\u0026gt; error = fastProducer.onBackpressureError(); 排程器（Scheduler） Reactor 提供多種排程器來控制執行上下文：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 不同類型的排程器 Scheduler single = Schedulers.single(); // 單執行緒 Scheduler parallel = Schedulers.parallel(); // 並行處理（CPU 密集） Scheduler boundedElastic = Schedulers.boundedElastic(); // 彈性執行緒池（I/O 密集） Scheduler immediate = Schedulers.immediate(); // 當前執行緒 // 使用排程器 Flux\u0026lt;String\u0026gt; source = Flux.just(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;); // 在指定排程器上發布 Flux\u0026lt;String\u0026gt; published = source.publishOn(Schedulers.parallel()); // 在指定排程器上訂閱 Flux\u0026lt;String\u0026gt; subscribed = source.subscribeOn(Schedulers.boundedElastic()); // 組合使用 source .subscribeOn(Schedulers.boundedElastic()) // 訂閱在彈性執行緒池 .map(s -\u0026gt; s.toLowerCase()) // 轉換操作 .publishOn(Schedulers.parallel()) // 後續操作在並行排程器 .map(s -\u0026gt; s.toUpperCase()) .subscribe(System.out::println); Spring WebFlux 實戰 依賴配置 1 2 3 4 5 6 7 8 9 10 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-webflux\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-r2dbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 響應式 REST Controller 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { private final UserService userService; public UserController(UserService userService) { this.userService = userService; } @GetMapping public Flux\u0026lt;User\u0026gt; getAllUsers() { return userService.findAll(); } @GetMapping(\u0026#34;/{id}\u0026#34;) public Mono\u0026lt;ResponseEntity\u0026lt;User\u0026gt;\u0026gt; getUserById(@PathVariable String id) { return userService.findById(id) .map(user -\u0026gt; ResponseEntity.ok(user)) .defaultIfEmpty(ResponseEntity.notFound().build()); } @PostMapping public Mono\u0026lt;User\u0026gt; createUser(@RequestBody User user) { return userService.save(user); } @PutMapping(\u0026#34;/{id}\u0026#34;) public Mono\u0026lt;ResponseEntity\u0026lt;User\u0026gt;\u0026gt; updateUser(@PathVariable String id, @RequestBody User user) { return userService.update(id, user) .map(updatedUser -\u0026gt; ResponseEntity.ok(updatedUser)) .defaultIfEmpty(ResponseEntity.notFound().build()); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) public Mono\u0026lt;ResponseEntity\u0026lt;Void\u0026gt;\u0026gt; deleteUser(@PathVariable String id) { return userService.deleteById(id) .then(Mono.just(ResponseEntity.noContent().\u0026lt;Void\u0026gt;build())) .defaultIfEmpty(ResponseEntity.notFound().build()); } // 串流端點 @GetMapping(value = \u0026#34;/stream\u0026#34;, produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux\u0026lt;User\u0026gt; getUserStream() { return userService.findAll() .delayElements(Duration.ofSeconds(1)); // 每秒發送一個用戶 } } 響應式 Service 層 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @Service public class UserService { private final UserRepository userRepository; private final WebClient webClient; public UserService(UserRepository userRepository, WebClient.Builder webClientBuilder) { this.userRepository = userRepository; this.webClient = webClientBuilder.baseUrl(\u0026#34;https://api.external.com\u0026#34;).build(); } public Flux\u0026lt;User\u0026gt; findAll() { return userRepository.findAll(); } public Mono\u0026lt;User\u0026gt; findById(String id) { return userRepository.findById(id); } public Mono\u0026lt;User\u0026gt; save(User user) { return userRepository.save(user); } public Mono\u0026lt;User\u0026gt; update(String id, User user) { return userRepository.findById(id) .flatMap(existingUser -\u0026gt; { existingUser.setName(user.getName()); existingUser.setEmail(user.getEmail()); return userRepository.save(existingUser); }); } public Mono\u0026lt;Void\u0026gt; deleteById(String id) { return userRepository.deleteById(id); } // 組合多個非同步操作 public Mono\u0026lt;UserProfile\u0026gt; getUserProfile(String userId) { Mono\u0026lt;User\u0026gt; userMono = findById(userId); Mono\u0026lt;List\u0026lt;Order\u0026gt;\u0026gt; ordersMono = getOrdersByUserId(userId); Mono\u0026lt;UserPreferences\u0026gt; preferencesMono = getUserPreferences(userId); return Mono.zip(userMono, ordersMono, preferencesMono) .map(tuple -\u0026gt; new UserProfile( tuple.getT1(), // User tuple.getT2(), // Orders tuple.getT3() // Preferences )); } // 外部 API 呼叫 private Mono\u0026lt;List\u0026lt;Order\u0026gt;\u0026gt; getOrdersByUserId(String userId) { return webClient.get() .uri(\u0026#34;/orders?userId={userId}\u0026#34;, userId) .retrieve() .bodyToFlux(Order.class) .collectList() .timeout(Duration.ofSeconds(5)) // 5 秒逾時 .onErrorReturn(Collections.emptyList()); // 錯誤時返回空列表 } private Mono\u0026lt;UserPreferences\u0026gt; getUserPreferences(String userId) { return webClient.get() .uri(\u0026#34;/preferences/{userId}\u0026#34;, userId) .retrieve() .bodyToMono(UserPreferences.class) .onErrorReturn(new UserPreferences()); // 預設偏好設定 } } 響應式資料庫存取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // R2DBC Repository @Repository public interface UserRepository extends ReactiveCrudRepository\u0026lt;User, String\u0026gt; { Flux\u0026lt;User\u0026gt; findByNameContaining(String name); Flux\u0026lt;User\u0026gt; findByEmailDomain(String domain); @Query(\u0026#34;SELECT * FROM users WHERE created_at \u0026gt; :date\u0026#34;) Flux\u0026lt;User\u0026gt; findUsersCreatedAfter(LocalDateTime date); @Modifying @Query(\u0026#34;UPDATE users SET last_login = :loginTime WHERE id = :userId\u0026#34;) Mono\u0026lt;Integer\u0026gt; updateLastLogin(String userId, LocalDateTime loginTime); } // 自訂 Repository 實作 @Component public class CustomUserRepository { private final DatabaseClient databaseClient; public CustomUserRepository(DatabaseClient databaseClient) { this.databaseClient = databaseClient; } public Flux\u0026lt;User\u0026gt; findUsersByComplexCriteria(UserSearchCriteria criteria) { return databaseClient.sql(\u0026#34;\u0026#34;\u0026#34; SELECT * FROM users WHERE (:name IS NULL OR name LIKE :name) AND (:email IS NULL OR email = :email) AND (:minAge IS NULL OR age \u0026gt;= :minAge) ORDER BY created_at DESC \u0026#34;\u0026#34;\u0026#34;) .bind(\u0026#34;name\u0026#34;, criteria.getName() != null ? \u0026#34;%\u0026#34; + criteria.getName() + \u0026#34;%\u0026#34; : null) .bind(\u0026#34;email\u0026#34;, criteria.getEmail()) .bind(\u0026#34;minAge\u0026#34;, criteria.getMinAge()) .map((row, metadata) -\u0026gt; User.builder() .id(row.get(\u0026#34;id\u0026#34;, String.class)) .name(row.get(\u0026#34;name\u0026#34;, String.class)) .email(row.get(\u0026#34;email\u0026#34;, String.class)) .age(row.get(\u0026#34;age\u0026#34;, Integer.class)) .createdAt(row.get(\u0026#34;created_at\u0026#34;, LocalDateTime.class)) .build()) .all(); } } WebClient 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @Component public class ExternalApiClient { private final WebClient webClient; public ExternalApiClient(WebClient.Builder webClientBuilder) { this.webClient = webClientBuilder .baseUrl(\u0026#34;https://jsonplaceholder.typicode.com\u0026#34;) .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .build(); } // GET 請求 public Mono\u0026lt;Post\u0026gt; getPost(Long id) { return webClient.get() .uri(\u0026#34;/posts/{id}\u0026#34;, id) .retrieve() .onStatus(HttpStatus::is4xxClientError, response -\u0026gt; Mono.error(new NotFoundException(\u0026#34;Post not found\u0026#34;))) .onStatus(HttpStatus::is5xxServerError, response -\u0026gt; Mono.error(new ServiceException(\u0026#34;Server error\u0026#34;))) .bodyToMono(Post.class) .timeout(Duration.ofSeconds(10)) .retry(3); } // POST 請求 public Mono\u0026lt;Post\u0026gt; createPost(Post post) { return webClient.post() .uri(\u0026#34;/posts\u0026#34;) .bodyValue(post) .retrieve() .bodyToMono(Post.class); } // 批量請求 public Flux\u0026lt;Post\u0026gt; getAllPosts() { return webClient.get() .uri(\u0026#34;/posts\u0026#34;) .retrieve() .bodyToFlux(Post.class) .onBackpressureBuffer(100); // 緩衝處理 } // 並行請求 public Mono\u0026lt;List\u0026lt;PostWithComments\u0026gt;\u0026gt; getPostsWithComments(List\u0026lt;Long\u0026gt; postIds) { return Flux.fromIterable(postIds) .flatMap(this::getPostWithComments, 5) // 最多 5 個並行請求 .collectList(); } private Mono\u0026lt;PostWithComments\u0026gt; getPostWithComments(Long postId) { Mono\u0026lt;Post\u0026gt; postMono = getPost(postId); Mono\u0026lt;List\u0026lt;Comment\u0026gt;\u0026gt; commentsMono = getCommentsByPostId(postId); return Mono.zip(postMono, commentsMono, PostWithComments::new); } private Mono\u0026lt;List\u0026lt;Comment\u0026gt;\u0026gt; getCommentsByPostId(Long postId) { return webClient.get() .uri(\u0026#34;/posts/{postId}/comments\u0026#34;, postId) .retrieve() .bodyToFlux(Comment.class) .collectList(); } } 測試響應式程式碼 測試配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 @ExtendWith(MockitoExtension.class) class UserServiceTest { @Mock private UserRepository userRepository; @Mock private WebClient webClient; @Mock private WebClient.RequestHeadersUriSpec requestHeadersUriSpec; @Mock private WebClient.ResponseSpec responseSpec; @InjectMocks private UserService userService; @Test void testFindById() { // Given String userId = \u0026#34;123\u0026#34;; User expectedUser = new User(userId, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); when(userRepository.findById(userId)).thenReturn(Mono.just(expectedUser)); // When Mono\u0026lt;User\u0026gt; result = userService.findById(userId); // Then StepVerifier.create(result) .expectNext(expectedUser) .verifyComplete(); verify(userRepository).findById(userId); } @Test void testFindByIdNotFound() { // Given String userId = \u0026#34;999\u0026#34;; when(userRepository.findById(userId)).thenReturn(Mono.empty()); // When Mono\u0026lt;User\u0026gt; result = userService.findById(userId); // Then StepVerifier.create(result) .verifyComplete(); // 期望空結果 } @Test void testGetAllUsers() { // Given List\u0026lt;User\u0026gt; users = Arrays.asList( new User(\u0026#34;1\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;), new User(\u0026#34;2\u0026#34;, \u0026#34;Jane\u0026#34;, \u0026#34;jane@example.com\u0026#34;) ); when(userRepository.findAll()).thenReturn(Flux.fromIterable(users)); // When Flux\u0026lt;User\u0026gt; result = userService.findAll(); // Then StepVerifier.create(result) .expectNext(users.get(0)) .expectNext(users.get(1)) .verifyComplete(); } @Test void testSaveUser() { // Given User userToSave = new User(null, \u0026#34;New User\u0026#34;, \u0026#34;new@example.com\u0026#34;); User savedUser = new User(\u0026#34;123\u0026#34;, \u0026#34;New User\u0026#34;, \u0026#34;new@example.com\u0026#34;); when(userRepository.save(userToSave)).thenReturn(Mono.just(savedUser)); // When Mono\u0026lt;User\u0026gt; result = userService.save(userToSave); // Then StepVerifier.create(result) .expectNext(savedUser) .verifyComplete(); } @Test void testErrorHandling() { // Given String userId = \u0026#34;123\u0026#34;; when(userRepository.findById(userId)) .thenReturn(Mono.error(new RuntimeException(\u0026#34;Database error\u0026#34;))); // When Mono\u0026lt;User\u0026gt; result = userService.findById(userId); // Then StepVerifier.create(result) .expectError(RuntimeException.class) .verify(); } } 整合測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) class UserControllerIntegrationTest { @Autowired private WebTestClient webTestClient; @MockBean private UserService userService; @Test void testGetAllUsers() { // Given List\u0026lt;User\u0026gt; users = Arrays.asList( new User(\u0026#34;1\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;), new User(\u0026#34;2\u0026#34;, \u0026#34;Jane\u0026#34;, \u0026#34;jane@example.com\u0026#34;) ); when(userService.findAll()).thenReturn(Flux.fromIterable(users)); // When \u0026amp; Then webTestClient.get() .uri(\u0026#34;/api/users\u0026#34;) .exchange() .expectStatus().isOk() .expectBodyList(User.class) .hasSize(2) .contains(users.toArray(new User[0])); } @Test void testGetUserById() { // Given String userId = \u0026#34;123\u0026#34;; User user = new User(userId, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); when(userService.findById(userId)).thenReturn(Mono.just(user)); // When \u0026amp; Then webTestClient.get() .uri(\u0026#34;/api/users/{id}\u0026#34;, userId) .exchange() .expectStatus().isOk() .expectBody(User.class) .isEqualTo(user); } @Test void testGetUserByIdNotFound() { // Given String userId = \u0026#34;999\u0026#34;; when(userService.findById(userId)).thenReturn(Mono.empty()); // When \u0026amp; Then webTestClient.get() .uri(\u0026#34;/api/users/{id}\u0026#34;, userId) .exchange() .expectStatus().isNotFound(); } @Test void testCreateUser() { // Given User userToCreate = new User(null, \u0026#34;New User\u0026#34;, \u0026#34;new@example.com\u0026#34;); User createdUser = new User(\u0026#34;123\u0026#34;, \u0026#34;New User\u0026#34;, \u0026#34;new@example.com\u0026#34;); when(userService.save(any(User.class))).thenReturn(Mono.just(createdUser)); // When \u0026amp; Then webTestClient.post() .uri(\u0026#34;/api/users\u0026#34;) .bodyValue(userToCreate) .exchange() .expectStatus().isOk() .expectBody(User.class) .isEqualTo(createdUser); } } 效能優化與最佳實踐 1. 適當的背壓策略 1 2 3 4 5 6 7 8 9 // 根據情況選擇合適的背壓策略 public Flux\u0026lt;ProcessedData\u0026gt; processLargeDataset(Flux\u0026lt;RawData\u0026gt; input) { return input .onBackpressureBuffer(1000) // 適度緩衝 .flatMap(this::processData, 10) // 限制並行度 .onErrorContinue((error, item) -\u0026gt; { log.warn(\u0026#34;處理項目 {} 時發生錯誤: {}\u0026#34;, item, error.getMessage()); }); } 2. 合理使用排程器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Service public class OptimizedService { // CPU 密集型操作使用 parallel() public Mono\u0026lt;String\u0026gt; cpuIntensiveTask(String input) { return Mono.fromCallable(() -\u0026gt; { // 複雜計算 return performComplexCalculation(input); }).subscribeOn(Schedulers.parallel()); } // I/O 操作使用 boundedElastic() public Mono\u0026lt;String\u0026gt; ioTask(String filename) { return Mono.fromCallable(() -\u0026gt; { // 檔案讀取 return readFromFile(filename); }).subscribeOn(Schedulers.boundedElastic()); } } 3. 資源管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 使用 using() 確保資源正確釋放 public Mono\u0026lt;String\u0026gt; processFileWithProperCleanup(String filename) { return Mono.using( () -\u0026gt; Files.newBufferedReader(Paths.get(filename)), // 資源供應商 reader -\u0026gt; Mono.fromCallable(() -\u0026gt; { // 使用資源 return reader.lines().collect(Collectors.joining(\u0026#34;\\n\u0026#34;)); }).subscribeOn(Schedulers.boundedElastic()), reader -\u0026gt; { // 清理資源 try { reader.close(); } catch (IOException e) { log.warn(\u0026#34;關閉檔案時發生錯誤\u0026#34;, e); } } ); } 4. 快取策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Service public class CachedUserService { private final Cache\u0026lt;String, User\u0026gt; userCache = Caffeine.newBuilder() .maximumSize(1000) .expireAfterWrite(Duration.ofMinutes(10)) .build(); public Mono\u0026lt;User\u0026gt; getUserWithCache(String userId) { User cachedUser = userCache.getIfPresent(userId); if (cachedUser != null) { return Mono.just(cachedUser); } return userRepository.findById(userId) .doOnNext(user -\u0026gt; userCache.put(userId, user)) .cache(Duration.ofMinutes(5)); // Reactor 層級快取 } } 監控與除錯 1. 日誌記錄 1 2 3 4 5 6 7 8 public Flux\u0026lt;User\u0026gt; processUsers() { return userRepository.findAll() .doOnSubscribe(subscription -\u0026gt; log.info(\u0026#34;開始處理用戶\u0026#34;)) .doOnNext(user -\u0026gt; log.debug(\u0026#34;處理用戶: {}\u0026#34;, user.getId())) .doOnError(error -\u0026gt; log.error(\u0026#34;處理過程中發生錯誤\u0026#34;, error)) .doOnComplete(() -\u0026gt; log.info(\u0026#34;用戶處理完成\u0026#34;)) .doFinally(signalType -\u0026gt; log.info(\u0026#34;處理結束，信號類型: {}\u0026#34;, signalType)); } 2. 度量收集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Component public class MetricsService { private final MeterRegistry meterRegistry; private final Counter userProcessedCounter; private final Timer userProcessingTimer; public MetricsService(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; this.userProcessedCounter = Counter.builder(\u0026#34;users.processed\u0026#34;) .description(\u0026#34;處理的用戶數量\u0026#34;) .register(meterRegistry); this.userProcessingTimer = Timer.builder(\u0026#34;users.processing.time\u0026#34;) .description(\u0026#34;用戶處理時間\u0026#34;) .register(meterRegistry); } public Mono\u0026lt;User\u0026gt; processUserWithMetrics(User user) { return Mono.fromCallable(() -\u0026gt; { // 處理邏輯 return processUser(user); }) .doOnNext(u -\u0026gt; userProcessedCounter.increment()) .doOnSuccess(u -\u0026gt; userProcessingTimer.recordCallable(() -\u0026gt; { // 計時邏輯 return u; })) .subscribeOn(Schedulers.boundedElastic()); } } 總結 Reactive Programming 為 Java 開發者提供了處理非同步、非阻塞程式設計的強大工具。透過 Project Reactor 和 Spring WebFlux，我們可以：\n核心優勢 高效能：非阻塞 I/O 提升系統吞吐量 可擴展性：更好地利用系統資源 彈性：內建錯誤處理和恢復機制 組合性：豐富的操作符支援複雜的資料流處理 最佳實踐要點 適當場景：I/O 密集型應用程式最適合 操作符選擇：理解不同操作符的特性和適用場景 錯誤處理：設計完善的錯誤處理策略 測試：使用 StepVerifier 進行完整測試 監控：建立適當的日誌和度量機制 響應式程式設計雖然學習曲線較陡，但掌握後能顯著提升應用程式的效能和可維護性，特別適合現代微服務架構和雲端環境。\n參考資料 Project Reactor 官方文檔 Spring WebFlux 參考指南 Reactive Streams 規範 R2DBC 響應式資料庫存取 Reactor 3 Reference Guide ","permalink":"https://xinqilin.github.io/post/backend/reactivejava/","tags":["Java","Spring","WebFlux","Reactor","Reactive","Async","Mono","Flux"],"title":"Reactive Programming 完整指南：Spring WebFlux 與 Project Reactor"},{"content":"#721 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Input: accounts = [ [\u0026#34;John\u0026#34;,\u0026#34;johnsmith@mail.com\u0026#34;,\u0026#34;john_newyork@mail.com\u0026#34;], [\u0026#34;John\u0026#34;,\u0026#34;johnsmith@mail.com\u0026#34;,\u0026#34;john00@mail.com\u0026#34;], [\u0026#34;Mary\u0026#34;,\u0026#34;mary@mail.com\u0026#34;], [\u0026#34;John\u0026#34;,\u0026#34;johnnybravo@mail.com\u0026#34;] ] Output: [ [\u0026#34;John\u0026#34;,\u0026#34;john00@mail.com\u0026#34;,\u0026#34;john_newyork@mail.com\u0026#34;,\u0026#34;johnsmith@mail.com\u0026#34;], [\u0026#34;Mary\u0026#34;,\u0026#34;mary@mail.com\u0026#34;], [\u0026#34;John\u0026#34;,\u0026#34;johnnybravo@mail.com\u0026#34;] ] Explanation: The first and second John\u0026#39;s are the same person as they have the common email \u0026#34;johnsmith@mail.com\u0026#34;. The third John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [[\u0026#39;Mary\u0026#39;, \u0026#39;mary@mail.com\u0026#39;], [\u0026#39;John\u0026#39;, \u0026#39;johnnybravo@mail.com\u0026#39;], [\u0026#39;John\u0026#39;, \u0026#39;john00@mail.com\u0026#39;, \u0026#39;john_newyork@mail.com\u0026#39;, \u0026#39;johnsmith@mail.com\u0026#39;]] would still be accepted. Sol: Graph + DFS ref: click me!\n1 2 3 4 5 6 7 Use these edges to build some components. Common email addresses are like the intersections that connect each single component for each account. Because each component represents a merged account, do DFS search for each components and add into a list. Before add the name into this list, sort the emails. Then add name string into it. Examples: Assume we have three accounts, we connect them like this in order to use DFS. {Name, 1, 2, 3} =\u0026gt; Name -- 1 -- 2 -- 3 {Name, 2, 4, 5} =\u0026gt; Name -- 2 -- 4 -- 5 (The same graph node 2 appears) {Name, 6, 7, 8} =\u0026gt; Name -- 6 -- 7 -- 8 (Where numbers represent email addresses). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accountsMerge(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accounts) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if(accounts==null || accounts.size()==0) return result; Map\u0026lt;String, String\u0026gt; names = new HashMap\u0026lt;String, String\u0026gt;(); //email - username Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt;(); //email - neighbors Set\u0026lt;String\u0026gt; emails = new HashSet\u0026lt;String\u0026gt;(); for(List\u0026lt;String\u0026gt; list : accounts){ String name = list.get(0); for(int i=1; i\u0026lt;list.size(); i++){ String email = list.get(i); emails.add( email ); names.put( email, name ); map.putIfAbsent( email, new HashSet\u0026lt;String\u0026gt;() ); if(i==1) continue; //build the \u0026#34;edge\u0026#34; between two adjacent email-nodes map.get( list.get(i-1) ).add( email ); map.get( email ).add( list.get(i-1) ); } } Set\u0026lt;String\u0026gt; visited = new HashSet\u0026lt;String\u0026gt;(); for(String s : emails) if( !visited.contains(s) ){ visited.add(s); List\u0026lt;String\u0026gt; buffer = new ArrayList\u0026lt;String\u0026gt;(); buffer.add(s); helper(s, map, visited, buffer); Collections.sort(buffer); buffer.add(0, names.get(s)); result.add(buffer); } return result; } private void helper(String s, Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; map, Set\u0026lt;String\u0026gt; visited, List\u0026lt;String\u0026gt; buffer){ for(String node : map.get(s)) if( !visited.contains(node) ){ visited.add(node); buffer.add(node); helper(node, map, visited, buffer); } } } BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accountsMerge(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; accounts) { HashMap\u0026lt;String,String\u0026gt; emailName = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; graph = new HashMap\u0026lt;\u0026gt;(); for(List\u0026lt;String\u0026gt; account: accounts){ String name = account.get(0); graph.putIfAbsent(account.get(1), new LinkedList\u0026lt;\u0026gt;()); emailName.put(account.get(1), name); for(int i = 2; i \u0026lt; account.size(); i++){ emailName.put(account.get(i), name); graph.putIfAbsent(account.get(i), new LinkedList\u0026lt;\u0026gt;()); graph.get(account.get(i)).add(account.get(1)); graph.get(account.get(1)).add(account.get(i)); } } List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); HashSet\u0026lt;String\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); for(String email: graph.keySet()){ if(visited.contains(email)) continue; visited.add(email); String name = emailName.get(email); List\u0026lt;String\u0026gt; emails = new LinkedList\u0026lt;\u0026gt;(); Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(email); while(!queue.isEmpty()){ String cur = queue.poll(); emails.add(cur); for(String next: graph.get(cur)){ if(!visited.contains(next)){ queue.offer(next); visited.add(next); } } } Collections.sort(emails); emails.add(0,name); res.add(emails); } return res; } ","permalink":"https://xinqilin.github.io/post/algorithm/graphaccountmerge/","tags":["Algorithm"],"title":"GraphAccountMerge"},{"content":"概述 二元樹遍歷是資料結構與演算法中的基本概念，主要有三種遍歷方式：前序遍歷（PreOrder）、中序遍歷（InOrder）、後序遍歷（PostOrder）。每種遍歷方式都有其特定的應用場景和優勢。\n基本概念 考慮以下二元樹結構：\n1 2 3 4 5 4 / \\ 2 6 / \\ / \\ 1 3 5 7 三種遍歷方式的順序 前序遍歷（PreOrder）：中 → 左 → 右\n遍歷順序：4 → 2 → 1 → 3 → 6 → 5 → 7 中序遍歷（InOrder）：左 → 中 → 右\n遍歷順序：1 → 2 → 3 → 4 → 5 → 6 → 7 對於二元搜尋樹，中序遍歷可得到有序序列 後序遍歷（PostOrder）：左 → 右 → 中\n遍歷順序：1 → 3 → 2 → 5 → 7 → 6 → 4 遍歷實作 1. 中序遍歷（InOrder Traversal） 中序遍歷在二元搜尋樹中特別有用，因為它會按升序訪問所有節點。\n遞歸實作 1 2 3 4 5 6 7 public void inorderTraversal(TreeNode root) { if (root == null) return; inorderTraversal(root.left); // 遍歷左子樹 System.out.print(root.val + \u0026#34; \u0026#34;); // 處理根節點 inorderTraversal(root.right); // 遍歷右子樹 } 迭代實作（使用堆疊） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode current = root; while (current != null || !stack.isEmpty()) { // 將所有左子節點推入堆疊 while (current != null) { stack.push(current); current = current.left; } // 處理堆疊頂部節點 current = stack.pop(); result.add(current.val); // 移動到右子樹 current = current.right; } return result; } 2. 前序遍歷（PreOrder Traversal） 前序遍歷適用於複製樹結構或建立表達式樹等場景。\n遞歸實作 1 2 3 4 5 6 7 public void preorderTraversal(TreeNode root) { if (root == null) return; System.out.print(root.val + \u0026#34; \u0026#34;); // 處理根節點 preorderTraversal(root.left); // 遍歷左子樹 preorderTraversal(root.right); // 遍歷右子樹 } 迭代實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return result; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode current = stack.pop(); result.add(current.val); // 注意：先推入右子節點，再推入左子節點 // 這樣確保左子節點先被處理 if (current.right != null) { stack.push(current.right); } if (current.left != null) { stack.push(current.left); } } return result; } 3. 後序遍歷（PostOrder Traversal） 後序遍歷適用於計算樹的大小、刪除節點或計算表達式值等場景。\n遞歸實作 1 2 3 4 5 6 7 public void postorderTraversal(TreeNode root) { if (root == null) return; postorderTraversal(root.left); // 遍歷左子樹 postorderTraversal(root.right); // 遍歷右子樹 System.out.print(root.val + \u0026#34; \u0026#34;); // 處理根節點 } 迭代實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return result; Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); TreeNode lastVisited = null; TreeNode current = root; while (current != null || !stack.isEmpty()) { if (current != null) { stack.push(current); current = current.left; } else { TreeNode peekNode = stack.peek(); // 如果右子節點存在且未被訪問過 if (peekNode.right != null \u0026amp;\u0026amp; lastVisited != peekNode.right) { current = peekNode.right; } else { result.add(peekNode.val); lastVisited = stack.pop(); } } } return result; } 實際應用：從遍歷序列重建二元樹 1. 從中序與後序遍歷重建二元樹 LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class Solution { public TreeNode buildTree(int[] inorder, int[] postorder) { if (inorder == null || inorder.length == 0 || postorder == null || postorder.length == 0) { return null; } return helper(postorder, postorder.length - 1, inorder, 0, inorder.length - 1); } private TreeNode helper(int[] postorder, int postIndex, int[] inorder, int inStart, int inEnd) { if (inStart \u0026gt; inEnd || postIndex \u0026lt; 0) { return null; } // 後序遍歷的最後一個元素是根節點 TreeNode root = new TreeNode(postorder[postIndex]); // 在中序遍歷中找到根節點的位置 int rootIndex = 0; for (int i = inStart; i \u0026lt;= inEnd; i++) { if (inorder[i] == root.val) { rootIndex = i; break; } } // 遞歸建構左右子樹 // 注意：先建構右子樹，因為後序遍歷是左-右-根 root.right = helper(postorder, postIndex - 1, inorder, rootIndex + 1, inEnd); root.left = helper(postorder, postIndex - (inEnd - rootIndex + 1), inorder, inStart, rootIndex - 1); return root; } } 2. 從前序與中序遍歷重建二元樹 LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { return helper(preorder, inorder, 0, 0, inorder.length - 1); } private TreeNode helper(int[] preorder, int[] inorder, int preStart, int inStart, int inEnd) { if (preStart \u0026gt; preorder.length - 1 || inStart \u0026gt; inEnd) { return null; } // 前序遍歷的第一個元素是根節點 TreeNode root = new TreeNode(preorder[preStart]); // 在中序遍歷中找到根節點的位置 int rootIndex = 0; for (int i = inStart; i \u0026lt;= inEnd; i++) { if (inorder[i] == preorder[preStart]) { rootIndex = i; break; } } // 遞歸建構左右子樹 root.left = helper(preorder, inorder, preStart + 1, inStart, rootIndex - 1); root.right = helper(preorder, inorder, preStart + rootIndex - inStart + 1, rootIndex + 1, inEnd); return root; } } 時間與空間複雜度 遍歷方式 時間複雜度 空間複雜度（遞歸） 空間複雜度（迭代） 前序遍歷 O(n) O(h) O(h) 中序遍歷 O(n) O(h) O(h) 後序遍歷 O(n) O(h) O(h) 其中 n 是節點數量，h 是樹的高度（最壞情況下 h = n，最佳情況下 h = log n）。\n應用場景總結 前序遍歷：複製樹、序列化樹結構、建立表達式樹 中序遍歷：二元搜尋樹的有序輸出、驗證二元搜尋樹 後序遍歷：計算樹的大小、刪除樹、計算表達式值、釋放記憶體 參考資料 LeetCode 94. Binary Tree Inorder Traversal LeetCode 144. Binary Tree Preorder Traversal LeetCode 145. Binary Tree Postorder Traversal 演算法導論 - 二元樹的基本操作 ","permalink":"https://xinqilin.github.io/post/algorithm/treetraversal/","tags":["Algorithm","Tree","遞歸","Java"],"title":"二元樹遍歷（Binary Tree Traversal）完整指南"},{"content":"TreeMap Method Map \u0026lt;-繼承 SortedMap \u0026lt;-繼承 NavigableMap \u0026lt;-實作 TreeMap\nSortedMap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public interface SortedMap\u0026lt;K,V\u0026gt; extends Map\u0026lt;K,V\u0026gt; { //return 元素comparator。如果是 ASC，则返回null； Comparator\u0026lt;? super K\u0026gt; comparator(); //fromKey到toKey的集合：含頭不含尾 java.util.SortedMap\u0026lt;K,V\u0026gt; subMap(K fromKey, K toKey); // 0 到toKey的集合：不包含toKey java.util.SortedMap\u0026lt;K,V\u0026gt; headMap(K toKey); //返回 fromKey 到结尾的集合：包含fromKey java.util.SortedMap\u0026lt;K,V\u0026gt; tailMap(K fromKey); //返回集合中的第一個元素： K firstKey(); //返回集合中的最后一個元素： K lastKey(); //返回集合中所有key的集合： Set\u0026lt;K\u0026gt; keySet(); //返回集合中所有value的集合： Collection\u0026lt;V\u0026gt; values(); //返回集合中的元素映射： Set\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; entrySet(); } NavigableMap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public interface NavigableMap\u0026lt;K,V\u0026gt; extends SortedMap\u0026lt;K,V\u0026gt; { //返回 \u0026lt; key的第一個元素： Map.Entry\u0026lt;K,V\u0026gt; lowerEntry(K key); // 返回 \u0026lt; key的第一個 key： K lowerKey(K key); // 返回 \u0026lt;= key的第一個元素： Map.Entry\u0026lt;K,V\u0026gt; floorEntry(K key); //返回 \u0026lt;= key的第一個键： K floorKey(K key); //返回 \u0026gt;= key的第一個元素： Map.Entry\u0026lt;K,V\u0026gt; ceilingEntry(K key); //返回 \u0026gt;= key的第一個键： K ceilingKey(K key); //返回 \u0026gt; key的第一個元素： Map.Entry\u0026lt;K,V\u0026gt; higherEntry(K key); //返回 \u0026gt; key的第一個键： K higherKey(K key); //return 第一個元素： Map.Entry\u0026lt;K,V\u0026gt; firstEntry(); //return 最後一個元素： Map.Entry\u0026lt;K,V\u0026gt; lastEntry(); //return 第一個元素，並刪除： Map.Entry\u0026lt;K,V\u0026gt; pollFirstEntry(); //return 最後一個元素，並刪除： Map.Entry\u0026lt;K,V\u0026gt; pollLastEntry(); //返回 desc 的Map集合： java.util.NavigableMap\u0026lt;K,V\u0026gt; descendingMap(); NavigableSet\u0026lt;K\u0026gt; navigableKeySet(); //返回Map集合中 desc 的Key组成的Set集合： NavigableSet\u0026lt;K\u0026gt; descendingKeySet(); java.util.NavigableMap\u0026lt;K,V\u0026gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive); java.util.NavigableMap\u0026lt;K,V\u0026gt; headMap(K toKey, boolean inclusive); java.util.NavigableMap\u0026lt;K,V\u0026gt; tailMap(K fromKey, boolean inclusive); SortedMap\u0026lt;K,V\u0026gt; subMap(K fromKey, K toKey); SortedMap\u0026lt;K,V\u0026gt; headMap(K toKey); SortedMap\u0026lt;K,V\u0026gt; tailMap(K fromKey); } Practice Leetcode 2055. Map.Entry ceilingEntry(K key) It returns the key-value pair having the least key, greater than or equal to the specified key, or null if there is no such key. K ceilingKey(K key)\tIt returns the least key, greater than the specified key or null if there is no such key. ","permalink":"https://xinqilin.github.io/post/backend/treemap/","tags":["Java","TreeMap","NavigableMap","Red-Black Tree","Data Structure","Sorting"],"title":"Java TreeMap 完整方法指南：NavigableMap 介面與紅黑樹實作"},{"content":"Maven integration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.querydsl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;querydsl-apt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${querydsl.version}\u0026lt;/version\u0026gt; \u0026lt;!-- //可不寫，由 spring 自動判斷 --\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.querydsl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;querydsl-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${querydsl.version}\u0026lt;/version\u0026gt; \u0026lt;!-- //可不寫，由 spring 自動判斷 --\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 會在 target/generated-sources/kotlin 生成 @Entity 的 Q類別 --\u0026gt; \u0026lt;project\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; ... \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;com.mysema.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;apt-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.3\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;process\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;outputDirectory\u0026gt;target/generated-sources/kotlin\u0026lt;/outputDirectory\u0026gt; \u0026lt;processor\u0026gt;com.querydsl.apt.jpa.JPAAnnotationProcessor\u0026lt;/processor\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; ... \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 產生 Q 類 1 mvn clean compile 使用 select 1 2 3 4 5 6 7 8 9 10 @Autowired lateinit var queryFactory: JPAQueryFactory val qadmin: QAdmin.admin bill = queryFactory.selectFrom(qadmin) .where(qadmin.account.eq(\u0026#34;Bill\u0026#34;)) .and(qadmin.password.ed(\u0026#34;password\u0026#34;)) .fetchOne(); join ===== 以下 官網 java 範例 =====\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Autowired private JPAQueryFactory queryFactory; QCat cat = QCat.cat; QCat mate = new QCat(\u0026#34;mate\u0026#34;); QCat kitten = new QCat(\u0026#34;kitten\u0026#34;); queryFactory.selectFrom(cat) .innerJoin(cat.mate, mate) .leftJoin(cat.kittens, kitten) .fetch(); queryFactory.selectFrom(cat) .leftJoin(cat.kittens, kitten) .on(kitten.bodyWeight.gt(10.0)) .fetch(); update 1 2 3 4 5 QCustomer customer = QCustomer.customer; // rename customers named Bob to Bobby queryFactory.update(customer).where(customer.name.eq(\u0026#34;Bob\u0026#34;)) .set(customer.name, \u0026#34;Bobby\u0026#34;) .execute(); delete 1 2 3 4 5 QCustomer customer = QCustomer.customer; // delete all customers queryFactory.delete(customer).execute(); // delete all customers with a level less than 3 queryFactory.delete(customer).where(customer.level.lt(3)).execute(); 子查詢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 QDepartment department = QDepartment.department; QDepartment d = new QDepartment(\u0026#34;d\u0026#34;); queryFactory.selectFrom(department) .where(department.size.eq(JPAExpressions.select(d.size.max()).from(d))) .fetch(); //---------- QEmployee employee = QEmployee.employee; QEmployee e = new QEmployee(\u0026#34;e\u0026#34;); queryFactory.selectFrom(employee) .where(employee.weeklyhours.gt( JPAExpressions.select(e.weeklyhours.avg()) .from(employee.department.employees, e) .where(e.manager.eq(employee.manager)))) .fetch(); order by 1 2 3 4 QCustomer customer = QCustomer.customer; queryFactory.selectFrom(customer) .orderBy(customer.lastName.asc(), customer.firstName.desc()) .fetch(); group by 1 2 3 4 QCustomer customer = QCustomer.customer; queryFactory.select(customer.lastName).from(customer) .groupBy(customer.lastName) .fetch(); Reference : 官網範例 請點我!\n","permalink":"https://xinqilin.github.io/post/backend/querydsl/","tags":["QueryDSL","JPA","Spring Data","Database","Query Builder","Type Safety"],"title":"QueryDSL 動態查詢框架：類型安全的 SQL 查詢建構器"},{"content":"lateinit：延遲初始化 當不想設定 init value 又不想加上 !! ， ?. ， 貓王運算 時 可以使用\nex: DI 時可以使用\n1 lateinit var adminUserRepository: AdminUserRepository lateinit with val 1 lateinit modifier is allowed only on mutable properties lateinit 算有點語法糖，強制不初始化，繞過compiler，但要小心 之後一定要給值，不然就踩到自己埋的地雷 檢查 lateinit 是否已給值:\n1 xxx.isInitialized ","permalink":"https://xinqilin.github.io/post/backend/lateinit/","tags":["Kotlin","lateinit","Property","Initialization","Android"],"title":"Kotlin lateinit 關鍵字詳解：延遲初始化與使用最佳實踐"},{"content":"概述 cURL（Client URL）是一個功能強大的命令行工具和函式庫，用於傳輸各種網路協定的資料。它支援 HTTP、HTTPS、FTP、SFTP、TELNET 等多種協定，是開發者進行 API 測試、網路除錯和自動化腳本的必備工具。\n核心特徵 多協定支援：HTTP/HTTPS、FTP、SFTP、SMTP、POP3 等 豐富的選項：支援各種 HTTP 方法、標頭、認證方式 跨平台：適用於 Linux、macOS、Windows 等系統 腳本友好：輸出格式化，適合自動化處理 安全性：支援 SSL/TLS、各種認證機制 基本語法 1 curl [選項] [URL] 簡單範例 1 2 3 4 5 6 7 8 9 10 11 # 基本 GET 請求 curl https://httpbin.org/get # 查看 HTTP 響應標頭 curl -I https://google.com # 下載檔案 curl -o filename.html https://example.com # 靜默模式 curl -s https://api.github.com/users/octocat 核心選項詳解 基本操作選項 1 2 3 4 5 6 7 8 9 10 11 12 13 # 輸出控制 -o, --output \u0026lt;file\u0026gt; # 將輸出寫入檔案 -O, --remote-name # 使用遠程檔案名稱儲存 -s, --silent # 靜默模式，不顯示進度 -S, --show-error # 顯示錯誤訊息 -v, --verbose # 詳細輸出模式 -w, --write-out \u0026lt;format\u0026gt; # 自訂輸出格式 # 基本範例 curl -o index.html https://example.com curl -O https://example.com/file.zip curl -s https://api.example.com/data curl -v https://httpbin.org/get HTTP 方法選項 1 2 3 4 5 6 7 8 9 10 11 # 請求方法 -X, --request \u0026lt;method\u0026gt; # 指定 HTTP 方法 -G, --get # 強制使用 GET 方法 -I, --head # 只獲取 HTTP 標頭 (HEAD 方法) # 範例 curl -X POST https://httpbin.org/post curl -X PUT https://httpbin.org/put curl -X DELETE https://httpbin.org/delete curl -X PATCH https://httpbin.org/patch curl -I https://httpbin.org/headers 資料傳送選項 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 資料傳送 -d, --data \u0026lt;data\u0026gt; # 發送 POST 資料 -d @filename # 從檔案讀取資料 -F, --form \u0026lt;name=content\u0026gt; # 表單資料 (multipart/form-data) -T, --upload-file \u0026lt;file\u0026gt; # 上傳檔案 # JSON 資料範例 curl -X POST https://httpbin.org/post \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 30}\u0026#39; # 表單資料範例 curl -X POST https://httpbin.org/post \\ -F \u0026#34;name=John\u0026#34; \\ -F \u0026#34;file=@upload.txt\u0026#34; # 從檔案讀取資料 curl -X POST https://httpbin.org/post \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d @data.json HTTP 標頭選項 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 標頭設定 -H, --header \u0026lt;header\u0026gt; # 添加自訂標頭 -A, --user-agent \u0026lt;agent\u0026gt; # 設定 User-Agent -e, --referer \u0026lt;URL\u0026gt; # 設定 Referer -i, --include # 在輸出中包含響應標頭 # 範例 curl -H \u0026#34;Authorization: Bearer token123\u0026#34; https://api.example.com curl -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;Accept: application/json\u0026#34; \\ https://api.example.com curl -A \u0026#34;MyApp/1.0\u0026#34; https://httpbin.org/user-agent curl -e \u0026#34;https://google.com\u0026#34; https://httpbin.org/headers curl -i https://httpbin.org/get HTTP 方法應用 GET 請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 基本 GET 請求 curl https://jsonplaceholder.typicode.com/posts # 帶查詢參數的 GET curl \u0026#34;https://jsonplaceholder.typicode.com/posts?userId=1\u0026#34; # 使用 -G 和 -d 構建查詢字串 curl -G -d \u0026#34;userId=1\u0026#34; -d \u0026#34;id=1\u0026#34; https://jsonplaceholder.typicode.com/posts # 帶認證的 GET curl -H \u0026#34;Authorization: Bearer your-token\u0026#34; https://api.example.com/user # 自訂 User-Agent curl -A \u0026#34;Mozilla/5.0 (Custom Agent)\u0026#34; https://httpbin.org/user-agent POST 請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # JSON 資料 POST curl -X POST https://jsonplaceholder.typicode.com/posts \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;title\u0026#34;: \u0026#34;New Post\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;This is the content\u0026#34;, \u0026#34;userId\u0026#34;: 1 }\u0026#39; # 表單資料 POST curl -X POST https://httpbin.org/post \\ -d \u0026#34;username=john\u0026#34; \\ -d \u0026#34;password=secret\u0026#34; # 檔案上傳 POST curl -X POST https://httpbin.org/post \\ -F \u0026#34;file=@document.pdf\u0026#34; \\ -F \u0026#34;description=Important document\u0026#34; # URL 編碼資料 curl -X POST https://httpbin.org/post \\ -H \u0026#34;Content-Type: application/x-www-form-urlencoded\u0026#34; \\ -d \u0026#34;name=John%20Doe\u0026amp;email=john%40example.com\u0026#34; PUT 和 PATCH 請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # PUT 更新資源 curl -X PUT https://jsonplaceholder.typicode.com/posts/1 \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;Updated Title\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Updated content\u0026#34;, \u0026#34;userId\u0026#34;: 1 }\u0026#39; # PATCH 部分更新 curl -X PATCH https://jsonplaceholder.typicode.com/posts/1 \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;title\u0026#34;: \u0026#34;Partially Updated Title\u0026#34;}\u0026#39; # 檔案替換上傳 curl -X PUT https://api.example.com/files/document.pdf \\ -T document.pdf \\ -H \u0026#34;Authorization: Bearer token\u0026#34; DELETE 請求 1 2 3 4 5 6 7 8 9 10 11 # 基本 DELETE curl -X DELETE https://jsonplaceholder.typicode.com/posts/1 # 帶認證的 DELETE curl -X DELETE https://api.example.com/users/123 \\ -H \u0026#34;Authorization: Bearer your-token\u0026#34; # 帶確認資料的 DELETE curl -X DELETE https://api.example.com/dangerous-action \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;confirm\u0026#34;: true, \u0026#34;reason\u0026#34;: \u0026#34;No longer needed\u0026#34;}\u0026#39; 認證與安全 基本認證 1 2 3 4 5 6 7 8 9 # HTTP Basic Authentication curl -u username:password https://httpbin.org/basic-auth/username/password # 從提示輸入密碼 curl -u username https://httpbin.org/basic-auth/username/password # 使用 Base64 編碼 curl -H \u0026#34;Authorization: Basic $(echo -n username:password | base64)\u0026#34; \\ https://httpbin.org/basic-auth/username/password Bearer Token 認證 1 2 3 4 5 6 7 8 9 # JWT Token curl -H \u0026#34;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\u0026#34; \\ https://api.example.com/protected # API Key in Header curl -H \u0026#34;X-API-Key: your-api-key\u0026#34; https://api.example.com/data # API Key in Query curl \u0026#34;https://api.example.com/data?api_key=your-api-key\u0026#34; OAuth 2.0 1 2 3 4 5 6 7 8 9 10 # 獲取存取令牌 curl -X POST https://oauth.example.com/token \\ -H \u0026#34;Content-Type: application/x-www-form-urlencoded\u0026#34; \\ -d \u0026#34;grant_type=client_credentials\u0026#34; \\ -d \u0026#34;client_id=your-client-id\u0026#34; \\ -d \u0026#34;client_secret=your-client-secret\u0026#34; # 使用存取令牌 curl -H \u0026#34;Authorization: Bearer access-token\u0026#34; \\ https://api.example.com/protected-resource SSL/TLS 選項 1 2 3 4 5 6 7 8 9 10 # SSL 相關選項 -k, --insecure # 允許不安全的 SSL 連接 --cert \u0026lt;certificate\u0026gt; # 客戶端證書 --key \u0026lt;private-key\u0026gt; # 私鑰檔案 --cacert \u0026lt;CA-certificate\u0026gt; # CA 證書檔案 # 範例 curl -k https://self-signed.example.com curl --cert client.crt --key client.key https://secure.example.com curl --cacert ca-bundle.crt https://secure.example.com Cookie 處理 Cookie 基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 發送 Cookie curl -b \u0026#34;session=abc123; user=john\u0026#34; https://httpbin.org/cookies # 從檔案讀取 Cookie curl -b cookies.txt https://httpbin.org/cookies # 儲存 Cookie 到檔案 curl -c cookies.txt https://httpbin.org/cookies/set/session/abc123 # 同時讀取和儲存 Cookie curl -b cookies.txt -c cookies.txt https://example.com/login # Cookie Jar 格式 curl -b cookie-jar.txt -c cookie-jar.txt https://example.com 會話管理 1 2 3 4 5 6 7 8 9 # 登入並保持會話 curl -c session.txt -d \u0026#34;username=john\u0026amp;password=secret\u0026#34; \\ https://example.com/login # 使用會話訪問受保護頁面 curl -b session.txt https://example.com/dashboard # 登出並清除會話 curl -b session.txt -c /dev/null https://example.com/logout 檔案傳輸 檔案下載 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 基本下載 curl -O https://example.com/file.zip # 自訂檔案名 curl -o myfile.zip https://example.com/file.zip # 斷點續傳 curl -C - -O https://example.com/largefile.zip # 限制下載速度 curl --limit-rate 100k -O https://example.com/file.zip # 下載多個檔案 curl -O https://example.com/file1.zip -O https://example.com/file2.zip # 使用範圍下載 curl -r 0-1023 https://example.com/file.txt # 下載前 1024 位元組 檔案上傳 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # FTP 上傳 curl -T localfile.txt ftp://ftp.example.com/remote/ # HTTP PUT 上傳 curl -T document.pdf https://api.example.com/upload # 表單檔案上傳 curl -F \u0026#34;file=@document.pdf\u0026#34; -F \u0026#34;title=My Document\u0026#34; \\ https://example.com/upload # 多檔案上傳 curl -F \u0026#34;file1=@doc1.pdf\u0026#34; -F \u0026#34;file2=@doc2.pdf\u0026#34; \\ https://example.com/upload # 帶進度條的上傳 curl -# -T largefile.zip https://api.example.com/upload 進階功能 輸出格式化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 自訂輸出格式 curl -w \u0026#34;Status: %{http_code}\\nTime: %{time_total}s\\nSize: %{size_download} bytes\\n\u0026#34; \\ -o /dev/null -s https://example.com # 常用格式變數 %{http_code} # HTTP 狀態碼 %{time_total} # 總耗時 %{time_connect} # 連接時間 %{time_starttransfer} # 開始傳輸時間 %{size_download} # 下載大小 %{size_upload} # 上傳大小 %{speed_download} # 下載速度 %{speed_upload} # 上傳速度 # 效能測試範例 curl -w \u0026#34;@curl-format.txt\u0026#34; -o /dev/null -s https://example.com 建立 curl-format.txt 檔案：\n1 2 3 4 5 6 7 8 time_namelookup: %{time_namelookup}s\\n time_connect: %{time_connect}s\\n time_appconnect: %{time_appconnect}s\\n time_pretransfer: %{time_pretransfer}s\\n time_redirect: %{time_redirect}s\\n time_starttransfer: %{time_starttransfer}s\\n ----------\\n time_total: %{time_total}s\\n 重定向處理 1 2 3 4 5 6 7 8 9 10 11 # 跟隨重定向 curl -L https://bit.ly/shortened-url # 限制重定向次數 curl -L --max-redirs 5 https://example.com # 顯示重定向過程 curl -L -v https://bit.ly/shortened-url # 不跟隨重定向（預設） curl https://bit.ly/shortened-url 代理設定 1 2 3 4 5 6 7 8 9 10 11 12 13 # HTTP 代理 curl --proxy http://proxy.example.com:8080 https://httpbin.org/ip # SOCKS 代理 curl --socks5 localhost:1080 https://httpbin.org/ip # 代理認證 curl --proxy-user username:password \\ --proxy http://proxy.example.com:8080 \\ https://httpbin.org/ip # 排除代理 curl --noproxy localhost,127.0.0.1 https://localhost:8080/api 並行請求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 背景執行 curl https://api1.example.com \u0026amp; curl https://api2.example.com \u0026amp; curl https://api3.example.com \u0026amp; wait # 使用 xargs 並行 echo -e \u0026#34;https://api1.example.com\\nhttps://api2.example.com\u0026#34; | \\ xargs -n 1 -P 2 curl -s # 循環請求 for i in {1..5}; do curl -s \u0026#34;https://api.example.com/data/$i\u0026#34; \u0026amp; done wait API 測試實戰 REST API 測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 使用者管理 API 測試 BASE_URL=\u0026#34;https://jsonplaceholder.typicode.com\u0026#34; # 1. 獲取所有使用者 curl -s \u0026#34;$BASE_URL/users\u0026#34; | jq \u0026#39;.[0:3]\u0026#39; # 2. 獲取特定使用者 curl -s \u0026#34;$BASE_URL/users/1\u0026#34; | jq \u0026#39;.\u0026#39; # 3. 創建新使用者 curl -X POST \u0026#34;$BASE_URL/users\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;johndoe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34; }\u0026#39; | jq \u0026#39;.\u0026#39; # 4. 更新使用者 curl -X PUT \u0026#34;$BASE_URL/users/1\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Jane Doe\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;janedoe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;jane@example.com\u0026#34; }\u0026#39; | jq \u0026#39;.\u0026#39; # 5. 刪除使用者 curl -X DELETE \u0026#34;$BASE_URL/users/1\u0026#34; -w \u0026#34;Status: %{http_code}\\n\u0026#34; API 效能測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 響應時間測試 test_api_performance() { local url=\u0026#34;$1\u0026#34; local requests=\u0026#34;$2\u0026#34; echo \u0026#34;Testing $url with $requests requests...\u0026#34; for i in $(seq 1 $requests); do curl -w \u0026#34;%{time_total}\\n\u0026#34; -o /dev/null -s \u0026#34;$url\u0026#34; done | awk \u0026#39;{sum+=$1; count++} END {print \u0026#34;Average:\u0026#34;, sum/count \u0026#34;s\u0026#34;}\u0026#39; } test_api_performance \u0026#34;https://httpbin.org/delay/1\u0026#34; 5 # 並發測試 concurrent_test() { local url=\u0026#34;$1\u0026#34; local concurrent=\u0026#34;$2\u0026#34; local total=\u0026#34;$3\u0026#34; echo \u0026#34;Concurrent test: $concurrent parallel requests, $total total\u0026#34; seq 1 $total | xargs -n 1 -P $concurrent -I {} \\ curl -w \u0026#34;Request {}: %{time_total}s\\n\u0026#34; -o /dev/null -s \u0026#34;$url\u0026#34; } concurrent_test \u0026#34;https://httpbin.org/delay/1\u0026#34; 3 10 API 健康檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #!/bin/bash # api_health_check.sh check_api_health() { local name=\u0026#34;$1\u0026#34; local url=\u0026#34;$2\u0026#34; local expected_status=\u0026#34;$3\u0026#34; echo -n \u0026#34;Checking $name... \u0026#34; response=$(curl -s -w \u0026#34;HTTPSTATUS:%{http_code}\u0026#34; \u0026#34;$url\u0026#34;) http_code=$(echo \u0026#34;$response\u0026#34; | tr -d \u0026#39;\\n\u0026#39; | sed -E \u0026#39;s/.*HTTPSTATUS:([0-9]{3})$/\\1/\u0026#39;) body=$(echo \u0026#34;$response\u0026#34; | sed -E \u0026#39;s/HTTPSTATUS:[0-9]{3}$//\u0026#39;) if [ \u0026#34;$http_code\u0026#34; -eq \u0026#34;$expected_status\u0026#34; ]; then echo \u0026#34;✓ OK (HTTP $http_code)\u0026#34; return 0 else echo \u0026#34;✗ FAIL (HTTP $http_code)\u0026#34; echo \u0026#34;Response: $body\u0026#34; return 1 fi } # 健康檢查 check_api_health \u0026#34;Main API\u0026#34; \u0026#34;https://api.example.com/health\u0026#34; 200 check_api_health \u0026#34;User Service\u0026#34; \u0026#34;https://api.example.com/users/1\u0026#34; 200 check_api_health \u0026#34;Auth Service\u0026#34; \u0026#34;https://api.example.com/auth/status\u0026#34; 200 除錯與監控 詳細除錯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 詳細模式 curl -v https://httpbin.org/get # 追蹤 ASCII 格式 curl --trace-ascii debug.txt https://httpbin.org/get # 追蹤二進位格式 curl --trace debug.bin https://httpbin.org/get # 只顯示標頭 curl -I https://httpbin.org/get # 顯示請求和響應標頭 curl -D headers.txt https://httpbin.org/get 網路診斷 1 2 3 4 5 6 7 8 9 10 11 12 13 # DNS 解析時間 curl -w \u0026#34;DNS lookup: %{time_namelookup}s\\n\u0026#34; -o /dev/null -s https://example.com # 連接時間分析 curl -w \u0026#34;Connect: %{time_connect}s, Start transfer: %{time_starttransfer}s, Total: %{time_total}s\\n\u0026#34; \\ -o /dev/null -s https://example.com # 檢查 SSL 證書 curl -vI https://example.com 2\u0026gt;\u0026amp;1 | grep -E \u0026#34;(SSL|TLS|certificate)\u0026#34; # 測試不同 HTTP 版本 curl --http1.1 -I https://example.com curl --http2 -I https://example.com 錯誤處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 基本錯誤處理 if curl -s --fail https://api.example.com/data; then echo \u0026#34;Request successful\u0026#34; else echo \u0026#34;Request failed with exit code $?\u0026#34; fi # 詳細錯誤資訊 curl -s -w \u0026#34;Status: %{http_code}, Exit: %{exitcode}\\n\u0026#34; \\ https://httpbin.org/status/404 # 重試機制 retry_curl() { local url=\u0026#34;$1\u0026#34; local max_attempts=3 local attempt=1 while [ $attempt -le $max_attempts ]; do echo \u0026#34;Attempt $attempt of $max_attempts...\u0026#34; if curl -s --fail \u0026#34;$url\u0026#34;; then echo \u0026#34;Success on attempt $attempt\u0026#34; return 0 fi echo \u0026#34;Failed attempt $attempt\u0026#34; ((attempt++)) sleep 2 done echo \u0026#34;All attempts failed\u0026#34; return 1 } retry_curl \u0026#34;https://unstable-api.example.com\u0026#34; 實用腳本範例 1. API 批次測試腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #!/bin/bash # api_batch_test.sh API_BASE=\u0026#34;https://jsonplaceholder.typicode.com\u0026#34; AUTH_TOKEN=\u0026#34;your-auth-token\u0026#34; # 測試配置 declare -A TESTS=( [\u0026#34;GET /users\u0026#34;]=\u0026#34;$API_BASE/users\u0026#34; [\u0026#34;GET /posts\u0026#34;]=\u0026#34;$API_BASE/posts\u0026#34; [\u0026#34;GET /user/1\u0026#34;]=\u0026#34;$API_BASE/users/1\u0026#34; [\u0026#34;POST /posts\u0026#34;]=\u0026#34;$API_BASE/posts\u0026#34; ) # 執行測試 run_tests() { echo \u0026#34;Starting API batch tests...\u0026#34; echo \u0026#34;==========================\u0026#34; local passed=0 local failed=0 for test_name in \u0026#34;${!TESTS[@]}\u0026#34;; do local url=\u0026#34;${TESTS[$test_name]}\u0026#34; echo -n \u0026#34;Testing $test_name... \u0026#34; if [[ \u0026#34;$test_name\u0026#34; == \u0026#34;POST\u0026#34;* ]]; then # POST 測試 response=$(curl -s -w \u0026#34;HTTPSTATUS:%{http_code}\u0026#34; \\ -X POST \u0026#34;$url\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;Authorization: Bearer $AUTH_TOKEN\u0026#34; \\ -d \u0026#39;{\u0026#34;title\u0026#34;:\u0026#34;Test\u0026#34;,\u0026#34;body\u0026#34;:\u0026#34;Test content\u0026#34;,\u0026#34;userId\u0026#34;:1}\u0026#39;) else # GET 測試 response=$(curl -s -w \u0026#34;HTTPSTATUS:%{http_code}\u0026#34; \\ -H \u0026#34;Authorization: Bearer $AUTH_TOKEN\u0026#34; \\ \u0026#34;$url\u0026#34;) fi http_code=$(echo \u0026#34;$response\u0026#34; | tr -d \u0026#39;\\n\u0026#39; | sed -E \u0026#39;s/.*HTTPSTATUS:([0-9]{3})$/\\1/\u0026#39;) if [[ \u0026#34;$http_code\u0026#34; -ge 200 \u0026amp;\u0026amp; \u0026#34;$http_code\u0026#34; -lt 300 ]]; then echo \u0026#34;✓ PASS (HTTP $http_code)\u0026#34; ((passed++)) else echo \u0026#34;✗ FAIL (HTTP $http_code)\u0026#34; ((failed++)) fi done echo \u0026#34;==========================\u0026#34; echo \u0026#34;Results: $passed passed, $failed failed\u0026#34; } run_tests 2. 檔案同步腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #!/bin/bash # file_sync.sh LOCAL_DIR=\u0026#34;./local_files\u0026#34; REMOTE_BASE=\u0026#34;https://api.example.com/files\u0026#34; AUTH_TOKEN=\u0026#34;your-token\u0026#34; sync_files() { echo \u0026#34;Starting file synchronization...\u0026#34; # 獲取遠程檔案列表 remote_files=$(curl -s -H \u0026#34;Authorization: Bearer $AUTH_TOKEN\u0026#34; \\ \u0026#34;$REMOTE_BASE\u0026#34; | jq -r \u0026#39;.[].filename\u0026#39;) for file in $remote_files; do local_file=\u0026#34;$LOCAL_DIR/$file\u0026#34; remote_url=\u0026#34;$REMOTE_BASE/$file\u0026#34; echo -n \u0026#34;Checking $file... \u0026#34; if [ -f \u0026#34;$local_file\u0026#34; ]; then # 比較檔案雜湊 local_hash=$(sha256sum \u0026#34;$local_file\u0026#34; | cut -d\u0026#39; \u0026#39; -f1) remote_hash=$(curl -s -I -H \u0026#34;Authorization: Bearer $AUTH_TOKEN\u0026#34; \\ \u0026#34;$remote_url\u0026#34; | grep -i \u0026#34;x-file-hash\u0026#34; | cut -d\u0026#39; \u0026#39; -f2 | tr -d \u0026#39;\\r\u0026#39;) if [ \u0026#34;$local_hash\u0026#34; = \u0026#34;$remote_hash\u0026#34; ]; then echo \u0026#34;✓ Up to date\u0026#34; continue fi fi # 下載檔案 echo \u0026#34;⬇ Downloading...\u0026#34; curl -s -H \u0026#34;Authorization: Bearer $AUTH_TOKEN\u0026#34; \\ -o \u0026#34;$local_file\u0026#34; \u0026#34;$remote_url\u0026#34; if [ $? -eq 0 ]; then echo \u0026#34;✓ Downloaded successfully\u0026#34; else echo \u0026#34;✗ Download failed\u0026#34; fi done } mkdir -p \u0026#34;$LOCAL_DIR\u0026#34; sync_files 3. 網站監控腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #!/bin/bash # website_monitor.sh SITES=( \u0026#34;https://example.com\u0026#34; \u0026#34;https://api.example.com/health\u0026#34; \u0026#34;https://cdn.example.com\u0026#34; ) TIMEOUT=10 LOG_FILE=\u0026#34;/var/log/website_monitor.log\u0026#34; log_message() { echo \u0026#34;$(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;) - $1\u0026#34; | tee -a \u0026#34;$LOG_FILE\u0026#34; } check_site() { local url=\u0026#34;$1\u0026#34; local name=$(echo \u0026#34;$url\u0026#34; | sed \u0026#39;s|https\\?://||\u0026#39; | sed \u0026#39;s|/.*||\u0026#39;) response=$(curl -s -w \u0026#34;HTTPSTATUS:%{http_code};TIME:%{time_total}\u0026#34; \\ --max-time \u0026#34;$TIMEOUT\u0026#34; \u0026#34;$url\u0026#34;) if [ $? -eq 0 ]; then http_code=$(echo \u0026#34;$response\u0026#34; | grep -o \u0026#34;HTTPSTATUS:[0-9]*\u0026#34; | cut -d: -f2) time_total=$(echo \u0026#34;$response\u0026#34; | grep -o \u0026#34;TIME:[0-9.]*\u0026#34; | cut -d: -f2) if [ \u0026#34;$http_code\u0026#34; = \u0026#34;200\u0026#34; ]; then log_message \u0026#34;✓ $name - OK (${time_total}s)\u0026#34; else log_message \u0026#34;⚠ $name - HTTP $http_code (${time_total}s)\u0026#34; fi else log_message \u0026#34;✗ $name - TIMEOUT or ERROR\u0026#34; fi } log_message \u0026#34;Starting website monitoring...\u0026#34; for site in \u0026#34;${SITES[@]}\u0026#34;; do check_site \u0026#34;$site\u0026#34; done log_message \u0026#34;Monitoring completed\u0026#34; 效能最佳化 連接重用 1 2 3 4 5 6 7 8 9 10 # HTTP/1.1 Keep-Alive curl --keepalive-time 30 https://api.example.com/endpoint1 curl --keepalive-time 30 https://api.example.com/endpoint2 # HTTP/2 多路復用 curl --http2 https://example.com/resource1 curl --http2 https://example.com/resource2 # 連接池配置 curl --max-time 30 --connect-timeout 10 https://api.example.com 快取與壓縮 1 2 3 4 5 6 7 8 9 10 # 啟用壓縮 curl -H \u0026#34;Accept-Encoding: gzip, deflate\u0026#34; https://example.com # 條件請求 curl -H \u0026#34;If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT\u0026#34; \\ https://example.com/data # ETag 支援 curl -H \u0026#34;If-None-Match: \\\u0026#34;33a64df551425fcc55e4d42a148795d9f25f89d4\\\u0026#34;\u0026#34; \\ https://example.com/resource 批次優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 並行下載 urls=( \u0026#34;https://api.example.com/data1\u0026#34; \u0026#34;https://api.example.com/data2\u0026#34; \u0026#34;https://api.example.com/data3\u0026#34; ) for url in \u0026#34;${urls[@]}\u0026#34;; do curl -s \u0026#34;$url\u0026#34; \u0026gt; \u0026#34;$(basename \u0026#34;$url\u0026#34;).json\u0026#34; \u0026amp; done wait # 限制並行數 printf \u0026#34;%s\\n\u0026#34; \u0026#34;${urls[@]}\u0026#34; | xargs -n 1 -P 3 -I {} \\ sh -c \u0026#39;curl -s \u0026#34;{}\u0026#34; \u0026gt; \u0026#34;$(basename \u0026#34;{}\u0026#34;).json\u0026#34;\u0026#39; 常見問題與解決方案 SSL/TLS 問題 1 2 3 4 5 6 7 8 9 # 證書驗證問題 curl -k https://self-signed.example.com # 跳過驗證（不推薦） curl --cacert /path/to/ca-bundle.crt https://example.com # 指定 CA # 檢查證書資訊 curl -vI https://example.com 2\u0026gt;\u0026amp;1 | grep -A 10 \u0026#34;Server certificate\u0026#34; # 測試 SSL 配置 curl --tlsv1.2 --ciphers HIGH https://example.com 編碼問題 1 2 3 4 5 6 7 8 # UTF-8 編碼 curl -H \u0026#34;Accept-Charset: utf-8\u0026#34; https://example.com # URL 編碼 curl \u0026#34;https://example.com/search?q=$(echo \u0026#39;中文查詢\u0026#39; | curl -Gso /dev/null -w %{url_effective} --data-urlencode @- | cut -c3-)\u0026#34; # 處理特殊字元 curl -G -d \u0026#34;query=hello world\u0026#34; https://example.com/search 超時與重試 1 2 3 4 5 6 7 8 9 # 超時設定 curl --connect-timeout 10 --max-time 30 https://slow-api.example.com # 自動重試 curl --retry 3 --retry-delay 5 https://unstable-api.example.com # 指數退避 curl --retry 3 --retry-delay 1 --retry-max-time 60 \\ https://api.example.com 總結 核心優勢 多功能性：支援多種協定和操作方式 靈活性：豐富的選項和配置能力 可程式性：適合自動化和腳本處理 跨平台：在各種系統上表現一致 效能：高效的網路通訊和傳輸 最佳實踐 安全第一：正確處理認證和 SSL 驗證 錯誤處理：實作適當的重試和錯誤恢復機制 效能優化：使用連接重用和並行處理 日誌記錄：保留詳細的請求和響應日誌 測試自動化：將 API 測試整合到 CI/CD 流程 常用模式記憶 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # API 測試基本模式 curl -X POST https://api.example.com/resource \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;Authorization: Bearer token\u0026#34; \\ -d \u0026#39;{\u0026#34;key\u0026#34;: \u0026#34;value\u0026#34;}\u0026#39; # 檔案操作模式 curl -O https://example.com/file.zip # 下載 curl -T file.txt https://api.example.com/upload # 上傳 # 除錯模式 curl -v -I https://example.com # 詳細標頭 curl -w \u0026#34;%{http_code}\\n\u0026#34; https://example.com # 狀態碼 # 效能測試模式 curl -w \u0026#34;@curl-format.txt\u0026#34; -o /dev/null -s https://example.com cURL 是現代開發者工具箱中不可或缺的利器，掌握其核心功能和進階技巧，能夠大幅提升 API 開發、測試和維護的效率。記住：實務中最重要的是理解 HTTP 協定基礎，並善用 cURL 的豐富選項來解決實際問題。\n參考資料 cURL 官方文檔 cURL Tutorial HTTP/1.1 規範 REST API 設計指南 JSON API 規範 ","permalink":"https://xinqilin.github.io/post/tools/curl/","tags":["cURL","HTTP","API","REST","Web Development","Command Line","Network"],"title":"cURL 完整指南：HTTP 客戶端工具與 API 測試利器"},{"content":"概述 在現代應用程式開發中，一個專案往往由多個服務組成，例如前端、後端 API、資料庫、快取等。這些服務各自運行在不同的容器中，而 Docker Compose 正是為了解決這種多容器應用程式的定義與管理而生。\nDocker Compose 允許您使用一個 YAML 檔案 (docker-compose.yml) 來定義應用程式的所有服務、網路和儲存卷，然後透過單一指令啟動、停止或管理整個應用程式堆疊。這極大地簡化了開發、測試和部署的流程。\n常用 Docker Compose 指令 以下是 Docker Compose 的一些常用指令，用於管理您的多容器應用程式：\n指令 說明 範例 docker-compose --version 顯示 Docker Compose 的版本資訊。 docker-compose --version docker-compose -h 顯示 Docker Compose 的幫助訊息。 docker-compose -h docker-compose up 啟動並建立所有服務的容器。如果容器已存在，則會重新建立。 docker-compose up docker-compose up -d 在背景模式 (detached mode) 啟動並建立所有服務的容器。 docker-compose up -d docker-compose down 停止並移除所有服務的容器、網路和預設儲存卷。 docker-compose down docker-compose exec \u0026lt;service_name\u0026gt; \u0026lt;command\u0026gt; 在指定服務的容器中執行指令。 docker-compose exec microService /bin/bash docker-compose ps 列出所有服務的容器狀態。 docker-compose ps docker-compose top 顯示服務容器的運行進程。 docker-compose top docker-compose logs \u0026lt;service_name\u0026gt; 顯示指定服務容器的日誌輸出。 docker-compose logs microService docker-compose config 驗證 docker-compose.yml 檔案的語法是否正確，並顯示解析後的配置。 docker-compose config docker-compose config -q 靜默模式驗證配置，只在有錯誤時輸出訊息。 docker-compose config -q docker-compose restart \u0026lt;service_name\u0026gt; 重新啟動指定服務的容器。若未指定服務，則重新啟動所有服務。 docker-compose restart microService docker-compose start \u0026lt;service_name\u0026gt; 啟動指定服務的容器。若未指定服務，則啟動所有已停止的服務。 docker-compose start microService docker-compose stop \u0026lt;service_name\u0026gt; 停止指定服務的容器。若未指定服務，則停止所有運行中的服務。 docker-compose stop microService 常用組合指令 1 2 # 驗證配置後，停止並重新啟動所有服務 docker-compose config -q \u0026amp;\u0026amp; docker-compose down \u0026amp;\u0026amp; docker-compose up -d docker-compose.yml 檔案結構詳解 docker-compose.yml 是 Docker Compose 的核心配置檔案，它使用 YAML 語法來定義應用程式的服務。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 # 指定 Docker Compose 檔案格式的版本，建議使用最新穩定版 (目前為 \u0026#39;3.x\u0026#39;) version: \u0026#34;3.8\u0026#34; # 建議使用 3.8 或更高版本，以支援更多功能 # 定義應用程式中的所有服務 (即容器) services: # 自訂服務名稱，例如 \u0026#39;microService\u0026#39;、\u0026#39;web\u0026#39;、\u0026#39;db\u0026#39; 等 microService: # 指定服務所使用的 Docker 映像檔 image: my_image:1.0 # 定義容器的名稱，方便識別和管理 container_name: ms_01 # 埠映射：將主機埠映射到容器埠 (HOST_PORT:CONTAINER_PORT) ports: - \u0026#34;8081:8080\u0026#34; # 將主機的 8081 埠映射到容器的 8080 埠 # 儲存卷映射：將主機路徑映射到容器路徑 (HOST_PATH:CONTAINER_PATH) volumes: - /Users/bill/microService:/app # 將主機的 /Users/bill/microService 目錄映射到容器的 /app 目錄 # 指定服務所連接的網路 networks: - my_network # 連接到名為 \u0026#39;my_network\u0026#39; 的網路 # 定義服務的啟動順序依賴關係 # 注意：depends_on 只保證服務啟動順序，不保證服務內部應用程式完全就緒 # 可搭配 https://github.com/vishnubob/wait-for-it 或其他健康檢查機制確保服務可用 depends_on: - redis # microService 服務會在 redis 服務啟動後才啟動 - mysql # microService 服務會在 mysql 服務啟動後才啟動 # 範例：等同於 `docker run -d -p 8081:8080 -v /Users/bill/microService:/app --network my_network` redis: image: redis:6.0.8 # 使用 Redis 6.0.8 映像檔 ports: - \u0026#34;6379:6379\u0026#34; # 映射 Redis 預設埠 volumes: # 映射 Redis 配置檔，讓容器使用自訂配置 - /app/redis/redis.conf:/etc/redis/redis.conf # 映射 Redis 資料目錄，實現資料持久化 - /app/redis/data:/data networks: - my_network # 覆寫容器的預設啟動指令，讓 Redis 使用指定的配置檔啟動 command: redis-server /etc/redis/redis.conf mysql: image: mysql:5.7 # 使用 MySQL 5.7 映像檔 # 設定 MySQL 容器的環境變數 environment: MYSQL_ROOT_PASSWORD: \u0026#39;123456\u0026#39; # 設定 root 使用者的密碼 MYSQL_ALLOW_EMPTY_PASSWORD: \u0026#39;no\u0026#39; # 不允許 root 密碼為空 MYSQL_DATABASE: \u0026#39;my_test_db\u0026#39; # 建立一個名為 \u0026#39;my_test_db\u0026#39; 的資料庫 MYSQL_USER: \u0026#39;bill\u0026#39; # 建立一個名為 \u0026#39;bill\u0026#39; 的使用者 MYSQL_PASSWORD: \u0026#39;user_pwd\u0026#39; # 設定 \u0026#39;bill\u0026#39; 使用者的密碼 ports: - \u0026#34;3306:3306\u0026#34; # 映射 MySQL 預設埠 volumes: # 映射 MySQL 資料目錄，實現資料持久化 - /app/mysql/db:/var/lib/mysql # 映射 MySQL 配置檔 - /app/mysql/conf/my.cnf:/etc/my.cnf # 映射初始化腳本目錄，容器啟動時會執行此目錄下的 .sh 或 .sql 腳本 - /app/mysql/init:/docker-entrypoint-initdb.d networks: - my_network # 解決 MySQL 8.0 之後預設認證插件導致外部客戶端無法連接的問題 command: --default-authentication-plugin=mysql_native_password # 定義應用程式使用的網路 networks: my_network: # 自訂網路名稱，所有服務將在此網路中互相通訊 # 定義應用程式使用的儲存卷 (可選，如果服務中直接使用匿名卷或綁定掛載則不需要在此定義) # volumes: # my_data: # 自訂儲存卷名稱 ","permalink":"https://xinqilin.github.io/post/devops/docker-compose/","tags":["Docker","Docker Compose","DevOps","Containerization","Microservices","YAML"],"title":"Docker Compose 完整指南：多容器應用程式的定義與執行"},{"content":"概述 Docker 網路是容器化應用程式的基石，它決定了容器如何與外部世界通訊，以及容器之間如何互相連接。理解 Docker 的網路模式對於建構穩健、可擴展的容器化應用程式至關重要。本文將詳細介紹 Docker 提供的幾種主要網路模式及其應用場景。\nDocker 網路模式 Docker 提供了多種網路驅動程式，每種驅動程式都提供不同的網路功能。最常用的包括 bridge、host、none 和 container。\n1. Bridge (橋接模式) 說明：這是 Docker 的預設網路模式。當您不指定網路模式時，Docker 會自動為容器分配一個 IP 位址，並將其連接到一個名為 docker0 的虛擬橋接器上。每個容器都會獲得一個獨立的網路堆疊。 工作原理： Docker 會在主機上建立一個名為 docker0 的虛擬橋接器。 每個容器都會建立一對虛擬乙太網卡 (veth pair)，其中一端連接到容器內的 eth0，另一端連接到 docker0 橋接器。 容器可以透過 docker0 橋接器與同一橋接器上的其他容器通訊，也可以透過主機的網路介面與外部網路通訊。 優點：提供良好的隔離性，容器間預設不直接暴露埠。 缺點：容器需要透過埠映射才能從外部訪問。 2. Host (主機模式) 說明：在主機模式下，容器不會有自己的獨立網路堆疊，而是直接使用主機的網路堆疊。這意味著容器會直接使用主機的 IP 位址和埠。 工作原理：容器內的應用程式會直接綁定到主機的網路介面和埠上。 優點：網路效能最佳，因為沒有額外的網路層。 缺點： 容器不再與主機隔離，容器內應用程式使用的埠不能與主機上已佔用的埠衝突。 安全性較低，因為容器直接暴露在主機網路中。 使用方式：--network host 3. None (無網路模式) 說明：在無網路模式下，容器會建立一個獨立的網路堆疊，但不會對其進行任何網路配置。容器將沒有網路介面，無法與外部通訊。 工作原理：容器只包含一個 lo (loopback) 介面。 優點：適用於只需要計算資源而不需要網路連接的特殊場景，或者需要手動配置網路的進階情況。 缺點：容器無法進行任何網路通訊，除非手動配置。 使用方式：--network none 4. Container (容器模式) 說明：在容器模式下，新建立的容器不會有自己的網路堆疊，而是與另一個已存在的容器共享其網路堆疊。這意味著兩個容器會共享同一個 IP 位址和埠空間。 工作原理：兩個容器共享同一個網路命名空間。 優點：適用於需要緊密協同工作的應用程式，例如主應用程式容器和一個代理或日誌收集容器。 缺點：兩個容器會共享埠，可能導致埠衝突。 使用方式：--network container:\u0026lt;name_or_id\u0026gt; 常用 Docker 網路指令 指令 說明 範例 docker network ls 列出所有 Docker 網路。 docker network ls docker network prune 刪除所有未使用的網路。 docker network prune docker network inspect \u0026lt;network_name_or_id\u0026gt; 顯示指定網路的詳細資訊，包括連接到該網路的容器。 docker network inspect bridge docker inspect \u0026lt;container_id\u0026gt; 顯示指定容器的詳細資訊，包括其網路配置。 docker inspect \u0026lt;container_id\u0026gt; 自訂網路 (User-defined Bridge Networks) 雖然 Docker 預設的 bridge 網路 (docker0) 已經足夠應付許多情況，但強烈建議您建立自訂橋接網路 (User-defined Bridge Networks)。自訂網路提供了更好的隔離性、內建的 DNS 解析和更靈活的配置。\n優點 內建 DNS 解析：在自訂網路中，容器可以透過服務名稱（而不是 IP 位址）互相通訊，因為 Docker 會為自訂網路提供內建的 DNS 解析服務。這使得容器的 IP 位址變化不再是問題。 更好的隔離性：自訂網路中的容器預設只能與同一網路中的其他容器通訊，提供了更好的安全性。 可移植性：在 Docker Compose 中，自訂網路是預設行為，這使得多容器應用程式的定義更加簡潔和可移植。 建立自訂網路 1 2 # 建立一個名為 \u0026#39;my_network\u0026#39; 的自訂橋接網路 docker network create my_network 將容器連接到自訂網路 在啟動容器時，使用 --network 參數指定自訂網路名稱：\n1 2 3 4 5 # 啟動第一個 Tomcat 容器，連接到 \u0026#39;my_network\u0026#39; docker run -d -p 8080:8080 --network my_network --name tomcat_1 tomcat # 啟動第二個 Tomcat 容器，連接到 \u0026#39;my_network\u0026#39; docker run -d -p 8081:8080 --network my_network --name tomcat_2 tomcat 現在，tomcat_1 和 tomcat_2 容器都在 my_network 中，它們可以透過彼此的容器名稱（tomcat_1 和 tomcat_2）互相通訊，例如：\n1 2 3 4 5 # 進入 tomcat_1 容器內部 docker exec -it tomcat_1 bash # 在 tomcat_1 容器內部 ping tomcat_2 ping tomcat_2 容器模式的限制與自訂網路的優勢 您原先的範例中，嘗試讓兩個 Tomcat 容器共享網路，但由於埠衝突而失敗：\n1 2 3 4 # 坑 （下面起不起來因兩台 tomcat 都用 8080 映射出去） # 借用 tomcat_1 網路 docker run -d -p 8080:8080 --name tomcat_1 tomcat docker run -d -p 8081:8080 --network container:tomcat_1 --name tomcat_2 tomcat # 會失敗，因為 tomcat_2 試圖使用 tomcat_1 的 8080 埠 這是因為在 container 模式下，兩個容器共享同一個網路命名空間，包括埠空間。如果 tomcat_1 已經佔用了 8080 埠，那麼 tomcat_2 就無法再使用這個埠。\n相比之下，使用自訂網路則沒有這個問題。每個容器在自訂網路中仍然擁有自己的獨立網路堆疊和埠空間，只是它們可以透過網路名稱互相發現和通訊。這使得自訂網路成為多容器應用程式之間通訊的更優雅和健壯的解決方案。\n透過理解和善用 Docker 網路模式，您可以更有效地設計和管理您的容器化應用程式。\n","permalink":"https://xinqilin.github.io/post/devops/docker-network/","tags":["Docker","Network","DevOps","Containerization","Bridge","Host"],"title":"Docker 網路模式詳解：容器間通訊與外部連接"},{"content":"概述 在自動化測試和網路爬蟲等場景中，經常需要將應用程式與瀏覽器自動化工具 (如 Selenium) 打包到同一個 Docker 容器中。此外，為了支援不同的運行環境（例如 ARM64 或 x86_64 架構，以及 Firefox 或 Chrome 瀏覽器），我們需要一個靈活的建構流程。\n本文將深入解析一個多階段 Dockerfile，它展示了如何：\n建構一個包含 Node.js 應用程式的基礎映像檔。 利用這個基礎映像檔，為不同的 CPU 架構和瀏覽器環境建立多個最終的 Selenium 應用程式映像檔。 透過一個通用的 entrypoint.sh 腳本，在容器啟動時自動判斷環境並執行對應的測試。 Dockerfile 詳解 這個 Dockerfile 採用了多階段建構 (Multi-stage Builds) 的方式，以確保最終映像檔的輕量化和模組化。\n第一階段：應用程式建構 (build 階段) 這個階段負責準備 Node.js 環境並打包應用程式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 FROM ubuntu:22.04 AS build # 設定環境變數 ENV NVM_DIR /opt/nvm # NVM (Node Version Manager) 的安裝目錄 ENV NODE_VERSION v16.13.2 # 指定要安裝的 Node.js 版本 ENV APP_DIR /app # 應用程式的工作目錄 # 建立必要的目錄 RUN [ -d $APP_DIR ] || mkdir -p $APP_DIR RUN [ -d $NVM_DIR ] || mkdir -p $NVM_DIR # 更新套件列表並安裝 curl (用於下載 NVM) RUN apt-get update \u0026amp;\u0026amp; apt-get install curl -y # 安裝 NVM 和指定版本的 Node.js # 從 GitHub 下載 NVM 安裝腳本 RUN curl -o $NVM_DIR/install.sh https://raw.githubusercontent.com/nvm-sh/nvm/master/install.sh # 執行 NVM 安裝腳本 RUN /bin/bash $NVM_DIR/install.sh # 設定 PATH 環境變數，將 Node.js 可執行檔加入路徑 ENV PATH $NVM_DIR/versions/node/$NODE_VERSION/bin:$PATH # 複製應用程式檔案 COPY test /app/test # 複製 \u0026#39;test\u0026#39; 目錄 COPY *.js /app/ # 複製所有 .js 檔案 COPY *.json /app/ # 複製所有 .json 檔案 COPY *.sh /app/ # 複製所有 .sh 腳本 RUN chmod 0755 /app/*.sh # 為腳本添加執行權限 # 設定工作目錄並安裝 Node.js 依賴 WORKDIR $APP_DIR RUN npm install 第二階段：Selenium 瀏覽器映像檔建構 (多個 FROM 階段) 這個 Dockerfile 為不同的 CPU 架構 (ARM64, x86_64) 和瀏覽器 (Firefox, Chrome) 定義了多個最終映像檔。每個階段都從一個預先建構好的 Selenium 映像檔開始，並將第一階段建構好的應用程式複製進來。\nARM64 架構 - Firefox 瀏覽器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 FROM seleniarm/standalone-firefox:latest AS arm64-firefox # 設定終端機和語言環境變數 ENV TERM=\u0026#34;xterm-color\u0026#34; ENV LANG=\u0026#39;en_US.UTF-8\u0026#39; ENV LANGUAGE=\u0026#39;en_US.UTF-8\u0026#39; # 重新設定 NVM 和應用程式目錄 (因為是新的 FROM 階段) ENV NVM_DIR /opt/nvm ENV NODE_VERSION v16.13.2 ENV APP_DIR /app # 建立目錄並調整權限 (使用 sudo 和 chown 是因為基礎映像檔可能以非 root 用戶運行) RUN [ -d $APP_DIR ] || (sudo mkdir -p $APP_DIR \u0026amp;\u0026amp; sudo chown `whoami`:`id -g -n` $APP_DIR) RUN [ -d $NVM_DIR ] || (sudo mkdir -p $NVM_DIR \u0026amp;\u0026amp; sudo chown `whoami`:`id -g -n` $NVM_DIR) # 從 \u0026#39;build\u0026#39; 階段複製 NVM 安裝腳本並執行 COPY --from=build $NVM_DIR/install.sh $NVM_DIR RUN /bin/bash $NVM_DIR/install.sh # 設定 PATH 環境變數 ENV PATH $NVM_DIR/versions/node/$NODE_VERSION/bin:$PATH # 從 \u0026#39;build\u0026#39; 階段複製應用程式檔案 COPY --from=build $APP_DIR $APP_DIR # 調整應用程式目錄的擁有者為 \u0026#39;seluser\u0026#39; (Selenium 映像檔的預設用戶) RUN chown seluser:seluser $APP_DIR # 設定工作目錄 WORKDIR $APP_DIR # 定義容器啟動時執行的命令 (將由 entrypoint.sh 腳本處理) CMD [ \u0026#34;/app/entrypoint.sh\u0026#34; ] ARM64 架構 - Chrome 瀏覽器 1 2 3 FROM seleniarm/standalone-chromium:latest AS arm64-chrome # ... (與 arm64-firefox 階段類似的環境變數、目錄建立、NVM 安裝、應用程式複製和權限調整) ... CMD [ \u0026#34;/app/entrypoint.sh\u0026#34; ] x86_64 架構 - Firefox 瀏覽器 1 2 3 FROM selenium/standalone-firefox:latest AS x86_64-firefox # ... (與 arm64-firefox 階段類似的環境變數、目錄建立、NVM 安裝、應用程式複製和權限調整) ... CMD [ \u0026#34;/app/entrypoint.sh\u0026#34; ] x86_64 架構 - Chrome 瀏覽器 1 2 3 FROM selenium/standalone-chrome:latest AS x86_64-chrome # ... (與 arm64-firefox 階段類似的環境變數、目錄建立、NVM 安裝、應用程式複製和權限調整) ... CMD [ \u0026#34;/app/entrypoint.sh\u0026#34; ] entrypoint.sh 腳本詳解 這個腳本是容器啟動時執行的入口點，它負責根據運行環境動態判斷要執行的 npm 腳本，並確保 Selenium 服務已啟動。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #!/bin/bash # 根據容器中存在的瀏覽器可執行檔來設定 SCRIPTS 變數 # 如果找到 firefox，則 SCRIPTS 為 \u0026#34;docker-firefox\u0026#34; [ -f /usr/bin/firefox ] \u0026amp;\u0026amp; export SCRIPTS=\u0026#34;docker-firefox\u0026#34; # 如果找到 chromium-browser 或 google-chrome，則 SCRIPTS 為 \u0026#34;docker-chrome\u0026#34; [ -f /usr/bin/chromium-browser ] \u0026amp;\u0026amp; export SCRIPTS=\u0026#34;docker-chrome\u0026#34; [ -f /usr/bin/google-chrome ] \u0026amp;\u0026amp; export SCRIPTS=\u0026#34;docker-chrome\u0026#34; # 判斷 CPU 架構 (uname -m 會回傳機器硬體名稱) uu=`uname -m` echo \u0026#39;uname -m:\u0026#39; $uu if [ \u0026#34;$uu\u0026#34; = \u0026#34;arm64\u0026#34; ] || [ \u0026#34;$uu\u0026#34; = \u0026#34;aarch64\u0026#34; ];then # 如果是 ARM64 架構，則在 SCRIPTS 後面加上 \u0026#34;-arm64\u0026#34; export SCRIPTS=\u0026#34;$SCRIPTS-arm64\u0026#34; fi # 啟動 Selenium 服務的入口點腳本 (通常由基礎映像檔提供) # 將標準輸出和標準錯誤重定向到 /dev/null，使其在背景靜默運行 /opt/bin/entry_point.sh \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; # 等待 Selenium 服務啟動 (檢查 localhost:4444 是否可訪問) for number in {1..120} # 最多等待 120 秒 do if curl -s http://localhost:4444; then # -s 靜默模式，不顯示進度或錯誤 break # 如果成功訪問，則跳出迴圈 fi echo \u0026#34;Waiting selenium service,\u0026#34; $number # 顯示等待訊息 sleep 1 # 每秒檢查一次 done # 再次檢查 Selenium 服務是否成功啟動，如果沒有則退出並報錯 if ! curl -s http://localhost:4444; then echo \u0026#34;Selenium service failed to start.\u0026#34; exit 1 fi # 進入應用程式目錄 cd /app # 執行對應的 npm 腳本 echo \u0026#34;npm run $SCRIPTS\u0026#34; npm run $SCRIPTS 最佳實踐與考量 多階段建構：此 Dockerfile 充分利用了多階段建構的優勢，將建構環境與運行環境分離，顯著減小了最終映像檔的大小，並提高了安全性。 跨平台支援：透過為不同 CPU 架構和瀏覽器建立獨立的階段，實現了單一 Dockerfile 支援多種運行環境的能力。 權限管理：在複製應用程式檔案後，使用 chown 調整檔案擁有者，確保應用程式以非 root 用戶運行，這是一個重要的安全實踐。 健壯的啟動腳本：entrypoint.sh 腳本包含了等待外部服務 (Selenium) 啟動的邏輯，這使得容器的啟動更加健壯和可靠。 環境變數：合理使用 ENV 指令來管理版本號和路徑，提高了 Dockerfile 的可維護性。 透過這個詳細的 Dockerfile 和啟動腳本，您可以高效地建構和部署跨平台的 Selenium 自動化測試應用程式。\n","permalink":"https://xinqilin.github.io/post/devops/dockerfile-docker_in_docker/","tags":["Docker","Dockerfile","Multi-stage Build","Selenium","Node.js","DevOps","Cross-platform"],"title":"多階段 Dockerfile：建構跨平台 Selenium 應用程式映像檔"},{"content":"概述 Dockerfile 是一個包含一系列指令的文字檔案，Docker 引擎會讀取這些指令，並自動建構出 Docker 映像檔 (Image)。它定義了映像檔的內容、運行環境以及啟動時執行的指令。理解 Dockerfile 是掌握 Docker 容器化技術的關鍵一步。\nDockerfile 核心指令詳解 1. 基礎指令 FROM：指定基礎映像檔。Dockerfile 的第一條指令必須是 FROM。\n語法：FROM \u0026lt;image\u0026gt;[:\u0026lt;tag\u0026gt;] 範例：FROM ubuntu:18.04 (使用 Ubuntu 18.04 作為基礎映像檔) 注意：如果未指定 tag，預設為 latest。建議明確指定版本，以確保建構的可重複性。 MAINTAINER：指定映像檔的維護者資訊。\n語法：MAINTAINER \u0026lt;name\u0026gt; [email] 範例：MAINTAINER Bill.Lin \u0026lt;zzx123bill@gmail.com\u0026gt; 注意：此指令已過時，建議使用 LABEL 指令來替代，例如 LABEL maintainer=\u0026quot;Bill.Lin \u0026lt;zzx123bill@gmail.com\u0026gt;\u0026quot;。 2. 執行指令 RUN：在建構映像檔時執行命令。每個 RUN 指令都會在映像檔中建立一個新的層 (layer)。\n語法： RUN \u0026lt;command\u0026gt; (shell 模式，預設使用 /bin/sh -c 執行) RUN [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;] (exec 模式，直接執行可執行檔) 範例 (shell 模式)： 1 2 RUN apt-get update -y \\ \u0026amp;\u0026amp; apt-get install nginx -y 注意：使用 \u0026amp;\u0026amp; 將多個命令串聯起來，可以減少映像檔層數，優化映像檔大小。 範例 (exec 模式)： 1 2 RUN [\u0026#34;./test.php\u0026#34;, \u0026#34;dev\u0026#34;, \u0026#34;offline\u0026#34;] # 等同於在容器內執行 `./test.php dev offline` CMD：設定容器啟動時預設執行的命令。如果 docker run 命令後帶有參數，CMD 的命令會被覆蓋。一個 Dockerfile 中只能有一個 CMD，多個 CMD 只有最後一個生效。\n語法： CMD [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;] (exec 模式，推薦) CMD [\u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;] (作為 ENTRYPOINT 的預設參數) CMD command param1 param2 (shell 模式) 範例：CMD [\u0026quot;nginx\u0026quot;, \u0026quot;-g\u0026quot;, \u0026quot;daemon off;\u0026quot;] (啟動 Nginx 並保持在前台運行) 注意：CMD 會被 docker run \u0026lt;image\u0026gt; \u0026lt;command\u0026gt; 中的 \u0026lt;command\u0026gt; 覆蓋。 ENTRYPOINT：設定容器啟動時執行的命令。ENTRYPOINT 不會被 docker run 後的參數覆蓋，而是將這些參數作為 ENTRYPOINT 命令的參數。\n語法：ENTRYPOINT [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;] (exec 模式，推薦) 範例：ENTRYPOINT [\u0026quot;docker-entrypoint.sh\u0026quot;] CMD 與 ENTRYPOINT 組合使用： 當 ENTRYPOINT 和 CMD 都使用 exec 模式時，CMD 的內容會作為 ENTRYPOINT 的參數。 1 2 3 4 FROM nginx ENTRYPOINT [\u0026#34;nginx\u0026#34;, \u0026#34;-c\u0026#34;] CMD [\u0026#34;/etc/nginx/nginx.conf\u0026#34;] # 容器啟動時實際執行：nginx -c /etc/nginx/nginx.conf 這種組合常用於設定固定的啟動命令，同時允許使用者透過 CMD 或 docker run 參數來提供預設或自訂的參數。 3. 環境設定 WORKDIR：設定工作目錄。後續的 RUN, CMD, ENTRYPOINT, COPY, ADD 指令都會在這個目錄下執行。\n語法：WORKDIR /path/to/workdir 範例： 1 2 WORKDIR /app COPY . /app # 將建構上下文中的檔案複製到容器的 /app 目錄 USER：指定運行容器時的用戶或用戶組。\n語法：USER \u0026lt;user\u0026gt;[:\u0026lt;group\u0026gt;] 範例：USER nobody (以非 root 用戶運行，提高安全性) 注意：預設為 root。在生產環境中，建議使用非 root 用戶運行應用程式。 VOLUME：建立一個掛載點，將容器內的路徑標記為外部掛載點，用於持久化資料或共享資料。\n語法：VOLUME [\u0026quot;/data\u0026quot;] 範例：VOLUME /var/lib/mysql (將 MySQL 資料目錄標記為儲存卷) ARG：定義建構時的變數。這些變數只在 docker build 過程中有效，不會保留在最終的映像檔中。\n語法：ARG \u0026lt;name\u0026gt;[=\u0026lt;default value\u0026gt;] 範例： 1 2 ARG VERSION=1.0 FROM myapp:${VERSION} 使用：docker build --build-arg VERSION=2.0 . ENV：設定環境變數。這些變數會保留在最終的映像檔中，並在容器運行時可用。\n語法：ENV \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; ... 範例： 1 2 ENV MY_PATH /usr/local WORKDIR $MY_PATH # WORKDIR 可以使用 ENV 定義的變數 EXPOSE：聲明容器運行時監聽的埠。這只是一個文件說明，並不會實際發布埠。要發布埠，需要在 docker run 或 docker-compose.yml 中使用 -p 或 ports。\n語法：EXPOSE \u0026lt;port\u0026gt; [\u0026lt;port\u0026gt;...] 範例：EXPOSE 8080 (聲明容器會監聽 8080 埠) 4. 檔案操作 COPY：將建構上下文中的檔案或目錄複製到映像檔中。\n語法：COPY \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt; 範例：COPY ./target/mms.war /app/mms.war (將主機 target 目錄下的 mms.war 複製到容器的 /app 目錄) 注意：COPY 只能複製本地建構上下文中的檔案。 ADD：與 COPY 類似，但 ADD 具有額外的功能：\n如果 \u0026lt;src\u0026gt; 是一個壓縮檔 (如 .tar, .gz, .zip)，它會自動解壓縮到 \u0026lt;dest\u0026gt;。 如果 \u0026lt;src\u0026gt; 是一個 URL，它會從該 URL 下載檔案。 語法：ADD \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt; 範例：ADD https://example.com/app.tar.gz /app/ 注意：由於 ADD 的自動解壓縮和 URL 下載功能可能導致不確定性，通常建議優先使用 COPY，除非您明確需要 ADD 的特殊功能。 Docker Build 流程 使用 docker build 命令來建構 Docker 映像檔。\n語法：docker build [OPTIONS] PATH | URL | - 範例：docker build -t my-app:1.0 . -t my-app:1.0：為映像檔指定名稱和標籤。 .：指定建構上下文的路徑。Docker 會將此路徑下的所有檔案發送到 Docker Daemon，作為建構過程的上下文。 範例：Java Spring Boot 應用程式的多階段建構 多階段建構 (Multi-stage Builds) 允許您在一個 Dockerfile 中使用多個 FROM 指令。每個 FROM 指令都可以使用不同的基礎映像檔，並且每個階段都可以獨立地建構。最終的映像檔只包含您需要的最終產物，大大減少了映像檔的大小。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # --- 第一階段：建構應用程式 --- # 使用一個包含 Java 開發工具包 (JDK) 的映像檔來編譯和打包應用程式 FROM openjdk:11-jdk-slim AS build # 設定工作目錄 WORKDIR /app # 將 Maven 的設定檔複製到容器中 (如果有的話) # COPY settings.xml /root/.m2/ # 將專案的 pom.xml 複製到容器中，並下載依賴，利用 Docker 層快取 COPY pom.xml . RUN mvn dependency:go-offline # 將所有原始碼複製到容器中 COPY src ./src # 編譯並打包應用程式，生成 JAR 檔案 RUN mvn clean package -DskipTests # --- 第二階段：運行應用程式 --- # 使用一個輕量級的 Java 運行環境 (JRE) 映像檔來運行應用程式 FROM openjdk:11-jre-slim # 設定環境變數，指定應用程式的 JAR 檔案路徑 ENV APP_HOME=/app # 設定工作目錄 WORKDIR $APP_HOME # 從第一階段複製編譯好的 JAR 檔案 COPY --from=build /app/target/*.jar app.jar # 暴露應用程式監聽的埠 EXPOSE 8080 # 定義容器啟動時執行的命令 ENTRYPOINT [\u0026#34;java\u0026#34;, \u0026#34;-jar\u0026#34;, \u0026#34;app.jar\u0026#34;] 這個範例展示了如何使用多階段建構來：\n在第一個階段 (build) 中編譯 Java 應用程式，生成一個 JAR 檔案。 在第二個階段中，只複製最終的 JAR 檔案到一個更小的 JRE 基礎映像檔中。 這樣可以避免將編譯工具、原始碼等不必要的內容包含在最終的運行映像檔中，從而顯著減小映像檔大小，提高安全性和部署效率。\n透過熟練掌握 Dockerfile 的各項指令和最佳實踐，您可以更有效地建構和管理您的 Docker 映像檔。\n","permalink":"https://xinqilin.github.io/post/devops/dockerfile-basic/","tags":["Docker","Dockerfile","DevOps","Containerization","Image Build"],"title":"Dockerfile 基礎：建構 Docker 映像檔的核心指令"},{"content":"Instance Level Dependency 依賴 Association 關聯 Aggregation 聚合 Composition 組合 Class Level Implementation 實作 Inheritance 繼承 Dependency 1 2 3 4 虛線，箭頭指向 被使用者 A ---\u0026gt; B Association 1 2 3 4 實線，箭頭指向 被擁有者 ， 可在箭頭上增加 1-many 1-1 關西 A -\u0026gt; B Aggregation 1 2 3 4 5 6 7 8 空心菱形屁股箭頭，箭頭指向 整體 A \u0026lt;\u0026gt;-\u0026gt; B \u0026lt;\u0026gt;-\u0026gt; C 要有A 必須要有B，C Composition 1 2 實心菱形屁股箭頭，箭頭指向 整體 to be continued\u0026hellip;.\n","permalink":"https://xinqilin.github.io/post/architecture/uml/","tags":[],"title":"UML"},{"content":"概述 Spring Framework 的核心特性之一是依賴注入（Dependency Injection, DI），它實現了控制反轉（Inversion of Control, IoC）的設計模式。正確使用依賴注入不僅能提升程式碼的可測試性和可維護性，還能降低組件間的耦合度。本文將深入探討 Spring 中各種依賴注入方式，並重點說明最佳實踐。\n為什麼不建議使用 @Autowired Field Injection？ 當你在 IntelliJ IDEA 中使用 @Autowired 進行欄位注入時，會看到這樣的警告：\n1 2 3 4 Field injection is not recommended Inspection info: Spring Team recommends: \u0026#34;Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies\u0026#34;. 這個警告背後有深刻的技術理由，讓我們逐一分析。\nSpring 依賴注入的三種方式 1. Field Injection（不建議） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Service public class OrderService { @Autowired private PaymentService paymentService; // ❌ 不建議 @Autowired private InventoryService inventoryService; // ❌ 不建議 @Autowired private EmailService emailService; // ❌ 不建議 public void processOrder(Order order) { paymentService.processPayment(order); inventoryService.updateStock(order); emailService.sendConfirmation(order); } } Field Injection 的問題：\n問題 1：違反單一職責原則 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Service public class UserService { @Autowired private UserRepository userRepository; @Autowired private EmailService emailService; @Autowired private SmsService smsService; @Autowired private AuditService auditService; @Autowired private CacheService cacheService; @Autowired private ValidationService validationService; @Autowired private SecurityService securityService; @Autowired private LoggingService loggingService; @Autowired private MetricsService metricsService; @Autowired private ConfigurationService configurationService; // ... 還有更多依賴 // 當你看到這麼多依賴時，應該重新思考這個類別的職責 } 問題 2：無法進行單元測試 1 2 3 4 5 6 7 8 9 10 11 public class OrderServiceTest { @Test public void testProcessOrder() { // ❌ 無法輕易創建 OrderService 實例進行測試 OrderService orderService = new OrderService(); // PaymentService 為 null! Order order = new Order(); orderService.processOrder(order); // NullPointerException! } } 問題 3：隱藏的依賴關係 1 2 3 4 // 從這個建構子看不出這個類別需要什麼依賴 public class OrderService { // 依賴隱藏在類別內部，外部無法得知 } 問題 4：循環依賴不易發現 1 2 3 4 5 6 7 8 9 10 11 @Service public class ServiceA { @Autowired private ServiceB serviceB; // 循環依賴在運行時才會發現 } @Service public class ServiceB { @Autowired private ServiceA serviceA; // 循環依賴在運行時才會發現 } 2. Setter Injection（條件性建議） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Service public class OrderService { private PaymentService paymentService; private EmailService emailService; @Autowired public void setPaymentService(PaymentService paymentService) { this.paymentService = paymentService; } @Autowired public void setEmailService(EmailService emailService) { this.emailService = emailService; } public void processOrder(Order order) { if (paymentService != null) { paymentService.processPayment(order); } if (emailService != null) { emailService.sendConfirmation(order); } } } Setter Injection 適用場景：\n可選依賴（Optional Dependencies） 循環依賴的暫時解決方案 需要在運行時重新配置依賴 3. Constructor Injection（強烈建議） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Service public class OrderService { private final PaymentService paymentService; private final InventoryService inventoryService; private final EmailService emailService; // ✅ 推薦：Constructor Injection public OrderService(PaymentService paymentService, InventoryService inventoryService, EmailService emailService) { this.paymentService = Objects.requireNonNull(paymentService, \u0026#34;PaymentService cannot be null\u0026#34;); this.inventoryService = Objects.requireNonNull(inventoryService, \u0026#34;InventoryService cannot be null\u0026#34;); this.emailService = Objects.requireNonNull(emailService, \u0026#34;EmailService cannot be null\u0026#34;); } public void processOrder(Order order) { paymentService.processPayment(order); inventoryService.updateStock(order); emailService.sendConfirmation(order); } } Constructor Injection 的優勢 1. 不可變性（Immutability） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Service public class OrderService { // ✅ final 關鍵字確保依賴不會被修改 private final PaymentService paymentService; private final InventoryService inventoryService; public OrderService(PaymentService paymentService, InventoryService inventoryService) { this.paymentService = paymentService; this.inventoryService = inventoryService; } // 無法意外修改依賴關係 } 2. 強制依賴檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Service public class OrderService { private final PaymentService paymentService; public OrderService(PaymentService paymentService) { // ✅ 在物件創建時就確保依賴存在 this.paymentService = Objects.requireNonNull(paymentService, \u0026#34;PaymentService is required for OrderService\u0026#34;); } public void processOrder(Order order) { // ✅ 保證 paymentService 不為 null paymentService.processPayment(order); } } 3. 易於單元測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @ExtendWith(MockitoExtension.class) class OrderServiceTest { @Mock private PaymentService paymentService; @Mock private InventoryService inventoryService; @Mock private EmailService emailService; private OrderService orderService; @BeforeEach void setUp() { // ✅ 易於創建測試實例 orderService = new OrderService(paymentService, inventoryService, emailService); } @Test void testProcessOrder() { // Given Order order = new Order(); when(paymentService.processPayment(order)).thenReturn(true); // When orderService.processOrder(order); // Then verify(paymentService).processPayment(order); verify(inventoryService).updateStock(order); verify(emailService).sendConfirmation(order); } } 4. 明確的依賴關係 1 2 3 4 5 6 7 8 9 10 11 // ✅ 從建構子就能清楚看到所有依賴 public class OrderService { public OrderService(PaymentService paymentService, InventoryService inventoryService, EmailService emailService, AuditService auditService) { // 如果建構子參數太多，說明這個類別承擔了太多職責 // 這是一個程式碼異味（Code Smell），提醒我們重構 } } 使用 Lombok 簡化 Constructor Injection 基本用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Service @RequiredArgsConstructor // ✅ Lombok 自動生成建構子 public class OrderService { private final PaymentService paymentService; private final InventoryService inventoryService; private final EmailService emailService; // Lombok 自動生成： // public OrderService(PaymentService paymentService, // InventoryService inventoryService, // EmailService emailService) { // this.paymentService = paymentService; // this.inventoryService = inventoryService; // this.emailService = emailService; // } public void processOrder(Order order) { paymentService.processPayment(order); inventoryService.updateStock(order); emailService.sendConfirmation(order); } } 混合必要和可選依賴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Service @RequiredArgsConstructor public class NotificationService { // 必要依賴（final） private final EmailService emailService; private final SmsService smsService; // 可選依賴（non-final） private PushNotificationService pushService; private SlackService slackService; @Autowired(required = false) public void setPushNotificationService(PushNotificationService pushService) { this.pushService = pushService; } @Autowired(required = false) public void setSlackService(SlackService slackService) { this.slackService = slackService; } public void sendNotification(String message, User user) { // 必要服務 emailService.send(message, user.getEmail()); smsService.send(message, user.getPhone()); // 可選服務 if (pushService != null) { pushService.send(message, user.getDeviceToken()); } if (slackService != null) { slackService.send(message, user.getSlackChannel()); } } } 進階依賴注入技巧 1. 條件性依賴注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Configuration public class ServiceConfiguration { @Bean @ConditionalOnProperty(name = \u0026#34;payment.provider\u0026#34;, havingValue = \u0026#34;stripe\u0026#34;) public PaymentService stripePaymentService() { return new StripePaymentService(); } @Bean @ConditionalOnProperty(name = \u0026#34;payment.provider\u0026#34;, havingValue = \u0026#34;paypal\u0026#34;) public PaymentService paypalPaymentService() { return new PaypalPaymentService(); } @Bean @ConditionalOnMissingBean(PaymentService.class) public PaymentService defaultPaymentService() { return new DefaultPaymentService(); } } 2. 集合注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Service @RequiredArgsConstructor public class NotificationService { // ✅ 注入所有 NotificationProvider 實作 private final List\u0026lt;NotificationProvider\u0026gt; providers; public void sendNotification(String message, User user) { providers.forEach(provider -\u0026gt; { try { provider.send(message, user); } catch (Exception e) { log.warn(\u0026#34;Failed to send notification via {}: {}\u0026#34;, provider.getClass().getSimpleName(), e.getMessage()); } }); } } // 不同的通知提供者 @Component public class EmailNotificationProvider implements NotificationProvider { public void send(String message, User user) { // 發送郵件 } } @Component public class SmsNotificationProvider implements NotificationProvider { public void send(String message, User user) { // 發送簡訊 } } 3. 限定符注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 使用 @Qualifier 區分相同類型的 Bean @Service @RequiredArgsConstructor public class OrderService { @Qualifier(\u0026#34;primary\u0026#34;) private final PaymentService primaryPaymentService; @Qualifier(\u0026#34;backup\u0026#34;) private final PaymentService backupPaymentService; public void processPayment(Order order) { try { primaryPaymentService.processPayment(order); } catch (PaymentException e) { log.warn(\u0026#34;Primary payment failed, trying backup: {}\u0026#34;, e.getMessage()); backupPaymentService.processPayment(order); } } } @Configuration public class PaymentConfiguration { @Bean @Qualifier(\u0026#34;primary\u0026#34;) public PaymentService primaryPaymentService() { return new StripePaymentService(); } @Bean @Qualifier(\u0026#34;backup\u0026#34;) public PaymentService backupPaymentService() { return new PaypalPaymentService(); } } 4. Profile 相關注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Configuration public class DatabaseConfiguration { @Bean @Profile(\u0026#34;dev\u0026#34;) public DataSource devDataSource() { return new H2DataSource(); } @Bean @Profile(\u0026#34;prod\u0026#34;) public DataSource prodDataSource() { return new MySQLDataSource(); } @Bean @Profile(\u0026#34;test\u0026#34;) public DataSource testDataSource() { return new TestContainerDataSource(); } } 常見陷阱與解決方案 1. 循環依賴問題 問題示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class OrderService { private final CustomerService customerService; public OrderService(CustomerService customerService) { this.customerService = customerService; } } @Service public class CustomerService { private final OrderService orderService; // ❌ 循環依賴 public CustomerService(OrderService orderService) { this.orderService = orderService; } } 解決方案 1：重新設計架構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // ✅ 引入共享服務，避免循環依賴 @Service @RequiredArgsConstructor public class OrderService { private final CustomerRepository customerRepository; private final OrderRepository orderRepository; private final OrderValidationService validationService; } @Service @RequiredArgsConstructor public class CustomerService { private final CustomerRepository customerRepository; private final OrderRepository orderRepository; } @Service @RequiredArgsConstructor public class OrderValidationService { private final CustomerRepository customerRepository; private final PaymentService paymentService; } 解決方案 2：使用事件驅動架構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Service @RequiredArgsConstructor public class OrderService { private final ApplicationEventPublisher eventPublisher; private final OrderRepository orderRepository; public void createOrder(Order order) { order = orderRepository.save(order); // ✅ 發布事件而非直接調用 eventPublisher.publishEvent(new OrderCreatedEvent(order)); } } @Service @RequiredArgsConstructor @EventListener public class CustomerService { private final CustomerRepository customerRepository; @EventListener public void handleOrderCreated(OrderCreatedEvent event) { // 處理訂單創建事件 updateCustomerOrderCount(event.getOrder().getCustomerId()); } } 2. 建構子參數過多 問題識別： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class UserService { // ❌ 建構子參數過多，違反 SRP 原則 public UserService(UserRepository userRepository, EmailService emailService, SmsService smsService, AuditService auditService, CacheService cacheService, ValidationService validationService, SecurityService securityService, NotificationService notificationService, PaymentService paymentService, ReportService reportService) { // 太多依賴！ } } 解決方案：拆分服務 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // ✅ 拆分為多個專門的服務 @Service @RequiredArgsConstructor public class UserService { private final UserRepository userRepository; private final UserValidationService validationService; private final UserSecurityService securityService; } @Service @RequiredArgsConstructor public class UserNotificationService { private final EmailService emailService; private final SmsService smsService; private final NotificationService notificationService; } @Service @RequiredArgsConstructor public class UserBillingService { private final PaymentService paymentService; private final BillingRepository billingRepository; } 3. 可選依賴處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Service @RequiredArgsConstructor public class UserService { private final UserRepository userRepository; private final EmailService emailService; // ✅ 可選依賴使用 Optional private final Optional\u0026lt;SmsService\u0026gt; smsService; public void createUser(User user) { user = userRepository.save(user); // 必要服務 emailService.sendWelcomeEmail(user); // 可選服務 smsService.ifPresent(service -\u0026gt; service.sendWelcomeSms(user.getPhone()) ); } } @Configuration public class ServiceConfiguration { @Bean @ConditionalOnProperty(name = \u0026#34;sms.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public SmsService smsService() { return new TwilioSmsService(); } } 效能考量 1. 延遲初始化 1 2 3 4 5 6 7 8 9 10 11 12 @Service @Lazy // ✅ 延遲初始化，減少啟動時間 @RequiredArgsConstructor public class ReportService { private final DataAnalysisService dataAnalysisService; private final ChartGenerationService chartService; public Report generateReport(String type) { // 只有在實際使用時才會初始化 return dataAnalysisService.analyze(type); } } 2. 原型 Bean 的注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Service @RequiredArgsConstructor public class OrderProcessorService { private final ApplicationContext applicationContext; public void processOrder(Order order) { // ✅ 每次都創建新的處理器實例 OrderProcessor processor = applicationContext.getBean(OrderProcessor.class); processor.process(order); } } @Component @Scope(\u0026#34;prototype\u0026#34;) // 原型範圍 public class OrderProcessor { public void process(Order order) { // 處理邏輯 } } 3. Provider 模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Service @RequiredArgsConstructor public class OrderService { // ✅ 使用 Provider 延遲獲取 Bean private final Provider\u0026lt;ExpensiveService\u0026gt; expensiveServiceProvider; public void processSpecialOrder(Order order) { if (order.isSpecial()) { // 只有在需要時才獲取昂貴的服務 ExpensiveService service = expensiveServiceProvider.get(); service.processSpecialOrder(order); } } } 測試最佳實踐 1. 使用 Constructor Injection 的測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @ExtendWith(MockitoExtension.class) class OrderServiceTest { @Mock private PaymentService paymentService; @Mock private InventoryService inventoryService; @Mock private EmailService emailService; private OrderService orderService; @BeforeEach void setUp() { // ✅ 清晰的測試設置 orderService = new OrderService(paymentService, inventoryService, emailService); } @Test void shouldProcessOrderSuccessfully() { // Given Order order = TestDataBuilder.createOrder(); when(paymentService.processPayment(order)).thenReturn(PaymentResult.success()); // When OrderResult result = orderService.processOrder(order); // Then assertThat(result.isSuccessful()).isTrue(); verify(paymentService).processPayment(order); verify(inventoryService).updateStock(order); verify(emailService).sendConfirmation(order); } @Test void shouldHandlePaymentFailure() { // Given Order order = TestDataBuilder.createOrder(); when(paymentService.processPayment(order)) .thenThrow(new PaymentException(\u0026#34;Payment failed\u0026#34;)); // When \u0026amp; Then assertThatThrownBy(() -\u0026gt; orderService.processOrder(order)) .isInstanceOf(OrderProcessingException.class) .hasMessageContaining(\u0026#34;Payment failed\u0026#34;); verify(inventoryService, never()).updateStock(order); verify(emailService, never()).sendConfirmation(order); } } 2. Integration Testing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @SpringBootTest @TestPropertySource(properties = { \u0026#34;spring.datasource.url=jdbc:h2:mem:testdb\u0026#34;, \u0026#34;payment.provider=mock\u0026#34; }) class OrderServiceIntegrationTest { @Autowired private OrderService orderService; @MockBean // ✅ Spring Boot 的 Mock 支援 private EmailService emailService; @Test void shouldProcessOrderEndToEnd() { // Given Order order = TestDataBuilder.createOrder(); // When OrderResult result = orderService.processOrder(order); // Then assertThat(result.isSuccessful()).isTrue(); verify(emailService).sendConfirmation(order); } } Spring Boot 中的依賴注入 1. 自動配置與依賴注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @SpringBootApplication public class ECommerceApplication { public static void main(String[] args) { SpringApplication.run(ECommerceApplication.class, args); } } // ✅ Spring Boot 自動配置 + Constructor Injection @RestController @RequiredArgsConstructor @RequestMapping(\u0026#34;/api/orders\u0026#34;) public class OrderController { private final OrderService orderService; private final OrderMapper orderMapper; @PostMapping public ResponseEntity\u0026lt;OrderDto\u0026gt; createOrder(@RequestBody CreateOrderRequest request) { Order order = orderMapper.toEntity(request); Order savedOrder = orderService.createOrder(order); OrderDto dto = orderMapper.toDto(savedOrder); return ResponseEntity.ok(dto); } } 2. Configuration Properties 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @ConfigurationProperties(prefix = \u0026#34;app.order\u0026#34;) @ConstructorBinding // ✅ 不可變配置類 @RequiredArgsConstructor @Getter public class OrderProperties { private final Duration timeout; private final int maxRetries; private final boolean enableNotifications; private final PaymentConfig payment; @RequiredArgsConstructor @Getter public static class PaymentConfig { private final String provider; private final Duration timeout; private final boolean enableRetry; } } // 使用配置 @Service @RequiredArgsConstructor public class OrderService { private final OrderProperties properties; private final PaymentService paymentService; public void processOrder(Order order) { try { paymentService.processPayment(order, properties.getPayment().getTimeout()); } catch (PaymentException e) { if (properties.getPayment().isEnableRetry()) { retryPayment(order); } } } } 監控與偵錯 1. Bean 依賴關係檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Component @RequiredArgsConstructor public class DependencyHealthIndicator implements HealthIndicator { private final List\u0026lt;HealthCheckable\u0026gt; healthCheckableServices; @Override public Health health() { Health.Builder builder = Health.up(); for (HealthCheckable service : healthCheckableServices) { try { service.checkHealth(); builder.withDetail(service.getClass().getSimpleName(), \u0026#34;UP\u0026#34;); } catch (Exception e) { builder.withDetail(service.getClass().getSimpleName(), \u0026#34;DOWN: \u0026#34; + e.getMessage()); builder.down(); } } return builder.build(); } } 2. 依賴注入除錯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @EventListener @Component @Slf4j public class ApplicationStartupListener { @EventListener public void handleContextRefresh(ContextRefreshedEvent event) { ApplicationContext context = event.getApplicationContext(); log.info(\u0026#34;=== Spring Context Loaded ===\u0026#34;); log.info(\u0026#34;Total beans: {}\u0026#34;, context.getBeanDefinitionCount()); // 列出所有 Bean String[] beanNames = context.getBeanDefinitionNames(); for (String beanName : beanNames) { Object bean = context.getBean(beanName); log.debug(\u0026#34;Bean: {} -\u0026gt; {}\u0026#34;, beanName, bean.getClass().getName()); } } } 總結 依賴注入方式比較 注入方式 推薦度 優點 缺點 適用場景 Constructor ⭐⭐⭐⭐⭐ 不可變、強制檢查、易測試 建構子可能變長 預設選擇 Setter ⭐⭐⭐ 靈活、支援可選依賴 可變、晚期檢查 可選依賴、循環依賴 Field ⭐ 簡潔 難測試、隱藏依賴、可變 避免使用 最佳實踐總結 優先使用 Constructor Injection：確保依賴的不可變性和強制檢查 使用 Lombok @RequiredArgsConstructor：減少模板程式碼 限制建構子參數數量：超過 5 個參數考慮重構 使用 final 關鍵字：確保依賴不會被意外修改 適當使用 @Qualifier：區分相同類型的 Bean 考慮可選依賴：使用 Optional 或 Setter Injection 避免循環依賴：重新設計架構或使用事件驅動 編寫完整的測試：利用 Constructor Injection 的可測試性 遷移策略 如果你的專案目前大量使用 Field Injection，可以採用漸進式遷移：\n新程式碼：立即採用 Constructor Injection 現有程式碼：在修改時逐步重構 關鍵服務：優先重構核心業務邏輯 工具支援：使用 IDE 的自動重構功能 正確的依賴注入不僅是技術最佳實踐，更是建立可維護、可測試、高品質軟體的基礎。\n參考資料 Spring Framework Reference Documentation Spring Boot Reference Guide Effective Java by Joshua Bloch Clean Code by Robert Martin Spring in Action by Craig Walls ","permalink":"https://xinqilin.github.io/post/backend/@autowired/","tags":["Java","Spring","DI","IoC","Autowired","Constructor","Best-Practices"],"title":"Spring 依賴注入完整指南：@Autowired 與最佳實踐"},{"content":"概述 SOLID 是物件導向程式設計和軟體架構設計中五個核心設計原則的縮寫，由 Robert C. Martin（Uncle Bob）在 21 世紀初期提出。這些原則旨在讓軟體設計更加容易理解、靈活且可維護。\nSOLID 原則不僅適用於物件導向程式設計，也是現代軟體架構的基石，從微服務設計到 Clean Architecture 都深受其影響。\nSOLID 原則概覽 首字母 英文原則名稱 中文名稱 核心概念 S Single Responsibility Principle 單一職責原則 一個類別應該只有一個改變的理由 O Open/Closed Principle 開閉原則 對擴展開放，對修改封閉 L Liskov Substitution Principle 里氏替換原則 子類別應該能完全替換父類別 I Interface Segregation Principle 介面隔離原則 客戶端不應該依賴它不需要的介面 D Dependency Inversion Principle 依賴反轉原則 依賴於抽象而非具體實作 1. Single Responsibility Principle (SRP) - 單一職責原則 定義 一個類別應該只有一個引起它變化的原因\n核心概念 高內聚性：類別內部的方法和屬性應該為同一個目標服務 低耦合性：減少類別之間的依賴關係 明確責任：每個類別都應該有明確且單一的職責 違反 SRP 的範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // ❌ 違反 SRP：一個類別承擔多種職責 public class User { private String name; private String email; // 用戶資料驗證職責 public boolean validateEmail(String email) { return email.contains(\u0026#34;@\u0026#34;) \u0026amp;\u0026amp; email.contains(\u0026#34;.\u0026#34;); } // 用戶持久化職責 public void saveToDatabase() { // 資料庫存儲邏輯 System.out.println(\u0026#34;儲存用戶到資料庫\u0026#34;); } // 用戶通知職責 public void sendWelcomeEmail() { // 郵件發送邏輯 System.out.println(\u0026#34;發送歡迎郵件\u0026#34;); } // 用戶報表職責 public String generateUserReport() { return \u0026#34;用戶報表: \u0026#34; + name + \u0026#34; - \u0026#34; + email; } } 遵循 SRP 的重構範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 // ✅ 遵循 SRP：職責分離 // 1. 用戶實體類別（僅負責用戶資料） public class User { private String name; private String email; public User(String name, String email) { this.name = name; this.email = email; } // Getter and Setter methods public String getName() { return name; } public String getEmail() { return email; } public void setName(String name) { this.name = name; } public void setEmail(String email) { this.email = email; } } // 2. 用戶驗證服務（僅負責驗證邏輯） @Service public class UserValidator { public boolean validateEmail(String email) { return email != null \u0026amp;\u0026amp; email.contains(\u0026#34;@\u0026#34;) \u0026amp;\u0026amp; email.contains(\u0026#34;.\u0026#34;) \u0026amp;\u0026amp; email.length() \u0026gt; 5; } public boolean validateName(String name) { return name != null \u0026amp;\u0026amp; name.trim().length() \u0026gt; 0 \u0026amp;\u0026amp; name.length() \u0026lt;= 50; } public ValidationResult validateUser(User user) { ValidationResult result = new ValidationResult(); if (!validateName(user.getName())) { result.addError(\u0026#34;用戶名格式無效\u0026#34;); } if (!validateEmail(user.getEmail())) { result.addError(\u0026#34;郵箱格式無效\u0026#34;); } return result; } } // 3. 用戶持久化服務（僅負責資料存取） @Repository public class UserRepository { public void save(User user) { // 資料庫存儲邏輯 System.out.println(\u0026#34;儲存用戶到資料庫: \u0026#34; + user.getName()); } public User findByEmail(String email) { // 查詢邏輯 return new User(\u0026#34;找到的用戶\u0026#34;, email); } public List\u0026lt;User\u0026gt; findAll() { // 查詢所有用戶 return Arrays.asList(new User(\u0026#34;用戶1\u0026#34;, \u0026#34;user1@example.com\u0026#34;)); } } // 4. 用戶通知服務（僅負責通知邏輯） @Service public class UserNotificationService { public void sendWelcomeEmail(User user) { System.out.println(\u0026#34;發送歡迎郵件給: \u0026#34; + user.getEmail()); } public void sendPasswordResetEmail(User user) { System.out.println(\u0026#34;發送密碼重設郵件給: \u0026#34; + user.getEmail()); } public void sendAccountActivationEmail(User user) { System.out.println(\u0026#34;發送帳戶啟用郵件給: \u0026#34; + user.getEmail()); } } // 5. 用戶報表服務（僅負責報表生成） @Service public class UserReportService { public String generateUserReport(User user) { return String.format(\u0026#34;用戶報表\\n姓名: %s\\n郵箱: %s\\n生成時間: %s\u0026#34;, user.getName(), user.getEmail(), LocalDateTime.now()); } public String generateUsersListReport(List\u0026lt;User\u0026gt; users) { StringBuilder report = new StringBuilder(\u0026#34;用戶列表報表\\n\u0026#34;); users.forEach(user -\u0026gt; report.append(String.format(\u0026#34;- %s (%s)\\n\u0026#34;, user.getName(), user.getEmail())) ); return report.toString(); } } // 6. 用戶服務協調器（組合各種服務） @Service public class UserService { private final UserValidator userValidator; private final UserRepository userRepository; private final UserNotificationService notificationService; public UserService(UserValidator userValidator, UserRepository userRepository, UserNotificationService notificationService) { this.userValidator = userValidator; this.userRepository = userRepository; this.notificationService = notificationService; } public Result\u0026lt;User\u0026gt; createUser(String name, String email) { User user = new User(name, email); // 驗證用戶資料 ValidationResult validation = userValidator.validateUser(user); if (!validation.isValid()) { return Result.failure(\u0026#34;驗證失敗: \u0026#34; + validation.getErrors()); } // 儲存用戶 userRepository.save(user); // 發送歡迎郵件 notificationService.sendWelcomeEmail(user); return Result.success(user); } } SRP 的好處 降低複雜度：每個類別的責任明確，易於理解 提高可讀性：程式碼結構清晰，功能劃分明確 增強可維護性：修改某個功能時，只需要關注特定的類別 提升可測試性：職責單一的類別更容易進行單元測試 促進重用性：功能獨立的類別可以在不同場景中重複使用 2. Open/Closed Principle (OCP) - 開閉原則 定義 軟體實體（類別、模組、函數等）應該對擴展開放，對修改封閉\n核心概念 對擴展開放：可以透過新增程式碼來擴展功能 對修改封閉：不應該修改現有的程式碼 策略模式：透過抽象介面實現不同的實作策略 違反 OCP 的範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // ❌ 違反 OCP：每次新增形狀都需要修改計算器類別 public class AreaCalculator { public double calculateArea(Object shape) { if (shape instanceof Rectangle) { Rectangle rectangle = (Rectangle) shape; return rectangle.getWidth() * rectangle.getHeight(); } else if (shape instanceof Circle) { Circle circle = (Circle) shape; return Math.PI * circle.getRadius() * circle.getRadius(); } else if (shape instanceof Triangle) { // 新增三角形需要修改此方法 Triangle triangle = (Triangle) shape; return 0.5 * triangle.getBase() * triangle.getHeight(); } // 每次新增新形狀都需要修改這裡 throw new IllegalArgumentException(\u0026#34;不支援的形狀類型\u0026#34;); } } 遵循 OCP 的重構範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 // ✅ 遵循 OCP：定義抽象介面 public interface Shape { double calculateArea(); String getShapeType(); } // 具體實作 - 矩形 public class Rectangle implements Shape { private double width; private double height; public Rectangle(double width, double height) { this.width = width; this.height = height; } @Override public double calculateArea() { return width * height; } @Override public String getShapeType() { return \u0026#34;矩形\u0026#34;; } // Getter methods public double getWidth() { return width; } public double getHeight() { return height; } } // 具體實作 - 圓形 public class Circle implements Shape { private double radius; public Circle(double radius) { this.radius = radius; } @Override public double calculateArea() { return Math.PI * radius * radius; } @Override public String getShapeType() { return \u0026#34;圓形\u0026#34;; } public double getRadius() { return radius; } } // 具體實作 - 三角形（新增時無需修改現有程式碼） public class Triangle implements Shape { private double base; private double height; public Triangle(double base, double height) { this.base = base; this.height = height; } @Override public double calculateArea() { return 0.5 * base * height; } @Override public String getShapeType() { return \u0026#34;三角形\u0026#34;; } public double getBase() { return base; } public double getHeight() { return height; } } // 新增多邊形（無需修改現有程式碼） public class Polygon implements Shape { private List\u0026lt;Point\u0026gt; vertices; public Polygon(List\u0026lt;Point\u0026gt; vertices) { this.vertices = vertices; } @Override public double calculateArea() { // 使用鞋帶公式計算多邊形面積 double area = 0; int n = vertices.size(); for (int i = 0; i \u0026lt; n; i++) { int j = (i + 1) % n; area += vertices.get(i).getX() * vertices.get(j).getY(); area -= vertices.get(j).getX() * vertices.get(i).getY(); } return Math.abs(area) / 2.0; } @Override public String getShapeType() { return \u0026#34;多邊形\u0026#34;; } } // 面積計算器（無需修改，支援所有 Shape 實作） @Service public class AreaCalculator { public double calculateArea(Shape shape) { return shape.calculateArea(); } public List\u0026lt;AreaReport\u0026gt; calculateMultipleAreas(List\u0026lt;Shape\u0026gt; shapes) { return shapes.stream() .map(shape -\u0026gt; new AreaReport( shape.getShapeType(), shape.calculateArea() )) .collect(Collectors.toList()); } public double calculateTotalArea(List\u0026lt;Shape\u0026gt; shapes) { return shapes.stream() .mapToDouble(Shape::calculateArea) .sum(); } } // 形狀工廠（支援擴展新形狀） @Component public class ShapeFactory { public Shape createRectangle(double width, double height) { return new Rectangle(width, height); } public Shape createCircle(double radius) { return new Circle(radius); } public Shape createTriangle(double base, double height) { return new Triangle(base, height); } public Shape createPolygon(List\u0026lt;Point\u0026gt; vertices) { return new Polygon(vertices); } } // 使用範例 @RestController @RequestMapping(\u0026#34;/shapes\u0026#34;) public class ShapeController { private final AreaCalculator areaCalculator; private final ShapeFactory shapeFactory; public ShapeController(AreaCalculator areaCalculator, ShapeFactory shapeFactory) { this.areaCalculator = areaCalculator; this.shapeFactory = shapeFactory; } @PostMapping(\u0026#34;/rectangle/area\u0026#34;) public AreaResponse calculateRectangleArea(@RequestBody RectangleRequest request) { Shape rectangle = shapeFactory.createRectangle(request.getWidth(), request.getHeight()); double area = areaCalculator.calculateArea(rectangle); return new AreaResponse(rectangle.getShapeType(), area); } @PostMapping(\u0026#34;/circle/area\u0026#34;) public AreaResponse calculateCircleArea(@RequestBody CircleRequest request) { Shape circle = shapeFactory.createCircle(request.getRadius()); double area = areaCalculator.calculateArea(circle); return new AreaResponse(circle.getShapeType(), area); } } 進階應用：策略模式與工廠模式結合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 // 折扣策略介面 public interface DiscountStrategy { double calculateDiscount(double originalPrice); String getStrategyName(); } // 具體折扣策略 @Component(\u0026#34;regular\u0026#34;) public class RegularCustomerDiscount implements DiscountStrategy { @Override public double calculateDiscount(double originalPrice) { return originalPrice * 0.05; // 5% 折扣 } @Override public String getStrategyName() { return \u0026#34;一般客戶折扣\u0026#34;; } } @Component(\u0026#34;vip\u0026#34;) public class VipCustomerDiscount implements DiscountStrategy { @Override public double calculateDiscount(double originalPrice) { return originalPrice * 0.15; // 15% 折扣 } @Override public String getStrategyName() { return \u0026#34;VIP 客戶折扣\u0026#34;; } } @Component(\u0026#34;premium\u0026#34;) public class PremiumCustomerDiscount implements DiscountStrategy { @Override public double calculateDiscount(double originalPrice) { return originalPrice * 0.25; // 25% 折扣 } @Override public String getStrategyName() { return \u0026#34;尊享客戶折扣\u0026#34;; } } // 折扣計算器（對修改封閉，對擴展開放） @Service public class DiscountCalculator { private final Map\u0026lt;String, DiscountStrategy\u0026gt; strategies; public DiscountCalculator(Map\u0026lt;String, DiscountStrategy\u0026gt; strategies) { this.strategies = strategies; } public DiscountResult calculateDiscount(String customerType, double originalPrice) { DiscountStrategy strategy = strategies.get(customerType); if (strategy == null) { throw new IllegalArgumentException(\u0026#34;不支援的客戶類型: \u0026#34; + customerType); } double discountAmount = strategy.calculateDiscount(originalPrice); double finalPrice = originalPrice - discountAmount; return new DiscountResult( strategy.getStrategyName(), originalPrice, discountAmount, finalPrice ); } } 3. Liskov Substitution Principle (LSP) - 里氏替換原則 定義 子類別必須能夠替換其父類別，而不會改變程式的正確性\n核心概念 行為相容性：子類別的行為應該與父類別一致 契約保持：子類別不能違反父類別建立的契約 強化前置條件：子類別不能強化前置條件 弱化後置條件：子類別不能弱化後置條件 違反 LSP 的範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 // ❌ 違反 LSP：正方形修改了矩形的行為契約 public class Rectangle { protected double width; protected double height; public Rectangle(double width, double height) { this.width = width; this.height = height; } public void setWidth(double width) { this.width = width; } public void setHeight(double height) { this.height = height; } public double getWidth() { return width; } public double getHeight() { return height; } public double getArea() { return width * height; } } // ❌ 正方形繼承矩形，但違反了里氏替換原則 public class Square extends Rectangle { public Square(double side) { super(side, side); } // 違反LSP：改變了父類別的行為契約 @Override public void setWidth(double width) { this.width = width; this.height = width; // 強制保持正方形性質 } @Override public void setHeight(double height) { this.width = height; // 強制保持正方形性質 this.height = height; } } // 測試程式碼展示問題 public class GeometryTest { public static void testRectangle(Rectangle rectangle) { rectangle.setWidth(4); rectangle.setHeight(5); // 期望面積是 20，但如果傳入 Square 物件，面積會是 25 double expectedArea = 20; double actualArea = rectangle.getArea(); System.out.println(\u0026#34;期望面積: \u0026#34; + expectedArea); System.out.println(\u0026#34;實際面積: \u0026#34; + actualArea); System.out.println(\u0026#34;測試結果: \u0026#34; + (expectedArea == actualArea ? \u0026#34;通過\u0026#34; : \u0026#34;失敗\u0026#34;)); } public static void main(String[] args) { Rectangle rectangle = new Rectangle(0, 0); testRectangle(rectangle); // 通過 Rectangle square = new Square(0); testRectangle(square); // 失敗！違反了 LSP } } 遵循 LSP 的重構範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 // ✅ 遵循 LSP：重新設計繼承階層 // 抽象基礎類別 public abstract class Shape { public abstract double getArea(); public abstract double getPerimeter(); public abstract String getShapeType(); // 模板方法 public String getShapeInfo() { return String.format(\u0026#34;%s - 面積: %.2f, 周長: %.2f\u0026#34;, getShapeType(), getArea(), getPerimeter()); } } // 矩形實作 public class Rectangle extends Shape { private double width; private double height; public Rectangle(double width, double height) { if (width \u0026lt;= 0 || height \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;長度和寬度必須大於 0\u0026#34;); } this.width = width; this.height = height; } @Override public double getArea() { return width * height; } @Override public double getPerimeter() { return 2 * (width + height); } @Override public String getShapeType() { return \u0026#34;矩形\u0026#34;; } // 只提供安全的修改方法 public Rectangle resize(double newWidth, double newHeight) { return new Rectangle(newWidth, newHeight); } public double getWidth() { return width; } public double getHeight() { return height; } } // 正方形實作（不繼承矩形） public class Square extends Shape { private double side; public Square(double side) { if (side \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;邊長必須大於 0\u0026#34;); } this.side = side; } @Override public double getArea() { return side * side; } @Override public double getPerimeter() { return 4 * side; } @Override public String getShapeType() { return \u0026#34;正方形\u0026#34;; } public Square resize(double newSide) { return new Square(newSide); } public double getSide() { return side; } } // 圓形實作 public class Circle extends Shape { private double radius; public Circle(double radius) { if (radius \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;半徑必須大於 0\u0026#34;); } this.radius = radius; } @Override public double getArea() { return Math.PI * radius * radius; } @Override public double getPerimeter() { return 2 * Math.PI * radius; } @Override public String getShapeType() { return \u0026#34;圓形\u0026#34;; } public Circle resize(double newRadius) { return new Circle(newRadius); } public double getRadius() { return radius; } } // 幾何計算器（可以安全地使用任何 Shape 子類別） @Service public class GeometryCalculator { // 可以安全地接受任何 Shape 子類別 public double calculateArea(Shape shape) { return shape.getArea(); } public double calculatePerimeter(Shape shape) { return shape.getPerimeter(); } public List\u0026lt;ShapeReport\u0026gt; generateShapeReports(List\u0026lt;Shape\u0026gt; shapes) { return shapes.stream() .map(shape -\u0026gt; new ShapeReport( shape.getShapeType(), shape.getArea(), shape.getPerimeter() )) .collect(Collectors.toList()); } public Shape findLargestShape(List\u0026lt;Shape\u0026gt; shapes) { return shapes.stream() .max(Comparator.comparing(Shape::getArea)) .orElseThrow(() -\u0026gt; new IllegalArgumentException(\u0026#34;形狀列表不能為空\u0026#34;)); } } // 測試證明 LSP 合規性 @Component public class GeometryTestService { private final GeometryCalculator calculator; public GeometryTestService(GeometryCalculator calculator) { this.calculator = calculator; } public void testShapePolymorphism() { List\u0026lt;Shape\u0026gt; shapes = Arrays.asList( new Rectangle(4, 5), // 面積: 20 new Square(4), // 面積: 16 new Circle(3) // 面積: ~28.27 ); // 所有形狀都可以安全地使用相同的方法 shapes.forEach(shape -\u0026gt; { System.out.println(shape.getShapeInfo()); }); // 找出最大面積的形狀 Shape largest = calculator.findLargestShape(shapes); System.out.println(\u0026#34;最大形狀: \u0026#34; + largest.getShapeInfo()); } } LSP 的進階應用：契約設計 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 // 定義清楚的契約 public abstract class Bird { protected String name; protected double weight; public Bird(String name, double weight) { this.name = name; this.weight = weight; } // 契約：所有鳥類都可以吃 public abstract void eat(String food); // 契約：所有鳥類都可以移動 public abstract void move(); public String getName() { return name; } public double getWeight() { return weight; } } // 可飛行的鳥類介面 public interface Flyable { void fly(); double getMaxFlightHeight(); } // 可游泳的鳥類介面 public interface Swimmable { void swim(); double getMaxDivingDepth(); } // 具體實作 - 老鷹（可飛行） public class Eagle extends Bird implements Flyable { public Eagle(String name, double weight) { super(name, weight); } @Override public void eat(String food) { System.out.println(name + \u0026#34; 正在吃 \u0026#34; + food); } @Override public void move() { fly(); // 老鷹主要透過飛行移動 } @Override public void fly() { System.out.println(name + \u0026#34; 正在高空飛翔\u0026#34;); } @Override public double getMaxFlightHeight() { return 3000; // 3000公尺 } } // 具體實作 - 企鵝（可游泳，不能飛行） public class Penguin extends Bird implements Swimmable { public Penguin(String name, double weight) { super(name, weight); } @Override public void eat(String food) { System.out.println(name + \u0026#34; 正在吃 \u0026#34; + food); } @Override public void move() { swim(); // 企鵝主要透過游泳移動 } @Override public void swim() { System.out.println(name + \u0026#34; 正在水中游泳\u0026#34;); } @Override public double getMaxDivingDepth() { return 200; // 200公尺 } } // 鳥類管理服務（完全遵循 LSP） @Service public class BirdManagementService { // 可以安全地處理任何 Bird 子類別 public void feedBird(Bird bird, String food) { bird.eat(food); } public void moveBird(Bird bird) { bird.move(); } // 專門處理可飛行的鳥類 public void makeFly(Flyable flyableBird) { flyableBird.fly(); System.out.println(\u0026#34;最大飛行高度: \u0026#34; + flyableBird.getMaxFlightHeight() + \u0026#34; 公尺\u0026#34;); } // 專門處理可游泳的鳥類 public void makeSwim(Swimmable swimmableBird) { swimmableBird.swim(); System.out.println(\u0026#34;最大潛水深度: \u0026#34; + swimmableBird.getMaxDivingDepth() + \u0026#34; 公尺\u0026#34;); } } 4. Interface Segregation Principle (ISP) - 介面隔離原則 定義 不應該強迫客戶端依賴它們不使用的介面方法\n核心概念 介面最小化：介面應該只包含客戶端需要的方法 職責分離：大介面應該拆分成多個小介面 依賴最小化：降低介面之間的耦合度 違反 ISP 的範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // ❌ 違反 ISP：萬能介面，強迫實作不需要的方法 public interface MediaPlayer { void playAudio(String audioFile); void playVideo(String videoFile); void displaySubtitles(String subtitleFile); void adjustVolume(int volume); void adjustBrightness(int brightness); void recordAudio(); void recordVideo(); void takeScreenshot(); void applyAudioFilter(String filter); void applyVideoFilter(String filter); } // ❌ 音頻播放器被迫實作不需要的視頻相關方法 public class AudioPlayer implements MediaPlayer { @Override public void playAudio(String audioFile) { System.out.println(\u0026#34;播放音頻: \u0026#34; + audioFile); } @Override public void adjustVolume(int volume) { System.out.println(\u0026#34;調整音量到: \u0026#34; + volume); } @Override public void applyAudioFilter(String filter) { System.out.println(\u0026#34;應用音頻濾鏡: \u0026#34; + filter); } // 被迫實作不需要的方法 @Override public void playVideo(String videoFile) { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援視頻播放\u0026#34;); } @Override public void displaySubtitles(String subtitleFile) { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援字幕\u0026#34;); } @Override public void adjustBrightness(int brightness) { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援亮度調整\u0026#34;); } @Override public void recordAudio() { throw new UnsupportedOperationException(\u0026#34;此音頻播放器不支援錄音\u0026#34;); } @Override public void recordVideo() { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援視頻錄製\u0026#34;); } @Override public void takeScreenshot() { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援截圖\u0026#34;); } @Override public void applyVideoFilter(String filter) { throw new UnsupportedOperationException(\u0026#34;音頻播放器不支援視頻濾鏡\u0026#34;); } } 遵循 ISP 的重構範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 // ✅ 遵循 ISP：將大介面拆分成多個職責明確的小介面 // 基礎播放介面 public interface Playable { void play(String file); void pause(); void stop(); void seek(long position); } // 音頻相關介面 public interface AudioPlayable extends Playable { void adjustVolume(int volume); int getVolume(); } // 視頻相關介面 public interface VideoPlayable extends Playable { void adjustBrightness(int brightness); void adjustContrast(int contrast); int getBrightness(); int getContrast(); } // 字幕支援介面 public interface SubtitleSupport { void loadSubtitles(String subtitleFile); void showSubtitles(boolean show); void adjustSubtitleSize(int size); } // 錄音介面 public interface AudioRecordable { void startAudioRecording(String outputFile); void stopAudioRecording(); boolean isRecording(); } // 錄影介面 public interface VideoRecordable { void startVideoRecording(String outputFile); void stopVideoRecording(); void takeScreenshot(String outputFile); } // 濾鏡支援介面 public interface AudioFilterSupport { void applyAudioFilter(AudioFilter filter); void removeAudioFilter(); List\u0026lt;AudioFilter\u0026gt; getAvailableAudioFilters(); } public interface VideoFilterSupport { void applyVideoFilter(VideoFilter filter); void removeVideoFilter(); List\u0026lt;VideoFilter\u0026gt; getAvailableVideoFilters(); } // 音頻播放器實作（只實作需要的介面） @Component public class SimpleAudioPlayer implements AudioPlayable, AudioFilterSupport { private int volume = 50; private boolean isPlaying = false; private AudioFilter currentFilter; @Override public void play(String file) { System.out.println(\u0026#34;播放音頻檔案: \u0026#34; + file); isPlaying = true; } @Override public void pause() { System.out.println(\u0026#34;暫停播放\u0026#34;); isPlaying = false; } @Override public void stop() { System.out.println(\u0026#34;停止播放\u0026#34;); isPlaying = false; } @Override public void seek(long position) { System.out.println(\u0026#34;跳轉到位置: \u0026#34; + position + \u0026#34; 秒\u0026#34;); } @Override public void adjustVolume(int volume) { this.volume = Math.max(0, Math.min(100, volume)); System.out.println(\u0026#34;音量調整為: \u0026#34; + this.volume); } @Override public int getVolume() { return volume; } @Override public void applyAudioFilter(AudioFilter filter) { this.currentFilter = filter; System.out.println(\u0026#34;應用音頻濾鏡: \u0026#34; + filter.getName()); } @Override public void removeAudioFilter() { this.currentFilter = null; System.out.println(\u0026#34;移除音頻濾鏡\u0026#34;); } @Override public List\u0026lt;AudioFilter\u0026gt; getAvailableAudioFilters() { return Arrays.asList( new AudioFilter(\u0026#34;回音\u0026#34;, \u0026#34;echo\u0026#34;), new AudioFilter(\u0026#34;降噪\u0026#34;, \u0026#34;noise_reduction\u0026#34;), new AudioFilter(\u0026#34;等化器\u0026#34;, \u0026#34;equalizer\u0026#34;) ); } } // 專業錄音機實作（實作錄音相關介面） @Component public class ProfessionalAudioRecorder implements AudioPlayable, AudioRecordable, AudioFilterSupport { private int volume = 50; private boolean isPlaying = false; private boolean isRecording = false; private String currentRecordingFile; // 實作播放功能 @Override public void play(String file) { if (!isRecording) { System.out.println(\u0026#34;播放音頻檔案: \u0026#34; + file); isPlaying = true; } else { System.out.println(\u0026#34;錄音中，無法播放\u0026#34;); } } @Override public void pause() { System.out.println(\u0026#34;暫停播放\u0026#34;); isPlaying = false; } @Override public void stop() { System.out.println(\u0026#34;停止播放\u0026#34;); isPlaying = false; } @Override public void seek(long position) { System.out.println(\u0026#34;跳轉到位置: \u0026#34; + position + \u0026#34; 秒\u0026#34;); } @Override public void adjustVolume(int volume) { this.volume = Math.max(0, Math.min(100, volume)); System.out.println(\u0026#34;音量調整為: \u0026#34; + this.volume); } @Override public int getVolume() { return volume; } // 實作錄音功能 @Override public void startAudioRecording(String outputFile) { if (!isPlaying) { this.currentRecordingFile = outputFile; this.isRecording = true; System.out.println(\u0026#34;開始錄音到: \u0026#34; + outputFile); } else { System.out.println(\u0026#34;播放中，無法錄音\u0026#34;); } } @Override public void stopAudioRecording() { if (isRecording) { this.isRecording = false; System.out.println(\u0026#34;錄音完成: \u0026#34; + currentRecordingFile); this.currentRecordingFile = null; } } @Override public boolean isRecording() { return isRecording; } // 實作濾鏡功能 @Override public void applyAudioFilter(AudioFilter filter) { System.out.println(\u0026#34;應用專業音頻濾鏡: \u0026#34; + filter.getName()); } @Override public void removeAudioFilter() { System.out.println(\u0026#34;移除音頻濾鏡\u0026#34;); } @Override public List\u0026lt;AudioFilter\u0026gt; getAvailableAudioFilters() { return Arrays.asList( new AudioFilter(\u0026#34;回音\u0026#34;, \u0026#34;echo\u0026#34;), new AudioFilter(\u0026#34;降噪\u0026#34;, \u0026#34;noise_reduction\u0026#34;), new AudioFilter(\u0026#34;等化器\u0026#34;, \u0026#34;equalizer\u0026#34;), new AudioFilter(\u0026#34;壓縮器\u0026#34;, \u0026#34;compressor\u0026#34;), new AudioFilter(\u0026#34;限制器\u0026#34;, \u0026#34;limiter\u0026#34;) ); } } // 視頻播放器實作（實作視頻相關介面） @Component public class VideoPlayer implements VideoPlayable, SubtitleSupport, VideoFilterSupport { private int brightness = 50; private int contrast = 50; private boolean subtitlesVisible = false; private String currentSubtitleFile; @Override public void play(String file) { System.out.println(\u0026#34;播放視頻檔案: \u0026#34; + file); } @Override public void pause() { System.out.println(\u0026#34;暫停視頻\u0026#34;); } @Override public void stop() { System.out.println(\u0026#34;停止視頻\u0026#34;); } @Override public void seek(long position) { System.out.println(\u0026#34;跳轉到視頻位置: \u0026#34; + position + \u0026#34; 秒\u0026#34;); } @Override public void adjustBrightness(int brightness) { this.brightness = Math.max(0, Math.min(100, brightness)); System.out.println(\u0026#34;亮度調整為: \u0026#34; + this.brightness); } @Override public void adjustContrast(int contrast) { this.contrast = Math.max(0, Math.min(100, contrast)); System.out.println(\u0026#34;對比度調整為: \u0026#34; + this.contrast); } @Override public int getBrightness() { return brightness; } @Override public int getContrast() { return contrast; } // 字幕支援 @Override public void loadSubtitles(String subtitleFile) { this.currentSubtitleFile = subtitleFile; System.out.println(\u0026#34;載入字幕檔案: \u0026#34; + subtitleFile); } @Override public void showSubtitles(boolean show) { this.subtitlesVisible = show; System.out.println(\u0026#34;字幕顯示: \u0026#34; + (show ? \u0026#34;開啟\u0026#34; : \u0026#34;關閉\u0026#34;)); } @Override public void adjustSubtitleSize(int size) { System.out.println(\u0026#34;字幕大小調整為: \u0026#34; + size); } // 視頻濾鏡支援 @Override public void applyVideoFilter(VideoFilter filter) { System.out.println(\u0026#34;應用視頻濾鏡: \u0026#34; + filter.getName()); } @Override public void removeVideoFilter() { System.out.println(\u0026#34;移除視頻濾鏡\u0026#34;); } @Override public List\u0026lt;VideoFilter\u0026gt; getAvailableVideoFilters() { return Arrays.asList( new VideoFilter(\u0026#34;模糊\u0026#34;, \u0026#34;blur\u0026#34;), new VideoFilter(\u0026#34;銳化\u0026#34;, \u0026#34;sharpen\u0026#34;), new VideoFilter(\u0026#34;色彩增強\u0026#34;, \u0026#34;color_enhance\u0026#34;) ); } } // 媒體管理服務（使用介面隔離的好處） @Service public class MediaManagementService { // 只處理播放功能 public void playMedia(Playable player, String file) { player.play(file); } // 只處理音頻播放 public void playAudioWithVolume(AudioPlayable audioPlayer, String file, int volume) { audioPlayer.adjustVolume(volume); audioPlayer.play(file); } // 只處理錄音功能 public void recordAudio(AudioRecordable recorder, String outputFile) { if (!recorder.isRecording()) { recorder.startAudioRecording(outputFile); } } // 只處理字幕功能 public void setupSubtitles(SubtitleSupport player, String subtitleFile) { player.loadSubtitles(subtitleFile); player.showSubtitles(true); } } 5. Dependency Inversion Principle (DIP) - 依賴反轉原則 定義 高層模組不應該依賴低層模組，兩者都應該依賴於抽象。抽象不應該依賴於細節，細節應該依賴於抽象。\n核心概念 依賴注入：透過外部注入依賴而非內部創建 控制反轉：將依賴關係的控制權交給外部容器 抽象依賴：依賴於介面而非具體實作 違反 DIP 的範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // ❌ 違反 DIP：高層模組直接依賴低層模組的具體實作 public class MySQLDatabase { public void save(String data) { System.out.println(\u0026#34;儲存資料到 MySQL: \u0026#34; + data); } public String load(String id) { return \u0026#34;從 MySQL 載入資料: \u0026#34; + id; } } public class EmailService { public void sendEmail(String to, String subject, String body) { System.out.println(\u0026#34;發送郵件到: \u0026#34; + to); System.out.println(\u0026#34;主題: \u0026#34; + subject); System.out.println(\u0026#34;內容: \u0026#34; + body); } } // ❌ UserService 直接依賴具體實作，難以測試和擴展 public class UserService { private MySQLDatabase database; // 直接依賴具體實作 private EmailService emailService; // 直接依賴具體實作 public UserService() { this.database = new MySQLDatabase(); // 在構造函數中創建依賴 this.emailService = new EmailService(); // 硬編碼依賴 } public void createUser(String username, String email) { // 驗證邏輯 if (username == null || username.trim().isEmpty()) { throw new IllegalArgumentException(\u0026#34;用戶名不能為空\u0026#34;); } // 儲存用戶（依賴具體的 MySQL 實作） String userData = \u0026#34;User: \u0026#34; + username + \u0026#34;, Email: \u0026#34; + email; database.save(userData); // 發送歡迎郵件（依賴具體的郵件服務實作） emailService.sendEmail(email, \u0026#34;歡迎\u0026#34;, \u0026#34;歡迎加入我們的平台！\u0026#34;); } public String getUser(String userId) { return database.load(userId); } } 遵循 DIP 的重構範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 // ✅ 遵循 DIP：定義抽象介面 // 資料庫抽象介面 public interface UserRepository { void save(User user); Optional\u0026lt;User\u0026gt; findById(String id); Optional\u0026lt;User\u0026gt; findByEmail(String email); List\u0026lt;User\u0026gt; findAll(); void delete(String id); } // 通知服務抽象介面 public interface NotificationService { void sendWelcomeNotification(User user); void sendPasswordResetNotification(User user, String resetToken); void sendAccountActivationNotification(User user, String activationToken); } // 用戶驗證抽象介面 public interface UserValidator { ValidationResult validate(User user); boolean isEmailUnique(String email); boolean isUsernameValid(String username); } // 具體實作 - MySQL 資料庫 @Repository public class MySQLUserRepository implements UserRepository { @Override public void save(User user) { System.out.println(\u0026#34;儲存用戶到 MySQL: \u0026#34; + user.getUsername()); // 實際的資料庫操作邏輯 } @Override public Optional\u0026lt;User\u0026gt; findById(String id) { System.out.println(\u0026#34;從 MySQL 查找用戶: \u0026#34; + id); // 實際的查詢邏輯 return Optional.of(new User(id, \u0026#34;user@example.com\u0026#34;)); } @Override public Optional\u0026lt;User\u0026gt; findByEmail(String email) { System.out.println(\u0026#34;從 MySQL 根據郵箱查找用戶: \u0026#34; + email); return Optional.empty(); } @Override public List\u0026lt;User\u0026gt; findAll() { System.out.println(\u0026#34;從 MySQL 查找所有用戶\u0026#34;); return Arrays.asList(new User(\u0026#34;1\u0026#34;, \u0026#34;user1@example.com\u0026#34;)); } @Override public void delete(String id) { System.out.println(\u0026#34;從 MySQL 刪除用戶: \u0026#34; + id); } } // 具體實作 - MongoDB 資料庫（可替換實作） @Repository @Profile(\u0026#34;mongodb\u0026#34;) public class MongoUserRepository implements UserRepository { @Override public void save(User user) { System.out.println(\u0026#34;儲存用戶到 MongoDB: \u0026#34; + user.getUsername()); } @Override public Optional\u0026lt;User\u0026gt; findById(String id) { System.out.println(\u0026#34;從 MongoDB 查找用戶: \u0026#34; + id); return Optional.of(new User(id, \u0026#34;user@example.com\u0026#34;)); } @Override public Optional\u0026lt;User\u0026gt; findByEmail(String email) { System.out.println(\u0026#34;從 MongoDB 根據郵箱查找用戶: \u0026#34; + email); return Optional.empty(); } @Override public List\u0026lt;User\u0026gt; findAll() { System.out.println(\u0026#34;從 MongoDB 查找所有用戶\u0026#34;); return Arrays.asList(new User(\u0026#34;1\u0026#34;, \u0026#34;user1@example.com\u0026#34;)); } @Override public void delete(String id) { System.out.println(\u0026#34;從 MongoDB 刪除用戶: \u0026#34; + id); } } // 具體實作 - 郵件通知服務 @Service public class EmailNotificationService implements NotificationService { @Override public void sendWelcomeNotification(User user) { System.out.println(\u0026#34;發送歡迎郵件到: \u0026#34; + user.getEmail()); // 實際的郵件發送邏輯 } @Override public void sendPasswordResetNotification(User user, String resetToken) { System.out.println(\u0026#34;發送密碼重設郵件到: \u0026#34; + user.getEmail()); System.out.println(\u0026#34;重設令牌: \u0026#34; + resetToken); } @Override public void sendAccountActivationNotification(User user, String activationToken) { System.out.println(\u0026#34;發送帳戶啟用郵件到: \u0026#34; + user.getEmail()); System.out.println(\u0026#34;啟用令牌: \u0026#34; + activationToken); } } // 具體實作 - SMS 通知服務（可替換實作） @Service @Profile(\u0026#34;sms\u0026#34;) public class SMSNotificationService implements NotificationService { @Override public void sendWelcomeNotification(User user) { System.out.println(\u0026#34;發送歡迎 SMS 到: \u0026#34; + user.getPhoneNumber()); } @Override public void sendPasswordResetNotification(User user, String resetToken) { System.out.println(\u0026#34;發送密碼重設 SMS 到: \u0026#34; + user.getPhoneNumber()); System.out.println(\u0026#34;重設代碼: \u0026#34; + resetToken); } @Override public void sendAccountActivationNotification(User user, String activationToken) { System.out.println(\u0026#34;發送帳戶啟用 SMS 到: \u0026#34; + user.getPhoneNumber()); System.out.println(\u0026#34;啟用代碼: \u0026#34; + activationToken); } } // 具體實作 - 用戶驗證器 @Component public class DefaultUserValidator implements UserValidator { private final UserRepository userRepository; public DefaultUserValidator(UserRepository userRepository) { this.userRepository = userRepository; } @Override public ValidationResult validate(User user) { ValidationResult result = new ValidationResult(); if (!isUsernameValid(user.getUsername())) { result.addError(\u0026#34;用戶名格式無效\u0026#34;); } if (!isEmailValid(user.getEmail())) { result.addError(\u0026#34;郵箱格式無效\u0026#34;); } if (!isEmailUnique(user.getEmail())) { result.addError(\u0026#34;郵箱已被使用\u0026#34;); } return result; } @Override public boolean isEmailUnique(String email) { return userRepository.findByEmail(email).isEmpty(); } @Override public boolean isUsernameValid(String username) { return username != null \u0026amp;\u0026amp; username.trim().length() \u0026gt;= 3 \u0026amp;\u0026amp; username.trim().length() \u0026lt;= 50 \u0026amp;\u0026amp; username.matches(\u0026#34;^[a-zA-Z0-9_]+$\u0026#34;); } private boolean isEmailValid(String email) { return email != null \u0026amp;\u0026amp; email.contains(\u0026#34;@\u0026#34;) \u0026amp;\u0026amp; email.contains(\u0026#34;.\u0026#34;) \u0026amp;\u0026amp; email.length() \u0026gt; 5; } } // 高層模組 - 用戶服務（依賴於抽象） @Service public class UserService { private final UserRepository userRepository; private final NotificationService notificationService; private final UserValidator userValidator; // 依賴注入：透過構造函數注入依賴 public UserService(UserRepository userRepository, NotificationService notificationService, UserValidator userValidator) { this.userRepository = userRepository; this.notificationService = notificationService; this.userValidator = userValidator; } public Result\u0026lt;User\u0026gt; createUser(String username, String email) { User user = new User(username, email); // 驗證用戶資料 ValidationResult validation = userValidator.validate(user); if (!validation.isValid()) { return Result.failure(\u0026#34;驗證失敗: \u0026#34; + validation.getErrors()); } try { // 儲存用戶 userRepository.save(user); // 發送通知 notificationService.sendWelcomeNotification(user); return Result.success(user); } catch (Exception e) { return Result.failure(\u0026#34;創建用戶失敗: \u0026#34; + e.getMessage()); } } public Result\u0026lt;User\u0026gt; getUserById(String id) { Optional\u0026lt;User\u0026gt; user = userRepository.findById(id); if (user.isPresent()) { return Result.success(user.get()); } else { return Result.failure(\u0026#34;用戶不存在\u0026#34;); } } public Result\u0026lt;Void\u0026gt; resetPassword(String email) { Optional\u0026lt;User\u0026gt; userOpt = userRepository.findByEmail(email); if (userOpt.isEmpty()) { return Result.failure(\u0026#34;用戶不存在\u0026#34;); } User user = userOpt.get(); String resetToken = generateResetToken(); // 儲存重設令牌（實際應該儲存到資料庫） // userRepository.saveResetToken(user.getId(), resetToken); // 發送重設通知 notificationService.sendPasswordResetNotification(user, resetToken); return Result.success(null); } private String generateResetToken() { return \u0026#34;RESET-\u0026#34; + UUID.randomUUID().toString(); } } // 配置類別（控制依賴注入） @Configuration public class UserServiceConfiguration { @Bean @ConditionalOnProperty(name = \u0026#34;database.type\u0026#34;, havingValue = \u0026#34;mysql\u0026#34;, matchIfMissing = true) public UserRepository mysqlUserRepository() { return new MySQLUserRepository(); } @Bean @ConditionalOnProperty(name = \u0026#34;database.type\u0026#34;, havingValue = \u0026#34;mongodb\u0026#34;) public UserRepository mongoUserRepository() { return new MongoUserRepository(); } @Bean @ConditionalOnProperty(name = \u0026#34;notification.type\u0026#34;, havingValue = \u0026#34;email\u0026#34;, matchIfMissing = true) public NotificationService emailNotificationService() { return new EmailNotificationService(); } @Bean @ConditionalOnProperty(name = \u0026#34;notification.type\u0026#34;, havingValue = \u0026#34;sms\u0026#34;) public NotificationService smsNotificationService() { return new SMSNotificationService(); } } DIP 的進階應用：工廠模式與策略模式結合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 // 報表生成策略介面 public interface ReportGenerator { String generateReport(List\u0026lt;User\u0026gt; users); String getReportFormat(); } // CSV 報表生成器 @Component(\u0026#34;csvReportGenerator\u0026#34;) public class CSVReportGenerator implements ReportGenerator { @Override public String generateReport(List\u0026lt;User\u0026gt; users) { StringBuilder csv = new StringBuilder(); csv.append(\u0026#34;用戶名,郵箱,創建時間\\n\u0026#34;); users.forEach(user -\u0026gt; csv.append(String.format(\u0026#34;%s,%s,%s\\n\u0026#34;, user.getUsername(), user.getEmail(), user.getCreatedAt())) ); return csv.toString(); } @Override public String getReportFormat() { return \u0026#34;CSV\u0026#34;; } } // JSON 報表生成器 @Component(\u0026#34;jsonReportGenerator\u0026#34;) public class JSONReportGenerator implements ReportGenerator { private final ObjectMapper objectMapper; public JSONReportGenerator(ObjectMapper objectMapper) { this.objectMapper = objectMapper; } @Override public String generateReport(List\u0026lt;User\u0026gt; users) { try { Map\u0026lt;String, Object\u0026gt; report = new HashMap\u0026lt;\u0026gt;(); report.put(\u0026#34;totalUsers\u0026#34;, users.size()); report.put(\u0026#34;generatedAt\u0026#34;, LocalDateTime.now()); report.put(\u0026#34;users\u0026#34;, users); return objectMapper.writeValueAsString(report); } catch (Exception e) { throw new RuntimeException(\u0026#34;JSON 報表生成失敗\u0026#34;, e); } } @Override public String getReportFormat() { return \u0026#34;JSON\u0026#34;; } } // 報表工廠 @Service public class ReportGeneratorFactory { private final Map\u0026lt;String, ReportGenerator\u0026gt; generators; public ReportGeneratorFactory(Map\u0026lt;String, ReportGenerator\u0026gt; generators) { this.generators = generators; } public ReportGenerator getGenerator(String format) { ReportGenerator generator = generators.get(format.toLowerCase() + \u0026#34;ReportGenerator\u0026#34;); if (generator == null) { throw new IllegalArgumentException(\u0026#34;不支援的報表格式: \u0026#34; + format); } return generator; } public List\u0026lt;String\u0026gt; getSupportedFormats() { return generators.values().stream() .map(ReportGenerator::getReportFormat) .collect(Collectors.toList()); } } // 報表服務（高層模組，依賴於抽象） @Service public class UserReportService { private final UserRepository userRepository; private final ReportGeneratorFactory reportGeneratorFactory; public UserReportService(UserRepository userRepository, ReportGeneratorFactory reportGeneratorFactory) { this.userRepository = userRepository; this.reportGeneratorFactory = reportGeneratorFactory; } public String generateUserReport(String format) { List\u0026lt;User\u0026gt; users = userRepository.findAll(); ReportGenerator generator = reportGeneratorFactory.getGenerator(format); return generator.generateReport(users); } public List\u0026lt;String\u0026gt; getSupportedReportFormats() { return reportGeneratorFactory.getSupportedFormats(); } } 總結 SOLID 原則是軟體設計的基石，它們相互補充，共同促進程式碼的品質：\n核心價值 可維護性：每個原則都有助於降低程式碼修改的複雜度 可擴展性：支援新功能的增加而不破壞現有功能 可測試性：依賴注入和介面隔離使單元測試更容易 可重用性：職責明確的類別可以在不同場景中重複使用 實踐建議 從小處開始：在新專案中逐步應用 SOLID 原則 重構現有程式碼：識別違反 SOLID 原則的程式碼並逐步改進 使用現代框架：Spring、依賴注入容器等工具有助於實踐 SOLID 原則 程式碼審查：在團隊中推廣 SOLID 原則的理解和應用 持續學習：SOLID 原則是軟體架構的基礎，需要在實踐中不斷深化理解 常見陷阱 過度設計：不要為了遵循原則而增加不必要的複雜性 教條主義：原則是指導而非絕對規則，需要根據具體情況靈活應用 忽略性能：在追求設計原則的同時要考慮性能影響 缺乏漸進性：不要試圖一次性重構整個系統，要採用漸進式改進 SOLID 原則不僅適用於物件導向程式設計，在微服務架構、函數式程式設計等現代軟體架構中同樣具有指導意義。掌握這些原則將顯著提升你的軟體設計能力。\n參考資料 Clean Code by Robert C. Martin Agile Software Development, Principles, Patterns, and Practices SOLID Principles of Object Oriented Design Spring Framework Documentation ","permalink":"https://xinqilin.github.io/post/architecture/solid/","tags":["SOLID","Design Principles","OOP","Software Architecture","Clean Code","Best Practices"],"title":"SOLID 設計原則完整指南：物件導向程式設計的五大核心原則"},{"content":"筆記 Vue 未整理 version 套件 vetur vue2 snippets webpack -\u0026gt; npm install webpack -g vue -\u0026gt; npm install -g @vue/cli-init chrome: vue plugin\n快速開始 vue init webpack \u0026lt;你的app名字\u0026gt;\nnpm run dev\nmain.js -\u0026gt; 路由 index.js 在 [router 內]\n1 2 3 4 5 6 7 8 9 10 export default new Router({ routes:[ { path: \u0026#39;/\u0026#39;, name: \u0026#39;HelloWorld\u0026#39;, component: HelloWorld } ] }) HelloWorld.vue 內容 在 [components內]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data(){ return name: \u0026#39;Bill\u0026#39; } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 跳頁\n1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;router-link to=\u0026#34;/HelloWorld\u0026#34;\u0026gt;go to hello world\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 單向綁定 1 2 3 4 v-text v-html v-bind:href=\u0026#34;link\u0026#34; vue instance 內的 method 的 data:{link} (v-bind:href 可縮寫:href) 雙向綁定 v-model\n綁定事件 1 2 3 4 5 6 7 8 9 10 v-on:click=\u0026#34;num++\u0026#34; = @click v-on 防止事件冒泡{ `.stop`: 阻止事件冒泡倒父層 `.prevent`: 阻止默認(預設) 事件發生 `.capture`: 阻止事件捕獲模式 `.self`: 只有自身觸發事件才執行 `.once`: 只執行一次 } 按鍵修飾符 v-on:keyup.13 1 2 3 4 5 6 7 8 9 10 11 12 13 13 是鍵碼 v-on 按鍵修飾符 懶人包{ `.enter` `.tab` `.delete` `.esc` `.space` `.up` `.down` `.left` `.right` } v-for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 v-for = \u0026#34;user in users\u0026#34; 或 v-for=\u0026#34;(user, index) in users\u0026#34; v-for = \u0026#34;(value, key, index) in users\u0026#34; {{value}} {{key}} {{index}} v-for 增加 :key = \u0026#34;\u0026#34; 可增加效率 最主要是是別惟一值 :key 是 v-bind縮寫 v-if 裡面都填boolean 整個標籤不見 v-show 裡面都填boolean 是用 display:none 常跟 v-if 一起用 v-else-if v-else 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // computed 計算屬性 // watch 監控屬性 // filter 過濾屬性 -\u0026gt; 使用 {{user.gender | genderFilter}} new Vue({ el: \u0026#34;#app\u0026#34;, data:{ a:100, b:200 }, computed: { total: function(){ return this.a+this.b } }, watch:{ a: function(newValue, oldValue){ alert(\u0026#34;new: \u0026#34;+newValue+\u0026#34; , old: \u0026#34;+oldValue) if(a\u0026gt;3){ this.msg = \u0026#34;太多\u0026#34; } } }, filters:{ genderFilter(val){ if(val == 1) return \u0026#34;male\u0026#34; else return \u0026#34;female\u0026#34; } } }) 組件:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;script\u0026gt; Global 組件: Vue.component(\u0026#34;counter\u0026#34;,{ template: `\u0026lt;button v-on:click = \u0026#34;count++\u0026#34;\u0026gt; {{count}}\u0026lt;/button\u0026gt;` data(){ return { count: 0 } } }); 區域組件: const buttonCounter = { template: `\u0026lt;button v-on:click = \u0026#34;count++\u0026#34;\u0026gt; {{count}}\u0026lt;/button\u0026gt;` data(){ return { count: 0 } } } 後 放入 vue instance components:{}中 components:{ \u0026#39;button-counter 名字\u0026#39;: buttonCounter } ``` \u0026lt;button-counter\u0026gt;\u0026lt;/button-counter\u0026gt; 使用 ``` \u0026lt;/script\u0026gt; lifeCycle 1 2 3 4 5 6 7 8 9 10 11 let app = new Vue(){ el: app, data: { }, beforeCreate: function(){ } // 放一些生命週期的東西 }; ","permalink":"https://xinqilin.github.io/post/frontend/vue-intro/","tags":[],"title":"Vue Intro"},{"content":"JWT Dependency Inject 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 兩種 引入 jjwt ， version 放 properties 內方便控管 \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;jjwt.version\u0026gt;0.9.0\u0026lt;/jjwt.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jjwt.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; // 第二種 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.11.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-impl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.11.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-jackson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.11.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 流程: 使用者帳密登入 -\u0026gt; 驗證後 -\u0026gt; 回應 token -\u0026gt; 取得token 放入 header 中 打 API\nmodel Request 帳密\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class AuthenticationRequest implements Serializable { private String userName; private String password; public AuthenticationRequest() { } public AuthenticationRequest(String userName, String password) { this.userName = userName; this.password = password; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } Response 回應 token\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class AuthenticationResponse implements Serializable { private final String jwt; public AuthenticationResponse(String jwt) { this.jwt = jwt; } public String getJwt() { return jwt; } } Config 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @EnableWebSecurity public class MySecurityConfig extends WebSecurityConfigurerAdapter { // 建構子方式注入 private final MyUserDetailsService myUserDetailsService; private final JwtRequestFilter jwtRequestFilter; public MySecurityConfig(MyUserDetailsService myUserDetailsService, JwtRequestFilter jwtRequestFilter) { this.myUserDetailsService = myUserDetailsService; this.jwtRequestFilter = jwtRequestFilter; } // AuthenticationManager init 別的地方會用到 @Override @Bean public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } // /authentication 請求可過 @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable().authorizeRequests() .antMatchers(\u0026#34;/authentication\u0026#34;) .permitAll() .anyRequest() .authenticated() .and() .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS); http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class); } @Override public void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(myUserDetailsService); } @Bean public PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } 最重要的 JWTUtil 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @Service public class JwtUtil { private final String SECRET_KEY = \u0026#34;@*$\u0026amp;Secret\u0026amp;\u0026amp;$#\u0026#34;; public String extractUsername(String token) { return extractClaim(token, Claims::getSubject); } public Date extractExpiration(String token) { return extractClaim(token, Claims::getExpiration); } public \u0026lt;T\u0026gt; T extractClaim(String token, Function\u0026lt;Claims, T\u0026gt; claimsResolver) { final Claims claims = extractAllClaims(token); return claimsResolver.apply(claims); } private Claims extractAllClaims(String token) { return Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token).getBody(); } private Boolean isTokenExpired(String token) { return extractExpiration(token).before(new Date()); } public String generateToken(UserDetails userDetails) { Map\u0026lt;String, Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); return createToken(claims, userDetails.getUsername()); } private String createToken(Map\u0026lt;String, Object\u0026gt; claims, String subject) { return Jwts.builder().setClaims(claims).setSubject(subject).setIssuedAt(new Date(System.currentTimeMillis())) .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 10)) .signWith(SignatureAlgorithm.HS256, SECRET_KEY).compact(); } public Boolean validateToken(String token, UserDetails userDetails) { final String userName = extractUsername(token); return (userName.equals(userDetails.getUsername()) \u0026amp;\u0026amp; !isTokenExpired(token)); } } JWT Filter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @Component public class JwtRequestFilter extends OncePerRequestFilter { private final MyUserDetailsService myUserDetailsService; private final JwtUtil jwtUtil; public JwtRequestFilter(MyUserDetailsService myUserDetailsService, JwtUtil jwtUtil) { this.myUserDetailsService = myUserDetailsService; this.jwtUtil = jwtUtil; } @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { final String authorzationHeader = request.getHeader(\u0026#34;Authorization\u0026#34;); String username = null; String jwt = null; if (authorzationHeader != null \u0026amp;\u0026amp; authorzationHeader.startsWith(\u0026#34;Bearer \u0026#34;)) { jwt = authorzationHeader.substring(7); username = jwtUtil.extractUsername(jwt); } if (username != null \u0026amp;\u0026amp; SecurityContextHolder.getContext().getAuthentication() == null) { UserDetails userDetails = this.myUserDetailsService.loadUserByUsername(username); if (jwtUtil.validateToken(jwt, userDetails)) { UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken( userDetails, null, userDetails.getAuthorities() ); usernamePasswordAuthenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken); } } filterChain.doFilter(request, response); } } 系統可以取得 User 帳密的 service 1 2 3 4 5 6 7 8 9 10 @Service public class MyUserDetailsService implements UserDetailsService { @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { //implement it in system user module return new User(\u0026#34;Bill\u0026#34;, \u0026#34;billisgood\u0026#34;, new ArrayList\u0026lt;\u0026gt;()); } } JWT Controller 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @RestController public class JwtController { private final AuthenticationManager authenticationManager; private final MyUserDetailsService myUserDetailsService; private final JwtUtil jwtUtil; public JwtController(AuthenticationManager authenticationManager, MyUserDetailsService myUserDetailsService, JwtUtil jwtUtil) { this.authenticationManager = authenticationManager; this.myUserDetailsService = myUserDetailsService; this.jwtUtil = jwtUtil; } @RequestMapping(value = \u0026#34;/hello\u0026#34;, method = RequestMethod.GET) public ResponseEntity\u0026lt;?\u0026gt; sayHello() { return ResponseEntity.ok().body(\u0026#34;say hello success\u0026#34;); } @RequestMapping(value = \u0026#34;/authentication\u0026#34;, method = RequestMethod.POST) public ResponseEntity\u0026lt;?\u0026gt; createAuthenticationToken(@RequestBody AuthenticationRequest authenticationRequest) throws Exception { try { authenticationManager.authenticate( new UsernamePasswordAuthenticationToken(authenticationRequest.getUserName(), authenticationRequest.getPassword()) ); } catch (BadCredentialsException e) { throw new Exception(\u0026#34;Incorrect username or password\u0026#34;); } final UserDetails userDetails = myUserDetailsService.loadUserByUsername(authenticationRequest.getUserName()); final String jwt = jwtUtil.generateToken(userDetails); return ResponseEntity.ok(new AuthenticationResponse(jwt)); } } ","permalink":"https://xinqilin.github.io/post/backend/jwt/","tags":["JWT","Spring Security","Authentication","Java","Spring Boot","Security"],"title":"JWT 認證機制完整實作：Spring Security 整合與最佳實踐"},{"content":"概述 Swagger（現稱為 OpenAPI）是目前最流行的 REST API 文檔化工具之一。它不僅能自動生成美觀的 API 文檔，還提供互動式測試介面，支援多種程式語言的客戶端程式碼生成。本文將全面介紹如何在 Spring Boot 專案中整合和使用 Swagger，從基礎配置到進階功能的完整實戰指南。\n版本選擇與依賴配置 OpenAPI 3.0 vs Swagger 2.0 特性 Swagger 2.0 OpenAPI 3.0 規範版本 較舊 最新標準 Spring Boot 支援 良好 原生支援 功能豐富度 基本功能 豐富特性 社群活躍度 維護模式 積極開發 推薦度 僅限舊專案 強烈推薦 現代化依賴配置（OpenAPI 3.0） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!-- 推薦：SpringDoc OpenAPI 3 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-starter-webmvc-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 安全整合 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-security\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- WebFlux 支援 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-starter-webflux-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 傳統 Swagger 2.0 配置（僅供參考） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;!-- 傳統：Springfox Swagger 2 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; OpenAPI 3.0 基礎配置 1. 應用程式配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # application.yml springdoc: api-docs: path: /api-docs enabled: true swagger-ui: path: /swagger-ui.html enabled: true operations-sorter: method tags-sorter: alpha try-it-out-enabled: true filter: true display-request-duration: true packages-to-scan: com.example.controller paths-to-match: /api/** default-consumes-media-type: application/json default-produces-media-type: application/json # 自訂配置 app: api: title: E-Commerce API description: 電商平台核心 API 服務 version: 1.0.0 contact: name: API Support Team email: api-support@example.com url: https://example.com/support license: name: Apache 2.0 url: https://www.apache.org/licenses/LICENSE-2.0.html terms-of-service: https://example.com/terms 2. 進階 OpenAPI 配置類 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @Configuration @EnableOpenApi public class OpenApiConfiguration { @Value(\u0026#34;${app.api.title}\u0026#34;) private String title; @Value(\u0026#34;${app.api.description}\u0026#34;) private String description; @Value(\u0026#34;${app.api.version}\u0026#34;) private String version; @Bean public OpenAPI customOpenAPI() { return new OpenAPI() .info(createApiInfo()) .servers(createServers()) .security(createSecurityRequirements()) .components(createComponents()); } private Info createApiInfo() { return new Info() .title(title) .description(description) .version(version) .contact(new Contact() .name(\u0026#34;API Support Team\u0026#34;) .email(\u0026#34;api-support@example.com\u0026#34;) .url(\u0026#34;https://example.com/support\u0026#34;)) .license(new License() .name(\u0026#34;Apache 2.0\u0026#34;) .url(\u0026#34;https://www.apache.org/licenses/LICENSE-2.0.html\u0026#34;)) .termsOfService(\u0026#34;https://example.com/terms\u0026#34;); } private List\u0026lt;Server\u0026gt; createServers() { return List.of( new Server() .url(\u0026#34;https://api.example.com\u0026#34;) .description(\u0026#34;Production Server\u0026#34;), new Server() .url(\u0026#34;https://staging-api.example.com\u0026#34;) .description(\u0026#34;Staging Server\u0026#34;), new Server() .url(\u0026#34;http://localhost:8080\u0026#34;) .description(\u0026#34;Development Server\u0026#34;) ); } private List\u0026lt;SecurityRequirement\u0026gt; createSecurityRequirements() { return List.of( new SecurityRequirement().addList(\u0026#34;bearerAuth\u0026#34;), new SecurityRequirement().addList(\u0026#34;apiKey\u0026#34;) ); } private Components createComponents() { return new Components() .addSecuritySchemes(\u0026#34;bearerAuth\u0026#34;, new SecurityScheme() .type(SecurityScheme.Type.HTTP) .scheme(\u0026#34;bearer\u0026#34;) .bearerFormat(\u0026#34;JWT\u0026#34;) .description(\u0026#34;JWT Bearer Token Authentication\u0026#34;)) .addSecuritySchemes(\u0026#34;apiKey\u0026#34;, new SecurityScheme() .type(SecurityScheme.Type.APIKEY) .in(SecurityScheme.In.HEADER) .name(\u0026#34;X-API-Key\u0026#34;) .description(\u0026#34;API Key Authentication\u0026#34;)) .addSchemas(\u0026#34;Error\u0026#34;, createErrorSchema()) .addSchemas(\u0026#34;PageInfo\u0026#34;, createPageInfoSchema()); } private Schema\u0026lt;?\u0026gt; createErrorSchema() { return new Schema\u0026lt;\u0026gt;() .type(\u0026#34;object\u0026#34;) .addProperties(\u0026#34;timestamp\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;string\u0026#34;).format(\u0026#34;date-time\u0026#34;)) .addProperties(\u0026#34;status\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;integer\u0026#34;)) .addProperties(\u0026#34;error\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;string\u0026#34;)) .addProperties(\u0026#34;message\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;string\u0026#34;)) .addProperties(\u0026#34;path\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;string\u0026#34;)); } private Schema\u0026lt;?\u0026gt; createPageInfoSchema() { return new Schema\u0026lt;\u0026gt;() .type(\u0026#34;object\u0026#34;) .addProperties(\u0026#34;page\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;integer\u0026#34;)) .addProperties(\u0026#34;size\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;integer\u0026#34;)) .addProperties(\u0026#34;totalElements\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;integer\u0026#34;)) .addProperties(\u0026#34;totalPages\u0026#34;, new Schema\u0026lt;\u0026gt;().type(\u0026#34;integer\u0026#34;)); } } 控制器註解詳解 1. 完整的 REST Controller 範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 @RestController @RequestMapping(\u0026#34;/api/v1/users\u0026#34;) @Tag(name = \u0026#34;User Management\u0026#34;, description = \u0026#34;用戶管理相關 API\u0026#34;) @SecurityRequirement(name = \u0026#34;bearerAuth\u0026#34;) public class UserController { private final UserService userService; public UserController(UserService userService) { this.userService = userService; } @GetMapping @Operation( summary = \u0026#34;獲取用戶列表\u0026#34;, description = \u0026#34;分頁查詢用戶資訊，支援多種過濾條件\u0026#34;, tags = {\u0026#34;User Management\u0026#34;} ) @ApiResponses(value = { @ApiResponse( responseCode = \u0026#34;200\u0026#34;, description = \u0026#34;成功獲取用戶列表\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = PagedUserResponse.class), examples = @ExampleObject( name = \u0026#34;用戶列表範例\u0026#34;, value = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;content\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;username\u0026#34;: \u0026#34;john_doe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34;, \u0026#34;firstName\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Doe\u0026#34;, \u0026#34;createdAt\u0026#34;: \u0026#34;2023-01-15T10:30:00Z\u0026#34; } ], \u0026#34;pageable\u0026#34;: { \u0026#34;page\u0026#34;: 0, \u0026#34;size\u0026#34;: 20, \u0026#34;totalElements\u0026#34;: 1, \u0026#34;totalPages\u0026#34;: 1 } } \u0026#34;\u0026#34;\u0026#34; ) ) ), @ApiResponse( responseCode = \u0026#34;400\u0026#34;, description = \u0026#34;請求參數錯誤\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = ErrorResponse.class) ) ), @ApiResponse( responseCode = \u0026#34;401\u0026#34;, description = \u0026#34;未授權訪問\u0026#34;, content = @Content(schema = @Schema(implementation = ErrorResponse.class)) ), @ApiResponse( responseCode = \u0026#34;403\u0026#34;, description = \u0026#34;權限不足\u0026#34;, content = @Content(schema = @Schema(implementation = ErrorResponse.class)) ) }) public ResponseEntity\u0026lt;Page\u0026lt;UserResponse\u0026gt;\u0026gt; getUsers( @Parameter( description = \u0026#34;頁碼（從 0 開始）\u0026#34;, example = \u0026#34;0\u0026#34;, schema = @Schema(minimum = \u0026#34;0\u0026#34;, defaultValue = \u0026#34;0\u0026#34;) ) @RequestParam(defaultValue = \u0026#34;0\u0026#34;) @Min(0) int page, @Parameter( description = \u0026#34;每頁大小\u0026#34;, example = \u0026#34;20\u0026#34;, schema = @Schema(minimum = \u0026#34;1\u0026#34;, maximum = \u0026#34;100\u0026#34;, defaultValue = \u0026#34;20\u0026#34;) ) @RequestParam(defaultValue = \u0026#34;20\u0026#34;) @Min(1) @Max(100) int size, @Parameter( description = \u0026#34;排序欄位，格式：field,direction\u0026#34;, example = \u0026#34;createdAt,desc\u0026#34;, array = @ArraySchema(schema = @Schema(type = \u0026#34;string\u0026#34;)) ) @RequestParam(defaultValue = \u0026#34;createdAt,desc\u0026#34;) String[] sort, @Parameter( description = \u0026#34;用戶名搜尋關鍵字\u0026#34;, example = \u0026#34;john\u0026#34; ) @RequestParam(required = false) String username, @Parameter( description = \u0026#34;郵箱搜尋關鍵字\u0026#34;, example = \u0026#34;example.com\u0026#34; ) @RequestParam(required = false) String email, @Parameter( description = \u0026#34;用戶狀態過濾\u0026#34;, schema = @Schema(allowableValues = {\u0026#34;ACTIVE\u0026#34;, \u0026#34;INACTIVE\u0026#34;, \u0026#34;SUSPENDED\u0026#34;}) ) @RequestParam(required = false) UserStatus status ) { UserSearchCriteria criteria = UserSearchCriteria.builder() .username(username) .email(email) .status(status) .build(); Pageable pageable = createPageable(page, size, sort); Page\u0026lt;UserResponse\u0026gt; users = userService.findUsers(criteria, pageable); return ResponseEntity.ok(users); } @GetMapping(\u0026#34;/{id}\u0026#34;) @Operation( summary = \u0026#34;根據 ID 獲取用戶\u0026#34;, description = \u0026#34;根據用戶 ID 獲取詳細資訊\u0026#34; ) @ApiResponses(value = { @ApiResponse( responseCode = \u0026#34;200\u0026#34;, description = \u0026#34;成功獲取用戶資訊\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = UserDetailResponse.class) ) ), @ApiResponse(responseCode = \u0026#34;404\u0026#34;, description = \u0026#34;用戶不存在\u0026#34;) }) public ResponseEntity\u0026lt;UserDetailResponse\u0026gt; getUserById( @Parameter( description = \u0026#34;用戶 ID\u0026#34;, required = true, example = \u0026#34;123\u0026#34; ) @PathVariable @Positive Long id ) { UserDetailResponse user = userService.findDetailById(id); return ResponseEntity.ok(user); } @PostMapping @Operation( summary = \u0026#34;創建新用戶\u0026#34;, description = \u0026#34;創建新的用戶帳戶，郵箱必須唯一\u0026#34; ) @ApiResponses(value = { @ApiResponse( responseCode = \u0026#34;201\u0026#34;, description = \u0026#34;用戶創建成功\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = UserResponse.class) ) ), @ApiResponse( responseCode = \u0026#34;400\u0026#34;, description = \u0026#34;請求資料驗證失敗\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = ValidationErrorResponse.class) ) ), @ApiResponse( responseCode = \u0026#34;409\u0026#34;, description = \u0026#34;郵箱已存在\u0026#34; ) }) public ResponseEntity\u0026lt;UserResponse\u0026gt; createUser( @io.swagger.v3.oas.annotations.parameters.RequestBody( description = \u0026#34;用戶創建請求\u0026#34;, required = true, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = CreateUserRequest.class), examples = @ExampleObject( name = \u0026#34;用戶創建範例\u0026#34;, value = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;username\u0026#34;: \u0026#34;john_doe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34;, \u0026#34;firstName\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Doe\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;SecurePassword123!\u0026#34; } \u0026#34;\u0026#34;\u0026#34; ) ) ) @RequestBody @Valid CreateUserRequest request ) { UserResponse user = userService.createUser(request); URI location = URI.create(\u0026#34;/api/v1/users/\u0026#34; + user.getId()); return ResponseEntity.created(location).body(user); } @PutMapping(\u0026#34;/{id}\u0026#34;) @Operation( summary = \u0026#34;更新用戶資訊\u0026#34;, description = \u0026#34;更新指定用戶的基本資訊\u0026#34; ) public ResponseEntity\u0026lt;UserResponse\u0026gt; updateUser( @PathVariable @Positive Long id, @RequestBody @Valid UpdateUserRequest request ) { UserResponse user = userService.updateUser(id, request); return ResponseEntity.ok(user); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) @Operation( summary = \u0026#34;刪除用戶\u0026#34;, description = \u0026#34;軟刪除指定用戶（標記為已刪除狀態）\u0026#34; ) @ApiResponses(value = { @ApiResponse(responseCode = \u0026#34;204\u0026#34;, description = \u0026#34;刪除成功\u0026#34;), @ApiResponse(responseCode = \u0026#34;404\u0026#34;, description = \u0026#34;用戶不存在\u0026#34;), @ApiResponse(responseCode = \u0026#34;409\u0026#34;, description = \u0026#34;用戶有關聯資料，無法刪除\u0026#34;) }) public ResponseEntity\u0026lt;Void\u0026gt; deleteUser( @PathVariable @Positive Long id ) { userService.deleteUser(id); return ResponseEntity.noContent().build(); } @PostMapping(\u0026#34;/{id}/avatar\u0026#34;) @Operation( summary = \u0026#34;上傳用戶頭像\u0026#34;, description = \u0026#34;上傳用戶頭像圖片，支援 JPG、PNG 格式\u0026#34; ) @ApiResponses(value = { @ApiResponse( responseCode = \u0026#34;200\u0026#34;, description = \u0026#34;頭像上傳成功\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = UploadResponse.class) ) ), @ApiResponse(responseCode = \u0026#34;400\u0026#34;, description = \u0026#34;檔案格式不支援\u0026#34;), @ApiResponse(responseCode = \u0026#34;413\u0026#34;, description = \u0026#34;檔案大小超出限制\u0026#34;) }) public ResponseEntity\u0026lt;UploadResponse\u0026gt; uploadAvatar( @PathVariable @Positive Long id, @Parameter( description = \u0026#34;頭像圖片檔案\u0026#34;, required = true, content = @Content(mediaType = \u0026#34;multipart/form-data\u0026#34;) ) @RequestParam(\u0026#34;file\u0026#34;) MultipartFile file ) { UploadResponse response = userService.uploadAvatar(id, file); return ResponseEntity.ok(response); } } 2. DTO 類別註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @Schema(description = \u0026#34;用戶創建請求\u0026#34;) public class CreateUserRequest { @Schema( description = \u0026#34;用戶名\u0026#34;, example = \u0026#34;john_doe\u0026#34;, minLength = 3, maxLength = 50, pattern = \u0026#34;^[a-zA-Z0-9_]+$\u0026#34; ) @NotBlank(message = \u0026#34;用戶名不能為空\u0026#34;) @Size(min = 3, max = 50, message = \u0026#34;用戶名長度必須在 3-50 字元之間\u0026#34;) @Pattern(regexp = \u0026#34;^[a-zA-Z0-9_]+$\u0026#34;, message = \u0026#34;用戶名只能包含字母、數字和底線\u0026#34;) private String username; @Schema( description = \u0026#34;郵箱地址\u0026#34;, example = \u0026#34;john@example.com\u0026#34;, format = \u0026#34;email\u0026#34; ) @NotBlank(message = \u0026#34;郵箱不能為空\u0026#34;) @Email(message = \u0026#34;郵箱格式不正確\u0026#34;) private String email; @Schema( description = \u0026#34;名字\u0026#34;, example = \u0026#34;John\u0026#34;, maxLength = 30 ) @NotBlank(message = \u0026#34;名字不能為空\u0026#34;) @Size(max = 30, message = \u0026#34;名字長度不能超過 30 字元\u0026#34;) private String firstName; @Schema( description = \u0026#34;姓氏\u0026#34;, example = \u0026#34;Doe\u0026#34;, maxLength = 30 ) @NotBlank(message = \u0026#34;姓氏不能為空\u0026#34;) @Size(max = 30, message = \u0026#34;姓氏長度不能超過 30 字元\u0026#34;) private String lastName; @Schema( description = \u0026#34;密碼\u0026#34;, example = \u0026#34;SecurePassword123!\u0026#34;, minLength = 8, maxLength = 100, format = \u0026#34;password\u0026#34; ) @NotBlank(message = \u0026#34;密碼不能為空\u0026#34;) @Size(min = 8, max = 100, message = \u0026#34;密碼長度必須在 8-100 字元之間\u0026#34;) @Pattern( regexp = \u0026#34;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[@$!%*?\u0026amp;])[A-Za-z\\\\d@$!%*?\u0026amp;]+$\u0026#34;, message = \u0026#34;密碼必須包含大小寫字母、數字和特殊字元\u0026#34; ) private String password; @Schema( description = \u0026#34;出生日期\u0026#34;, example = \u0026#34;1990-01-15\u0026#34;, format = \u0026#34;date\u0026#34; ) @Past(message = \u0026#34;出生日期必須是過去的日期\u0026#34;) private LocalDate birthDate; @Schema( description = \u0026#34;用戶角色\u0026#34;, allowableValues = {\u0026#34;USER\u0026#34;, \u0026#34;ADMIN\u0026#34;, \u0026#34;MODERATOR\u0026#34;}, defaultValue = \u0026#34;USER\u0026#34; ) private UserRole role = UserRole.USER; // Getters and Setters... } @Schema(description = \u0026#34;分頁用戶回應\u0026#34;) public class PagedUserResponse { @Schema(description = \u0026#34;用戶列表\u0026#34;) private List\u0026lt;UserResponse\u0026gt; content; @Schema(description = \u0026#34;分頁資訊\u0026#34;) private PageInfo pageable; // Getters and Setters... } @Schema(description = \u0026#34;用戶基本資訊回應\u0026#34;) public class UserResponse { @Schema(description = \u0026#34;用戶 ID\u0026#34;, example = \u0026#34;123\u0026#34;) private Long id; @Schema(description = \u0026#34;用戶名\u0026#34;, example = \u0026#34;john_doe\u0026#34;) private String username; @Schema(description = \u0026#34;郵箱\u0026#34;, example = \u0026#34;john@example.com\u0026#34;) private String email; @Schema(description = \u0026#34;全名\u0026#34;, example = \u0026#34;John Doe\u0026#34;) private String fullName; @Schema(description = \u0026#34;頭像 URL\u0026#34;, example = \u0026#34;https://example.com/avatars/123.jpg\u0026#34;) private String avatarUrl; @Schema(description = \u0026#34;用戶狀態\u0026#34;, allowableValues = {\u0026#34;ACTIVE\u0026#34;, \u0026#34;INACTIVE\u0026#34;, \u0026#34;SUSPENDED\u0026#34;}) private UserStatus status; @Schema(description = \u0026#34;創建時間\u0026#34;, format = \u0026#34;date-time\u0026#34;) private LocalDateTime createdAt; @Schema(description = \u0026#34;最後登入時間\u0026#34;, format = \u0026#34;date-time\u0026#34;) private LocalDateTime lastLoginAt; // Getters and Setters... } 安全配置整合 1. JWT Bearer Token 整合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @Configuration @EnableWebSecurity public class SecurityConfiguration { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { return http .csrf(csrf -\u0026gt; csrf.disable()) .authorizeHttpRequests(auth -\u0026gt; auth // Swagger 相關路徑公開 .requestMatchers( \u0026#34;/api-docs/**\u0026#34;, \u0026#34;/swagger-ui/**\u0026#34;, \u0026#34;/swagger-ui.html\u0026#34;, \u0026#34;/webjars/**\u0026#34; ).permitAll() // 公開 API .requestMatchers(HttpMethod.POST, \u0026#34;/api/v1/auth/**\u0026#34;).permitAll() .requestMatchers(HttpMethod.GET, \u0026#34;/api/v1/public/**\u0026#34;).permitAll() // 需要認證的 API .anyRequest().authenticated() ) .oauth2ResourceServer(oauth2 -\u0026gt; oauth2 .jwt(jwt -\u0026gt; jwt.jwtDecoder(jwtDecoder())) ) .sessionManagement(session -\u0026gt; session .sessionCreationPolicy(SessionCreationPolicy.STATELESS) ) .build(); } @Bean public JwtDecoder jwtDecoder() { return NimbusJwtDecoder.withJwkSetUri(\u0026#34;https://your-auth-server/.well-known/jwks.json\u0026#34;) .build(); } } // 在 Controller 中指定安全需求 @RestController @RequestMapping(\u0026#34;/api/v1/admin\u0026#34;) @Tag(name = \u0026#34;Admin Management\u0026#34;, description = \u0026#34;管理員專用 API\u0026#34;) @SecurityRequirement(name = \u0026#34;bearerAuth\u0026#34;) @PreAuthorize(\u0026#34;hasRole(\u0026#39;ADMIN\u0026#39;)\u0026#34;) public class AdminController { @GetMapping(\u0026#34;/users\u0026#34;) @Operation( summary = \u0026#34;管理員查看所有用戶\u0026#34;, description = \u0026#34;需要 ADMIN 角色權限\u0026#34; ) @PreAuthorize(\u0026#34;hasAuthority(\u0026#39;USER_READ_ALL\u0026#39;)\u0026#34;) public ResponseEntity\u0026lt;Page\u0026lt;UserResponse\u0026gt;\u0026gt; getAllUsersForAdmin( @ParameterObject Pageable pageable ) { // Implementation... return ResponseEntity.ok().build(); } } 2. API Key 認證 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 @Component public class ApiKeyAuthenticationFilter extends OncePerRequestFilter { private static final String API_KEY_HEADER = \u0026#34;X-API-Key\u0026#34;; private final ApiKeyService apiKeyService; public ApiKeyAuthenticationFilter(ApiKeyService apiKeyService) { this.apiKeyService = apiKeyService; } @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain ) throws ServletException, IOException { String apiKey = request.getHeader(API_KEY_HEADER); if (apiKey != null \u0026amp;\u0026amp; apiKeyService.isValidApiKey(apiKey)) { ApiKeyDetails details = apiKeyService.getApiKeyDetails(apiKey); ApiKeyAuthenticationToken authentication = new ApiKeyAuthenticationToken(details); SecurityContextHolder.getContext().setAuthentication(authentication); } filterChain.doFilter(request, response); } } // 在特定 Controller 中使用 API Key @RestController @RequestMapping(\u0026#34;/api/v1/webhook\u0026#34;) @Tag(name = \u0026#34;Webhook API\u0026#34;, description = \u0026#34;第三方系統回調 API\u0026#34;) @SecurityRequirement(name = \u0026#34;apiKey\u0026#34;) public class WebhookController { @PostMapping(\u0026#34;/payment\u0026#34;) @Operation( summary = \u0026#34;支付結果回調\u0026#34;, description = \u0026#34;第三方支付系統回調通知\u0026#34; ) public ResponseEntity\u0026lt;Void\u0026gt; handlePaymentWebhook( @RequestBody PaymentWebhookRequest request ) { // Implementation... return ResponseEntity.ok().build(); } } 進階功能配置 1. 自訂文檔分組 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @Configuration public class OpenApiGroupConfiguration { @Bean @Primary public GroupedOpenApi publicApi() { return GroupedOpenApi.builder() .group(\u0026#34;public\u0026#34;) .displayName(\u0026#34;Public API\u0026#34;) .pathsToMatch(\u0026#34;/api/v1/public/**\u0026#34;, \u0026#34;/api/v1/auth/**\u0026#34;) .build(); } @Bean public GroupedOpenApi userApi() { return GroupedOpenApi.builder() .group(\u0026#34;user\u0026#34;) .displayName(\u0026#34;User API\u0026#34;) .pathsToMatch(\u0026#34;/api/v1/users/**\u0026#34;, \u0026#34;/api/v1/profile/**\u0026#34;) .addOperationCustomizer((operation, handlerMethod) -\u0026gt; { operation.addSecurityItem(new SecurityRequirement().addList(\u0026#34;bearerAuth\u0026#34;)); return operation; }) .build(); } @Bean public GroupedOpenApi adminApi() { return GroupedOpenApi.builder() .group(\u0026#34;admin\u0026#34;) .displayName(\u0026#34;Admin API\u0026#34;) .pathsToMatch(\u0026#34;/api/v1/admin/**\u0026#34;) .addOperationCustomizer((operation, handlerMethod) -\u0026gt; { operation.addSecurityItem(new SecurityRequirement().addList(\u0026#34;bearerAuth\u0026#34;)); // 添加管理員 API 的額外標籤 operation.addTagsItem(\u0026#34;Admin Only\u0026#34;); return operation; }) .build(); } @Bean public GroupedOpenApi internalApi() { return GroupedOpenApi.builder() .group(\u0026#34;internal\u0026#34;) .displayName(\u0026#34;Internal API\u0026#34;) .pathsToMatch(\u0026#34;/api/internal/**\u0026#34;) .addOperationCustomizer((operation, handlerMethod) -\u0026gt; { operation.addSecurityItem(new SecurityRequirement().addList(\u0026#34;apiKey\u0026#34;)); return operation; }) .build(); } } 2. 自訂操作符處理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @Component public class CustomOperationCustomizer implements OperationCustomizer { @Override public Operation customize(Operation operation, HandlerMethod handlerMethod) { // 自動添加通用錯誤回應 addCommonErrorResponses(operation); // 為分頁端點添加通用參數 if (isPaginationEndpoint(handlerMethod)) { addPaginationParameters(operation); } // 添加請求追蹤資訊 addRequestTrackingInfo(operation); return operation; } private void addCommonErrorResponses(Operation operation) { ApiResponses responses = operation.getResponses(); if (responses.get(\u0026#34;400\u0026#34;) == null) { responses.addApiResponse(\u0026#34;400\u0026#34;, new ApiResponse() .description(\u0026#34;請求參數錯誤\u0026#34;) .content(new Content() .addMediaType(\u0026#34;application/json\u0026#34;, new MediaType() .schema(new Schema\u0026lt;\u0026gt;().$ref(\u0026#34;#/components/schemas/Error\u0026#34;))))); } if (responses.get(\u0026#34;500\u0026#34;) == null) { responses.addApiResponse(\u0026#34;500\u0026#34;, new ApiResponse() .description(\u0026#34;內部伺服器錯誤\u0026#34;) .content(new Content() .addMediaType(\u0026#34;application/json\u0026#34;, new MediaType() .schema(new Schema\u0026lt;\u0026gt;().$ref(\u0026#34;#/components/schemas/Error\u0026#34;))))); } } private boolean isPaginationEndpoint(HandlerMethod handlerMethod) { return Arrays.stream(handlerMethod.getMethodParameters()) .anyMatch(param -\u0026gt; Pageable.class.isAssignableFrom(param.getParameterType())); } private void addPaginationParameters(Operation operation) { if (operation.getParameters() == null) { operation.setParameters(new ArrayList\u0026lt;\u0026gt;()); } // 添加通用分頁參數 operation.getParameters().add(new Parameter() .name(\u0026#34;page\u0026#34;) .in(ParameterIn.QUERY) .description(\u0026#34;頁碼（從 0 開始）\u0026#34;) .schema(new IntegerSchema().minimum(BigDecimal.ZERO)._default(0))); operation.getParameters().add(new Parameter() .name(\u0026#34;size\u0026#34;) .in(ParameterIn.QUERY) .description(\u0026#34;每頁大小\u0026#34;) .schema(new IntegerSchema().minimum(BigDecimal.ONE).maximum(BigDecimal.valueOf(100))._default(20))); } private void addRequestTrackingInfo(Operation operation) { operation.addExtension(\u0026#34;x-request-id\u0026#34;, \u0026#34;自動生成的請求追蹤 ID\u0026#34;); operation.addExtension(\u0026#34;x-rate-limit\u0026#34;, \u0026#34;API 呼叫頻率限制資訊\u0026#34;); } } 3. 自訂 Schema 處理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @Component public class CustomModelConverter implements ModelConverter { @Override public ModelConverterContext resolve( AnnotatedType annotatedType, ModelConverterContext context, Iterator\u0026lt;ModelConverter\u0026gt; chain ) { if (chain.hasNext()) { context = chain.next().resolve(annotatedType, context, chain); } // 自訂枚舉處理 if (annotatedType.getType() instanceof Class\u0026lt;?\u0026gt; clazz \u0026amp;\u0026amp; clazz.isEnum()) { Schema\u0026lt;?\u0026gt; schema = context.getDefinedModels().get(annotatedType.getType().getTypeName()); if (schema != null) { enhanceEnumSchema(schema, clazz); } } return context; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private void enhanceEnumSchema(Schema\u0026lt;?\u0026gt; schema, Class\u0026lt;?\u0026gt; enumClass) { if (enumClass.isEnum()) { Enum\u0026lt;?\u0026gt;[] enumConstants = (Enum\u0026lt;?\u0026gt;[]) enumClass.getEnumConstants(); List\u0026lt;String\u0026gt; enumValues = Arrays.stream(enumConstants) .map(Enum::name) .collect(Collectors.toList()); schema.setEnum(enumValues); // 添加枚舉描述 StringBuilder description = new StringBuilder(schema.getDescription() != null ? schema.getDescription() : \u0026#34;\u0026#34;); description.append(\u0026#34;\\n\\n可用值：\\n\u0026#34;); for (Enum\u0026lt;?\u0026gt; enumConstant : enumConstants) { description.append(\u0026#34;- `\u0026#34;).append(enumConstant.name()).append(\u0026#34;`\u0026#34;); // 如果枚舉有描述方法，添加描述 try { Method getDescription = enumClass.getMethod(\u0026#34;getDescription\u0026#34;); Object desc = getDescription.invoke(enumConstant); if (desc != null) { description.append(\u0026#34;: \u0026#34;).append(desc); } } catch (Exception ignored) { // 忽略沒有 getDescription 方法的情況 } description.append(\u0026#34;\\n\u0026#34;); } schema.setDescription(description.toString()); } } } 測試整合 1. API 文檔測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @TestMethodOrder(OrderAnnotation.class) class OpenApiDocumentationTest { @Autowired private TestRestTemplate restTemplate; @LocalServerPort private int port; @Test @Order(1) void testOpenApiJsonGeneration() { String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/api-docs\u0026#34;; ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.getForEntity(url, String.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK); assertThat(response.getBody()).isNotNull(); // 驗證 JSON 結構 DocumentContext context = JsonPath.parse(response.getBody()); assertThat(context.read(\u0026#34;$.openapi\u0026#34;, String.class)).isEqualTo(\u0026#34;3.0.1\u0026#34;); assertThat(context.read(\u0026#34;$.info.title\u0026#34;, String.class)).isNotEmpty(); assertThat(context.read(\u0026#34;$.paths\u0026#34;, Map.class)).isNotEmpty(); } @Test @Order(2) void testSwaggerUiAccess() { String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/swagger-ui.html\u0026#34;; ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.getForEntity(url, String.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK); assertThat(response.getBody()).contains(\u0026#34;Swagger UI\u0026#34;); } @Test @Order(3) void testApiGroupsGeneration() { String[] groups = {\u0026#34;public\u0026#34;, \u0026#34;user\u0026#34;, \u0026#34;admin\u0026#34;, \u0026#34;internal\u0026#34;}; for (String group : groups) { String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/api-docs/\u0026#34; + group; ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.getForEntity(url, String.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK); DocumentContext context = JsonPath.parse(response.getBody()); assertThat(context.read(\u0026#34;$.paths\u0026#34;, Map.class)).isNotEmpty(); } } @Test @Order(4) void testSecuritySchemesDefinition() { String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/api-docs\u0026#34;; ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.getForEntity(url, String.class); DocumentContext context = JsonPath.parse(response.getBody()); // 驗證安全方案定義 assertThat(context.read(\u0026#34;$.components.securitySchemes.bearerAuth.type\u0026#34;, String.class)) .isEqualTo(\u0026#34;http\u0026#34;); assertThat(context.read(\u0026#34;$.components.securitySchemes.apiKey.type\u0026#34;, String.class)) .isEqualTo(\u0026#34;apiKey\u0026#34;); } } 2. 契約測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) class ApiContractTest { @Autowired private TestRestTemplate restTemplate; @Autowired private ObjectMapper objectMapper; @LocalServerPort private int port; @Test void testUserApiContract() throws Exception { // 獲取 OpenAPI 規範 String openApiJson = getOpenApiJson(); OpenAPIV3Parser parser = new OpenAPIV3Parser(); OpenAPI openAPI = parser.readContents(openApiJson).getOpenAPI(); // 測試用戶創建端點 PathItem userPath = openAPI.getPaths().get(\u0026#34;/api/v1/users\u0026#34;); assertThat(userPath).isNotNull(); Operation postOperation = userPath.getPost(); assertThat(postOperation).isNotNull(); assertThat(postOperation.getSummary()).isEqualTo(\u0026#34;創建新用戶\u0026#34;); // 驗證請求 Schema RequestBody requestBody = postOperation.getRequestBody(); assertThat(requestBody).isNotNull(); Content content = requestBody.getContent(); MediaType mediaType = content.get(\u0026#34;application/json\u0026#34;); assertThat(mediaType).isNotNull(); // 驗證回應 Schema ApiResponse response201 = postOperation.getResponses().get(\u0026#34;201\u0026#34;); assertThat(response201).isNotNull(); assertThat(response201.getDescription()).isEqualTo(\u0026#34;用戶創建成功\u0026#34;); } @Test void testActualApiMatchesContract() throws Exception { // 根據文檔測試實際 API String requestJson = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;username\u0026#34;: \u0026#34;test_user\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;test@example.com\u0026#34;, \u0026#34;firstName\u0026#34;: \u0026#34;Test\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;User\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;TestPassword123!\u0026#34; } \u0026#34;\u0026#34;\u0026#34;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); headers.setBearerAuth(\u0026#34;valid-jwt-token\u0026#34;); HttpEntity\u0026lt;String\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(requestJson, headers); // 假設這個端點在測試環境中可用 String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/api/v1/users\u0026#34;; ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.postForEntity(url, request, String.class); // 根據文檔，應該返回 201 或 401（如果沒有有效 token） assertThat(response.getStatusCode()) .isIn(HttpStatus.CREATED, HttpStatus.UNAUTHORIZED); } private String getOpenApiJson() { String url = \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/api-docs\u0026#34;; return restTemplate.getForObject(url, String.class); } } 部署與 CI/CD 整合 1. 文檔生成腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #!/bin/bash # scripts/generate-api-docs.sh set -e echo \u0026#34;🚀 生成 API 文檔...\u0026#34; # 啟動應用程式 echo \u0026#34;啟動 Spring Boot 應用程式...\u0026#34; java -jar target/api-service.jar --server.port=8080 \u0026amp; APP_PID=$! # 等待應用程式啟動 echo \u0026#34;等待應用程式啟動...\u0026#34; for i in {1..30}; do if curl -s http://localhost:8080/actuator/health \u0026gt; /dev/null; then echo \u0026#34;應用程式已啟動\u0026#34; break fi sleep 2 done # 生成 OpenAPI JSON echo \u0026#34;下載 OpenAPI 規範...\u0026#34; curl -o docs/openapi.json http://localhost:8080/api-docs # 生成不同格式的文檔 echo \u0026#34;生成 HTML 文檔...\u0026#34; npx @redocly/openapi-cli build-docs docs/openapi.json --output docs/api.html echo \u0026#34;生成 Markdown 文檔...\u0026#34; npx widdershins docs/openapi.json -o docs/api.md # 生成客戶端 SDK echo \u0026#34;生成客戶端 SDK...\u0026#34; mkdir -p generated/java-client npx @openapitools/openapi-generator-cli generate \\ -i docs/openapi.json \\ -g java \\ -o generated/java-client \\ --additional-properties=invokerPackage=com.example.client # 停止應用程式 echo \u0026#34;停止應用程式...\u0026#34; kill $APP_PID echo \u0026#34;✅ API 文檔生成完成\u0026#34; 2. GitHub Actions 工作流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 # .github/workflows/api-docs.yml name: Generate API Documentation on: push: branches: [ main, develop ] pull_request: branches: [ main ] jobs: generate-docs: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set up JDK 17 uses: actions/setup-java@v3 with: java-version: \u0026#39;17\u0026#39; distribution: \u0026#39;temurin\u0026#39; - name: Cache Maven dependencies uses: actions/cache@v3 with: path: ~/.m2 key: ${{ runner.os }}-m2-${{ hashFiles(\u0026#39;**/pom.xml\u0026#39;) }} - name: Build application run: mvn clean package -DskipTests - name: Setup Node.js uses: actions/setup-node@v3 with: node-version: \u0026#39;18\u0026#39; - name: Install documentation tools run: | npm install -g @redocly/openapi-cli npm install -g widdershins npm install -g @openapitools/openapi-generator-cli - name: Generate API documentation run: | chmod +x scripts/generate-api-docs.sh ./scripts/generate-api-docs.sh - name: Upload documentation artifacts uses: actions/upload-artifact@v3 with: name: api-documentation path: | docs/ generated/ - name: Deploy to GitHub Pages if: github.ref == \u0026#39;refs/heads/main\u0026#39; uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./docs 3. Docker 整合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Dockerfile.docs FROM openjdk:17-jdk-slim as builder WORKDIR /app COPY . . RUN ./mvnw clean package -DskipTests FROM node:18-alpine as docs-generator WORKDIR /app # 安裝文檔生成工具 RUN npm install -g @redocly/openapi-cli widdershins @openapitools/openapi-generator-cli # 複製應用程式 COPY --from=builder /app/target/*.jar app.jar # 生成文檔的腳本 COPY scripts/generate-docs-docker.sh . RUN chmod +x generate-docs-docker.sh EXPOSE 8080 CMD [\u0026#34;./generate-docs-docker.sh\u0026#34;] 效能優化與最佳實踐 1. 大型 API 的文檔優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @Configuration public class OpenApiPerformanceConfiguration { @Bean @ConditionalOnProperty(name = \u0026#34;springdoc.api-docs.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public OpenApiCustomiser openApiCustomiser() { return openApi -\u0026gt; { // 移除不必要的 Schema removeUnusedSchemas(openApi); // 簡化複雜的嵌套對象 simplifyNestedObjects(openApi); // 添加快取頭 addCacheHeaders(openApi); }; } private void removeUnusedSchemas(OpenAPI openApi) { if (openApi.getComponents() != null \u0026amp;\u0026amp; openApi.getComponents().getSchemas() != null) { Set\u0026lt;String\u0026gt; usedSchemas = findUsedSchemas(openApi); openApi.getComponents().getSchemas().entrySet() .removeIf(entry -\u0026gt; !usedSchemas.contains(entry.getKey())); } } private Set\u0026lt;String\u0026gt; findUsedSchemas(OpenAPI openApi) { Set\u0026lt;String\u0026gt; usedSchemas = new HashSet\u0026lt;\u0026gt;(); if (openApi.getPaths() != null) { openApi.getPaths().values().forEach(pathItem -\u0026gt; { Stream.of( pathItem.getGet(), pathItem.getPost(), pathItem.getPut(), pathItem.getDelete(), pathItem.getPatch() ).filter(Objects::nonNull) .forEach(operation -\u0026gt; collectUsedSchemas(operation, usedSchemas)); }); } return usedSchemas; } private void collectUsedSchemas(Operation operation, Set\u0026lt;String\u0026gt; usedSchemas) { // 從請求體收集 if (operation.getRequestBody() != null \u0026amp;\u0026amp; operation.getRequestBody().getContent() != null) { operation.getRequestBody().getContent().values() .forEach(mediaType -\u0026gt; collectSchemaRefs(mediaType.getSchema(), usedSchemas)); } // 從回應收集 if (operation.getResponses() != null) { operation.getResponses().values().forEach(response -\u0026gt; { if (response.getContent() != null) { response.getContent().values() .forEach(mediaType -\u0026gt; collectSchemaRefs(mediaType.getSchema(), usedSchemas)); } }); } } private void collectSchemaRefs(Schema\u0026lt;?\u0026gt; schema, Set\u0026lt;String\u0026gt; usedSchemas) { if (schema != null) { if (schema.get$ref() != null) { String schemaName = schema.get$ref().substring(\u0026#34;#/components/schemas/\u0026#34;.length()); usedSchemas.add(schemaName); } // 遞迴處理嵌套 Schema if (schema.getProperties() != null) { schema.getProperties().values().forEach(prop -\u0026gt; collectSchemaRefs((Schema\u0026lt;?\u0026gt;) prop, usedSchemas)); } } } } 2. 快取策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @RestController @RequestMapping(\u0026#34;/api-docs\u0026#34;) public class CachedApiDocsController { private final SpringDocConfigProperties springDocConfigProperties; private final ObjectMapper objectMapper; private final Cache\u0026lt;String, String\u0026gt; apiDocsCache; public CachedApiDocsController( SpringDocConfigProperties springDocConfigProperties, ObjectMapper objectMapper ) { this.springDocConfigProperties = springDocConfigProperties; this.objectMapper = objectMapper; this.apiDocsCache = Caffeine.newBuilder() .maximumSize(10) .expireAfterWrite(Duration.ofMinutes(30)) .build(); } @GetMapping( value = \u0026#34;/{group}\u0026#34;, produces = MediaType.APPLICATION_JSON_VALUE ) public ResponseEntity\u0026lt;String\u0026gt; getCachedApiDocs( @PathVariable String group, HttpServletRequest request ) { String cacheKey = group + \u0026#34;_\u0026#34; + getVersionHash(); String cachedDocs = apiDocsCache.get(cacheKey, key -\u0026gt; { // 生成文檔的邏輯 return generateApiDocs(group); }); return ResponseEntity.ok() .cacheControl(CacheControl.maxAge(Duration.ofHours(1))) .eTag(calculateETag(cachedDocs)) .body(cachedDocs); } private String getVersionHash() { // 基於應用程式版本和配置生成雜湊 String version = getClass().getPackage().getImplementationVersion(); return DigestUtils.md5Hex(version != null ? version : \u0026#34;dev\u0026#34;); } private String calculateETag(String content) { return \u0026#34;\\\u0026#34;\u0026#34; + DigestUtils.md5Hex(content) + \u0026#34;\\\u0026#34;\u0026#34;; } } 3. 環境配置最佳實踐 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # application-dev.yml springdoc: api-docs: enabled: true swagger-ui: enabled: true try-it-out-enabled: true operations-sorter: method tags-sorter: alpha display-request-duration: true doc-expansion: list default-models-expand-depth: 2 # application-prod.yml springdoc: api-docs: enabled: false # 生產環境關閉 swagger-ui: enabled: false # 生產環境關閉 # application-staging.yml springdoc: api-docs: enabled: true swagger-ui: enabled: true try-it-out-enabled: false # 測試環境禁止直接測試 監控與分析 1. API 使用情況追蹤 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Component public class ApiUsageTracker { private final MeterRegistry meterRegistry; private final Counter apiCallsCounter; private final Timer apiResponseTimer; public ApiUsageTracker(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; this.apiCallsCounter = Counter.builder(\u0026#34;api.calls\u0026#34;) .description(\u0026#34;API 呼叫次數\u0026#34;) .register(meterRegistry); this.apiResponseTimer = Timer.builder(\u0026#34;api.response.time\u0026#34;) .description(\u0026#34;API 回應時間\u0026#34;) .register(meterRegistry); } @EventListener public void trackApiCall(ApiCallEvent event) { apiCallsCounter .tag(\u0026#34;endpoint\u0026#34;, event.getEndpoint()) .tag(\u0026#34;method\u0026#34;, event.getMethod()) .tag(\u0026#34;status\u0026#34;, String.valueOf(event.getStatusCode())) .increment(); apiResponseTimer .tag(\u0026#34;endpoint\u0026#34;, event.getEndpoint()) .record(event.getResponseTime(), TimeUnit.MILLISECONDS); } } @RestController @RequestMapping(\u0026#34;/api/v1/analytics\u0026#34;) @Tag(name = \u0026#34;API Analytics\u0026#34;, description = \u0026#34;API 使用情況分析\u0026#34;) public class ApiAnalyticsController { private final MeterRegistry meterRegistry; public ApiAnalyticsController(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; } @GetMapping(\u0026#34;/metrics\u0026#34;) @Operation(summary = \u0026#34;獲取 API 使用統計\u0026#34;) public ResponseEntity\u0026lt;ApiMetrics\u0026gt; getApiMetrics() { Map\u0026lt;String, Double\u0026gt; endpointCalls = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;String, Double\u0026gt; averageResponseTimes = new HashMap\u0026lt;\u0026gt;(); meterRegistry.getMeters().forEach(meter -\u0026gt; { if (meter instanceof Counter counter \u0026amp;\u0026amp; meter.getId().getName().equals(\u0026#34;api.calls\u0026#34;)) { String endpoint = meter.getId().getTag(\u0026#34;endpoint\u0026#34;); endpointCalls.put(endpoint, counter.count()); } if (meter instanceof Timer timer \u0026amp;\u0026amp; meter.getId().getName().equals(\u0026#34;api.response.time\u0026#34;)) { String endpoint = meter.getId().getTag(\u0026#34;endpoint\u0026#34;); averageResponseTimes.put(endpoint, timer.mean(TimeUnit.MILLISECONDS)); } }); ApiMetrics metrics = new ApiMetrics(endpointCalls, averageResponseTimes); return ResponseEntity.ok(metrics); } } 總結 Swagger/OpenAPI 是現代 API 開發的必備工具，提供了從文檔生成到測試、監控的完整解決方案。透過本文的深入介紹，我們了解到：\n核心價值 自動化文檔：減少手動維護成本，確保文檔與程式碼同步 互動式測試：提供友善的 API 測試介面 團隊協作：統一的 API 規範促進前後端協作 程式碼生成：支援多種語言的客戶端 SDK 自動生成 最佳實踐要點 選擇 OpenAPI 3.0：使用最新標準和工具鏈 完整的註解：提供詳細的描述、範例和驗證規則 安全整合：正確配置認證和授權機制 效能優化：適當的快取和文檔分組策略 CI/CD 整合：自動化文檔生成和部署流程 進階應用 契約測試和 API 治理 多環境配置和版本管理 監控和分析 API 使用情況 與微服務架構的整合 正確實施 Swagger/OpenAPI 不僅能提升開發效率，還能建立標準化的 API 開發流程，為團隊帶來長期的技術價值。\n參考資料 OpenAPI Specification SpringDoc OpenAPI Spring Boot OpenAPI Integration OpenAPI Generator Swagger UI Configuration ","permalink":"https://xinqilin.github.io/post/backend/swagger2/","tags":["Java","Spring","Swagger","OpenAPI","API","Documentation","SpringBoot","REST"],"title":"Swagger/OpenAPI 完整指南：API 文檔化與測試最佳實踐"},{"content":"RestTemplate 一般比較常用的 rest 服務，有的人自己公司可能會 base 在 OKHttp 上 包一層 HttpHelper/ HttpUtil 之類的方便使用，但在之前公司，有自己開發一個 microservice module 時 ，我一開始是選用 RestTemplate，這邊紀錄一下，未來要用時能直接隨開隨用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //config @Configuration public class RestTemplateConfig { @Bean public RestTemplate restTemplate(ClientHttpRequestFactory factory) { return new RestTemplate(factory); } @Bean public ClientHttpRequestFactory simpleClientHttpRequestFactory() { SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); factory.setReadTimeout(3000); factory.setConnectTimeout(3000); return factory; } } 注入 1 2 3 4 5 6 7 8 9 10 11 private final RestTemplate restTemplate; public XXService(RestTemplate restTemplate) { this.restTemplate = restTemplate; } //==============我是分隔線================ @AuroWired RestTemplate restTemplate; 使用 exchange 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 第一個直接開門見山，最常用的 exchange，先點進去看 override 有甚麼不同的參數 public \u0026lt;T\u0026gt; org.springframework.http.ResponseEntity\u0026lt;T\u0026gt; exchange(java.lang.String url, org.springframework.http.HttpMethod method, @org.springframework.lang.Nullable org.springframework.http.HttpEntity\u0026lt;?\u0026gt; requestEntity, java.lang.Class\u0026lt;T\u0026gt; responseType, java.lang.Object... uriVariables) throws org.springframework.web.client.RestClientException { /* compiled code */ } public \u0026lt;T\u0026gt; org.springframework.http.ResponseEntity\u0026lt;T\u0026gt; exchange(java.lang.String url, org.springframework.http.HttpMethod method, @org.springframework.lang.Nullable org.springframework.http.HttpEntity\u0026lt;?\u0026gt; requestEntity, java.lang.Class\u0026lt;T\u0026gt; responseType, java.util.Map\u0026lt;java.lang.String,?\u0026gt; uriVariables) throws org.springframework.web.client.RestClientException { /* compiled code */ } public \u0026lt;T\u0026gt; org.springframework.http.ResponseEntity\u0026lt;T\u0026gt; exchange(java.net.URI url, org.springframework.http.HttpMethod method, @org.springframework.lang.Nullable org.springframework.http.HttpEntity\u0026lt;?\u0026gt; requestEntity, java.lang.Class\u0026lt;T\u0026gt; responseType) throws org.springframework.web.client.RestClientException { /* compiled code */ } public \u0026lt;T\u0026gt; org.springframework.http.ResponseEntity\u0026lt;T\u0026gt; exchange(java.lang.String url, org.springframework.http.HttpMethod method, @org.springframework.lang.Nullable org.springframework.http.HttpEntity\u0026lt;?\u0026gt; requestEntity, org.springframework.core.ParameterizedTypeReference\u0026lt;T\u0026gt; responseType, java.lang.Object... uriVariables) throws org.springframework.web.client.RestClientException { /* compiled code */ } public \u0026lt;T\u0026gt; org.springframework.http.ResponseEntity\u0026lt;T\u0026gt; exchange(java.lang.String url, org.springframework.http.HttpMethod method, @org.springframework.lang.Nullable org.springframework.http.HttpEntity\u0026lt;?\u0026gt; requestEntity, org.springframework.core.ParameterizedTypeReference\u0026lt;T\u0026gt; responseType, java.util.Map\u0026lt;java.lang.String,?\u0026gt; uriVariables) throws org.springframework.web.client.RestClientException { /* compiled code */ } public \u0026lt;T\u0026gt; org.springframework.http.ResponseEntity\u0026lt;T\u0026gt; exchange(java.net.URI url, org.springframework.http.HttpMethod method, @org.springframework.lang.Nullable org.springframework.http.HttpEntity\u0026lt;?\u0026gt; requestEntity, org.springframework.core.ParameterizedTypeReference\u0026lt;T\u0026gt; responseType) throws org.springframework.web.client.RestClientException { /* compiled code */ } public \u0026lt;T\u0026gt; org.springframework.http.ResponseEntity\u0026lt;T\u0026gt; exchange(org.springframework.http.RequestEntity\u0026lt;?\u0026gt; entity, java.lang.Class\u0026lt;T\u0026gt; responseType) throws org.springframework.web.client.RestClientException { /* compiled code */ } public \u0026lt;T\u0026gt; org.springframework.http.ResponseEntity\u0026lt;T\u0026gt; exchange(org.springframework.http.RequestEntity\u0026lt;?\u0026gt; entity, org.springframework.core.ParameterizedTypeReference\u0026lt;T\u0026gt; responseType) throws org.springframework.web.client.RestClientException { /* compiled code */ } //大致上來說，其實我自己最常用的是 //回來的是一個 mapperObject (String url, HttpMethod method, HttpEntity\u0026lt;?\u0026gt; requestEntity, Class\u0026lt;T\u0026gt; responseType) //回來的是一個 List\u0026lt;mapperObject\u0026gt; (String url, HttpMethod method, HttpEntity\u0026lt;?\u0026gt; requestEntity, ParameterizedTypeReference\u0026lt;T\u0026gt; new ParameterizedTypeReference\u0026lt;List\u0026lt;東西\u0026gt;\u0026gt;\u0026gt;() {}) //這兩個 // exchange 偷懶法 //沒用特定 POJO 使用 JSONObject JSONObject jsonObj = new JSONObject(); jsonObj.put(\u0026#34;start\u0026#34;,1); jsonObj.put(\u0026#34;page\u0026#34;,5); HttpEntity\u0026lt;String\u0026gt; entity = new HttpEntity\u0026lt;\u0026gt;(jsonObj.toString(), headers); ResponseEntity\u0026lt;JSONObject\u0026gt; exchange = restTemplate.exchange(url, HttpMethod.GET, entity, JSONObject.class); System.out.println(exchange.getBody()); get 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 在來是 Get 請求 中 最常用的 ( 如果不用 exchange 的話) // getForObject() 在裡面做 反序列化，所以不再自己處理 HTTP 回來的 ResponseEntity objectMapper to JavaObject的動作 而 getForEntity() 則要自己處理 public \u0026lt;T\u0026gt; T getForObject(String url, Class\u0026lt;T\u0026gt; responseType, Object... uriVariables){} public \u0026lt;T\u0026gt; T getForObject(String url, Class\u0026lt;T\u0026gt; responseType, Map\u0026lt;String, ?\u0026gt; uriVariables) public \u0026lt;T\u0026gt; T getForObject(URI url, Class\u0026lt;T\u0026gt; responseType) public \u0026lt;T\u0026gt; ResponseEntity\u0026lt;T\u0026gt; getForEntity(String url, Class\u0026lt;T\u0026gt; responseType, Object... uriVariables){} public \u0026lt;T\u0026gt; ResponseEntity\u0026lt;T\u0026gt; getForEntity(String url, Class\u0026lt;T\u0026gt; responseType, Map\u0026lt;String, ?\u0026gt; uriVariables){} public \u0026lt;T\u0026gt; ResponseEntity\u0026lt;T\u0026gt; getForEntity(URI url, Class\u0026lt;T\u0026gt; responseType){} //uriVariables 是用來帶在url上的參數用的 restTemplate.getForEntity(\u0026#34;http://bill_domain/{1}/{2}\u0026#34;, BillResponse.class,1,5); // Map\u0026lt;String, ?\u0026gt; uriVariables 使用 Map\u0026lt;String,String\u0026gt; map = new HashMap(); map.put(\u0026#34;start\u0026#34;,\u0026#34;1\u0026#34;); map.put(\u0026#34;page\u0026#34;,\u0026#34;5\u0026#34;); restTemplate.getForObject(\u0026#34;http://bill_domain/{1}/{2}\u0026#34;, BillResponse.class, map); post 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public \u0026lt;T\u0026gt; T postForObject(String url, @Nullable Object request, Class\u0026lt;T\u0026gt; responseType, Object... uriVariables) throws RestClientException {} public \u0026lt;T\u0026gt; T postForObject(String url, @Nullable Object request, Class\u0026lt;T\u0026gt; responseType, Map\u0026lt;String, ?\u0026gt; uriVariables) throws RestClientException {} public \u0026lt;T\u0026gt; T postForObject(URI url, @Nullable Object request, Class\u0026lt;T\u0026gt; responseType) throws RestClientException {} //這邊沒問題跟上面一樣 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); //重點來了 MultiValueMap ??? MultiValueMap\u0026lt;String, String\u0026gt; map= new LinkedMultiValueMap\u0026lt;\u0026gt;(); map.add(\u0026#34;email\u0026#34;, \u0026#34;bill@gmail.com\u0026#34;); HttpEntity\u0026lt;MultiValueMap\u0026lt;String, String\u0026gt;\u0026gt; request = new HttpEntity\u0026lt;\u0026gt;(map, headers); restTemplate.postForEntity( url, request , String.class ); ","permalink":"https://xinqilin.github.io/post/backend/resttemplate/","tags":["Spring","RestTemplate","HTTP Client","Java","Web Service","REST API"],"title":"Spring RestTemplate 完整使用指南：HTTP 客戶端操作與配置實戰"},{"content":"前言 在現代軟體開發中，設定檔是不可或缺的一環。從 Java 的 Spring Boot 框架 (Spring MVC 過往使用大量的 XML)，到我目前使用的 Hugo 靜態網站產生器，都能看到 .properties、.yml 或 .toml 等格式的身影。\n雖然這些格式各有優勢，但在雲原生領域，特別是設定 Kubernetes (K8s) 資源時，YAML (YAML Ain\u0026rsquo;t Markup Language) 已成為事實上的標準。因此，掌握 YAML 的語法至關重要。\n核心語法 YAML 的設計目標是易於人類閱讀和撰寫。它的語法主要基於縮排和幾個簡單的符號。\n註解: 使用 # 號標示單行註解。 文件開頭: 使用三個連字號 --- 作為文件的開始符號 (選用)。 鍵值對 (Key-Value Pair) YAML 的基本組成單位是鍵值對，格式為 key: value (注意冒號後面需要一個空格)。\n1 apiVersion: v1 階層/物件 (Objects) 透過換行和縮排 (建議使用兩個空格) 來表示階層關係。這在 JSON 中相當於一個物件。\n以下範例等同於 spring.datasource.username = \u0026quot;root\u0026quot;。\n1 2 3 spring: datasource: username: root 陣列/列表 (Arrays/Lists) 陣列有兩種常見的表示方式：\n塊序列 (Block Sequence): 透過換行、縮排，並在每個元素前加上 - (連字號 + 空格) 來表示。這種形式更易讀，且元素可以是複雜的物件。\n1 2 3 args: - \u0026#34;parameter1\u0026#34; - \u0026#34;parameter2\u0026#34; 流序列 (Flow Sequence): 將所有元素放在方括號 [] 中，並用逗號分隔。適合表示簡單的一維陣列。\n1 2 items: [1, 2, 3, 4, 5] args: [\u0026#34;parameter1\u0026#34;, \u0026#34;parameter2\u0026#34;] 綜合範例 讓我們來看一個更完整的範例，這個範例來自 CloudBees YAML Tutorial。\nYAML 格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --- doe: \u0026#34;a deer, a female deer\u0026#34; ray: \u0026#34;a drop of golden sun\u0026#34; pi: 3.14159 xmas: true french-hens: 3 calling-birds: - huey - dewey - louie - fred xmas-fifth-day: calling-birds: four french-hens: 3 golden-rings: 5 partridges: count: 1 location: \u0026#34;a pear tree\u0026#34; turtle-doves: two 等效的 JSON 格式 這個 YAML 結構可以完全對應到以下的 JSON 物件，展示了其清晰的資料表達能力。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \u0026#34;doe\u0026#34;: \u0026#34;a deer, a female deer\u0026#34;, \u0026#34;ray\u0026#34;: \u0026#34;a drop of golden sun\u0026#34;, \u0026#34;pi\u0026#34;: 3.14159, \u0026#34;xmas\u0026#34;: true, \u0026#34;french-hens\u0026#34;: 3, \u0026#34;calling-birds\u0026#34;: [ \u0026#34;huey\u0026#34;, \u0026#34;dewey\u0026#34;, \u0026#34;louie\u0026#34;, \u0026#34;fred\u0026#34; ], \u0026#34;xmas-fifth-day\u0026#34;: { \u0026#34;calling-birds\u0026#34;: \u0026#34;four\u0026#34;, \u0026#34;french-hens\u0026#34;: 3, \u0026#34;golden-rings\u0026#34;: 5, \u0026#34;partridges\u0026#34;: { \u0026#34;count\u0026#34;: 1, \u0026#34;location\u0026#34;: \u0026#34;a pear tree\u0026#34; }, \u0026#34;turtle-doves\u0026#34;: \u0026#34;two\u0026#34; } } 參考資料 CloudBees YAML Tutorial 菜鳥教程 - YAML 簡介 ","permalink":"https://xinqilin.github.io/post/tools/yaml/","tags":["YAML","Configuration","Kubernetes","Spring Boot","DevOps"],"title":"YAML 語法從入門到實踐"},{"content":"MergeSort Time complexity = log n * O(n) = O(n logn)\nMergeSort 套一句柯P 講的話，小問題解決了，就沒有大問題了\n將 n 個個數的陣列，先左右各切一半，一直切，切到最小單位後，開始拿兩條被切的單位做排序、合併 ! 合久必分，分久必合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import java.util.*; public class MergeSort { public static void mergeSort(int[] array) { int[] workArray = new int[array.length]; Sort(array, workArray, 0, array.length - 1); } private static void Sort(int[] array, int[] workArray, int start, int end) { if (start \u0026gt;= end) return; //避免溢位 start + end 可能超出去 int mid = start + (end - start)/2; Sort(array, workArray, start, mid); Sort(array, workArray, mid+1, end); Merge(array, workArray, start, mid, mid+1, end); } private static void Merge(int[] array, int[] workArray, int leftStart, int leftEnd, int rightStart, int rightEnd) { int leftPtr = leftStart, rightPtr = rightStart, index = leftStart; while (leftPtr \u0026lt;= leftEnd || rightPtr \u0026lt;= rightEnd) { if (leftPtr \u0026lt;= leftEnd \u0026amp;\u0026amp; rightPtr \u0026lt;= rightEnd) { //最後一排 if (array[rightPtr] \u0026lt; array[leftPtr]) workArray[index] = array[rightPtr++]; else workArray[index] = array[leftPtr++]; } else if (leftPtr \u0026lt;= leftEnd){ // 左邊排序 workArray[index] = array[leftPtr++]; }else{ // 右邊排序 workArray[index] = array[rightPtr++]; } ++index; } for (int i = leftStart; i \u0026lt; index; i++) array[i] = workArray[i]; } public static void main(String[] args) { int[] data = new int[10]; for (int i = 0; i \u0026lt; data.length; i++) { data[i] = (int) (Math.random() * 100); } System.out.println(\u0026#34;before: \u0026#34; + Arrays.toString(data)); mergeSort(data); System.out.println(\u0026#34;after: \u0026#34; + Arrays.toString(data)); } } ![MergeSortResult](images/Algorithm/mergeSort/mergeSortResult.png) 演算法序列，會用來記錄算法，再用自己或其他人寫的 code 我能吸收的做紀錄，目的是讓自己能多看，然後背起來\n","permalink":"https://xinqilin.github.io/post/algorithm/mergesort/","tags":["Java","Algorithm"],"title":"MergeSort"},{"content":"CQRS (Command Query Responsibility Segregation) Command: 命令 會對系統產生『影響』的動作 沒有『結果』回傳 Query: 查詢 不會對系統產生『影響』的動作 會回傳『結果』 CQS 原則的限制 當查詢所回傳的結果只有短暫的存在意義時便不適用 =\u0026gt; Queue.poll(), Stack.pop()\nCQS: 適用於方法 CQRS: 適用於模型類別\nEvent Sourcing 1 事件源（Event Sourcing）常與 CQRS 一併提及，此設計模式的用意，根據 Martin Fowler 的說法，是要讓應用程式能夠將異動資料的事件按照發生的時間順序全部記錄下來；如此一來，我們不只能夠查詢過去任意時間點的資料狀態，也能夠重現特定時間範圍之間所發生的事件過程。比如說，採用 Event Sourcing 的銀行交易系統可以讓使用者得知帳戶餘額是如何變成目前的狀態的。Event Sourcing 常與 CQRS 一起搭配運用，但採用 CQRS 模式的應用程式並不一定需要使用 Event Sourcing。 reference: huanlintalk\n","permalink":"https://xinqilin.github.io/post/architecture/cqrs/","tags":[],"title":"CQRS"},{"content":"Map Sort by value 有鑑於 Bill 上上週在刷 LC 時 題目點我!\n很簡單的排序問題，那時我的想法是先掃過一次，存 Map\u0026lt;String 字，Integer 字的長度\u0026gt; 然後在排序 Map Value 後 得到答案 但那時我心中想到的 map value 排序蠻麻煩的，這邊先記錄一下後來比較乾淨一點的寫法，以防之後忘記\n1 2 3 4 5 6 7 8 // 掃第一次 Map\u0026lt;String,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for(String s: words){ map.put(s, map.getOrDefault(s, 0) + 1); } 排序方法: 1 2 3 4 5 6 7 8 9 List\u0026lt;Map.Entry\u0026lt;String, Integer\u0026gt;\u0026gt; list = new ArrayList(map.entrySet()); Collections.sort(list, new Comparator\u0026lt;Map.Entry\u0026lt;String, Integer\u0026gt;\u0026gt;() { @Override public int compare(Map.Entry\u0026lt;String, Integer\u0026gt; e1, Map.Entry\u0026lt;String, Integer\u0026gt; e2) { return e2.getValue().compareTo(e1.getValue()); } }); 這個跟上面的幾乎一樣，一個是 list 存 Map.Entry 在排序器中拿 Entry 出來比，另一個存 map key 然後每次都從 map 掃一次拿 value 出來比\n1 2 3 4 5 6 7 8 9 10 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(map.keySet()); Collections.sort(list,new Comparator\u0026lt;String\u0026gt;(){ public int compare(String s1, String s2){ int length = map.get(s2) - map.get(s1); if(length != 0) return length; return s1.compareTo(s2); } }); 最後 lambda 寫法\n1 2 3 4 5 6 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(map.keySet()); Collections.sort(list, (s1, s2)-\u0026gt; { return (map.get(s2) == map.get(s1)) ? s1.compareTo(s2) : (map.get(s2)- map.get(s1)); }); ","permalink":"https://xinqilin.github.io/post/backend/map-sort-by-value/","tags":["Java","Map","Sorting","Collections","Stream API","Performance"],"title":"Java Map 按 Value 排序：多種實作方式與效能比較"},{"content":"Git tag\n1 2 3 4 5 6 7 8 9 git tag deploy/{env_name}/{feature_name} git push origin deploy/{env_name}/{feature_name} git tag -d/--delete deploy/{env_name}/{feature_name} git push origin --delete deploy/{env_name}/{feature_name} git push origin :{tagname} git describe --always HEAD remote info\n1 2 git remote show origin ","permalink":"https://xinqilin.github.io/post/tools/git/","tags":[],"title":"Git"},{"content":"概述 dig（Domain Information Groper）是一個功能強大的命令行 DNS 查詢工具，用於執行 DNS 查詢並顯示詳細的查詢結果。它是網路管理員、系統管理員和開發者進行 DNS 診斷、網路故障排除和域名解析分析的必備工具。\n核心特徵 靈活的查詢選項：支援各種 DNS 記錄類型查詢 詳細的輸出資訊：提供完整的 DNS 響應詳情 多種輸出格式：支援簡潔、詳細和自訂格式 強大的診斷功能：追蹤查詢路徑和效能分析 腳本友好：適合自動化和批次處理 安裝與環境準備 各系統安裝方法 1 2 3 4 5 6 7 8 9 10 11 12 # Ubuntu/Debian sudo apt-get install dnsutils # CentOS/RHEL/Fedora sudo yum install bind-utils # CentOS 7 及以下 sudo dnf install bind-utils # Fedora/CentOS 8+ # macOS (通常已預裝) brew install bind # 驗證安裝 dig -v 基本語法 1 dig [@server] [domain] [type] [options] 基本使用 簡單 DNS 查詢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 基本查詢（A 記錄） dig google.com # 指定記錄類型 dig google.com A dig google.com AAAA dig google.com MX dig google.com NS dig google.com TXT # 簡潔輸出 dig google.com +short # 只顯示答案部分 dig google.com +noall +answer 查詢結果解析 標準 dig 輸出包含以下部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 dig www.google.com ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.16.1 \u0026lt;\u0026lt;\u0026gt;\u0026gt; www.google.com ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 12345 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: # 查詢問題 ;www.google.com. IN A ;; ANSWER SECTION: # 查詢答案 www.google.com. 299 IN A 142.250.191.68 ;; Query time: 15 msec # 查詢時間 ;; SERVER: 8.8.8.8#53(8.8.8.8) # DNS 伺服器 ;; WHEN: Mon Jan 08 21:40:50 CST 2024 ;; MSG SIZE rcvd: 59 # 響應大小 DNS 記錄類型查詢 A 和 AAAA 記錄 1 2 3 4 5 6 7 8 9 10 # IPv4 地址記錄（A） dig example.com A dig example.com A +short # IPv6 地址記錄（AAAA） dig example.com AAAA dig example.com AAAA +short # 同時查詢 A 和 AAAA dig example.com A AAAA MX 記錄（郵件交換） 1 2 3 4 5 6 7 8 9 # 查詢郵件伺服器 dig google.com MX dig google.com MX +short # 查詢特定域名的郵件配置 dig gmail.com MX +noall +answer # 顯示優先級和郵件伺服器 dig yahoo.com MX | grep -E \u0026#34;^[^;].*MX\u0026#34; NS 記錄（名稱伺服器） 1 2 3 4 5 6 7 8 9 # 查詢域名伺服器 dig google.com NS dig google.com NS +short # 查詢根域名伺服器 dig . NS +short # 查詢特定 TLD 的名稱伺服器 dig com NS +short TXT 記錄（文本記錄） 1 2 3 4 5 6 7 8 9 10 11 12 # 查詢 TXT 記錄 dig google.com TXT dig google.com TXT +short # 查詢 SPF 記錄 dig _spf.google.com TXT # 查詢 DKIM 記錄 dig selector1._domainkey.example.com TXT # 查詢 DMARC 記錄 dig _dmarc.example.com TXT SOA 記錄（授權起始） 1 2 3 4 5 6 # 查詢 SOA 記錄 dig google.com SOA dig google.com SOA +short # 詳細 SOA 信息 dig google.com SOA +noall +answer +multiline CNAME 記錄（別名） 1 2 3 4 5 6 # 查詢 CNAME 記錄 dig www.github.com CNAME dig www.github.com CNAME +short # 追蹤 CNAME 鏈 dig www.example.com +trace PTR 記錄（反向查詢） 1 2 3 4 5 6 7 8 9 # 反向 DNS 查詢 dig -x 8.8.8.8 dig -x 8.8.8.8 +short # 手動 PTR 查詢 dig 8.8.8.8.in-addr.arpa PTR # IPv6 反向查詢 dig -x 2001:4860:4860::8888 進階查詢選項 指定 DNS 伺服器 1 2 3 4 5 6 7 8 9 10 # 使用 Google DNS dig @8.8.8.8 google.com # 使用 Cloudflare DNS dig @1.1.1.1 google.com # 使用多個 DNS 伺服器比較 dig @8.8.8.8 google.com +short dig @1.1.1.1 google.com +short dig @208.67.222.222 google.com +short # OpenDNS 查詢追蹤 1 2 3 4 5 6 7 8 9 10 11 # 追蹤 DNS 解析路徑 dig google.com +trace # 追蹤特定記錄類型 dig google.com MX +trace # 簡化追蹤輸出 dig google.com +trace +short # 追蹤並顯示所有步驟 dig google.com +trace +additional +all 輸出格式控制 1 2 3 4 5 6 7 8 9 10 11 12 # 簡潔輸出 dig google.com +short dig google.com +noall +answer # 多行格式化輸出 dig google.com SOA +multiline # 隱藏特定部分 dig google.com +nocomments +noquestion +noauthority +noadditional +nostats # 自訂輸出組合 dig google.com +nocmd +noall +answer +multiline 網路診斷與故障排除 DNS 效能測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 測量查詢時間 dig google.com | grep \u0026#34;Query time\u0026#34; # 批次效能測試 for i in {1..10}; do dig google.com +stats | grep \u0026#34;Query time\u0026#34; done # 比較不同 DNS 伺服器效能 dns_servers=(\u0026#34;8.8.8.8\u0026#34; \u0026#34;1.1.1.1\u0026#34; \u0026#34;208.67.222.222\u0026#34;) for server in \u0026#34;${dns_servers[@]}\u0026#34;; do echo \u0026#34;Testing $server:\u0026#34; dig @$server google.com +stats | grep \u0026#34;Query time\u0026#34; done DNS 快取分析 1 2 3 4 5 6 7 8 # 檢查 TTL 值 dig google.com +noall +answer # 監控 TTL 變化 watch -n 5 \u0026#39;dig google.com +noall +answer\u0026#39; # 檢查快取狀態 dig google.com +norecurse 域名可用性檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 檢查域名是否存在 dig example.com ANY +short # 檢查域名狀態 dig example.com +short \u0026gt; /dev/null \u0026amp;\u0026amp; echo \u0026#34;Domain exists\u0026#34; || echo \u0026#34;Domain not found\u0026#34; # 批次域名檢查 domains=(\u0026#34;google.com\u0026#34; \u0026#34;example.com\u0026#34; \u0026#34;nonexistent-domain-12345.com\u0026#34;) for domain in \u0026#34;${domains[@]}\u0026#34;; do if dig \u0026#34;$domain\u0026#34; +short \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;$domain: EXISTS\u0026#34; else echo \u0026#34;$domain: NOT FOUND\u0026#34; fi done DNSSEC 驗證 1 2 3 4 5 6 7 8 9 10 11 # 檢查 DNSSEC 支援 dig google.com +dnssec +multiline # 驗證 DNSSEC 簽名 dig google.com DNSKEY +dnssec # 檢查 DS 記錄 dig google.com DS +dnssec # 驗證鏈 dig +trace +dnssec google.com 實戰應用場景 1. 郵件伺服器診斷 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/bin/bash # mail_server_check.sh - 郵件伺服器診斷腳本 check_mail_server() { local domain=\u0026#34;$1\u0026#34; echo \u0026#34;=== Mail Server Diagnosis for $domain ===\u0026#34; # 檢查 MX 記錄 echo \u0026#34;MX Records:\u0026#34; dig \u0026#34;$domain\u0026#34; MX +noall +answer # 檢查 SPF 記錄 echo -e \u0026#34;\\nSPF Record:\u0026#34; dig \u0026#34;$domain\u0026#34; TXT +short | grep -i spf # 檢查 DMARC 記錄 echo -e \u0026#34;\\nDMARC Record:\u0026#34; dig \u0026#34;_dmarc.$domain\u0026#34; TXT +short # 檢查常見 DKIM 選擇器 echo -e \u0026#34;\\nDKIM Records:\u0026#34; selectors=(\u0026#34;default\u0026#34; \u0026#34;selector1\u0026#34; \u0026#34;selector2\u0026#34; \u0026#34;google\u0026#34; \u0026#34;k1\u0026#34;) for selector in \u0026#34;${selectors[@]}\u0026#34;; do result=$(dig \u0026#34;${selector}._domainkey.$domain\u0026#34; TXT +short 2\u0026gt;/dev/null) if [ -n \u0026#34;$result\u0026#34; ]; then echo \u0026#34;$selector: $result\u0026#34; fi done } # 使用範例 check_mail_server \u0026#34;gmail.com\u0026#34; 2. 網站可用性監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #!/bin/bash # website_dns_monitor.sh - 網站 DNS 監控腳本 monitor_website() { local domain=\u0026#34;$1\u0026#34; local log_file=\u0026#34;${2:-dns_monitor.log}\u0026#34; timestamp=$(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;) # 檢查 A 記錄 a_record=$(dig \u0026#34;$domain\u0026#34; A +short | head -1) # 檢查 AAAA 記錄 aaaa_record=$(dig \u0026#34;$domain\u0026#34; AAAA +short | head -1) # 測量查詢時間 query_time=$(dig \u0026#34;$domain\u0026#34; | grep \u0026#34;Query time\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) # 檢查 DNS 伺服器響應 dns_server=$(dig \u0026#34;$domain\u0026#34; | grep \u0026#34;SERVER:\u0026#34; | awk \u0026#39;{print $2}\u0026#39;) # 記錄結果 log_entry=\u0026#34;$timestamp | $domain | A: $a_record | AAAA: $aaaa_record | Time: ${query_time}ms | Server: $dns_server\u0026#34; echo \u0026#34;$log_entry\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; # 檢查異常 if [ -z \u0026#34;$a_record\u0026#34; ]; then echo \u0026#34;WARNING: No A record found for $domain\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; fi if [ \u0026#34;${query_time:-0}\u0026#34; -gt 1000 ]; then echo \u0026#34;WARNING: Slow DNS response (${query_time}ms) for $domain\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; fi } # 監控多個網站 websites=(\u0026#34;google.com\u0026#34; \u0026#34;github.com\u0026#34; \u0026#34;stackoverflow.com\u0026#34;) for site in \u0026#34;${websites[@]}\u0026#34;; do monitor_website \u0026#34;$site\u0026#34; done 3. DNS 伺服器效能比較 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #!/bin/bash # dns_performance_test.sh - DNS 效能測試腳本 dns_performance_test() { local domain=\u0026#34;${1:-google.com}\u0026#34; local test_count=\u0026#34;${2:-10}\u0026#34; # DNS 伺服器列表 declare -A dns_servers=( [\u0026#34;Google\u0026#34;]=\u0026#34;8.8.8.8\u0026#34; [\u0026#34;Cloudflare\u0026#34;]=\u0026#34;1.1.1.1\u0026#34; [\u0026#34;OpenDNS\u0026#34;]=\u0026#34;208.67.222.222\u0026#34; [\u0026#34;Quad9\u0026#34;]=\u0026#34;9.9.9.9\u0026#34; ) echo \u0026#34;DNS Performance Test for $domain\u0026#34; echo \u0026#34;==================================\u0026#34; for name in \u0026#34;${!dns_servers[@]}\u0026#34;; do server=\u0026#34;${dns_servers[$name]}\u0026#34; echo -e \u0026#34;\\nTesting $name ($server):\u0026#34; total_time=0 successful_queries=0 for i in $(seq 1 $test_count); do query_time=$(dig @\u0026#34;$server\u0026#34; \u0026#34;$domain\u0026#34; +stats 2\u0026gt;/dev/null | grep \u0026#34;Query time\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) if [ -n \u0026#34;$query_time\u0026#34; ]; then total_time=$((total_time + query_time)) successful_queries=$((successful_queries + 1)) echo -n \u0026#34;.\u0026#34; else echo -n \u0026#34;x\u0026#34; fi done if [ $successful_queries -gt 0 ]; then average_time=$((total_time / successful_queries)) echo -e \u0026#34;\\nAverage: ${average_time}ms (${successful_queries}/${test_count} successful)\u0026#34; else echo -e \u0026#34;\\nFailed: No successful queries\u0026#34; fi done } # 執行測試 dns_performance_test \u0026#34;google.com\u0026#34; 5 4. 域名變更追蹤 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #!/bin/bash # dns_change_tracker.sh - DNS 變更追蹤腳本 track_dns_changes() { local domain=\u0026#34;$1\u0026#34; local record_type=\u0026#34;${2:-A}\u0026#34; local interval=\u0026#34;${3:-300}\u0026#34; # 5分鐘 local log_file=\u0026#34;dns_changes_${domain}_${record_type}.log\u0026#34; echo \u0026#34;Tracking DNS changes for $domain ($record_type record)\u0026#34; echo \u0026#34;Log file: $log_file\u0026#34; previous_result=\u0026#34;\u0026#34; while true; do timestamp=$(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;) current_result=$(dig \u0026#34;$domain\u0026#34; \u0026#34;$record_type\u0026#34; +short | sort | tr \u0026#39;\\n\u0026#39; \u0026#39; \u0026#39;) if [ \u0026#34;$current_result\u0026#34; != \u0026#34;$previous_result\u0026#34; ]; then if [ -n \u0026#34;$previous_result\u0026#34; ]; then echo \u0026#34;$timestamp | CHANGE DETECTED\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; echo \u0026#34;$timestamp | Old: $previous_result\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; echo \u0026#34;$timestamp | New: $current_result\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; echo \u0026#34;$timestamp | ---\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; else echo \u0026#34;$timestamp | Initial: $current_result\u0026#34; | tee -a \u0026#34;$log_file\u0026#34; fi previous_result=\u0026#34;$current_result\u0026#34; else echo \u0026#34;$timestamp | No change: $current_result\u0026#34; fi sleep \u0026#34;$interval\u0026#34; done } # 使用範例 # track_dns_changes \u0026#34;example.com\u0026#34; \u0026#34;A\u0026#34; 60 5. 批次域名分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #!/bin/bash # batch_domain_analysis.sh - 批次域名分析腳本 analyze_domains() { local domain_file=\u0026#34;$1\u0026#34; local output_file=\u0026#34;${2:-domain_analysis_$(date +%Y%m%d_%H%M%S).csv}\u0026#34; # CSV 標題 echo \u0026#34;Domain,A_Record,MX_Record,NS_Record,TXT_Count,Query_Time_ms,Status\u0026#34; \u0026gt; \u0026#34;$output_file\u0026#34; while IFS= read -r domain; do # 跳過空行和註解 [[ -z \u0026#34;$domain\u0026#34; || \u0026#34;$domain\u0026#34; =~ ^[[:space:]]*# ]] \u0026amp;\u0026amp; continue echo \u0026#34;Analyzing: $domain\u0026#34; # 查詢各種記錄 a_record=$(dig \u0026#34;$domain\u0026#34; A +short | head -1) mx_record=$(dig \u0026#34;$domain\u0026#34; MX +short | head -1 | awk \u0026#39;{print $2}\u0026#39;) ns_record=$(dig \u0026#34;$domain\u0026#34; NS +short | head -1) txt_count=$(dig \u0026#34;$domain\u0026#34; TXT +short | wc -l) # 測量查詢時間 query_time=$(dig \u0026#34;$domain\u0026#34; | grep \u0026#34;Query time\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) # 判斷狀態 if [ -n \u0026#34;$a_record\u0026#34; ]; then status=\u0026#34;Active\u0026#34; elif dig \u0026#34;$domain\u0026#34; +short \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then status=\u0026#34;Registered\u0026#34; else status=\u0026#34;Not Found\u0026#34; fi # 寫入 CSV echo \u0026#34;$domain,$a_record,$mx_record,$ns_record,$txt_count,$query_time,$status\u0026#34; \u0026gt;\u0026gt; \u0026#34;$output_file\u0026#34; done \u0026lt; \u0026#34;$domain_file\u0026#34; echo \u0026#34;Analysis complete. Results saved to: $output_file\u0026#34; } # 建立範例域名列表 cat \u0026gt; domains.txt \u0026lt;\u0026lt; EOF google.com github.com stackoverflow.com example.com nonexistent-domain-12345.com EOF # 執行分析 analyze_domains \u0026#34;domains.txt\u0026#34; 進階技巧與最佳化 1. 自訂查詢腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #!/bin/bash # dig_wrapper.sh - dig 包裝器腳本 # 彩色輸出 RED=\u0026#39;\\033[0;31m\u0026#39; GREEN=\u0026#39;\\033[0;32m\u0026#39; YELLOW=\u0026#39;\\033[1;33m\u0026#39; BLUE=\u0026#39;\\033[0;34m\u0026#39; NC=\u0026#39;\\033[0m\u0026#39; # No Color enhanced_dig() { local domain=\u0026#34;$1\u0026#34; local record_type=\u0026#34;${2:-A}\u0026#34; echo -e \u0026#34;${BLUE}=== Enhanced DNS Query: $domain ($record_type) ===${NC}\u0026#34; # 基本查詢 echo -e \u0026#34;\\n${GREEN}Basic Query:${NC}\u0026#34; dig \u0026#34;$domain\u0026#34; \u0026#34;$record_type\u0026#34; +noall +answer # 查詢時間和伺服器資訊 echo -e \u0026#34;\\n${GREEN}Performance Info:${NC}\u0026#34; dig \u0026#34;$domain\u0026#34; \u0026#34;$record_type\u0026#34; | grep -E \u0026#34;(Query time|SERVER:)\u0026#34; # 權威伺服器查詢 echo -e \u0026#34;\\n${GREEN}Authoritative Servers:${NC}\u0026#34; dig \u0026#34;$domain\u0026#34; NS +short # 如果是 A 記錄，也顯示反向查詢 if [ \u0026#34;$record_type\u0026#34; = \u0026#34;A\u0026#34; ]; then echo -e \u0026#34;\\n${GREEN}Reverse DNS:${NC}\u0026#34; ip=$(dig \u0026#34;$domain\u0026#34; A +short | head -1) if [ -n \u0026#34;$ip\u0026#34; ]; then dig -x \u0026#34;$ip\u0026#34; +short fi fi } # 使用範例 enhanced_dig \u0026#34;google.com\u0026#34; \u0026#34;A\u0026#34; 2. DNS 健康檢查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #!/bin/bash # dns_health_check.sh - DNS 健康檢查腳本 dns_health_check() { local domain=\u0026#34;$1\u0026#34; echo \u0026#34;DNS Health Check for: $domain\u0026#34; echo \u0026#34;=============================\u0026#34; # 檢查項目計數 local total_checks=0 local passed_checks=0 # 1. 檢查 A 記錄 echo -n \u0026#34;Checking A record... \u0026#34; total_checks=$((total_checks + 1)) if dig \u0026#34;$domain\u0026#34; A +short \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;✓ PASS\u0026#34; passed_checks=$((passed_checks + 1)) else echo \u0026#34;✗ FAIL\u0026#34; fi # 2. 檢查 NS 記錄 echo -n \u0026#34;Checking NS records... \u0026#34; total_checks=$((total_checks + 1)) ns_count=$(dig \u0026#34;$domain\u0026#34; NS +short | wc -l) if [ \u0026#34;$ns_count\u0026#34; -ge 2 ]; then echo \u0026#34;✓ PASS ($ns_count nameservers)\u0026#34; passed_checks=$((passed_checks + 1)) else echo \u0026#34;✗ FAIL (only $ns_count nameserver)\u0026#34; fi # 3. 檢查 SOA 記錄 echo -n \u0026#34;Checking SOA record... \u0026#34; total_checks=$((total_checks + 1)) if dig \u0026#34;$domain\u0026#34; SOA +short \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;✓ PASS\u0026#34; passed_checks=$((passed_checks + 1)) else echo \u0026#34;✗ FAIL\u0026#34; fi # 4. 檢查查詢時間 echo -n \u0026#34;Checking query performance... \u0026#34; total_checks=$((total_checks + 1)) query_time=$(dig \u0026#34;$domain\u0026#34; | grep \u0026#34;Query time\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) if [ \u0026#34;${query_time:-9999}\u0026#34; -lt 1000 ]; then echo \u0026#34;✓ PASS (${query_time}ms)\u0026#34; passed_checks=$((passed_checks + 1)) else echo \u0026#34;✗ FAIL (${query_time}ms - too slow)\u0026#34; fi # 5. 檢查權威伺服器一致性 echo -n \u0026#34;Checking authoritative server consistency... \u0026#34; total_checks=$((total_checks + 1)) ns_servers=$(dig \u0026#34;$domain\u0026#34; NS +short) consistent=true if [ -n \u0026#34;$ns_servers\u0026#34; ]; then first_result=$(dig @$(echo \u0026#34;$ns_servers\u0026#34; | head -1) \u0026#34;$domain\u0026#34; A +short | sort) while IFS= read -r server; do current_result=$(dig @\u0026#34;$server\u0026#34; \u0026#34;$domain\u0026#34; A +short | sort) if [ \u0026#34;$current_result\u0026#34; != \u0026#34;$first_result\u0026#34; ]; then consistent=false break fi done \u0026lt;\u0026lt;\u0026lt; \u0026#34;$ns_servers\u0026#34; if $consistent; then echo \u0026#34;✓ PASS\u0026#34; passed_checks=$((passed_checks + 1)) else echo \u0026#34;✗ FAIL (inconsistent results)\u0026#34; fi else echo \u0026#34;✗ FAIL (no nameservers found)\u0026#34; fi # 總結 echo echo \u0026#34;Health Check Summary: $passed_checks/$total_checks passed\u0026#34; if [ \u0026#34;$passed_checks\u0026#34; -eq \u0026#34;$total_checks\u0026#34; ]; then echo \u0026#34;Status: ✓ HEALTHY\u0026#34; return 0 else echo \u0026#34;Status: ✗ ISSUES DETECTED\u0026#34; return 1 fi } # 使用範例 dns_health_check \u0026#34;google.com\u0026#34; 3. 配置檔案管理 建立 ~/.digrc 配置檔案：\n1 2 3 4 # ~/.digrc - dig 預設配置 +noall +answer +time=5 +tries=3 或使用環境變數：\n1 2 3 4 5 6 7 # 在 ~/.bashrc 或 ~/.zshrc 中添加 export DIG_DEFAULT_OPTS=\u0026#34;+short +time=3\u0026#34; # 使用別名 alias digs=\u0026#39;dig +short\u0026#39; alias digt=\u0026#39;dig +trace\u0026#39; alias digx=\u0026#39;dig +short +time=1\u0026#39; 常見問題與解決方案 1. 查詢超時問題 1 2 3 4 5 6 7 8 # 調整超時設定 dig google.com +time=10 +tries=3 # 使用 TCP 查詢 dig google.com +tcp # 檢查網路連接 dig google.com +trace | grep -E \u0026#34;(SERVFAIL|TIMEOUT)\u0026#34; 2. DNS 伺服器問題 1 2 3 4 5 6 7 8 # 測試多個 DNS 伺服器 dns_test() { local domain=\u0026#34;$1\u0026#34; for server in 8.8.8.8 1.1.1.1 208.67.222.222; do echo \u0026#34;Testing $server:\u0026#34; dig @$server \u0026#34;$domain\u0026#34; +short +time=3 || echo \u0026#34;Failed\u0026#34; done } 3. 記錄解析問題 1 2 3 4 5 6 7 8 # 檢查完整的解析路徑 dig google.com +trace +all # 驗證 DNSSEC dig google.com +dnssec +multiline # 檢查快取污染 dig google.com @8.8.8.8 +norecurse 與其他工具整合 1. 與 nslookup 比較 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # dig 格式 dig google.com A +short # nslookup 格式 nslookup google.com | grep \u0026#34;Address:\u0026#34; | tail -1 | awk \u0026#39;{print $2}\u0026#39; # 轉換腳本 dig2nslookup() { local domain=\u0026#34;$1\u0026#34; echo \u0026#34;Server: $(dig google.com | grep SERVER | awk \u0026#39;{print $2}\u0026#39; | cut -d# -f1)\u0026#34; echo \u0026#34;Address: $(dig google.com | grep SERVER | awk \u0026#39;{print $2}\u0026#39;)\u0026#34; echo echo \u0026#34;Name: $domain\u0026#34; dig \u0026#34;$domain\u0026#34; A +short | while read ip; do echo \u0026#34;Address: $ip\u0026#34; done } 2. 與監控系統整合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # Nagios 檢查腳本 check_dns_record() { local domain=\u0026#34;$1\u0026#34; local expected=\u0026#34;$2\u0026#34; local timeout=\u0026#34;${3:-5}\u0026#34; result=$(dig \u0026#34;$domain\u0026#34; A +short +time=\u0026#34;$timeout\u0026#34; 2\u0026gt;/dev/null | head -1) if [ \u0026#34;$result\u0026#34; = \u0026#34;$expected\u0026#34; ]; then echo \u0026#34;OK - DNS record matches: $result\u0026#34; exit 0 elif [ -z \u0026#34;$result\u0026#34; ]; then echo \u0026#34;CRITICAL - No DNS record found\u0026#34; exit 2 else echo \u0026#34;WARNING - DNS record mismatch. Expected: $expected, Got: $result\u0026#34; exit 1 fi } # Prometheus 指標生成 generate_dns_metrics() { local domain=\u0026#34;$1\u0026#34; query_time=$(dig \u0026#34;$domain\u0026#34; | grep \u0026#34;Query time\u0026#34; | awk \u0026#39;{print $4}\u0026#39;) record_count=$(dig \u0026#34;$domain\u0026#34; A +short | wc -l) echo \u0026#34;dns_query_duration_ms{domain=\\\u0026#34;$domain\\\u0026#34;} $query_time\u0026#34; echo \u0026#34;dns_record_count{domain=\\\u0026#34;$domain\\\u0026#34;,type=\\\u0026#34;A\\\u0026#34;} $record_count\u0026#34; } 總結 核心優勢 功能完整：支援所有 DNS 記錄類型和查詢選項 輸出詳細：提供完整的 DNS 響應資訊 診斷能力：強大的網路故障排除功能 腳本友好：適合自動化和批次處理 標準工具：廣泛支援和良好的文檔 最佳實踐 適當的超時設定：避免查詢掛起 使用追蹤功能：診斷複雜的 DNS 問題 驗證多個來源：比較不同 DNS 伺服器的結果 記錄和監控：建立 DNS 變更的歷史記錄 安全考慮：驗證 DNSSEC 和檢查 DNS 劫持 常用命令速查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 基本查詢 dig domain.com # 標準查詢 dig domain.com +short # 簡潔輸出 dig domain.com +trace # 追蹤解析路徑 # 記錄類型 dig domain.com A # IPv4 地址 dig domain.com AAAA # IPv6 地址 dig domain.com MX # 郵件交換 dig domain.com NS # 名稱伺服器 dig domain.com TXT # 文本記錄 # 進階選項 dig @8.8.8.8 domain.com # 指定 DNS 伺服器 dig -x 8.8.8.8 # 反向查詢 dig domain.com +dnssec # DNSSEC 驗證 dig domain.com +norecurse # 非遞歸查詢 dig 是網路管理和 DNS 診斷的核心工具，掌握其使用技巧能夠大幅提升網路問題診斷和域名管理的效率。記住：理解 DNS 系統的工作原理是有效使用 dig 的基礎。\n參考資料 BIND 9 Administrator Reference Manual RFC 1035 - Domain Names DNS and BIND on IPv6 DNSSEC Guide Linux dig Command Tutorial ","permalink":"https://xinqilin.github.io/post/tools/dig/","tags":["Linux","Dig","DNS","Network","Debugging","System Administration","Command Line"],"title":"Dig 命令完整指南：DNS 查詢與網路診斷的強大工具"},{"content":"SFTP 工具 Dependency 1 2 3 // https://mvnrepository.com/artifact/com.jcraft/jsch implementation \u0026#39;com.jcraft:jsch:{version}\u0026#39; 創建連線工廠 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import com.jcraft.jsch.Channel; import com.jcraft.jsch.ChannelSftp; import com.jcraft.jsch.JSch; import com.jcraft.jsch.JSchException; import com.jcraft.jsch.Session; import java.util.Properties; import lombok.extern.log4j.Log4j2; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component @Log4j2 public class SFTPConnectionFactory { @Value(\u0026#34;${sftp.domain}\u0026#34;) private String domain; @Value(\u0026#34;${sftp.port}\u0026#34;) private int port; @Value(\u0026#34;${sftp.username}\u0026#34;) private String username; @Value(\u0026#34;${sftp.password}\u0026#34;) private String password; private ChannelSftp client; private Session session; public synchronized ChannelSftp getConnection() { if (client == null || session == null || !client.isConnected() || !session.isConnected()) { log.info(\u0026#34;Connect to {}, port {}, username: {}\u0026#34;, domain, port, username); try { JSch jsch = new JSch(); session = jsch.getSession(username, domain, port); session.setPassword(password); Properties config = new Properties(); config.put(\u0026#34;StrictHostKeyChecking\u0026#34;, \u0026#34;no\u0026#34;); session.setConfig(config); session.connect(); Channel channel = session.openChannel(\u0026#34;sftp\u0026#34;); channel.connect(); client = (ChannelSftp) channel; log.info(\u0026#34;SFTP connect success !\u0026#34;); } catch (JSchException e) { log.error(e, e); } } return client; } public synchronized void disconnect() { if (client != null) { if (client.isConnected()) { client.disconnect(); } } if (session != null) { if (session.isConnected()) { session.disconnect(); } } } } 上傳 , 下載 (outputStream), 刪檔 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; import java.io.InputStreamReader; import java.nio.charset.StandardCharsets; import lombok.extern.log4j.Log4j2; import org.springframework.stereotype.Component; @Component @Log4j2 public class SftpUtil { private static final int uploadRetry = 5; private static final int uploadSleep = 100; private final SFTPConnectionFactory sftpConnectionFactory; public SftpUtil(SFTPConnectionFactory sftpConnectionFactory) { this.sftpConnectionFactory = sftpConnectionFactory; } public boolean upload(String basePath, String directory, String filePath) { var isSuccess = false; var sftp = sftpConnectionFactory.getConnection(); if (sftp == null) { throw new RuntimeException(\u0026#34;get connection error\u0026#34;); } try { sftp.cd(basePath); sftp.cd(directory); File file = new File(filePath); sftp.put(new FileInputStream(file), file.getName()); isSuccess = true; } catch (Exception e) { log.error(e, e); } finally { sftpConnectionFactory.disconnect(); } return isSuccess; } public void download(String basePath, String directory, String fileName) { var sftp = sftpConnectionFactory.getConnection(); if (sftp == null) { throw new RuntimeException(\u0026#34;get connection error\u0026#34;); } BufferedReader bufferReader = null; try { sftp.cd(basePath); sftp.cd(directory); InputStream inputStream = sftp.get(fileName); // return byte[] a file // ByteArrayOutputStream buffer = new ByteArrayOutputStream(); // byte[] bytes = new byte[1024]; // int n; // while ((n = inputStream.read(bytes, 0, bytes.length)) != -1) { // buffer.write(bytes, 0, n); // } // buffer.flush(); // return buffer.toByteArray(); // return outputStream // outputStream = new FileOutputStream(fileName); // sftp.get(fileName, outputStream); bufferReader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8)); var sb = new StringBuilder(); String str; while ((str = bufferReader.readLine()) != null) { sb.append(str); } log.info(sb.toString()); } catch (Exception e) { log.error(e, e); } finally { if (bufferReader != null) { try { bufferReader.close(); } catch (Exception e) { log.error(e, e); } } sftpConnectionFactory.disconnect(); } } public boolean deleteFile(String fileName) throws Exception { var isSuccess = false; var sftp = sftpConnectionFactory.getConnection(); if (sftp == null) { throw new RuntimeException(\u0026#34;get connection error\u0026#34;); } try { sftp.rm(fileName); isSuccess = true; } catch (Exception e) { log.error(e, e); } finally { sftpConnectionFactory.disconnect(); } return isSuccess; } } ","permalink":"https://xinqilin.github.io/post/backend/sftputil/","tags":["SFTP","Spring Boot","File Transfer","JSch","Security","Java"],"title":"Spring Boot SFTP 工具類：安全文件傳輸協議實作與最佳實踐"},{"content":"Specification CriteriaQuery介面： 代表一個specific的頂層查詢物件，它包含著查詢的各個部分，比如：select 、from、where、group by、order by等注意：CriteriaQuery物件只對實體型別或嵌入式型別的Criteria查詢起作用。\nRoot: 代表Criteria查詢的根物件，Criteria查詢的查詢根定義了實體型別，能為將來導航獲得想要的結果，它與SQL查詢中的FROM子句類似。 Root範例是型別化的，且定義了查詢的FROM子句中能夠出現的型別。root代表查詢的實體類,query可以從中得到root物件,告訴jpa查詢哪一個實體類,還可以新增查詢條件,還可以結合EntityManager物件 得到最終查詢的 TypedQuery物件。\nCriteriaBuilder介面： 用來構建CritiaQuery的構建器物件Predicate：一個簡單或複雜的謂詞型別，其實就相當於條件或者是條件組合。 可通過 EntityManager.getCriteriaBuilder 而得。\n1 2 3 4 5 var spec = Specification.\u0026lt;User\u0026gt;where(null); if (!user.getAccount().isEmpty()) { spec.and((r, q, cb) -\u0026gt; cb.like(r.get(\u0026#34;account\u0026#34;), \u0026#34;\u0026#34; + user.getAccount() + \u0026#34;%\u0026#34;)); } Page 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 private Specification\u0026lt;User\u0026gt; getSpecificationByAccountAndPwd(String account, String pwd) { return (Specification\u0026lt;User\u0026gt;) (root, criteriaQuery, criteriaBuilder) -\u0026gt; { // 獲取比較的屬性 Path\u0026lt;Object\u0026gt; compareAccount = root.get(\u0026#34;account\u0026#34;); Path\u0026lt;Object\u0026gt; comparePwd = root.get(\u0026#34;password\u0026#34;); Predicate predicate1 = criteriaBuilder.equal(compareAccount, account); Predicate predicate2 = criteriaBuilder.equal(comparePwd, pwd); // === and === // criteriaBuilder.and(predicate01, predicate02) // === or === // criteriaBuilder.or(predicate01, predicate02) return criteriaBuilder.and(predicate1, predicate2); }; } private Specification\u0026lt;User\u0026gt; getSpecificationByAccountLike() { return (Specification\u0026lt;User\u0026gt;) (root, criteriaQuery, criteriaBuilder) -\u0026gt; { // 獲取比較的屬性 Path\u0026lt;Object\u0026gt; compareAccount = root.get(\u0026#34;account\u0026#34;); // 模糊要求指定引數型別 return criteriaBuilder.like(compareAccount.as(String.class), \u0026#34;%test%\u0026#34;); }; } Pageable pageable = PageRequest.of(pageNum, rowCnt, Sort.Direction.DESC, \u0026#34;id\u0026#34;); Pageable pageable = PageRequest.of(pageNum, rowCnt); Page\u0026lt;User\u0026gt; pageResult = userDao.findAll(getSpecificationByAccountLike(), pageable); // 全部頁數 System.out.println(\u0026#34;getTotalPages(): \u0026#34; + pageResult.getTotalPages()); // 全部筆數 System.out.println(\u0026#34;getTotalElements(): \u0026#34; + pageResult.getTotalElements()); // 每頁筆數 System.out.println(\u0026#34;getSize(): \u0026#34; + pageResult.getSize()); // 目前頁號，0為第一頁 System.out.println(\u0026#34;getNumber(): \u0026#34; + pageResult.getNumber()); // 目前頁筆數 System.out.println(\u0026#34;getNumberOfElements(): \u0026#34; + pageResult.getNumberOfElements()); //result System.out.println(\u0026#34;getContent(): \u0026#34; + pageResult.getContent()); 小試身手1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * * * @param 第幾頁 * @param 每頁數量有幾個 */ public List\u0026lt;BigInteger\u0026gt; getOrderInfo(@PathVariable(\u0026#34;page\u0026#34;) int page, @PathVariable(\u0026#34;size\u0026#34;) int size){ var custInfo = \u0026#34;bill\u0026#34;; Pageable pageable = PageRequest.of(page, size, Sort.Direction.DESC, \u0026#34;order_id\u0026#34;); Page\u0026lt;OrderMaster\u0026gt; pageOrders = orderMasterRepository.findAll(getSpecialField(custInfo), pageable); log.info(\u0026#34;pageOrders: {}\u0026#34;, pageOrders); System.out.println(\u0026#34;total counts: \u0026#34; + pageOrders.getTotalElements()); System.out.println(\u0026#34;total page: \u0026#34; + pageOrders.getTotalPages()); return pageOrders.getContent().stream().map(OrderMaster::getOrderId).collect(Collectors.toList()); } // Predicate toPredicate(Root\u0026lt;T\u0026gt; root, CriteriaQuery\u0026lt;?\u0026gt; query, CriteriaBuilder cb); private Specification\u0026lt;OrderMaster\u0026gt; getSpecialField(String custInfo) { return (root, criteriaQuery, criteriaBuilder) -\u0026gt; { // Path\u0026lt;Object\u0026gt; comparePwd = root.get(\u0026#34;custInfo\u0026#34;); // Predicate predicate = criteriaBuilder.equal(comparePwd, custInfo); // return criteriaBuilder.and(predicate); return criteriaBuilder.equal(root.get(\u0026#34;custInfo\u0026#34;), custInfo); }; 小試身手2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * * * @param 第幾頁 * @param 每頁數量有幾個 */ public List\u0026lt;BigInteger\u0026gt; getOrderInfo(@PathVariable(\u0026#34;page\u0026#34;) int page, @PathVariable(\u0026#34;size\u0026#34;) int size) { var custInfo = \u0026#34;bill\u0026#34;; Pageable pageable = PageRequest.of(page, size, Sort.Direction.DESC, \u0026#34;order_id\u0026#34;); Page\u0026lt;OrderMaster\u0026gt; pageOrders = orderMasterRepository.findAll((root, criteriaQuery, criteriaBuilder) -\u0026gt; { Path\u0026lt;Object\u0026gt; comparePwd = root.get(\u0026#34;custInfo\u0026#34;); Predicate predicate = criteriaBuilder.equal(comparePwd, erpCustNo); return criteriaBuilder.and(predicate); }, pageable); log.info(\u0026#34;pageOrders: {}\u0026#34;, pageOrders); System.out.println(\u0026#34;total counts: \u0026#34; + pageOrders.getTotalElements()); System.out.println(\u0026#34;total page: \u0026#34; + pageOrders.getTotalPages()); return pageOrders.getContent().stream().map(OrderMaster::getOrderId).collect(Collectors.toList()); } 小試身手3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * * * @param 第幾頁 * @param 每頁數量有幾個 */ public List\u0026lt;BigInteger\u0026gt; getOrderInfo(@PathVariable(\u0026#34;page\u0026#34;) int page, @PathVariable(\u0026#34;size\u0026#34;) int size) { var custInfo = \u0026#34;bill\u0026#34;; Pageable pageable = PageRequest.of(page, size, Sort.Direction.DESC, \u0026#34;order_id\u0026#34;); Specification\u0026lt;OrderMaster\u0026gt; specification = new Specification\u0026lt;OrderMaster\u0026gt;() { @Override public Predicate toPredicate(Root\u0026lt;OrderMaster\u0026gt; root, CriteriaQuery\u0026lt;?\u0026gt; query, CriteriaBuilder criteriaBuilder) { return criteriaBuilder.equal(root.get(\u0026#34;custInfo\u0026#34;), erpCustNo); } }; Page\u0026lt;OrderMaster\u0026gt; pageOrders = orderMasterRepository.findAll(specification, pageable); log.info(\u0026#34;pageOrders: {}\u0026#34;, pageOrders); System.out.println(\u0026#34;total counts: \u0026#34; + pageOrders.getTotalElements()); System.out.println(\u0026#34;total page: \u0026#34; + pageOrders.getTotalPages()); return pageOrders.getContent().stream().map(OrderMaster::getOrderId).collect(Collectors.toList()); } ","permalink":"https://xinqilin.github.io/post/backend/jpapageable/","tags":["Spring Data JPA","Pageable","Pagination","Spring Boot","Database","Performance"],"title":"Spring Data JPA Pageable 分頁查詢：完整實作與效能優化指南"},{"content":"Side Project 常用功能，紀錄，方便以後快速 setup 環境 DI 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 \u0026lt;!-- Lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Test Swagger with GraphQL --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- StringUtil--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang3\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.11\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Validate--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.validation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;validation-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.1.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- JSON --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.10.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- logstash --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.logstash.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logstash-logback-encoder\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- guava --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.guava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;guava\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;30.1.1-jre\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Properties or Yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 server.port = 808x server.servlet.context-path = /name #mysql-8 spring.datasource.username = root spring.datasource.password = mysql spring.datasource.url = jdbc:mysql://localhost:3306/\u0026lt;name\u0026gt;?serverTimezone=Asia/Taipei\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false spring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver #JPA spring.jpa.hibernate.ddl-auto = update spring.jpa.show-sql = true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 server: port: 808x servlet: context-path: /name spring: thymeleaf: cache: false #mysql-8 datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/\u0026lt;name\u0026gt;?characterEncoding=utf-8\u0026amp;useSSL=false\u0026amp;serverTimezone=Asia/Taipei username: root password: mysql hikari: minimum-idle: 5 maximum-pool-size: 15 idle-timeout: 30000 pool-name: hikariCP connection-timeout: 30000 max-lifetime: 1800000 jpa: hibernate: ddl-auto: update show-sql: true Config Swagger2Config\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * @author Bill.Lin */ @Configuration @EnableSwagger2 public class Swagger2Config { @Bean public Docket api() { return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.any()) .build(); } } RestTemplateConfig\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Configuration public class RestTemplateConfig { @Bean public RestTemplate restTemplate(ClientHttpRequestFactory factory) { return new RestTemplate(factory); } @Bean public ClientHttpRequestFactory simpleClientHttpRequestFactory() { SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); factory.setReadTimeout(3000); factory.setConnectTimeout(3000); return factory; } } docker-compose kafka\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 version: \u0026#39;3\u0026#39; services: zookeeper1: image: wurstmeister/zookeeper ports: - 2181:2181 container_name: zookeeper kafka1: image: wurstmeister/kafka container_name: kafka ports: - 9092:9092 environment: KAFKA_ADVERTISED_HOST_NAME: 192.168.99.100 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_CREATE_TOPIC: \u0026#34;bill:1:3\u0026#34; redis: image: redis:\u0026lt;tag\u0026gt; expose: - 6379 ports: - \u0026#34;6379:6379\u0026#34; networks: - default rabbitmq: image: rabbitmq:3-management environment: - RABBITMQ_DEFAULT_USER=rabbitmq - RABBITMQ_DEFAULT_PASS=rabbitmq ports: - \u0026#34;15672:15672\u0026#34; - \u0026#34;5672:5672\u0026#34; networks: - default mysql: image: mysql:5.7 # 或 8 environment: - MYSQL_ROOT_PASSWORD=mysql expose: - 3306 ports: - \u0026#34;3306:3306\u0026#34; networks: - default mongo: image: mongo:4.1 restart: always expose: - 27017 ports: - 27017:27017 environment: MONGO_INITDB_DATABASE: db MONGO_INITDB_ROOT_USERNAME: root MONGO_INITDB_ROOT_PASSWORD: mongo networks: - default mongo-express: image: mongo-express restart: always ports: - 8081:8081 environment: ME_CONFIG_MONGODB_SERVER: mongo ME_CONFIG_MONGODB_ADMINUSERNAME: root ME_CONFIG_MONGODB_ADMINPASSWORD: mongo depends_on: - mongo networks: - default logstash config (resource) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;conversionRule conversionWord=\u0026#34;clr\u0026#34; converterClass=\u0026#34;org.springframework.boot.logging.logback.ColorConverter\u0026#34; /\u0026gt; \u0026lt;conversionRule conversionWord=\u0026#34;wex\u0026#34; converterClass=\u0026#34;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter\u0026#34; /\u0026gt; \u0026lt;conversionRule conversionWord=\u0026#34;wEx\u0026#34; converterClass=\u0026#34;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;CONSOLE_LOG_PATTERN\u0026#34; value=\u0026#34;${CONSOLE_LOG_PATTERN:-%clr(%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}\u0026#34;/\u0026gt; \u0026lt;appender name=\u0026#34;STDOUT\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;layout class=\u0026#34;ch.qos.logback.classic.PatternLayout\u0026#34;\u0026gt; \u0026lt;pattern\u0026gt;${CONSOLE_LOG_PATTERN}\u0026lt;/pattern\u0026gt; \u0026lt;/layout\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;logger name=\u0026#34;com.bill.xx\u0026#34; level=\u0026#34;info\u0026#34; /\u0026gt; \u0026lt;root level=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;property name=\u0026#34;LOGS\u0026#34; value=\u0026#34;./logs\u0026#34; /\u0026gt; \u0026lt;springProfile name=\u0026#34;indev, staging\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;LOGS\u0026#34; value=\u0026#34;IDC 目錄\u0026#34; /\u0026gt; \u0026lt;appender name=\u0026#34;RollingFile\u0026#34; class=\u0026#34;ch.qos.logback.core.rolling.RollingFileAppender\u0026#34;\u0026gt; \u0026lt;file\u0026gt;${LOGS}/ma-pos.log\u0026lt;/file\u0026gt; \u0026lt;encoder class=\u0026#34;ch.qos.logback.classic.encoder.PatternLayoutEncoder\u0026#34;\u0026gt; \u0026lt;Pattern\u0026gt;%d %p %C{1.} [%t] %m%n\u0026lt;/Pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;rollingPolicy class=\u0026#34;ch.qos.logback.core.rolling.TimeBasedRollingPolicy\u0026#34;\u0026gt; \u0026lt;!-- rollover daily and when the file reaches 10 MegaBytes --\u0026gt; \u0026lt;fileNamePattern\u0026gt;${LOGS}/archived/ma-pos-%d{yyyy-MM-dd}.%i.log \u0026lt;/fileNamePattern\u0026gt; \u0026lt;timeBasedFileNamingAndTriggeringPolicy class=\u0026#34;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\u0026#34;\u0026gt; \u0026lt;maxFileSize\u0026gt;10MB\u0026lt;/maxFileSize\u0026gt; \u0026lt;/timeBasedFileNamingAndTriggeringPolicy\u0026gt; \u0026lt;/rollingPolicy\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;appender name=\u0026#34;LogstashFile\u0026#34; class=\u0026#34;ch.qos.logback.core.rolling.RollingFileAppender\u0026#34;\u0026gt; \u0026lt;file\u0026gt;${LOGS}/logstash/logstash.log\u0026lt;/file\u0026gt; \u0026lt;rollingPolicy class=\u0026#34;ch.qos.logback.core.rolling.TimeBasedRollingPolicy\u0026#34;\u0026gt; \u0026lt;fileNamePattern\u0026gt;${LOGS}/logstash/logstash.%d{yyyy-MM-dd}.log\u0026lt;/fileNamePattern\u0026gt; \u0026lt;maxHistory\u0026gt;7\u0026lt;/maxHistory\u0026gt; \u0026lt;/rollingPolicy\u0026gt; \u0026lt;encoder class=\u0026#34;net.logstash.logback.encoder.LogstashEncoder\u0026#34;/\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;root level=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;RollingFile\u0026#34; /\u0026gt; \u0026lt;appender-ref ref=\u0026#34;LogstashFile\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/springProfile\u0026gt; \u0026lt;/configuration\u0026gt; Other banner.txt\n1 2 3 4 5 6 7 8 9 10 11 12 13 ,. - · - ., \u0026#39; ,.-·. ,. \u0026#39; ,. \u0026#39; ,·\u0026#39;´,.-, ,. -., `\u0026#39;;,\u0026#39; / ;\u0026#39;\\\u0026#39; / \u0026#39;;\\ / \u0026#39;;\\ \\::\\.\u0026#39;´ ;\u0026#39;\\::::;:\u0026#39; ,·\u0026#39;:\\\u0026#39; ; ;:::\\ ,\u0026#39; ,\u0026#39;::\u0026#39;\\ ,\u0026#39; ,\u0026#39;::\u0026#39;\\ \u0026#39;\\:\u0026#39;; ;:;:·\u0026#39;´,.·\u0026#39;´\\::::\u0026#39;; \u0026#39;; ;::::;\u0026#39; ,\u0026#39; ;:::\u0026#39;;\u0026#39; ,\u0026#39; ;:::\u0026#39;;\u0026#39; ,.·\u0026#39; ,.·:\u0026#39;´:::::::\u0026#39;\\;·´ ; ;::::; \u0026#39;; ,\u0026#39;:::;\u0026#39; \u0026#39;; ,\u0026#39;:::;\u0026#39; \u0026#39;·, ,.`\u0026#39; ·- :;:;·\u0026#39;´ \u0026#39;; ;\u0026#39;::::; ; ,\u0026#39;:::;\u0026#39; \u0026#39; ; ,\u0026#39;:::;\u0026#39; \u0026#39; ; \u0026#39;;:\\:`*·, \u0026#39;`·, ° ; \u0026#39;;:::\u0026#39;; ,\u0026#39; ,\u0026#39;::;\u0026#39; ,\u0026#39; ,\u0026#39;::;\u0026#39; ; ;:;:\u0026#39;-·\u0026#39;´ ,.·\u0026#39;:\\ \u0026#39;; ;::::;\u0026#39; ; \u0026#39;;_:,.-·´\u0026#39;;\\‘ ; \u0026#39;;_:,.-·´\u0026#39;;\\‘ ,·\u0026#39;, ,. -~:*\u0026#39;´\\:::::\u0026#39;\\‘ \\*´\\:::;‘ \u0026#39;, _,.-·\u0026#39;´:\\:\\‘ \u0026#39;, _,.-·\u0026#39;´:\\:\\‘ \\:\\`\u0026#39;´\\:::::::::\u0026#39;\\;:·\u0026#39;´ \u0026#39;\\::\\:;\u0026#39; \\¨:::::::::::\\\u0026#39;; \\¨:::::::::::\\\u0026#39;; \u0026#39;\\;\\:::\\;: -~*´‘ `*´‘ \u0026#39;\\;::_;:-·\u0026#39;´‘ \u0026#39;\\;::_;:-·\u0026#39;´‘ \u0026#39; \u0026#39;¨ \u0026#39;¨ ","permalink":"https://xinqilin.github.io/post/backend/sideprojectconfig/","tags":["Project Setup","Configuration","Development","Best Practices","Spring Boot"],"title":"Side Project 專案配置最佳實踐：開發環境設定與部署流程"},{"content":"概述 Spring Framework 廣泛使用註解（Annotations）來簡化配置和提升開發效率。從 Spring 2.5 開始引入註解驅動配置，到 Spring Boot 的自動配置，註解已成為現代 Spring 應用程式開發的核心。本文將系統性地整理 Spring 生態系統中的重要註解，並提供實用的程式碼範例。\n核心容器註解 1. Bean 定義與管理 @Component 系列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // 通用組件 @Component public class UserValidator { public boolean validate(User user) { return user != null \u0026amp;\u0026amp; user.getEmail() != null; } } // 服務層組件 @Service public class UserService { @Autowired private UserRepository userRepository; public User findById(Long id) { return userRepository.findById(id).orElse(null); } } // 資料存取層組件 @Repository public class UserRepositoryImpl implements UserRepository { @PersistenceContext private EntityManager entityManager; @Override public Optional\u0026lt;User\u0026gt; findById(Long id) { User user = entityManager.find(User.class, id); return Optional.ofNullable(user); } } // Web 層組件 @Controller public class UserController { @Autowired private UserService userService; @GetMapping(\u0026#34;/users/{id}\u0026#34;) @ResponseBody public User getUser(@PathVariable Long id) { return userService.findById(id); } } // RESTful API 控制器 @RestController // 等同於 @Controller + @ResponseBody @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserRestController { @Autowired private UserService userService; @GetMapping(\u0026#34;/{id}\u0026#34;) public User getUser(@PathVariable Long id) { return userService.findById(id); } } @Configuration 和 @Bean 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Configuration @EnableTransactionManagement @ComponentScan(basePackages = \u0026#34;com.example\u0026#34;) public class AppConfiguration { @Bean @Primary // 當有多個相同類型的 Bean 時，優先使用這個 public DataSource primaryDataSource() { HikariDataSource dataSource = new HikariDataSource(); dataSource.setJdbcUrl(\u0026#34;jdbc:mysql://localhost:3306/primary\u0026#34;); dataSource.setUsername(\u0026#34;user\u0026#34;); dataSource.setPassword(\u0026#34;password\u0026#34;); return dataSource; } @Bean @Qualifier(\u0026#34;secondary\u0026#34;) // 使用限定符區分 public DataSource secondaryDataSource() { HikariDataSource dataSource = new HikariDataSource(); dataSource.setJdbcUrl(\u0026#34;jdbc:mysql://localhost:3306/secondary\u0026#34;); dataSource.setUsername(\u0026#34;user\u0026#34;); dataSource.setPassword(\u0026#34;password\u0026#34;); return dataSource; } @Bean @Scope(\u0026#34;prototype\u0026#34;) // 每次注入都創建新實例 public OrderProcessor orderProcessor() { return new OrderProcessor(); } @Bean @Lazy // 延遲初始化 public ExpensiveService expensiveService() { return new ExpensiveService(); } } 2. 依賴注入註解 @Autowired 和相關註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Service public class OrderService { // 建構子注入（推薦） private final PaymentService paymentService; private final EmailService emailService; @Autowired public OrderService(PaymentService paymentService, EmailService emailService) { this.paymentService = paymentService; this.emailService = emailService; } // 可選依賴 @Autowired(required = false) private Optional\u0026lt;SmsService\u0026gt; smsService; // 集合注入 @Autowired private List\u0026lt;NotificationProvider\u0026gt; notificationProviders; // 使用限定符 @Autowired @Qualifier(\u0026#34;primary\u0026#34;) private DataSource primaryDataSource; // JSR-330 標準註解 @Inject // 等同於 @Autowired private AuditService auditService; @Named(\u0026#34;cache\u0026#34;) // 等同於 @Qualifier private CacheManager cacheManager; } @Value 屬性注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @Component public class ConfigurationService { // 基本屬性注入 @Value(\u0026#34;${app.name}\u0026#34;) private String appName; // 預設值 @Value(\u0026#34;${app.timeout:30}\u0026#34;) private int timeout; // 系統屬性 @Value(\u0026#34;#{systemProperties[\u0026#39;user.home\u0026#39;]}\u0026#34;) private String userHome; // SpEL 表達式 @Value(\u0026#34;#{T(java.lang.Math).random() * 100}\u0026#34;) private double randomNumber; // 陣列注入 @Value(\u0026#34;${app.allowed-origins}\u0026#34;) private String[] allowedOrigins; // List 注入 @Value(\u0026#34;#{\u0026#39;${app.features}\u0026#39;.split(\u0026#39;,\u0026#39;)}\u0026#34;) private List\u0026lt;String\u0026gt; features; // Map 注入 @Value(\u0026#34;#{${app.database-config}}\u0026#34;) private Map\u0026lt;String, String\u0026gt; databaseConfig; // 建構子參數注入 public ConfigurationService(@Value(\u0026#34;${app.version}\u0026#34;) String version) { this.version = version; } } Web 相關註解 1. MVC 控制器註解 @RequestMapping 系列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @RestController @RequestMapping(\u0026#34;/api/v1/orders\u0026#34;) @CrossOrigin(origins = \u0026#34;http://localhost:3000\u0026#34;) // CORS 設定 public class OrderController { @Autowired private OrderService orderService; // GET 請求 @GetMapping public Page\u0026lt;Order\u0026gt; getOrders( @RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @RequestParam(defaultValue = \u0026#34;20\u0026#34;) int size, @RequestParam(required = false) String status, Pageable pageable) { return orderService.findOrders(status, pageable); } // 路徑變數 @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;Order\u0026gt; getOrder(@PathVariable Long id) { return orderService.findById(id) .map(order -\u0026gt; ResponseEntity.ok(order)) .orElse(ResponseEntity.notFound().build()); } // POST 請求 @PostMapping @ResponseStatus(HttpStatus.CREATED) public Order createOrder(@RequestBody @Valid CreateOrderRequest request) { return orderService.createOrder(request); } // PUT 請求 @PutMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;Order\u0026gt; updateOrder( @PathVariable Long id, @RequestBody @Valid UpdateOrderRequest request) { return orderService.updateOrder(id, request) .map(order -\u0026gt; ResponseEntity.ok(order)) .orElse(ResponseEntity.notFound().build()); } // DELETE 請求 @DeleteMapping(\u0026#34;/{id}\u0026#34;) @ResponseStatus(HttpStatus.NO_CONTENT) public void deleteOrder(@PathVariable Long id) { orderService.deleteOrder(id); } // 檔案上傳 @PostMapping(\u0026#34;/{id}/attachments\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; uploadAttachment( @PathVariable Long id, @RequestParam(\u0026#34;file\u0026#34;) MultipartFile file) { String fileUrl = orderService.uploadAttachment(id, file); return ResponseEntity.ok(fileUrl); } // 自訂 HTTP 方法 @RequestMapping(value = \u0026#34;/{id}/status\u0026#34;, method = RequestMethod.PATCH) public Order updateOrderStatus( @PathVariable Long id, @RequestBody OrderStatusUpdate statusUpdate) { return orderService.updateStatus(id, statusUpdate); } } 參數處理註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @RestController public class UserController { // 請求頭處理 @GetMapping(\u0026#34;/profile\u0026#34;) public UserProfile getProfile( @RequestHeader(\u0026#34;Authorization\u0026#34;) String authToken, @RequestHeader(value = \u0026#34;User-Agent\u0026#34;, required = false) String userAgent) { return userService.getProfile(authToken); } // Cookie 處理 @GetMapping(\u0026#34;/preferences\u0026#34;) public UserPreferences getPreferences( @CookieValue(name = \u0026#34;sessionId\u0026#34;, required = false) String sessionId) { return userService.getPreferences(sessionId); } // Session 屬性 @PostMapping(\u0026#34;/login\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; login( @RequestBody LoginRequest request, @SessionAttribute(required = false) String captcha, HttpSession session) { if (userService.validateLogin(request, captcha)) { session.setAttribute(\u0026#34;userId\u0026#34;, request.getUsername()); return ResponseEntity.ok(\u0026#34;Login successful\u0026#34;); } return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(\u0026#34;Login failed\u0026#34;); } // Model 屬性 @ModelAttribute(\u0026#34;commonData\u0026#34;) public CommonData getCommonData() { return new CommonData(); } @GetMapping(\u0026#34;/dashboard\u0026#34;) public String dashboard(@ModelAttribute(\u0026#34;commonData\u0026#34;) CommonData commonData) { return \u0026#34;dashboard\u0026#34;; } } 2. 驗證註解 Bean Validation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @RestController @Validated // 開啟驗證 public class UserController { @PostMapping(\u0026#34;/users\u0026#34;) public ResponseEntity\u0026lt;User\u0026gt; createUser(@RequestBody @Valid CreateUserRequest request) { User user = userService.createUser(request); return ResponseEntity.ok(user); } @GetMapping(\u0026#34;/users/{id}\u0026#34;) public User getUser(@PathVariable @Min(1) Long id) { return userService.findById(id); } } // 請求 DTO 與驗證 public class CreateUserRequest { @NotBlank(message = \u0026#34;姓名不能為空\u0026#34;) @Size(min = 2, max = 50, message = \u0026#34;姓名長度必須在 2-50 字元之間\u0026#34;) private String name; @NotBlank(message = \u0026#34;信箱不能為空\u0026#34;) @Email(message = \u0026#34;信箱格式不正確\u0026#34;) private String email; @NotNull(message = \u0026#34;年齡不能為空\u0026#34;) @Min(value = 18, message = \u0026#34;年齡必須大於等於 18\u0026#34;) @Max(value = 120, message = \u0026#34;年齡必須小於等於 120\u0026#34;) private Integer age; @Pattern(regexp = \u0026#34;^\\\\+?[1-9]\\\\d{1,14}$\u0026#34;, message = \u0026#34;電話號碼格式不正確\u0026#34;) private String phone; @Valid // 巢狀物件驗證 private Address address; @NotEmpty(message = \u0026#34;至少要有一個興趣\u0026#34;) private List\u0026lt;@NotBlank String\u0026gt; interests; // getters and setters... } // 自訂驗證註解 @Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) @Constraint(validatedBy = UniqueEmailValidator.class) public @interface UniqueEmail { String message() default \u0026#34;信箱已被使用\u0026#34;; Class\u0026lt;?\u0026gt;[] groups() default {}; Class\u0026lt;? extends Payload\u0026gt;[] payload() default {}; } @Component public class UniqueEmailValidator implements ConstraintValidator\u0026lt;UniqueEmail, String\u0026gt; { @Autowired private UserRepository userRepository; @Override public boolean isValid(String email, ConstraintValidatorContext context) { return email == null || !userRepository.existsByEmail(email); } } 資料存取註解 1. JPA 和 Hibernate 註解 實體定義 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @Entity @Table(name = \u0026#34;users\u0026#34;, indexes = { @Index(name = \u0026#34;idx_email\u0026#34;, columnList = \u0026#34;email\u0026#34;), @Index(name = \u0026#34;idx_created_at\u0026#34;, columnList = \u0026#34;created_at\u0026#34;) }) @EntityListeners(AuditingEntityListener.class) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = \u0026#34;full_name\u0026#34;, nullable = false, length = 100) private String name; @Column(unique = true, nullable = false) private String email; @Enumerated(EnumType.STRING) @Column(name = \u0026#34;user_status\u0026#34;) private UserStatus status = UserStatus.ACTIVE; @CreatedDate @Column(name = \u0026#34;created_at\u0026#34;, updatable = false) private LocalDateTime createdAt; @LastModifiedDate @Column(name = \u0026#34;updated_at\u0026#34;) private LocalDateTime updatedAt; @CreatedBy @Column(name = \u0026#34;created_by\u0026#34;, updatable = false) private String createdBy; @LastModifiedBy @Column(name = \u0026#34;updated_by\u0026#34;) private String updatedBy; // 一對多關係 @OneToMany(mappedBy = \u0026#34;user\u0026#34;, cascade = CascadeType.ALL, orphanRemoval = true) @JsonIgnore private List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;(); // 多對一關係 @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;department_id\u0026#34;) private Department department; // 多對多關係 @ManyToMany @JoinTable( name = \u0026#34;user_roles\u0026#34;, joinColumns = @JoinColumn(name = \u0026#34;user_id\u0026#34;), inverseJoinColumns = @JoinColumn(name = \u0026#34;role_id\u0026#34;) ) private Set\u0026lt;Role\u0026gt; roles = new HashSet\u0026lt;\u0026gt;(); // 版本控制（樂觀鎖定） @Version private Long version; // getters and setters... } Repository 介面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt;, JpaSpecificationExecutor\u0026lt;User\u0026gt; { // 查詢方法名稱規則 Optional\u0026lt;User\u0026gt; findByEmail(String email); List\u0026lt;User\u0026gt; findByStatusAndCreatedAtAfter(UserStatus status, LocalDateTime date); Page\u0026lt;User\u0026gt; findByNameContainingIgnoreCase(String name, Pageable pageable); // 自訂查詢 @Query(\u0026#34;SELECT u FROM User u WHERE u.email = ?1 AND u.status = ?2\u0026#34;) Optional\u0026lt;User\u0026gt; findByEmailAndStatus(String email, UserStatus status); // 命名參數 @Query(\u0026#34;SELECT u FROM User u WHERE u.name LIKE %:name% ORDER BY u.createdAt DESC\u0026#34;) List\u0026lt;User\u0026gt; findByNameContaining(@Param(\u0026#34;name\u0026#34;) String name); // 原生 SQL @Query(value = \u0026#34;SELECT * FROM users WHERE email = ?1\u0026#34;, nativeQuery = true) User findByEmailNative(String email); // 更新查詢 @Modifying @Query(\u0026#34;UPDATE User u SET u.status = :status WHERE u.id = :id\u0026#34;) int updateUserStatus(@Param(\u0026#34;id\u0026#34;) Long id, @Param(\u0026#34;status\u0026#34;) UserStatus status); // 刪除查詢 @Modifying @Query(\u0026#34;DELETE FROM User u WHERE u.status = :status\u0026#34;) void deleteByStatus(@Param(\u0026#34;status\u0026#34;) UserStatus status); // 投影查詢 @Query(\u0026#34;SELECT new com.example.dto.UserSummary(u.id, u.name, u.email) FROM User u\u0026#34;) List\u0026lt;UserSummary\u0026gt; findUserSummaries(); // 計數查詢 long countByStatus(UserStatus status); boolean existsByEmail(String email); } 2. 交易管理 @Transactional 註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Service @Transactional // 類別層級的交易設定 public class OrderService { @Autowired private OrderRepository orderRepository; @Autowired private PaymentService paymentService; @Autowired private InventoryService inventoryService; // 預設交易設定 public Order createOrder(CreateOrderRequest request) { Order order = new Order(request); order = orderRepository.save(order); // 這些操作都在同一個交易中 paymentService.processPayment(order); inventoryService.updateStock(order.getItems()); return order; } // 唯讀交易（效能優化） @Transactional(readOnly = true) public List\u0026lt;Order\u0026gt; findOrdersByUser(Long userId) { return orderRepository.findByUserId(userId); } // 指定傳播行為 @Transactional(propagation = Propagation.REQUIRES_NEW) public void logOrderEvent(Long orderId, String event) { // 這個方法總是在新的交易中執行 OrderEvent orderEvent = new OrderEvent(orderId, event); orderEventRepository.save(orderEvent); } // 指定隔離級別 @Transactional(isolation = Isolation.SERIALIZABLE) public void processHighValueOrder(Order order) { // 序列化隔離級別，避免併發問題 processOrder(order); } // 異常回滾設定 @Transactional(rollbackFor = {Exception.class}, noRollbackFor = {ValidationException.class}) public void complexOperation() { // 遇到任何 Exception 都回滾，除了 ValidationException } // 超時設定 @Transactional(timeout = 30) // 30 秒超時 public void longRunningOperation() { // 長時間運行的操作 } // 指定交易管理器 @Transactional(transactionManager = \u0026#34;secondaryTransactionManager\u0026#34;) public void operationOnSecondaryDatabase() { // 使用指定的交易管理器 } } 排程和非同步處理 1. 排程任務註解 @Scheduled 和 @EnableScheduling 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 @Configuration @EnableScheduling public class SchedulingConfig { @Bean public TaskScheduler taskScheduler() { ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.setPoolSize(10); scheduler.setThreadNamePrefix(\u0026#34;scheduled-task-\u0026#34;); scheduler.initialize(); return scheduler; } } @Component @Slf4j public class ScheduledTasks { @Autowired private OrderService orderService; @Autowired private EmailService emailService; // 固定延遲執行（上次執行完成後多久再執行） @Scheduled(fixedDelay = 5000) // 5 秒 public void processOrders() { log.info(\u0026#34;處理待處理訂單\u0026#34;); orderService.processePendingOrders(); } // 固定頻率執行（固定間隔執行） @Scheduled(fixedRate = 10000) // 10 秒 public void heartbeat() { log.info(\u0026#34;系統心跳檢查\u0026#34;); // 系統健康檢查邏輯 } // 初始延遲 @Scheduled(fixedDelay = 30000, initialDelay = 60000) // 1 分鐘後開始，然後每 30 秒執行 public void cleanupTempFiles() { log.info(\u0026#34;清理暫存檔案\u0026#34;); // 清理邏輯 } // Cron 表達式 - 每分鐘執行 @Scheduled(cron = \u0026#34;0 * * * * *\u0026#34;) public void everyMinute() { log.info(\u0026#34;每分鐘執行的任務\u0026#34;); } // Cron 表達式 - 每天凌晨 2 點執行 @Scheduled(cron = \u0026#34;0 0 2 * * *\u0026#34;) public void dailyReport() { log.info(\u0026#34;產生每日報告\u0026#34;); emailService.sendDailyReport(); } // Cron 表達式 - 工作日上午 9 點執行 @Scheduled(cron = \u0026#34;0 0 9 * * MON-FRI\u0026#34;) public void workdayMorningTask() { log.info(\u0026#34;工作日早晨任務\u0026#34;); } // Cron 表達式 - 每月最後一天執行 @Scheduled(cron = \u0026#34;0 0 0 L * *\u0026#34;) public void monthlyTask() { log.info(\u0026#34;月末任務\u0026#34;); } // 使用配置屬性 @Scheduled(cron = \u0026#34;${app.cleanup.cron:0 0 3 * * *}\u0026#34;) // 預設每天凌晨 3 點 public void configuredTask() { log.info(\u0026#34;可配置的排程任務\u0026#34;); } // 條件性排程 @Scheduled(fixedDelay = 60000) @ConditionalOnProperty(name = \u0026#34;app.monitoring.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public void monitoringTask() { log.info(\u0026#34;監控任務\u0026#34;); } } Cron 表達式詳解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /** * Cron 表達式格式：秒 分 時 日 月 週 * * 欄位說明： * - 秒：0-59 * - 分：0-59 * - 時：0-23 * - 日：1-31 * - 月：1-12 或 JAN-DEC * - 週：0-7 或 SUN-SAT (0 和 7 都代表週日) * * 特殊字符： * * : 匹配任意值 * ? : 只能用在日和週，表示不指定值 * - : 表示範圍 (例如：1-5) * , : 表示列舉 (例如：1,3,5) * / : 表示增量 (例如：0/15 表示從 0 開始每 15 分鐘) * L : 表示最後 (例如：L 在日欄位表示該月最後一天) * W : 表示工作日 (例如：15W 表示距離 15 號最近的工作日) * # : 表示第幾個週幾 (例如：6#3 表示第三個週五) */ @Component public class CronExamples { @Scheduled(cron = \u0026#34;0 0 * * * *\u0026#34;) // 每小時整點執行 public void hourly() {} @Scheduled(cron = \u0026#34;*/10 * * * * *\u0026#34;) // 每 10 秒執行 public void every10Seconds() {} @Scheduled(cron = \u0026#34;0 0 8-18 * * *\u0026#34;) // 每天 8-18 點整點執行 public void businessHours() {} @Scheduled(cron = \u0026#34;0 0/30 8-18 * * *\u0026#34;) // 每天 8-18 點每半小時執行 public void businessHalfHour() {} @Scheduled(cron = \u0026#34;0 0 9-17 * * MON-FRI\u0026#34;) // 工作日 9-17 點整點執行 public void workingHours() {} @Scheduled(cron = \u0026#34;0 0 0 25 12 ?\u0026#34;) // 每年聖誕節 00:00 執行 public void christmas() {} @Scheduled(cron = \u0026#34;0 0 0 L * *\u0026#34;) // 每月最後一天 00:00 執行 public void lastDayOfMonth() {} @Scheduled(cron = \u0026#34;0 0 0 LW * *\u0026#34;) // 每月最後一個工作日 00:00 執行 public void lastWorkdayOfMonth() {} @Scheduled(cron = \u0026#34;0 0 0 * * 1#1\u0026#34;) // 每月第一個週一 00:00 執行 public void firstMondayOfMonth() {} } 2. 非同步處理註解 @Async 和 @EnableAsync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 @Configuration @EnableAsync public class AsyncConfig implements AsyncConfigurer { @Override @Bean(name = \u0026#34;taskExecutor\u0026#34;) public Executor getAsyncExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(5); executor.setMaxPoolSize(20); executor.setQueueCapacity(100); executor.setThreadNamePrefix(\u0026#34;async-task-\u0026#34;); executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); executor.initialize(); return executor; } @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() { return (ex, method, params) -\u0026gt; { log.error(\u0026#34;非同步方法 {} 執行異常\u0026#34;, method.getName(), ex); }; } } @Service @Slf4j public class NotificationService { // 簡單非同步方法 @Async public void sendEmail(String to, String subject, String content) { log.info(\u0026#34;發送郵件到 {}\u0026#34;, to); // 模擬郵件發送 try { Thread.sleep(2000); log.info(\u0026#34;郵件發送完成\u0026#34;); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } // 返回 CompletableFuture @Async public CompletableFuture\u0026lt;String\u0026gt; sendSms(String phone, String message) { log.info(\u0026#34;發送簡訊到 {}\u0026#34;, phone); try { Thread.sleep(1000); return CompletableFuture.completedFuture(\u0026#34;簡訊發送成功\u0026#34;); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return CompletableFuture.failedFuture(e); } } // 指定執行器 @Async(\u0026#34;taskExecutor\u0026#34;) public CompletableFuture\u0026lt;Boolean\u0026gt; processLargeFile(String filePath) { log.info(\u0026#34;開始處理大檔案：{}\u0026#34;, filePath); try { // 模擬檔案處理 Thread.sleep(5000); log.info(\u0026#34;檔案處理完成：{}\u0026#34;, filePath); return CompletableFuture.completedFuture(true); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return CompletableFuture.failedFuture(e); } } // 批量非同步處理 public CompletableFuture\u0026lt;Void\u0026gt; sendBulkNotifications(List\u0026lt;User\u0026gt; users, String message) { List\u0026lt;CompletableFuture\u0026lt;Void\u0026gt;\u0026gt; futures = users.stream() .map(user -\u0026gt; sendNotificationAsync(user, message)) .collect(Collectors.toList()); return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])); } @Async private CompletableFuture\u0026lt;Void\u0026gt; sendNotificationAsync(User user, String message) { // 發送通知邏輯 return CompletableFuture.completedFuture(null); } } Spring Boot 特定註解 1. 自動配置註解 @SpringBootApplication 分解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // @SpringBootApplication 等同於以下三個註解的組合： // @Configuration + @EnableAutoConfiguration + @ComponentScan @SpringBootApplication // 等同於： // @Configuration // @EnableAutoConfiguration // @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), // @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } // 自訂掃描配置 @SpringBootApplication( scanBasePackages = {\u0026#34;com.example.app\u0026#34;, \u0026#34;com.example.shared\u0026#34;}, exclude = {DataSourceAutoConfiguration.class} // 排除特定自動配置 ) public class CustomApplication { public static void main(String[] args) { SpringApplication.run(CustomApplication.class, args); } } 條件註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @Configuration public class ConditionalConfiguration { // 當類別存在時 @Bean @ConditionalOnClass(RedisTemplate.class) public RedisService redisService() { return new RedisService(); } // 當類別不存在時 @Bean @ConditionalOnMissingClass(\u0026#34;com.example.CustomService\u0026#34;) public DefaultService defaultService() { return new DefaultService(); } // 當 Bean 存在時 @Bean @ConditionalOnBean(DataSource.class) public JdbcTemplate jdbcTemplate(DataSource dataSource) { return new JdbcTemplate(dataSource); } // 當 Bean 不存在時 @Bean @ConditionalOnMissingBean(EmailService.class) public EmailService mockEmailService() { return new MockEmailService(); } // 當屬性存在且符合條件時 @Bean @ConditionalOnProperty(name = \u0026#34;app.cache.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;, matchIfMissing = false) public CacheManager cacheManager() { return new ConcurrentMapCacheManager(); } // 當 Web 應用程式時 @Bean @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) public WebMvcConfigurer webMvcConfigurer() { return new CustomWebMvcConfigurer(); } // 當非 Web 應用程式時 @Bean @ConditionalOnNotWebApplication public CommandLineRunner commandLineRunner() { return args -\u0026gt; System.out.println(\u0026#34;Non-web application started\u0026#34;); } // 當特定 Profile 啟用時 @Bean @Profile(\u0026#34;development\u0026#34;) public DataSource devDataSource() { return new H2DataSource(); } @Bean @Profile(\u0026#34;production\u0026#34;) public DataSource prodDataSource() { return new MySQLDataSource(); } // 自訂條件 @Bean @ConditionalOnCustomCondition public CustomService customService() { return new CustomService(); } } // 自訂條件實作 public class CustomCondition implements Condition { @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { // 自訂條件邏輯 String osName = context.getEnvironment().getProperty(\u0026#34;os.name\u0026#34;); return osName != null \u0026amp;\u0026amp; osName.toLowerCase().contains(\u0026#34;windows\u0026#34;); } } @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Conditional(CustomCondition.class) public @interface ConditionalOnCustomCondition { } 2. 配置屬性註解 @ConfigurationProperties 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @ConfigurationProperties(prefix = \u0026#34;app\u0026#34;) @Component @Validated @Data public class AppProperties { @NotBlank private String name; @NotBlank private String version; @Valid private Database database = new Database(); @Valid private Cache cache = new Cache(); private List\u0026lt;String\u0026gt; allowedOrigins = new ArrayList\u0026lt;\u0026gt;(); private Map\u0026lt;String, String\u0026gt; headers = new HashMap\u0026lt;\u0026gt;(); @Data public static class Database { @NotBlank private String url; @NotBlank private String username; @NotBlank private String password; @Min(1) @Max(100) private int maxConnections = 10; @DurationMin(seconds = 1) @DurationMax(minutes = 5) private Duration timeout = Duration.ofSeconds(30); } @Data public static class Cache { private boolean enabled = true; @Positive private int maxSize = 1000; @DurationMin(minutes = 1) private Duration ttl = Duration.ofMinutes(10); private CacheType type = CacheType.MEMORY; } public enum CacheType { MEMORY, REDIS, HAZELCAST } } // 使用配置 @Service @RequiredArgsConstructor public class AppService { private final AppProperties appProperties; public void printConfig() { System.out.println(\u0026#34;App Name: \u0026#34; + appProperties.getName()); System.out.println(\u0026#34;Database URL: \u0026#34; + appProperties.getDatabase().getUrl()); System.out.println(\u0026#34;Cache Enabled: \u0026#34; + appProperties.getCache().isEnabled()); } } 快取註解 @EnableCaching 和快取操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 @Configuration @EnableCaching public class CacheConfig { @Bean public CacheManager cacheManager() { ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager(); cacheManager.setAllowNullValues(false); return cacheManager; } } @Service @Slf4j public class UserService { @Autowired private UserRepository userRepository; // 快取結果 @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;) public User findById(Long id) { log.info(\u0026#34;從資料庫載入使用者：{}\u0026#34;, id); return userRepository.findById(id).orElse(null); } // 條件快取 @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#email\u0026#34;, condition = \u0026#34;#email.length() \u0026gt; 5\u0026#34;) public User findByEmail(String email) { return userRepository.findByEmail(email).orElse(null); } // 快取多個值 @Cacheable(value = \u0026#34;userProfiles\u0026#34;, key = \u0026#34;#user.id\u0026#34;, unless = \u0026#34;#result.isEmpty()\u0026#34;) public List\u0026lt;UserProfile\u0026gt; getUserProfiles(User user) { return userProfileRepository.findByUserId(user.getId()); } // 更新快取 @CachePut(value = \u0026#34;users\u0026#34;, key = \u0026#34;#user.id\u0026#34;) public User updateUser(User user) { log.info(\u0026#34;更新使用者並刷新快取：{}\u0026#34;, user.getId()); return userRepository.save(user); } // 清除快取 @CacheEvict(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;) public void deleteUser(Long id) { log.info(\u0026#34;刪除使用者並清除快取：{}\u0026#34;, id); userRepository.deleteById(id); } // 清除所有快取 @CacheEvict(value = \u0026#34;users\u0026#34;, allEntries = true) public void clearUserCache() { log.info(\u0026#34;清除所有使用者快取\u0026#34;); } // 組合快取操作 @Caching( cacheable = @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;), evict = @CacheEvict(value = \u0026#34;userStats\u0026#34;, key = \u0026#34;#id\u0026#34;) ) public User findAndUpdateStats(Long id) { User user = userRepository.findById(id).orElse(null); if (user != null) { updateUserStats(user); } return user; } // 自訂快取鍵生成器 @Cacheable(value = \u0026#34;userSearch\u0026#34;, keyGenerator = \u0026#34;customKeyGenerator\u0026#34;) public List\u0026lt;User\u0026gt; searchUsers(UserSearchCriteria criteria) { return userRepository.findByCriteria(criteria); } } @Component(\u0026#34;customKeyGenerator\u0026#34;) public class CustomKeyGenerator implements KeyGenerator { @Override public Object generate(Object target, Method method, Object... params) { return method.getName() + \u0026#34;_\u0026#34; + Arrays.toString(params); } } 測試註解 Spring Boot 測試註解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 // 完整的 Spring Boot 測試 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @TestPropertySource(properties = { \u0026#34;spring.datasource.url=jdbc:h2:mem:testdb\u0026#34;, \u0026#34;spring.jpa.hibernate.ddl-auto=create-drop\u0026#34; }) class IntegrationTest { @Autowired private TestRestTemplate restTemplate; @Autowired private UserService userService; @Test void testCreateUser() { CreateUserRequest request = new CreateUserRequest(\u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.postForEntity(\u0026#34;/api/users\u0026#34;, request, User.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED); assertThat(response.getBody().getName()).isEqualTo(\u0026#34;John\u0026#34;); } } // Web 層測試 @WebMvcTest(UserController.class) class UserControllerTest { @Autowired private MockMvc mockMvc; @MockBean private UserService userService; @Test void testGetUser() throws Exception { User user = new User(1L, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); when(userService.findById(1L)).thenReturn(user); mockMvc.perform(get(\u0026#34;/api/users/1\u0026#34;)) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.name\u0026#34;).value(\u0026#34;John\u0026#34;)) .andExpect(jsonPath(\u0026#34;$.email\u0026#34;).value(\u0026#34;john@example.com\u0026#34;)); } } // 資料層測試 @DataJpaTest class UserRepositoryTest { @Autowired private TestEntityManager entityManager; @Autowired private UserRepository userRepository; @Test void testFindByEmail() { // Given User user = new User(\u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); entityManager.persistAndFlush(user); // When Optional\u0026lt;User\u0026gt; found = userRepository.findByEmail(\u0026#34;john@example.com\u0026#34;); // Then assertThat(found).isPresent(); assertThat(found.get().getName()).isEqualTo(\u0026#34;John\u0026#34;); } } // JSON 序列化測試 @JsonTest class UserJsonTest { @Autowired private JacksonTester\u0026lt;User\u0026gt; json; @Test void testSerialize() throws Exception { User user = new User(1L, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;); assertThat(json.write(user)).isEqualToJson(\u0026#34;user.json\u0026#34;); assertThat(json.write(user)).hasJsonPathStringValue(\u0026#34;@.name\u0026#34;); assertThat(json.write(user)).extractingJsonPathStringValue(\u0026#34;@.name\u0026#34;).isEqualTo(\u0026#34;John\u0026#34;); } @Test void testDeserialize() throws Exception { String content = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34; } \u0026#34;\u0026#34;\u0026#34;; assertThat(json.parse(content)).usingRecursiveComparison() .isEqualTo(new User(1L, \u0026#34;John\u0026#34;, \u0026#34;john@example.com\u0026#34;)); } } 事件處理註解 @EventListener 和 @TransactionalEventListener 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // 事件定義 public class OrderCreatedEvent { private final Order order; private final LocalDateTime timestamp; public OrderCreatedEvent(Order order) { this.order = order; this.timestamp = LocalDateTime.now(); } // getters... } // 事件發布 @Service @RequiredArgsConstructor public class OrderService { private final OrderRepository orderRepository; private final ApplicationEventPublisher eventPublisher; @Transactional public Order createOrder(CreateOrderRequest request) { Order order = new Order(request); order = orderRepository.save(order); // 發布事件 eventPublisher.publishEvent(new OrderCreatedEvent(order)); return order; } } // 事件監聽 @Component @Slf4j public class OrderEventListener { @Autowired private EmailService emailService; @Autowired private InventoryService inventoryService; // 基本事件監聽 @EventListener public void handleOrderCreated(OrderCreatedEvent event) { log.info(\u0026#34;訂單創建事件：{}\u0026#34;, event.getOrder().getId()); } // 條件事件監聽 @EventListener(condition = \u0026#34;#event.order.amount \u0026gt; 1000\u0026#34;) public void handleHighValueOrder(OrderCreatedEvent event) { log.info(\u0026#34;高價值訂單創建：{}\u0026#34;, event.getOrder().getId()); // 特殊處理邏輯 } // 非同步事件處理 @EventListener @Async public void sendOrderConfirmationEmail(OrderCreatedEvent event) { log.info(\u0026#34;發送訂單確認郵件：{}\u0026#34;, event.getOrder().getId()); emailService.sendOrderConfirmation(event.getOrder()); } // 交易事件監聽（在交易提交後執行） @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT) public void updateInventoryAfterOrderCreated(OrderCreatedEvent event) { log.info(\u0026#34;交易提交後更新庫存：{}\u0026#34;, event.getOrder().getId()); inventoryService.updateStock(event.getOrder().getItems()); } // 交易回滾時執行 @TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK) public void handleOrderCreationRollback(OrderCreatedEvent event) { log.warn(\u0026#34;訂單創建回滾：{}\u0026#34;, event.getOrder().getId()); // 回滾處理邏輯 } // 監聽多種事件類型 @EventListener({OrderCreatedEvent.class, OrderUpdatedEvent.class}) public void handleOrderEvents(Object event) { log.info(\u0026#34;處理訂單事件：{}\u0026#34;, event.getClass().getSimpleName()); } } 總結 Spring Framework 的註解系統為開發者提供了強大且靈活的配置方式。透過合理使用這些註解，可以大幅簡化配置工作並提升開發效率。\n最佳實踐建議 優先使用註解配置：相比 XML 配置，註解更直觀且易於維護 組合使用註解：善用 @SpringBootApplication 等組合註解 適當使用條件註解：根據環境動態配置 Bean 驗證配置屬性：使用 @Validated 確保配置正確性 合理使用快取：在適當的地方使用快取提升效能 測試覆蓋：使用專門的測試註解進行各層測試 事件驅動設計：使用事件機制降低組件耦合度 注意事項 註解過載：避免在單一類別或方法上使用過多註解 配置外部化：敏感配置應使用外部屬性檔案 效能考量：注意代理模式可能帶來的效能影響 測試友善：設計時考慮測試的便利性 掌握這些註解的正確使用方式，將能大幅提升 Spring 應用程式的開發效率和程式碼品質。\n參考資料 Spring Framework Reference Documentation Spring Boot Reference Guide Spring Data JPA Reference Bean Validation Specification Cron Expression Generator ","permalink":"https://xinqilin.github.io/post/backend/springannotation/","tags":["Java","Spring","Annotation","Spring-Boot","Configuration","Web","Data","Security"],"title":"Spring Framework 註解完整指南：從基礎到進階應用"},{"content":"概述 AWK 是一種強大的模式掃描和處理語言，由 Alfred Aho、Peter Weinberger 和 Brian Kernighan 於 1977 年在貝爾實驗室開發。AWK 特別適合處理結構化文本資料，能夠進行複雜的文本分析、報表生成和資料提取。\n核心特徵 模式-動作程式設計：基於模式匹配執行相應動作 自動欄位分割：自動將輸入行分割為欄位 強大的內建變數：提供豐富的環境資訊 數學運算能力：支援完整的算術和字串操作 正規表達式支援：強大的模式匹配功能 基本語法 1 2 3 awk \u0026#39;pattern { action }\u0026#39; file(s) awk -f script.awk file(s) command | awk \u0026#39;pattern { action }\u0026#39; AWK 程式結構 1 2 3 awk \u0026#39;BEGIN { 初始化動作 } pattern { 主要處理動作 } END { 結束動作 }\u0026#39; file 基本範例 1 2 3 4 5 6 7 8 9 10 11 # 列印整個檔案 awk \u0026#39;{print}\u0026#39; file.txt # 等同於 awk \u0026#39;{print $0}\u0026#39; file.txt # 列印特定欄位 awk \u0026#39;{print $1, $3}\u0026#39; file.txt # 列印第1和第3欄位 # 簡單過濾 awk \u0026#39;/pattern/ {print}\u0026#39; file.txt # 列印包含 pattern 的行 # 計算統計 awk \u0026#39;{sum += $1} END {print sum}\u0026#39; file.txt # 計算第1欄位總和 欄位和記錄 欄位處理 AWK 自動將每行輸入分割為欄位，預設分隔符為空白字元：\n1 2 3 4 5 6 7 8 9 10 11 # 欄位變數 $0 # 整行內容 $1 # 第1個欄位 $2 # 第2個欄位 $NF # 最後一個欄位 $(NF-1) # 倒數第2個欄位 # 實際範例 echo \u0026#34;apple banana cherry\u0026#34; | awk \u0026#39;{print $2}\u0026#39; # banana echo \u0026#34;1 2 3 4 5\u0026#34; | awk \u0026#39;{print $NF}\u0026#39; # 5 echo \u0026#34;a:b:c:d\u0026#34; | awk -F: \u0026#39;{print $3}\u0026#39; # c 自訂分隔符 1 2 3 4 5 6 7 8 # 使用 -F 選項 awk -F: \u0026#39;{print $1, $3}\u0026#39; /etc/passwd # 使用冒號作分隔符 awk -F\u0026#39;,\u0026#39; \u0026#39;{print $2}\u0026#39; data.csv # CSV 檔案處理 awk -F\u0026#39;[,:]\u0026#39; \u0026#39;{print $1, $3}\u0026#39; file.txt # 多個分隔符 # 在程式中設定 awk \u0026#39;BEGIN {FS=\u0026#34;,\u0026#34;} {print $1, $2}\u0026#39; data.csv # 在 BEGIN 中設定 awk \u0026#39;{FS=\u0026#34;,\u0026#34;} NR\u0026gt;1 {print $1, $2}\u0026#39; data.csv # 動態改變分隔符 輸出欄位分隔符 1 2 3 4 5 6 7 # 設定輸出分隔符 awk \u0026#39;BEGIN {OFS=\u0026#34;\\t\u0026#34;} {print $1, $2, $3}\u0026#39; file.txt # 使用 tab 分隔輸出 awk \u0026#39;BEGIN {OFS=\u0026#34; | \u0026#34;} {print $1, $2}\u0026#39; file.txt # 使用 \u0026#34; | \u0026#34; 分隔 # 重建行 awk \u0026#39;{$1=$1; print}\u0026#39; file.txt # 重新格式化空白 awk \u0026#39;BEGIN {OFS=\u0026#34;,\u0026#34;} {$1=$1; print}\u0026#39; file.txt # 轉換為 CSV 格式 內建變數 核心內建變數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 記錄相關 NR # 總記錄數（行號） FNR # 當前檔案的記錄數 NF # 當前記錄的欄位數 # 分隔符相關 FS # 輸入欄位分隔符 OFS # 輸出欄位分隔符 RS # 輸入記錄分隔符 ORS # 輸出記錄分隔符 # 檔案相關 FILENAME # 當前處理的檔案名 ARGC # 命令行參數個數 ARGV # 命令行參數陣列 實用範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 使用 NR 添加行號 awk \u0026#39;{print NR, $0}\u0026#39; file.txt # 使用 NF 檢查欄位數 awk \u0026#39;NF != 3 {print \u0026#34;Line \u0026#34; NR \u0026#34; has \u0026#34; NF \u0026#34; fields\u0026#34;}\u0026#39; file.txt # 處理多個檔案時使用 FNR awk \u0026#39;{print FILENAME, FNR, $0}\u0026#39; file1.txt file2.txt # 使用 ARGC 和 ARGV awk \u0026#39;BEGIN { print \u0026#34;Total arguments:\u0026#34;, ARGC for (i=0; i\u0026lt;ARGC; i++) print \u0026#34;ARGV[\u0026#34; i \u0026#34;]:\u0026#34;, ARGV[i] }\u0026#39; file1 file2 特殊變數 1 2 3 4 5 6 7 8 9 10 11 # 數字格式 OFMT # 數字輸出格式（預設 \u0026#34;%.6g\u0026#34;） CONVFMT # 字串轉換格式 # 模式匹配 RSTART # match() 函數匹配的起始位置 RLENGTH # match() 函數匹配的長度 # 其他 SUBSEP # 下標分隔符（用於多維陣列） ENVIRON # 環境變數陣列 模式匹配 基本模式 1 2 3 4 5 6 7 8 9 10 11 12 13 # 正規表達式模式 awk \u0026#39;/pattern/ {print}\u0026#39; file.txt # 匹配包含 pattern 的行 awk \u0026#39;/^[0-9]/ {print}\u0026#39; file.txt # 匹配以數字開頭的行 awk \u0026#39;/\\.txt$/ {print}\u0026#39; file.txt # 匹配以 .txt 結尾的行 # 關係表達式模式 awk \u0026#39;$1 \u0026gt; 100 {print}\u0026#39; file.txt # 第1欄位 \u0026gt; 100 awk \u0026#39;NF == 5 {print}\u0026#39; file.txt # 有5個欄位的行 awk \u0026#39;length($0) \u0026gt; 80 {print}\u0026#39; file.txt # 行長度 \u0026gt; 80 # 範圍模式 awk \u0026#39;/start/,/end/ {print}\u0026#39; file.txt # 從 start 到 end 的行 awk \u0026#39;NR==5,NR==10 {print}\u0026#39; file.txt # 第5到10行 進階模式 1 2 3 4 5 6 7 8 9 10 11 # 組合模式 awk \u0026#39;/error/ \u0026amp;\u0026amp; $3 \u0026gt; 100 {print}\u0026#39; file.txt # AND 條件 awk \u0026#39;/warn/ || /error/ {print}\u0026#39; file.txt # OR 條件 awk \u0026#39;!/debug/ {print}\u0026#39; file.txt # NOT 條件 # 欄位模式匹配 awk \u0026#39;$2 ~ /pattern/ {print}\u0026#39; file.txt # 第2欄位匹配 pattern awk \u0026#39;$1 !~ /^[0-9]/ {print}\u0026#39; file.txt # 第1欄位不以數字開頭 # 複雜條件 awk \u0026#39;$1==\u0026#34;ERROR\u0026#34; \u0026amp;\u0026amp; $3\u0026gt;threshold {count++} END {print count}\u0026#39; file.txt 動作和控制結構 基本動作 1 2 3 4 5 6 7 8 # 列印動作 awk \u0026#39;{print}\u0026#39; file.txt # 列印整行 awk \u0026#39;{print $1, $2}\u0026#39; file.txt # 列印特定欄位 awk \u0026#39;{printf \u0026#34;%s: %d\\n\u0026#34;, $1, $2}\u0026#39; file.txt # 格式化列印 # 賦值動作 awk \u0026#39;{$1=\u0026#34;NEW\u0026#34;; print}\u0026#39; file.txt # 修改欄位值 awk \u0026#39;{sum += $1} END {print sum}\u0026#39; file.txt # 累加計算 控制結構 if-else 語句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 基本 if 語句 awk \u0026#39;{ if ($1 \u0026gt; 100) print \u0026#34;Large:\u0026#34;, $0 else print \u0026#34;Small:\u0026#34;, $0 }\u0026#39; file.txt # 多重條件 awk \u0026#39;{ if ($1 \u0026gt;= 90) grade = \u0026#34;A\u0026#34; else if ($1 \u0026gt;= 80) grade = \u0026#34;B\u0026#34; else if ($1 \u0026gt;= 70) grade = \u0026#34;C\u0026#34; else grade = \u0026#34;F\u0026#34; print $0, grade }\u0026#39; scores.txt 迴圈結構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # for 迴圈 awk \u0026#39;{ for (i=1; i\u0026lt;=NF; i++) { print \u0026#34;Field \u0026#34; i \u0026#34;:\u0026#34;, $i } }\u0026#39; file.txt # while 迴圈 awk \u0026#39;{ i = 1 while (i \u0026lt;= NF) { print $i i++ } }\u0026#39; file.txt # for-in 迴圈（陣列） awk \u0026#39;{ for (i in array) { print i, array[i] } }\u0026#39; file.txt 函數應用 字串函數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # length() - 字串長度 awk \u0026#39;{print length($0)}\u0026#39; file.txt # 每行長度 awk \u0026#39;length($0) \u0026gt; 80\u0026#39; file.txt # 長度超過80的行 # substr() - 子字串 awk \u0026#39;{print substr($1, 1, 3)}\u0026#39; file.txt # 第1欄位前3個字元 awk \u0026#39;{print substr($0, 5)}\u0026#39; file.txt # 從第5個字元開始 # index() - 查找位置 awk \u0026#39;{print index($0, \u0026#34;pattern\u0026#34;)}\u0026#39; file.txt # pattern 的位置 # split() - 分割字串 awk \u0026#39;{n=split($0, array, \u0026#34;,\u0026#34;); print n}\u0026#39; file.txt # 用逗號分割 # gsub() 和 sub() - 替換 awk \u0026#39;{gsub(/old/, \u0026#34;new\u0026#34;); print}\u0026#39; file.txt # 全域替換 awk \u0026#39;{sub(/old/, \u0026#34;new\u0026#34;); print}\u0026#39; file.txt # 只替換第一個 # tolower() 和 toupper() - 大小寫轉換 awk \u0026#39;{print tolower($0)}\u0026#39; file.txt # 轉小寫 awk \u0026#39;{print toupper($1)}\u0026#39; file.txt # 第1欄位轉大寫 數學函數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 基本數學函數 awk \u0026#39;{print sqrt($1)}\u0026#39; file.txt # 平方根 awk \u0026#39;{print int($1)}\u0026#39; file.txt # 取整數 awk \u0026#39;{print sin($1), cos($1)}\u0026#39; file.txt # 三角函數 # 統計函數 awk \u0026#39;{ sum += $1 count++ } END { print \u0026#34;Average:\u0026#34;, sum/count print \u0026#34;Total:\u0026#34;, sum }\u0026#39; file.txt # 最大值和最小值 awk \u0026#39;{ if (NR==1 || $1 \u0026gt; max) max = $1 if (NR==1 || $1 \u0026lt; min) min = $1 } END { print \u0026#34;Max:\u0026#34;, max, \u0026#34;Min:\u0026#34;, min }\u0026#39; file.txt 自訂函數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 定義函數 awk \u0026#39; function factorial(n) { if (n \u0026lt;= 1) return 1 return n * factorial(n-1) } { print $1, factorial($1) }\u0026#39; file.txt # 字串處理函數 awk \u0026#39; function trim(str) { gsub(/^[ \\t]+|[ \\t]+$/, \u0026#34;\u0026#34;, str) return str } { print trim($0) }\u0026#39; file.txt 陣列應用 一維陣列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 基本陣列操作 awk \u0026#39;{ arr[NR] = $0 } END { for (i=1; i\u0026lt;=NR; i++) { print i, arr[i] } }\u0026#39; file.txt # 關聯陣列 awk \u0026#39;{ count[$1]++ } END { for (item in count) { print item, count[item] } }\u0026#39; file.txt # 陣列排序 awk \u0026#39;{ arr[NR] = $1 } END { n = asort(arr) # 排序值 for (i=1; i\u0026lt;=n; i++) { print arr[i] } }\u0026#39; file.txt 多維陣列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 使用 SUBSEP 分隔多維索引 awk \u0026#39;BEGIN {SUBSEP = \u0026#34;:\u0026#34;} { matrix[$1,$2] = $3 } END { for (key in matrix) { print key, matrix[key] } }\u0026#39; file.txt # 二維統計 awk \u0026#39;{ sales[$1][$2] += $3 } END { for (region in sales) { for (product in sales[region]) { print region, product, sales[region][product] } } }\u0026#39; sales_data.txt 實戰應用場景 1. 日誌分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 存取日誌分析 awk \u0026#39;{ # 統計狀態碼 status[$9]++ # 統計 IP 地址 ip[$1]++ # 計算總流量 if ($10 != \u0026#34;-\u0026#34;) bytes += $10 } END { print \u0026#34;=== Status Code Statistics ===\u0026#34; for (code in status) { print code, status[code] } print \u0026#34;\\n=== Top 10 IP Addresses ===\u0026#34; PROCINFO[\u0026#34;sorted_in\u0026#34;] = \u0026#34;@val_num_desc\u0026#34; n = 0 for (addr in ip) { if (++n \u0026lt;= 10) print addr, ip[addr] } print \u0026#34;\\nTotal Bytes:\u0026#34;, bytes }\u0026#39; access.log # 錯誤日誌監控 awk \u0026#39; BEGIN { print \u0026#34;Error Analysis Report\u0026#34; } /ERROR|FATAL/ { split($1, date, \u0026#34;-\u0026#34;) errors[date[1] \u0026#34;-\u0026#34; date[2]]++ error_details[NR] = $0 } END { print \u0026#34;Errors by Month:\u0026#34; for (month in errors) { print month, errors[month] } }\u0026#39; error.log 2. 資料處理和統計 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # CSV 資料分析 awk -F, \u0026#39; NR==1 { # 跳過標題行 next } { # 銷售資料統計 total_sales += $3 sales_by_region[$2] += $3 if ($3 \u0026gt; max_sale) { max_sale = $3 max_sale_record = $0 } } END { print \u0026#34;Total Sales: $\u0026#34; total_sales print \u0026#34;Average Sale: $\u0026#34; total_sales/(NR-1) print \u0026#34;Largest Sale: $\u0026#34; max_sale print \u0026#34;Record:\u0026#34;, max_sale_record print \u0026#34;\\nSales by Region:\u0026#34; for (region in sales_by_region) { print region \u0026#34;: $\u0026#34; sales_by_region[region] } }\u0026#39; sales.csv # 成績統計 awk \u0026#39;{ # 計算每個學生的平均分 sum = 0 for (i=2; i\u0026lt;=NF; i++) { sum += $i subject_total[i-1] += $i } avg = sum / (NF-1) print $1, avg if (avg \u0026gt;= 90) grade_count[\u0026#34;A\u0026#34;]++ else if (avg \u0026gt;= 80) grade_count[\u0026#34;B\u0026#34;]++ else if (avg \u0026gt;= 70) grade_count[\u0026#34;C\u0026#34;]++ else grade_count[\u0026#34;F\u0026#34;]++ student_count++ } END { print \u0026#34;\\nGrade Distribution:\u0026#34; for (grade in grade_count) { printf \u0026#34;%s: %d (%.1f%%)\\n\u0026#34;, grade, grade_count[grade], grade_count[grade]/student_count*100 } }\u0026#39; grades.txt 3. 系統監控 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 程序監控 ps aux | awk \u0026#39; NR\u0026gt;1 { # 跳過標題行 cpu[$11] += $3 # 依程式名稱累加 CPU 使用率 mem[$11] += $4 # 依程式名稱累加記憶體使用率 proc_count[$11]++ } END { print \u0026#34;Process Resource Usage:\u0026#34; printf \u0026#34;%-20s %s %s %s\\n\u0026#34;, \u0026#34;PROCESS\u0026#34;, \u0026#34;COUNT\u0026#34;, \u0026#34;CPU%\u0026#34;, \u0026#34;MEM%\u0026#34; for (proc in cpu) { printf \u0026#34;%-20s %5d %6.1f %6.1f\\n\u0026#34;, proc, proc_count[proc], cpu[proc], mem[proc] } }\u0026#39; # 磁碟使用分析 df -h | awk \u0026#39; NR\u0026gt;1 { # 解析使用百分比 gsub(/%/, \u0026#34;\u0026#34;, $5) usage = $5 if (usage \u0026gt;= 90) { critical[++crit_count] = $6 \u0026#34; (\u0026#34; usage \u0026#34;%)\u0026#34; } else if (usage \u0026gt;= 80) { warning[++warn_count] = $6 \u0026#34; (\u0026#34; usage \u0026#34;%)\u0026#34; } } END { if (crit_count \u0026gt; 0) { print \u0026#34;CRITICAL: High disk usage detected!\u0026#34; for (i=1; i\u0026lt;=crit_count; i++) { print \u0026#34; \u0026#34; critical[i] } } if (warn_count \u0026gt; 0) { print \u0026#34;WARNING: Moderate disk usage:\u0026#34; for (i=1; i\u0026lt;=warn_count; i++) { print \u0026#34; \u0026#34; warning[i] } } }\u0026#39; 4. 文件格式轉換 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # JSON 簡單生成 awk -F, \u0026#39; BEGIN { print \u0026#34;{\u0026#34; } NR\u0026gt;1 { printf \u0026#34; \\\u0026#34;%s\\\u0026#34;: {\\n\u0026#34;, $1 printf \u0026#34; \\\u0026#34;name\\\u0026#34;: \\\u0026#34;%s\\\u0026#34;,\\n\u0026#34;, $2 printf \u0026#34; \\\u0026#34;age\\\u0026#34;: %d,\\n\u0026#34;, $3 printf \u0026#34; \\\u0026#34;city\\\u0026#34;: \\\u0026#34;%s\\\u0026#34;\\n\u0026#34;, $4 printf \u0026#34; }%s\\n\u0026#34;, (NR\u0026lt;total_lines ? \u0026#34;,\u0026#34; : \u0026#34;\u0026#34;) } END { print \u0026#34;}\u0026#34; }\u0026#39; data.csv # HTML 表格生成 awk -F, \u0026#39; BEGIN { print \u0026#34;\u0026lt;table border=\\\u0026#34;1\\\u0026#34;\u0026gt;\u0026#34; } NR==1 { print \u0026#34;\u0026lt;tr\u0026gt;\u0026#34; for (i=1; i\u0026lt;=NF; i++) { print \u0026#34;\u0026lt;th\u0026gt;\u0026#34; $i \u0026#34;\u0026lt;/th\u0026gt;\u0026#34; } print \u0026#34;\u0026lt;/tr\u0026gt;\u0026#34; } NR\u0026gt;1 { print \u0026#34;\u0026lt;tr\u0026gt;\u0026#34; for (i=1; i\u0026lt;=NF; i++) { print \u0026#34;\u0026lt;td\u0026gt;\u0026#34; $i \u0026#34;\u0026lt;/td\u0026gt;\u0026#34; } print \u0026#34;\u0026lt;/tr\u0026gt;\u0026#34; } END { print \u0026#34;\u0026lt;/table\u0026gt;\u0026#34; }\u0026#39; data.csv # 配置檔轉換 awk \u0026#39; /^[^#]/ \u0026amp;\u0026amp; /=/ { split($0, pair, \u0026#34;=\u0026#34;) key = pair[1] value = pair[2] gsub(/^[ \\t]+|[ \\t]+$/, \u0026#34;\u0026#34;, key) # trim gsub(/^[ \\t]+|[ \\t]+$/, \u0026#34;\u0026#34;, value) print key \u0026#34;: \\\u0026#34;\u0026#34; value \u0026#34;\\\u0026#34;\u0026#34; }\u0026#39; config.ini 5. 報表生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 # 銷售報表 awk -F, \u0026#39; BEGIN { print \u0026#34;Sales Report\u0026#34; print \u0026#34;============\u0026#34; total = 0 } NR\u0026gt;1 { date = $1 product = $2 amount = $3 # 按日期統計 daily_sales[date] += amount # 按產品統計 product_sales[product] += amount total += amount } END { print \u0026#34;\\nDaily Sales:\u0026#34; PROCINFO[\u0026#34;sorted_in\u0026#34;] = \u0026#34;@ind_str_asc\u0026#34; for (date in daily_sales) { printf \u0026#34;%-12s: $%8.2f\\n\u0026#34;, date, daily_sales[date] } print \u0026#34;\\nProduct Sales:\u0026#34; PROCINFO[\u0026#34;sorted_in\u0026#34;] = \u0026#34;@val_num_desc\u0026#34; for (product in product_sales) { printf \u0026#34;%-15s: $%8.2f (%4.1f%%)\\n\u0026#34;, product, product_sales[product], product_sales[product]/total*100 } printf \u0026#34;\\nTotal Sales: $%.2f\\n\u0026#34;, total }\u0026#39; sales.csv # 網站流量報表 awk \u0026#39;{ # 解析日期時間 gsub(/\\[|\\]/, \u0026#34;\u0026#34;, $4) split($4, datetime, \u0026#34;:\u0026#34;) date = datetime[1] hour = datetime[2] # 統計 daily_hits[date]++ hourly_hits[hour]++ if ($9 == \u0026#34;404\u0026#34;) not_found++ if ($9 ~ /^[45]/) errors++ total_hits++ } END { print \u0026#34;Website Traffic Report\u0026#34; print \u0026#34;=====================\u0026#34; print \u0026#34;\\nDaily Traffic:\u0026#34; for (date in daily_hits) { printf \u0026#34;%s: %d hits\\n\u0026#34;, date, daily_hits[date] } print \u0026#34;\\nHourly Distribution:\u0026#34; for (h=0; h\u0026lt;24; h++) { printf \u0026#34;%02d:00: %d hits\\n\u0026#34;, h, hourly_hits[h] } printf \u0026#34;\\nError Summary:\\n\u0026#34; printf \u0026#34;404 Errors: %d (%.1f%%)\\n\u0026#34;, not_found, not_found/total_hits*100 printf \u0026#34;5xx Errors: %d (%.1f%%)\\n\u0026#34;, errors, errors/total_hits*100 }\u0026#39; access.log 進階技巧 1. 多檔案處理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 比較兩個檔案 awk \u0026#39; FNR==NR { # 處理第一個檔案 file1[FNR] = $0 next } { # 處理第二個檔案 if (file1[FNR] != $0) { print \u0026#34;Line \u0026#34; FNR \u0026#34; differs:\u0026#34; print \u0026#34;File1: \u0026#34; file1[FNR] print \u0026#34;File2: \u0026#34; $0 } }\u0026#39; file1.txt file2.txt # 合併檔案資料 awk \u0026#39; FNR==NR { # 第一個檔案：建立索引 lookup[$1] = $2 next } { # 第二個檔案：查找並合併 if ($1 in lookup) { print $0, lookup[$1] } }\u0026#39; lookup.txt data.txt 2. 複雜文本解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # XML 簡單解析 awk \u0026#39; /\u0026lt;([^\u0026gt;]+)\u0026gt;([^\u0026lt;]*)\u0026lt;\\/\\1\u0026gt;/ { match($0, /\u0026lt;([^\u0026gt;]+)\u0026gt;([^\u0026lt;]*)\u0026lt;\\/\\1\u0026gt;/, arr) print \u0026#34;Tag:\u0026#34;, arr[1], \u0026#34;Content:\u0026#34;, arr[2] }\u0026#39; simple.xml # 配置檔解析 awk \u0026#39; /^\\[.*\\]$/ { # 區段標題 gsub(/\\[|\\]/, \u0026#34;\u0026#34;) section = $0 next } /^[^#].*=/ { # 鍵值對 split($0, kv, \u0026#34;=\u0026#34;) key = kv[1] value = kv[2] gsub(/^[ \\t]+|[ \\t]+$/, \u0026#34;\u0026#34;, key) gsub(/^[ \\t]+|[ \\t]+$/, \u0026#34;\u0026#34;, value) config[section][key] = value } END { for (sect in config) { print \u0026#34;[\u0026#34; sect \u0026#34;]\u0026#34; for (k in config[sect]) { print k \u0026#34; = \u0026#34; config[sect][k] } print \u0026#34;\u0026#34; } }\u0026#39; config.ini 3. 效能優化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 避免重複計算 awk \u0026#39;{ # 好的做法：儲存計算結果 len = length($0) if (len \u0026gt; max_len) { max_len = len longest_line = $0 } }\u0026#39; file.txt # 使用陣列而非字串連接 awk \u0026#39;{ # 好的做法：使用陣列 lines[NR] = $0 } END { for (i=NR; i\u0026gt;=1; i--) { print lines[i] } }\u0026#39; file.txt # 提早退出 awk \u0026#39;{ if (found_count \u0026gt;= 10) exit if (/pattern/) { print found_count++ } }\u0026#39; large_file.txt 腳本檔案 建立 script.awk 檔案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #!/usr/bin/awk -f BEGIN { FS = \u0026#34;,\u0026#34; OFS = \u0026#34;\\t\u0026#34; print \u0026#34;Processing CSV file...\u0026#34; } # 跳過空行 /^$/ { next } # 處理標題行 NR == 1 { print \u0026#34;Headers:\u0026#34;, $0 next } # 主要處理邏輯 { # 資料驗證 if (NF != 4) { print \u0026#34;Warning: Line \u0026#34; NR \u0026#34; has \u0026#34; NF \u0026#34; fields\u0026#34; \u0026gt; \u0026#34;/dev/stderr\u0026#34; next } # 處理資料 name = $1 age = $2 salary = $3 department = $4 # 統計 total_salary += salary dept_count[department]++ employee_count++ # 輸出處理結果 print name, age, salary, department } END { print \u0026#34;\\n=== Summary ===\u0026#34; print \u0026#34;Total employees:\u0026#34;, employee_count print \u0026#34;Average salary:\u0026#34;, total_salary/employee_count print \u0026#34;\\nDepartment distribution:\u0026#34; for (dept in dept_count) { printf \u0026#34;%-15s: %d\\n\u0026#34;, dept, dept_count[dept] } } 使用腳本：\n1 2 3 4 chmod +x script.awk ./script.awk data.csv # 或 awk -f script.awk data.csv 常見錯誤與除錯 1. 常見錯誤 1 2 3 4 5 6 7 8 9 10 # 錯誤：字串比較使用數值運算子 awk \u0026#39;$1 \u0026gt; \u0026#34;50\u0026#34;\u0026#39; file.txt # 錯誤：字串比較 awk \u0026#39;$1 + 0 \u0026gt; 50\u0026#39; file.txt # 正確：強制數值比較 # 錯誤：陣列索引問題 awk \u0026#39;{arr[0] = $1}\u0026#39; file.txt # 注意：AWK 陣列從1開始習慣使用 # 錯誤：未初始化變數 awk \u0026#39;{sum += $1} END {print sum/count}\u0026#39; file.txt # count 未初始化 awk \u0026#39;{sum += $1; count++} END {print sum/count}\u0026#39; file.txt # 正確 2. 除錯技巧 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 添加除錯輸出 awk \u0026#39;{ print \u0026#34;Debug: NR=\u0026#34; NR \u0026#34;, NF=\u0026#34; NF \u0026#34;, $0=\u0026#34; $0 \u0026gt; \u0026#34;/dev/stderr\u0026#34; # 主要邏輯 }\u0026#39; file.txt # 使用條件除錯 awk \u0026#39;{ if (debug) print \u0026#34;Processing:\u0026#34;, $0 # 主要邏輯 }\u0026#39; debug=1 file.txt # 分步驗證 awk \u0026#39;{print \u0026#34;Line \u0026#34; NR \u0026#34;: \u0026#34; $1}\u0026#39; file.txt | head -5 與其他工具整合 1. 與 grep 和 sed 組合 1 2 3 4 5 # 過濾後處理 grep \u0026#34;ERROR\u0026#34; log.txt | awk \u0026#39;{print $1, $3}\u0026#39; # 多步處理 cat data.txt | grep -v \u0026#34;^#\u0026#34; | sed \u0026#39;s/,/ /g\u0026#39; | awk \u0026#39;{print $1, $2}\u0026#39; 2. 與 sort 組合 1 2 3 4 5 # 排序後統計 awk \u0026#39;{print $1}\u0026#39; file.txt | sort | uniq -c | awk \u0026#39;{print $2, $1}\u0026#39; # 管道處理 awk \u0026#39;{print $3, $0}\u0026#39; file.txt | sort -nr | awk \u0026#39;{$1=\u0026#34;\u0026#34;; print}\u0026#39; 3. 與資料庫整合 1 2 3 4 5 6 7 8 9 10 11 # 生成 SQL 插入語句 awk -F, \u0026#39; NR\u0026gt;1 { printf \u0026#34;INSERT INTO users (name, age, city) VALUES (\\\u0026#34;%s\\\u0026#34;, %d, \\\u0026#34;%s\\\u0026#34;);\\n\u0026#34;, $1, $2, $3 }\u0026#39; data.csv # 生成批次更新腳本 awk \u0026#39;{ print \u0026#34;UPDATE table SET status=1 WHERE id=\u0026#34; $1 \u0026#34;;\u0026#34; }\u0026#39; ids.txt 總結 核心優勢 強大的模式匹配：支援複雜的正規表達式 豐富的內建功能：字串處理、數學運算、陣列操作 高效的文本處理：適合大量資料處理 靈活的程式結構：支援完整的程式設計概念 最佳實踐 善用 BEGIN 和 END：初始化和清理工作 合理使用陣列：避免記憶體過度使用 模式化程式設計：將常用邏輯封裝為函數 輸入驗證：檢查資料格式和欄位數量 錯誤處理：適當的錯誤檢查和恢復機制 學習路徑 1 2 3 4 5 6 7 8 9 10 11 12 # 基礎階段 awk \u0026#39;{print $1}\u0026#39; file.txt # 欄位處理 awk \u0026#39;/pattern/ {print}\u0026#39; file.txt # 模式匹配 awk \u0026#39;{sum += $1} END {print sum}\u0026#39; file.txt # 基本統計 # 進階階段 awk -F, \u0026#39;{arr[$1] += $2} END {for(i in arr) print i, arr[i]}\u0026#39; file.csv # 陣列應用 awk \u0026#39;function f(x) {return x*x} {print f($1)}\u0026#39; file.txt # 自訂函數 # 專家階段 awk \u0026#39;/start/,/end/ {if(/important/) print}\u0026#39; file.txt # 複雜模式 awk \u0026#39;BEGIN{PROCINFO[\u0026#34;sorted_in\u0026#34;]=\u0026#34;@val_num_desc\u0026#34;} ...\u0026#39; # 高級特性 AWK 是文本處理和資料分析的強大工具，掌握其核心概念和常用技巧，能夠大幅提升資料處理的效率和準確性。記住：AWK 的核心在於模式-動作程式設計思維，善用這個特性能夠解決複雜的文本處理問題。\n參考資料 GAWK Manual The AWK Programming Language Advanced Bash-Scripting Guide POSIX AWK Specification ","permalink":"https://xinqilin.github.io/post/tools/awk/","tags":["Linux","AWK","Text Processing","Data Analysis","Pattern Scanning","Shell","Unix"],"title":"AWK 程式設計完整指南：Linux 文本處理與資料分析利器"},{"content":"init 1 2 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;String, Integer\u0026gt;(); map.put(\u0026#34;a\u0026#34;, 1); putIfAbsent 有了就不塞, 沒有就塞 value (不存在就塞)\n1 2 3 4 map.putIfAbsent(\u0026#34;a\u0026#34;, 2); // return 1 System.out.println(map); // {a=1} map.putIfAbsent(\u0026#34;b\u0026#34;, 3); // return null (因不存在會回 null, 但會塞進 map) System.out.println(map); // {a=1, b=3} compute 1 2 3 4 map.compute(\u0026#34;a\u0026#34;, (k, v) -\u0026gt; v + 1); // return 2 System.out.println(map); // {a=2} map.compute(\u0026#34;b\u0026#34;, (k, v) -\u0026gt; v == null ? 1000 : v + 1); // return 1000 System.out.println(map); // {a=2, b=1000} computeIfAbsent 不存在就計算\n1 2 3 4 map.computeIfAbsent(\u0026#34;a\u0026#34;, k -\u0026gt; 2); // return 1 System.out.println(map); // {a=1} map.computeIfAbsent(\u0026#34;b\u0026#34;, k -\u0026gt; 1000); // return 1000 System.out.println(map); // {a=1, b=1000} computeIfPresent 存在就計算\n1 2 3 4 map.computeIfPresent(\u0026#34;a\u0026#34;, (k, v) -\u0026gt; v + 1); // return 2 System.out.println(map); // {a=2} map.computeIfPresent(\u0026#34;b\u0026#34;, (k, v) -\u0026gt; v == null ? 0 : v + 1); // reutrn null System.out.println(map); // {a=2} ","permalink":"https://xinqilin.github.io/post/backend/mapcompute/","tags":["Java","Map","HashMap","Collections","Data-Structure"],"title":"Java Map 計算方法詳解：putIfAbsent、compute、computeIfAbsent 使用指南"},{"content":"概述 sed（Stream Editor，流編輯器）是 Unix/Linux 系統中功能強大的文本處理工具。它能夠對文本流進行非互動式的編輯操作，包括搜尋、替換、插入、刪除等功能。作為管道處理的重要工具，sed 在自動化腳本和批次文本處理中扮演關鍵角色。\n核心特徵 流式處理：逐行處理文本，適合大檔案操作 非互動式：可在腳本中自動執行 正規表達式：支援強大的模式匹配 原地編輯：可直接修改原始檔案 管道友好：適合與其他命令組合使用 基本語法 1 2 3 sed [選項] \u0026#39;地址定界command\u0026#39; file(s) sed [選項] -e \u0026#39;script1\u0026#39; -e \u0026#39;script2\u0026#39; file(s) sed [選項] -f script.sed file(s) 常用選項 1 2 3 4 5 6 7 -n # 安靜模式，不自動列印處理結果 -e script # 指定要執行的腳本命令 -f file # 從檔案讀取腳本命令 -i[suffix] # 直接修改檔案（可選備份後綴） -r 或 -E # 使用擴展正規表達式 -s # 將多個檔案視為獨立處理 --debug # 偵錯模式，顯示執行過程 基本範例 1 2 3 4 5 6 7 8 # 基本文本替換 sed \u0026#39;s/old/new/\u0026#39; file.txt # 替換每行第一個匹配 sed \u0026#39;s/old/new/g\u0026#39; file.txt # 替換所有匹配 sed \u0026#39;s/old/new/2\u0026#39; file.txt # 替換每行第二個匹配 # 直接修改檔案 sed -i \u0026#39;s/old/new/g\u0026#39; file.txt # 直接修改原檔案 sed -i.bak \u0026#39;s/old/new/g\u0026#39; file.txt # 修改前先備份 地址定界 地址定界用於指定 sed 命令作用的行範圍：\n基本地址類型 1 2 3 4 5 6 7 8 9 10 11 12 # 行號地址 sed \u0026#39;3d\u0026#39; file.txt # 刪除第3行 sed \u0026#39;1,5d\u0026#39; file.txt # 刪除第1到5行 sed \u0026#39;3,$d\u0026#39; file.txt # 刪除第3行到檔案結尾 # 模式地址 sed \u0026#39;/pattern/d\u0026#39; file.txt # 刪除包含pattern的行 sed \u0026#39;/start/,/end/d\u0026#39; file.txt # 刪除從start到end之間的行 # 特殊地址 sed \u0026#39;$d\u0026#39; file.txt # 刪除最後一行 sed \u0026#39;0,/pattern/d\u0026#39; file.txt # 刪除到第一個匹配pattern的行 進階地址定界 1 2 3 4 5 6 7 8 9 10 11 12 # 步進地址 sed -n \u0026#39;1~2p\u0026#39; file.txt # 列印奇數行（從第1行開始，每2行一次） sed -n \u0026#39;2~2p\u0026#39; file.txt # 列印偶數行 sed -n \u0026#39;1~3p\u0026#39; file.txt # 每三行列印一次 # 地址取反 sed \u0026#39;3!d\u0026#39; file.txt # 刪除除第3行外的所有行 sed \u0026#39;/pattern/!d\u0026#39; file.txt # 只保留包含pattern的行 # 複雜地址組合 sed \u0026#39;1,3d; 5,7d\u0026#39; file.txt # 刪除1-3行和5-7行 sed \u0026#39;/^#/d; /^$/d\u0026#39; file.txt # 刪除註釋行和空行 核心命令詳解 1. 替換命令 (s) sed 最常用的命令，語法：s/pattern/replacement/flags\n基本替換 1 2 3 4 5 6 7 8 9 10 # 基本替換語法 sed \u0026#39;s/pattern/replacement/\u0026#39; file.txt # 替換每行第一個匹配 sed \u0026#39;s/pattern/replacement/g\u0026#39; file.txt # 全域替換 sed \u0026#39;s/pattern/replacement/2\u0026#39; file.txt # 替換第二個匹配 sed \u0026#39;s/pattern/replacement/2g\u0026#39; file.txt # 從第二個開始全部替換 # 使用不同分隔符 sed \u0026#39;s#/old/path#/new/path#g\u0026#39; file.txt # 使用 # 作為分隔符 sed \u0026#39;s|old|new|g\u0026#39; file.txt # 使用 | 作為分隔符 sed \u0026#39;s@old@new@g\u0026#39; file.txt # 使用 @ 作為分隔符 進階替換功能 1 2 3 4 5 6 7 8 9 10 11 12 13 # 大小寫轉換 sed \u0026#39;s/.*/\\U\u0026amp;/\u0026#39; file.txt # 全部轉大寫 sed \u0026#39;s/.*/\\L\u0026amp;/\u0026#39; file.txt # 全部轉小寫 sed \u0026#39;s/\\([a-z]\\)/\\U\\1/g\u0026#39; file.txt # 每個字母轉大寫 sed \u0026#39;s/\\b\\w/\\U\u0026amp;/g\u0026#39; file.txt # 單詞首字母大寫 # 使用捕獲群組 sed \u0026#39;s/\\([0-9]*\\)-\\([0-9]*\\)/\\2-\\1/\u0026#39; file.txt # 交換數字順序 sed \u0026#39;s/\\(.*\\): \\(.*\\)/\\2 - \\1/\u0026#39; file.txt # 重新排列格式 # 條件替換 sed \u0026#39;/pattern/s/old/new/g\u0026#39; file.txt # 只在包含pattern的行中替換 sed \u0026#39;1,10s/old/new/g\u0026#39; file.txt # 只在第1-10行中替換 2. 刪除命令 (d) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 基本刪除 sed \u0026#39;3d\u0026#39; file.txt # 刪除第3行 sed \u0026#39;1,5d\u0026#39; file.txt # 刪除第1-5行 sed \u0026#39;$d\u0026#39; file.txt # 刪除最後一行 # 模式刪除 sed \u0026#39;/pattern/d\u0026#39; file.txt # 刪除包含pattern的行 sed \u0026#39;/^$/d\u0026#39; file.txt # 刪除空行 sed \u0026#39;/^#/d\u0026#39; file.txt # 刪除註釋行 sed \u0026#39;/^[[:space:]]*$/d\u0026#39; file.txt # 刪除空行和只有空白的行 # 範圍刪除 sed \u0026#39;/start/,/end/d\u0026#39; file.txt # 刪除start到end之間的行 sed \u0026#39;/BEGIN/,/END/d\u0026#39; file.txt # 刪除BEGIN到END區塊 3. 列印命令 (p) 1 2 3 4 5 6 7 8 9 10 11 12 # 基本列印（通常與-n一起使用） sed -n \u0026#39;3p\u0026#39; file.txt # 只列印第3行 sed -n \u0026#39;1,5p\u0026#39; file.txt # 只列印第1-5行 sed -n \u0026#39;$p\u0026#39; file.txt # 只列印最後一行 # 模式列印 sed -n \u0026#39;/pattern/p\u0026#39; file.txt # 只列印包含pattern的行 sed -n \u0026#39;/^#/p\u0026#39; file.txt # 只列印註釋行 # 複製列印 sed \u0026#39;p\u0026#39; file.txt # 每行列印兩次 sed \u0026#39;/pattern/p\u0026#39; file.txt # 匹配行列印兩次 4. 插入和附加命令 (i, a, c) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 插入命令 (i) - 在指定行前插入 sed \u0026#39;3i\\New line before line 3\u0026#39; file.txt # 在第3行前插入 sed \u0026#39;/pattern/i\\New line\u0026#39; file.txt # 在匹配行前插入 # 附加命令 (a) - 在指定行後附加 sed \u0026#39;3a\\New line after line 3\u0026#39; file.txt # 在第3行後附加 sed \u0026#39;/pattern/a\\New line\u0026#39; file.txt # 在匹配行後附加 sed \u0026#39;$a\\Last line\u0026#39; file.txt # 在檔案末尾附加 # 替換命令 (c) - 替換整行 sed \u0026#39;3c\\Replacement line\u0026#39; file.txt # 替換第3行 sed \u0026#39;/pattern/c\\New content\u0026#39; file.txt # 替換匹配行 # 多行操作 sed \u0026#39;3i\\Line 1\\nLine 2\\nLine 3\u0026#39; file.txt # 插入多行 5. 檔案操作命令 (r, w) 1 2 3 4 5 6 7 8 # 讀取檔案 (r) sed \u0026#39;3r insert.txt\u0026#39; file.txt # 在第3行後插入檔案內容 sed \u0026#39;/pattern/r header.txt\u0026#39; file.txt # 在匹配行後插入檔案 # 寫入檔案 (w) sed -n \u0026#39;1,10w output.txt\u0026#39; file.txt # 將第1-10行寫入檔案 sed -n \u0026#39;/pattern/w matches.txt\u0026#39; file.txt # 將匹配行寫入檔案 sed \u0026#39;/ERROR/w errors.log\u0026#39; file.txt # 將錯誤行寫入日誌 正規表達式進階應用 基本正規表達式 (BRE) 1 2 3 4 5 6 7 8 9 # 基本元字元 sed \u0026#39;s/^/\u0026gt; /\u0026#39; file.txt # 在每行開頭加上 \u0026#34;\u0026gt; \u0026#34; sed \u0026#39;s/$/!/\u0026#39; file.txt # 在每行結尾加上 \u0026#34;!\u0026#34; sed \u0026#39;s/./X/g\u0026#39; file.txt # 將每個字元替換為X # 字元類別 sed \u0026#39;s/[0-9]/X/g\u0026#39; file.txt # 替換所有數字 sed \u0026#39;s/[a-zA-Z]/X/g\u0026#39; file.txt # 替換所有字母 sed \u0026#39;s/[[:digit:]]/X/g\u0026#39; file.txt # 使用POSIX字元類別 擴展正規表達式 (ERE) 1 2 3 4 5 6 7 8 9 10 # 使用 -E 或 -r 選項 sed -E \u0026#39;s/([0-9]+)-([0-9]+)/\\2-\\1/\u0026#39; file.txt # 交換連字號分隔的數字 sed -E \u0026#39;s/\\b[a-z]+/\\U\u0026amp;/g\u0026#39; file.txt # 單詞首字母大寫 sed -E \u0026#39;s/(.*\\.)(jpg|png)/\\1webp/\u0026#39; file.txt # 改變檔案副檔名 # 量詞使用 sed -E \u0026#39;s/a+/A/g\u0026#39; file.txt # 一個或多個a sed -E \u0026#39;s/a?/A/g\u0026#39; file.txt # 零個或一個a sed -E \u0026#39;s/a{3}/AAA/g\u0026#39; file.txt # 恰好三個a sed -E \u0026#39;s/a{2,4}/A/g\u0026#39; file.txt # 2到4個a 實戰應用場景 1. 檔案內容清理 1 2 3 4 5 6 7 8 9 10 # 清理空行和註釋 sed \u0026#39;/^$/d; /^#/d\u0026#39; file.txt # 刪除空行和註釋行 sed \u0026#39;/^[[:space:]]*$/d\u0026#39; file.txt # 刪除空行和只有空白的行 sed \u0026#39;s/[[:space:]]*$//\u0026#39; file.txt # 刪除行尾空白 sed \u0026#39;s/^[[:space:]]*//\u0026#39; file.txt # 刪除行首空白 # 清理特殊字元 sed \u0026#39;s/\\r$//\u0026#39; file.txt # 刪除Windows換行符 sed \u0026#39;s/\\t/ /g\u0026#39; file.txt # 將tab替換為空格 sed \u0026#39;s/[[:cntrl:]]//g\u0026#39; file.txt # 刪除控制字元 2. 資料格式轉換 1 2 3 4 5 6 7 8 9 10 11 12 # CSV處理 sed \u0026#39;s/,/\\t/g\u0026#39; data.csv # CSV轉TSV sed \u0026#39;s/;/,/g\u0026#39; file.csv # 更改分隔符 sed \u0026#39;1d\u0026#39; data.csv # 刪除標題行 # 日期格式轉換 sed -E \u0026#39;s/([0-9]{4})-([0-9]{2})-([0-9]{2})/\\3\\/\\2\\/\\1/g\u0026#39; file.txt # 2023-12-25 -\u0026gt; 25/12/2023 # 電話號碼格式化 sed -E \u0026#39;s/([0-9]{3})([0-9]{3})([0-9]{4})/(\\1) \\2-\\3/\u0026#39; file.txt # 1234567890 -\u0026gt; (123) 456-7890 3. 程式碼處理 1 2 3 4 5 6 7 8 9 # 批次重構程式碼 find . -name \u0026#34;*.java\u0026#34; -exec sed -i \u0026#39;s/oldClassName/newClassName/g\u0026#39; {} \\; # 移除偵錯程式碼 sed \u0026#39;/console\\.log/d\u0026#39; script.js # 刪除console.log行 sed \u0026#39;/DEBUG/,/END_DEBUG/d\u0026#39; code.c # 刪除DEBUG區塊 # 添加授權標題 sed \u0026#39;1i\\// Copyright 2023 Company Name\u0026#39; *.js # 在每個JS檔案開頭添加版權 4. 日誌分析 1 2 3 4 5 6 7 8 9 10 # 提取特定時間範圍的日誌 sed -n \u0026#39;/2023-12-01/,/2023-12-31/p\u0026#39; access.log # 過濾錯誤日誌 sed -n \u0026#39;/ERROR\\|FATAL/p\u0026#39; application.log # 只顯示錯誤和致命錯誤 sed \u0026#39;/INFO\\|DEBUG/d\u0026#39; application.log # 隱藏資訊和偵錯訊息 # 日誌格式化 sed \u0026#39;s/\\[\\([^]]*\\)\\]/\\1/g\u0026#39; syslog # 移除方括號 sed -E \u0026#39;s/^([^ ]+) ([^ ]+)/[\\1] \\2:/\u0026#39; log.txt # 重新格式化時間戳 5. 設定檔管理 1 2 3 4 5 6 7 8 # 修改設定值 sed -i \u0026#39;s/^port=.*/port=8080/\u0026#39; config.ini # 修改連接埠設定 sed -i \u0026#39;/^#.*debug/s/^#//\u0026#39; config.conf # 取消註釋debug設定 sed -i \u0026#39;/^debug=/s/false/true/\u0026#39; config.conf # 啟用debug模式 # 添加設定項目 sed -i \u0026#39;/\\[database\\]/a\\timeout=30\u0026#39; config.ini # 在[database]段落後添加設定 sed -i \u0026#39;$a\\new_setting=value\u0026#39; config.conf # 在檔案末尾添加設定 進階技巧 1. 多命令處理 1 2 3 4 5 6 7 8 # 使用分號分隔命令 sed \u0026#39;1d; s/old/new/g; $a\\EOF\u0026#39; file.txt # 使用-e選項 sed -e \u0026#39;1d\u0026#39; -e \u0026#39;s/old/new/g\u0026#39; -e \u0026#39;$a\\EOF\u0026#39; file.txt # 使用大括號組合命令 sed \u0026#39;/pattern/{s/old/new/; p;}\u0026#39; file.txt 2. 條件處理 1 2 3 4 5 6 7 8 # 分支和標籤 sed \u0026#39;:label; s/\\([0-9]*\\),\\([0-9]\\)/\\1\\2,/; t label\u0026#39; file.txt # 移除數字中的逗號 # 測試命令 sed \u0026#39;s/old/new/; t end; s/fallback/replacement/; :end\u0026#39; file.txt # 複雜條件邏輯 sed \u0026#39;/pattern1/{s/old/new/; b}; /pattern2/s/old/different/\u0026#39; file.txt 3. 保持空間 (Hold Space) 1 2 3 4 5 6 # 基本保持空間操作 sed -n \u0026#39;1h; 2g; 2p\u0026#39; file.txt # 將第1行複製到第2行位置顯示 sed -n \u0026#39;1h; 1!H; $!d; x; p\u0026#39; file.txt # 反轉檔案行順序 # 複雜的保持空間範例 sed -n \u0026#39;/pattern/{h; n; s/old/new/; H; x; s/\\n/ - /; p;}\u0026#39; file.txt 4. 腳本檔案 建立 script.sed 檔案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 這是一個sed腳本檔案 # 刪除空行 /^$/d # 刪除註釋行 /^#/d # 替換特定模式 s/old_pattern/new_pattern/g # 在檔案末尾添加內容 $a\\ Processing completed. 使用腳本：\n1 sed -f script.sed input.txt 效能優化與最佳實踐 1. 效能優化技巧 1 2 3 4 5 6 7 8 9 10 # 使用quit命令提早退出 sed \u0026#39;10q\u0026#39; file.txt # 只處理前10行後退出 sed \u0026#39;/pattern/q\u0026#39; file.txt # 找到匹配後立即退出 # 避免不必要的處理 sed -n \u0026#39;/pattern/p\u0026#39; file.txt # 使用-n避免自動列印 sed \u0026#39;/pattern/!d\u0026#39; file.txt # 只保留匹配行 # 組合多個操作 sed \u0026#39;s/old1/new1/g; s/old2/new2/g\u0026#39; file.txt # 一次執行多個替換 2. 記憶體使用優化 1 2 3 4 5 6 # 處理大檔案時的注意事項 sed \u0026#39;1,1000d\u0026#39; hugefile.txt \u0026gt; output.txt # 分段處理大檔案 sed -n \u0026#39;1000,2000p\u0026#39; hugefile.txt # 只處理特定範圍 # 使用管道減少中間檔案 cat input.txt | sed \u0026#39;s/old/new/g\u0026#39; | sed \u0026#39;/pattern/d\u0026#39; \u0026gt; output.txt 3. 錯誤處理 1 2 3 4 5 6 7 8 9 # 備份重要檔案 sed -i.backup \u0026#39;s/old/new/g\u0026#39; important.txt # 自動備份 # 測試命令 sed \u0026#39;s/old/new/g\u0026#39; file.txt \u0026gt; test_output.txt # 先測試輸出 diff file.txt test_output.txt # 檢查差異 # 檢查檔案存在 [ -f file.txt ] \u0026amp;\u0026amp; sed -i \u0026#39;s/old/new/g\u0026#39; file.txt 常見錯誤與除錯 1. 常見錯誤 1 2 3 4 5 6 7 8 9 10 11 # 錯誤：未轉義特殊字元 sed \u0026#39;s/file.txt/newfile.txt/\u0026#39; file # 錯誤：.匹配任意字元 sed \u0026#39;s/file\\.txt/newfile.txt/\u0026#39; file # 正確：轉義.字元 # 錯誤：地址範圍問題 sed \u0026#39;1,$s/old/new/\u0026#39; file.txt # 可能造成混淆 sed \u0026#39;1,$ s/old/new/\u0026#39; file.txt # 更清楚的寫法 # 錯誤：忘記分隔符轉義 sed \u0026#39;s/http://old.com/http://new.com/\u0026#39; file # 錯誤：分隔符衝突 sed \u0026#39;s#http://old.com#http://new.com#\u0026#39; file # 正確：使用不同分隔符 2. 除錯技巧 1 2 3 4 5 6 7 8 9 # 使用偵錯模式 sed --debug \u0026#39;s/old/new/g\u0026#39; file.txt # 逐步測試 sed -n \u0026#39;l\u0026#39; file.txt # 顯示不可見字元 sed = file.txt | sed \u0026#39;N; s/\\n/\\t/\u0026#39; # 顯示行號 # 測試正規表達式 echo \u0026#34;test string\u0026#34; | sed \u0026#39;s/pattern/replacement/\u0026#39; 與其他工具整合 1. 與 find 組合 1 2 3 4 5 6 # 批次處理檔案 find . -name \u0026#34;*.txt\u0026#34; -exec sed -i \u0026#39;s/old/new/g\u0026#39; {} \\; find . -name \u0026#34;*.conf\u0026#34; -exec sed -i \u0026#39;/^#/d\u0026#39; {} \\; # 使用 xargs 提升效能 find . -name \u0026#34;*.txt\u0026#34; | xargs sed -i \u0026#39;s/old/new/g\u0026#39; 2. 與 awk 組合 1 2 3 4 5 # sed處理格式，awk處理邏輯 sed \u0026#39;s/,/ /g\u0026#39; data.csv | awk \u0026#39;{print $1, $3}\u0026#39; # 管道組合處理 cat log.txt | sed \u0026#39;/ERROR/!d\u0026#39; | awk \u0026#39;{print $1, $4}\u0026#39; 3. 與 grep 組合 1 2 3 4 5 # 先過濾再處理 grep \u0026#34;pattern\u0026#34; file.txt | sed \u0026#39;s/old/new/g\u0026#39; # 組合條件處理 sed -n \u0026#39;/start/,/end/p\u0026#39; file.txt | grep \u0026#34;important\u0026#34; 實用腳本範例 1. 日誌清理腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/bin/bash # log_cleanup.sh - 清理和格式化日誌檔案 LOG_FILE=\u0026#34;$1\u0026#34; OUTPUT_FILE=\u0026#34;${LOG_FILE}.clean\u0026#34; sed -e \u0026#39;/^$/d\u0026#39; \\ -e \u0026#39;/^#/d\u0026#39; \\ -e \u0026#39;s/[[:space:]]*$//\u0026#39; \\ -e \u0026#39;s/\\t/ /g\u0026#39; \\ -e \u0026#39;/DEBUG/d\u0026#39; \\ \u0026#34;$LOG_FILE\u0026#34; \u0026gt; \u0026#34;$OUTPUT_FILE\u0026#34; echo \u0026#34;清理完成：$OUTPUT_FILE\u0026#34; 2. 設定檔更新腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/bin/bash # config_update.sh - 批次更新設定檔 CONFIG_DIR=\u0026#34;/etc/myapp\u0026#34; BACKUP_DIR=\u0026#34;/etc/myapp/backup\u0026#34; # 備份設定檔 mkdir -p \u0026#34;$BACKUP_DIR\u0026#34; cp \u0026#34;$CONFIG_DIR\u0026#34;/*.conf \u0026#34;$BACKUP_DIR\u0026#34;/ # 更新設定 find \u0026#34;$CONFIG_DIR\u0026#34; -name \u0026#34;*.conf\u0026#34; -exec sed -i \\ -e \u0026#39;s/^port=.*/port=8080/\u0026#39; \\ -e \u0026#39;s/^debug=false/debug=true/\u0026#39; \\ -e \u0026#39;/^#.*logging/s/^#//\u0026#39; \\ {} \\; echo \u0026#34;設定更新完成\u0026#34; 3. 程式碼重構腳本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/bin/bash # refactor.sh - 批次重構程式碼 OLD_CLASS=\u0026#34;$1\u0026#34; NEW_CLASS=\u0026#34;$2\u0026#34; if [ $# -ne 2 ]; then echo \u0026#34;用法: $0 \u0026lt;舊類別名\u0026gt; \u0026lt;新類別名\u0026gt;\u0026#34; exit 1 fi # 更新Java檔案 find . -name \u0026#34;*.java\u0026#34; -exec sed -i \\ -e \u0026#34;s/class $OLD_CLASS/class $NEW_CLASS/g\u0026#34; \\ -e \u0026#34;s/new $OLD_CLASS(/new $NEW_CLASS(/g\u0026#34; \\ -e \u0026#34;s/$OLD_CLASS\\.class/$NEW_CLASS.class/g\u0026#34; \\ {} \\; echo \u0026#34;重構完成：$OLD_CLASS -\u0026gt; $NEW_CLASS\u0026#34; 總結 核心優勢 高效率：流式處理，記憶體使用量小 靈活性：支援複雜的文本操作 自動化：適合腳本和批次處理 標準化：跨平台一致性好 最佳實踐 測試先行：重要操作前先測試輸出 備份重要檔案：使用 -i.backup 選項 善用正規表達式：提升處理效率 組合工具：與其他命令協作使用 腳本化：將複雜操作封裝為腳本 學習建議 1 2 3 4 5 6 7 # 常用操作記憶口訣 sed \u0026#39;s/old/new/g\u0026#39; # 替換：substitute sed \u0026#39;3d\u0026#39; # 刪除：delete sed \u0026#39;3p\u0026#39; # 列印：print sed \u0026#39;3a\\text\u0026#39; # 附加：append sed \u0026#39;3i\\text\u0026#39; # 插入：insert sed \u0026#39;3c\\text\u0026#39; # 改變：change sed 是文本處理的瑞士軍刀，掌握其核心概念和常用操作，能夠大幅提升 Linux 系統管理和自動化腳本的效率。記住：實務中最重要的是理解模式空間的概念，並善用地址定界來精確控制操作範圍。\n參考資料 GNU sed Manual sed \u0026amp; awk by O\u0026rsquo;Reilly Advanced Bash-Scripting Guide Regular Expressions Info ","permalink":"https://xinqilin.github.io/post/tools/sed/","tags":["Linux","Sed","Stream Editor","Text Processing","Regular Expression","Shell","Unix"],"title":"Sed 流編輯器完整指南：Linux 文本處理的強大工具"},{"content":"Memento 當我們想要保存對象的狀態以便以後恢復它時，我們使用備忘錄設計模式。備忘錄模式有助於以這樣一種方式實現這一點，即對象的已保存狀態數據在對像外部無法訪問；這保護了已保存狀態數據的完整性。\n實現 Memento 模式的想法始於兩個對象—— Originator 和 Caretaker。Originator是需要保存和恢復狀態的對象，它使用一個內部類來保存Object的狀態。內部類稱為 Memento 及其私有，因此無法從其他對象訪問。\nCaretaker 是幫助類，負責通過 Memento 對象存儲和恢復 Originator 的狀態。由於 Memento 對 Originator 是私有的，因此 Caretaker 無法訪問它，並且它作為 Object 存儲在 caretaker 中。\n現實生活中最好的例子之一是 IDE, 我們可以隨時保存其數據並使用撤消將其恢復到以前保存的狀態。\n必須保存對象狀態（某些部分）的快照，以便以後可以將其恢復到該狀態，並且 獲取狀態的直接接口會暴露實現細節並破壞對象的封裝。 ","permalink":"https://xinqilin.github.io/post/architecture/memento/","tags":[],"title":"DesignPattern - Behavioral - Memento"},{"content":"Interpreter 用它來定義一種語言的語法表示，它提供了一個解釋器來處理語法。這種模式的最佳示例是 java 編譯器，它將 java 源代碼解釋為 JVM 可以理解的字節碼。google translation 也是Interpreter 的一個例子，其中輸入可以是任何語言，我們可以得到另一種語言的解釋輸出。\n為了 Interpreter，我們需要創建 Interpreter 上下文引擎來完成解釋工作。然後，我們需要創建不同的 Expression 實現，這些實現將使用解釋器上下文提供的功能。最後，我們需要創建客戶端，該客戶端將從用戶那裡獲取輸入並決定使用哪個表達式，然後為用戶生成輸出。\n語法很簡單。對於復雜的語法，語法的類層次結構變得龐大且難以管理。在這種情況下，解析器生成器等工具是更好的選擇。他們可以在不構建抽象語法樹 (AST) 的情況下解釋表達式，這也可以節省空間和時間。 效率不是關鍵問題。最有效的解釋器通常不是通過直接解釋解析樹來實現，而是首先將它們翻譯成另一種形式。例如，正則表達式經常被轉換為狀態機。但即便如此，我們也可以藉助解釋器模式來實現翻譯器，因此該模式仍然適用。 ","permalink":"https://xinqilin.github.io/post/architecture/interpreter/","tags":[],"title":"DesignPattern - Behavioral - Interpreter"},{"content":"Iterator Iterator 是一種行為模式，使用它來提供一種標準的方式來遍歷一組對象。我們在 Java 集合框架中廣泛使用 Iterator，其中迭代器接口提供了遍歷集合的方法。 迭代的邏輯嵌入在集合本身中，它可以幫助客戶端程序輕鬆地對其進行迭代。Iterator 對象包含公共方法，以允許客戶端對像在容器內的對象列表迭代。\nIterator 定義 interface 用來迭代或存取的接口\nConcreteIterator implement Iterator interface tracking the current position in the traversal of the aggregate.\nAggregate 定義用於創建 Iterator 對象的接口。\nConcreteAggregate 實現 Iterator 創建接口以返回正確的 ConcreteIterator 的實例。\n當想提供一種標準方法來迭代集合併隱藏客戶端程序的實現邏輯時。 當您需要訪問聚合對象的內容而不暴露其內部表示時。 支持聚合對象的多次遍歷。 為遍歷不同的聚合結構提供統一的接口（即支持多態迭代）。 ","permalink":"https://xinqilin.github.io/post/architecture/iterator/","tags":[],"title":"DesignPattern - Behavioral - Iterator"},{"content":"Visitor 當必須對一組相似類型的對象執行操作時，我們使用訪問者模式。借助 visitor pattern，我們可以將操作邏輯從對象轉移到另一個類。例如，考慮一個購物車，我們可以在其中添加不同類型的商品（元素），當我們點擊結帳按鈕時，它會計算出我們需要支付的總金額。現在，我們可以在項目類中包含計算邏輯，或者我們可以使用 visitor pattern 將此邏輯移到另一個類中。因此，使用 visitor pattern，我們可以將邏輯移到另一個類。\nvisitor pattern 允許在不更改集合中任何對象的類的情況下定義操作。為此，visitor pattern 建議在稱為 visitor類的單獨類中定義操作。這將操作與其操作的對象集合分開。對於要定義的每個新操作，都會創建一個新的訪問者類。由於操作將在一組對像上執行，因此訪問者需要一種訪問這些對象的公共成員的方法。\nVisitor：為對象結構中的每個 ConcreteElement 類聲明一個訪問操作。操作的名稱和簽名標識向訪問者發送訪問請求的類。這讓訪問者可以確定被訪問元素的具體類。然後訪問者可以通過其特定的界面直接訪問該元素。 ConcreteVisitor：實現訪問者聲明的每個操作。每個操作都實現了為結構中的相應對像類定義的算法片段。ConcreteVisitor 為算法提供上下文並存儲其本地狀態。這種狀態通常會在結構的遍歷過程中累積結果。 Element：定義一個接受訪問者作為參數的操作。 ConcreteElement：實現以訪問者為參數的 Accept 操作。 ObjectStructure:\n可以枚舉它的元素。 可以提供高級界面以允許訪問者訪問其元素。 可以是組合或集合，例如列表或集合。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public interface ShoppingCartElement { public int accept(ShoppingCartVisitor visitor); } public class Beef implements ShoppingCartElement { private int price; private double weight; // constructor , getter , setter @Override //Notice the implementation of accept() method in concrete classes, //its calling visit() method of Visitor and passing itself as argument. public int accept(ShoppingCartVisitor visitor) { return visitor.visit(this); } } public class Fruit implements ShoppingCartElement { private int pricePerKg; private int weight; private String name; // constructor , getter , setter @Override public int accept(ShoppingCartVisitor visitor) { return visitor.visit(this); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public interface ShoppingCartVisitor { int visit(Beef book); int visit(Fruit fruit); } public class ShoppingCartVisitorImpl implements ShoppingCartVisitor { @Override public int visit(Beef beef) { var cost = 0; //apply 5$ discount if book price is greater than 50 if(beef.getPrice() \u0026gt; 50){ cost = beef.getPrice() - 5; } else { cost = beef.getPrice(); } log.info(\u0026#34;beef: {}\u0026#34;, beef); return cost; } @Override public int visit(Fruit fruit) { var cost = fruit.getPricePerKg() * fruit.getWeight(); log.info(\u0026#34;cost: \u0026#34; + cost); return cost; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public static void main(String[] args) { var items = new ShoppingCartElement[]{ new Beef(20, 2.0), new Beef(100, 3.0), new Fruit(10, 2, \u0026#34;Apple\u0026#34;), new Fruit(5, 5, \u0026#34;Banana\u0026#34;) }; int total = calculatePrice(items); log.info(\u0026#34;total: \u0026#34; + total); } private static int calculatePrice(ShoppingCartElement[] items) { var visitor = new ShoppingCartVisitorImpl(); int sum = 0; for(ShoppingCartElement item : items){ sum += item.accept(visitor); } return sum; } 一個對象結構包含許多具有不同接口的對像類，並且您希望對這些對象執行依賴於它們的具體類的操作。 當我們需要對對象結構中的對象執行許多不同且不相關的操作時，我們希望避免這些操作 \u0026ldquo;污染\u0026rdquo; 它們的 class。訪問者允許您通過在一個類中定義相關操作來將它們保持在一起。當我們需要與許多應用程序共享對象結構時，使用訪問者將操作放在那些需要它們的應用程序中。 定義對象結構的類很少更改，但您經常希望在該結構上定義新操作。但是，更改對象結構類需要重新定義所有訪問者的接口，這可能是昂貴的。如果對象結構類經常更改，那麼最好在這些類中定義操作。 ","permalink":"https://xinqilin.github.io/post/architecture/visitor/","tags":[],"title":"DesignPattern - Behavioral - Visitor"},{"content":"State 當對像在其內部狀態改變時改變其行為時，我們使用狀態設計模式。我們可以將對象的狀態定義為其在任何給定時間點的確切條件，具體取決於其屬性或屬性的值。一個類實現的一組方法構成了它的實例的行為。每當其屬性值發生變化時，我們就說對象的狀態發生了變化。\n首次創建 Context 對象時，它會使用其初始 State 對像對其自身進行初始化。此 State 對象成為上下文的當前 State 對象。通過用新的 State 對象替換當前的 State 對象，上下文轉換到新的狀態。當應用程序對象調用 Context 方法（行為）時，它會將方法調用轉發到其當前的 State 對象。\n上下文：定義客戶感興趣的接口。此外，它維護了一個定義當前狀態的 ConcreteState 子類的實例。 State： 定義一個接口，用於封裝與 Context 的特定狀態相關的行為。 ConcreteState 子類：每個子類實現與上下文狀態相關聯的行為。 在狀態模式中，我們有一個 Context 類，並且這個類有一個對具體狀態實例的狀態引用。State 接口聲明了表示特定狀態行為的特定方法。具體國家實施這些行為。通過改變上下文的具體狀態，我們改變了它的行為。本質上，在狀態模式中，一個類（上下文）應該根據其狀態表現得像不同的類。狀態模式避免使用 switch 和 if 語句來改變行為。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public interface MacState { public void getState(); } public class Lighting implements MacState { @Override public void getState() { System.out.println(\u0026#34;mac bright!\u0026#34;); } } public class Close implements MacState { @Override public void getState() { System.out.println(\u0026#34;Mac is shut down\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 public class MacContext implements MacState { private MacState macState; // constructor , setter , getter public void getState(){ macState.getState(); } } 1 2 3 4 5 6 7 8 9 10 11 public static void main(String[] args) { var ctx = new MacContext(new Lighting()); ctx.getState(); ctx.getState(); ctx.setMacState(new Close()); ctx.getState(); ctx.getState(); ctx.getState(); } 狀態模式的好處之一是多態行為的實現，這是清晰可見的。因此，出錯的可能性較小。此外，很容易為其他行為添加更多狀態，使其更加健壯、易於維護和靈活。此外，在這種情況下，狀態模式有助於避免 if-else 或 switch-case 條件邏輯。\n當對象的行為取決於其狀態時，它必須在運行時根據其狀態改變其行為。 當操作具有依賴於對象狀態的大型、多部分條件語句時。這種狀態通常由一個或多個枚舉常量表示。通常，多個操作將包含相同的條件結構。狀態模式將條件的每個分支放在一個單獨的類中。 這讓我們可以將對象的狀態視為一個可以獨立於其他對像變化的對象。 ","permalink":"https://xinqilin.github.io/post/architecture/state/","tags":[],"title":"DesignPattern - Behavioral - State"},{"content":"Command Command Pattern 是一種行為對象設計模式。在 Command Pattern 中，命令接口聲明了用於執行特定操作的方法。具體的 Command 類實現了 Command interface 的 execute()方法，這個execute()方法調用了具體 Command 類所包含的 Receiver 類的相應動作方法。此外，Receiver 類執行特定的操作。但是，客戶端類負責創建具體命令並設置具體命令的接收者。此外，Invoker 類包含對 Command 的引用，並具有執行 Command 的方法。\n在命令模式中，調用者與接收者執行的動作分離。調用者不知道接收者。調用者調用命令，命令執行接收者的適當動作。因此，調用者可以在不知道要執行的動作的細節的情況下調用命令。此外，這種解耦意味著對接收者動作的更改不會直接影響動作的調用。\n我們甚至可以使用命令模式來執行“撤消”功能。在這種情況下，Command 接口應該包含一個方法，例如 unexecuted() 方法。\n不用說，它還幫助我們在請求-響應模型中實現松耦合。簡而言之，請求被發送給調用者，調用者將其傳遞給封裝的 命令對象。命令對象將請求傳遞給 Receiver的適當方法以執行特定操作。客戶端程序創建接收器對象，然後將其附加到命令。然後，它創建調用程序對象並附加命令對像以執行操作。現在，當客戶端程序執行動作時，它會根據命令和接收器對象進行處理。\nCommand是一個帶有 execute() 方法的接口。它是契約的核心。 Client 創建一個命令實現的實例並將其與接收器相關聯。 Invoker指示命令執行操作。 命令實現的實例在接收者和動作之間創建一個綁定。 Receiver 是知道執行操作的實際步驟的對象。任何類都可以作為接收者。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // command pattern 起手式 public interface Command { public void execute(); } public class Homework { public void writeHomework(){ System.out.println(\u0026#34;write HW right now!\u0026#34;); } } // Receiver public class HomeworkCommand implements Command { Homework homework; public HomeworkCommand(Homework homework) { this.homework = homework; } @Override public void execute() { homework.writeHomework(); } } // Receiver public class ClassmateCommand implements Command { Classmate classmate; public ClassmateCommand(Classmate classmate) { this.classmate = classmate; } @Override public void execute() { classmate.writeHomeworkTogether(); } } // Invoker public class Invoker { Command command; public Invoker(Command command) { this.command = command; } public void setCommand(Command command) { this.command = command; } public void invoke() { command.execute(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static void main(String[] args) { var homework = new Homework(); // receiver Command homeworkCommand = new HomeworkCommand(homework); // concrete command var classmate = new Classmate(); // receiver Command classmateCommand = new ClassmateCommand(classmate); // concrete command Invoker invoker = new Invoker(); // invoker invoker.setCommand(homeworkCommand); invoker.invoke(); invoker.setCommand(classmateCommand); invoker.invoke(); } 通過要執行的操作參數化對象。 圍繞基於原語操作的高級操作構建系統。這種結構在支持事務的信息系統中很常見。此外，命令模式提供了一種對事務建模的方法。命令有一個通用接口，讓您以相同的方式調用所有事務。該模式還使得使用新事務擴展系統變得容易。 命令的執行操作可以存儲狀態以在命令本身中反轉其效果。Command 接口必須有一個添加的 Un-execute 操作，它可以逆轉先前調用 Execute 的效果。我們可以將執行的命令存儲在歷史列表中。此外，我們可以通過分別調用 Un-execute 和 Execute 來回遍歷這個列表來實現無限級別的撤消和重做。它也支持撤消。 ","permalink":"https://xinqilin.github.io/post/architecture/command/","tags":[],"title":"DesignPattern - Behavioral - Command"},{"content":"Strategy 當存在一組相關算法並且客戶端對象需要能夠從該組中動態挑選適合其當前需求的算法時，策略設計模式很有用。策略模式建議將每個算法的實現保留在一個單獨的類中。封裝在單獨類中的每個此類算法稱為策略。使用 Strategy 對象的對象通常稱為上下文對象。\n當我們為特定任務有多種算法並且客戶端決定在運行時使用的實際實現時，我們使用策略模式。策略模式也稱為策略模式。我們定義了多種算法，並讓客戶端應用程序傳遞算法以用作參數。例如，此模式的最佳示例之一是 Collections.sort () 方法，該方法採用 Comparator 參數。基於 Comparator 接口的不同實現，對像以不同的方式排序。\n策略模式是我們可以使用組合作為子分類的替代方法的一種方式。策略模式不是通過子類覆蓋父類中的方法來提供不同的行為，而是允許將不同的行為放置在共享公共策略接口的具體策略類中。Context 對象包含對 Strategy 的引用。通過改變上下文的策略，我們可以獲得不同的行為。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public interface CreditCardStrategy { public void pay(BigDecimal money); } public class CTBC implements CreditCardStrategy { @Override public void pay(BigDecimal money) { System.out.println(\u0026#34;CTBC pay\u0026#34;); } } public class MEGA implements CreditCardStrategy { @Override public void pay(BigDecimal money) { System.out.println(\u0026#34;MEGA pay\u0026#34;); } } public class NCCC implements CreditCardStrategy { @Override public void pay(BigDecimal money) { System.out.println(\u0026#34;NCCC pay\u0026#34;); } } // base public class Context { private CreditCardStrategy strategy; public Context(CreditCardStrategy strategy){ this.strategy = strategy; } public void apply(BigDecimal money){ strategy.pay(money); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) { var money = new BigDecimal(\u0026#34;100\u0026#34;); // DI 注入 （constructor or setter） Context ctx = new Context(new CTBC()); ctx.pay(money); // change strategy ctx = new Context(new MEGA()); ctx.apu(money); } 為策略提供了一種使用多種行為之一配置類的方法。 算法使用客戶不應該知道的數據。使用策略模式來避免暴露複雜的、特定於算法的數據結構。 （封裝時做的細節） 一個類定義了許多行為，這些行為在其操作中表現為多個條件語句。將相關的條件分支移到它們自己的 Strategy 類中，而不是許多條件。 ","permalink":"https://xinqilin.github.io/post/architecture/strategy/","tags":[],"title":"DesignPattern - Behavioral - Strategy"},{"content":"Observer (pub-sub) 在觀察者設計模式中，多個觀察者對象向一個主題註冊以獲取通知中的任何更改。當主題的狀態發生變化時，它會通知觀察者。監聽或觀察變化的對象稱為觀察者，被觀察的對象稱為主體。\n主題為觀察者提供了一個接口，可以在主題中註冊和註銷自己。 主題知道它的訂閱者是誰。 多個觀察者可以訂閱通知。 主題發布通知。 主題只是發送通知說狀態已更改。它不傳遞任何狀態信息。 一旦收到來自主題的通知，觀察者就會調用主題並獲取更改的數據。\nSubject， 註冊觀察者。對象使用此接口註冊為觀察者，也可以將自己從觀察者中移除。 Observer為對象定義了一個更新接口，這些接口應該被通知主題的變化。但是，所有的觀察者都需要實現 Observer 接口。該接口有一個方法 update()，當 Subject 的狀態發生變化時會調用該方法。 ConcreteSubject，將感興趣的狀態存儲到 ConcreteObserver 對象。當它的狀態改變時，它會向它的觀察者發送一個通知。此外，一個具體的主題總是實現主題接口。我們使用 * notifyObservers() 方法在狀態發生變化時更新所有當前的觀察者。 ConcreateObserver 維護對 ConcreteSubject 對象的引用並實現 Observer 接口。每個觀察者註冊一個具體的主題以接收更新。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 public interface Subject { public void registerObserver(Observer observer); public void notifyObserver(); public void unregisterObserver(Observer observer); public Object getUpdate(); } public interface Observer { public void update(); public void setSubject(Subject sub); } //Concrete Subject public class Blog implements Subject { List\u0026lt;Observer\u0026gt; observersList; private boolean stateChange; public Blog() { this.observersList = new ArrayList(); stateChange = false; } @Override public void registerObserver(Observer observer) { observersList.add(observer); } @Override public void notifyObserver() { if (stateChange) { for(Observer observer : observersList) { observer.update(); System.out.println(\u0026#34;Observer notified !\u0026#34;); } } } @Override public void unregisterObserver(Observer observer) { observersList.remove(observer); } @Override public Object getUpdate() { Object changedState = null; // should have logic to send the state change to querying observer if (stateChange) { changedState = \u0026#34;Observer Design Pattern\u0026#34;; } return changedState; } public void postNewArticle() { stateChange = true; notifyObserver(); } } //Concrete Observer public class User implements Observer { private String article; private Subject blog; @Override public void update() { System.out.println(\u0026#34;State change reported by Subject.\u0026#34;); article = (String) blog.getUpdate(); } @Override public void setSubject(Subject blog) { this.blog = blog; article = \u0026#34;No New Article!\u0026#34;; } public String getArticle() { return article; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) { Blog blog = new Blog(); User user1 = new User(); User user2 = new User(); blog.registerObserver(user1); blog.registerObserver(user2); user1.setSubject(blog); user2.setSubject(blog); System.out.println(user1.getArticle()); blog.postNewArticle(); System.out.println(user1.getArticle()); } 當一個抽像有兩個方面時，一個依賴於另一個。將這些方面封裝在單獨的對像中可以讓您獨立地改變和重用它們。 當對一個對象的更改需要更改其他對象時，您不知道需要更改多少個對象？ 當一個對象應該能夠通知其他對象而不假設這些對像是誰。換句話說，您不希望這些對象緊密耦合。 reference: https://javatechonline.com/behavioral-design-patterns-in-java/#Template_Method_Design_Pattern\n","permalink":"https://xinqilin.github.io/post/architecture/observer/","tags":[],"title":"DesignPattern - Behavioral - Observer"},{"content":"Chain Of Responsibility 當有多個對象可以處理或滿足客戶端請求時，責任鏈模式建議給這些對像中的每一個以某種順序處理請求的機會。在這種情況下應用該模式，這些潛在的處理程序中的每一個都可以以鏈的形式排列，每個對像都具有對鏈中下一個對象的引用。鏈中的第一個對象接收請求並決定處理請求或將其傳遞給鏈中的下一個對象。請求一個接一個地流過鏈中的所有對象，直到請求被鏈中的一個處理程序處理或請求到達鏈的末端而沒有得到處理。\n顯然，責任鏈模式用於在軟件設計中實現鬆散耦合，其中來自客戶端的請求被傳遞到對象鏈以處理它們。然後鏈中的對象將自行決定誰將處理請求以及是否需要將請求發送到鏈中的下一個對象。\n多個類別繼承或實作抽象, 並使用, 實作中不是自己的就 next 下去, 是自己的就 action 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // This\u0026#39;s the request object. public class Number { private int number; public int getNumber() { return number; } public Number(int num){ number=num; } } // interface that acts as a chain link. public interface Chain { public void setNext(Chain nextInChain); public void process(Number request); } public class PositiveNumberProcessor implements Chain { private Chain nextInChain; @Override public void setNext(Chain c) { nextInChain = c; } @Override public void process(Number request) { if (request.getNumber() \u0026gt; 0) { System.out.println(\u0026#34;PositiveNumberProcessor : \u0026#34; + request.getNumber()); } else { nextInChain.process(request); } } } public class NegativeNumberProcessor implements Chain { private Chain nextInChain; @Override public void setNext(Chain c) { nextInChain = c; } @Override public void process(Number request) { if (request.getNumber() \u0026lt; 0) { System.out.println(\u0026#34;NegativeNumberProcessor : \u0026#34; + request.getNumber()); } else { nextInChain.process(request); } } } public class ZeroProcessor implements Chain { private Chain nextInChain; @Override public void setNext(Chain c) { nextInChain = c; } @Override public void process(Number request) { if (request.getNumber() == 0) { System.out.println(\u0026#34;ZeroProcessor : \u0026#34; + request.getNumber()); } else { nextInChain.process(request); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public static void main(String[] args) { // Chain c1 = new NegativeNumberProcessor(); // Chain c2 = new ZeroProcessor(); // Chain c3 = new PositiveNumberProcessor(); // c1.setNext(c2); // c2.setNext(c3); // chain Chain c = new Chain(new NegativeNumberProcessor(new ZeroProcessor(new PositiveNumberProcessor()))) //calling chain of responsibility c1.process(new Number(99)); c1.process(new Number(-30)); c1.process(new Number(0)); c1.process(new Number(100)); } 多個對象可以處理一個請求，並且處理程序是先驗未知的。應自動確定處理程序。 您想向多個對象之一發出請求，而不明確指定接收者。 應該動態指定可以處理請求的對象集。 ","permalink":"https://xinqilin.github.io/post/architecture/chainofresponsibility/","tags":[],"title":"DesignPattern - Behavioral - Chain Of Responsibility"},{"content":"Mediator Mediator 通過阻止對象顯式地相互引用來促進鬆散耦合，並且它允許您獨立地改變它們的交互。 我們使用中介者設計模式在系統中的不同對象之間提供集中的通信媒介。\n中介者模式專注於在對象之間提供一個中介者進行互動，並幫助實現對象之間的丟失耦合。對像要求中介者代表它們進行交互，而不是直接相互交互。它導致可重用性和鬆散耦合。此外，它封裝了對象之間的交互，使它們相互獨立。這也允許他們通過實現不同的中介以完全不同的方式改變與其他對象的交互。調解器有助於降低類的複雜性。此外，每個對像不再需要詳細了解如何與其他對象交互。對象之間的耦合從緊緻僵硬到鬆散優雅。 中介者設計模式在多個對象相互交互的企業應用程序中非常有用。如果對象直接相互交互，系統組件就會相互緊密耦合。它們還使可維護性成本更高，並且不能靈活地輕鬆擴展。\n例如，空中交通管制員是調解員模式的一個很好的例子，其中機場控制室充當不同航班之間通信的調解員。中介作為對象之間的路由器工作，它可以有自己的邏輯來提供通信方式。\nMediator: 定義一個與同事對象通信的 interface ConcreteMediator: 通過協調 Colleague 對象來實現協作行為。它還了解並維護其同事。 Colleague Classes: 每個 Colleague class 都知道它的 Mediator 對象。每位同事在本應與另一位同事溝通時都會與其調解員溝通。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public interface IMediator { public void talk(); public void fight(); public void registerA(ColleagueA a); public void registerB(ColleagueB b); } public class ConcreteMediator implements IMediator { ColleagueA talk; ColleagueB fight; @Override public void talk() { System.out.println(\u0026#34;Mediator is talking\u0026#34;); } @Override public void fight() { System.out.println(\u0026#34;Mediator is fighting\u0026#34;); } @Override public void registerA(ColleagueA a) { this.talk = a; } @Override public void registerB(ColleagueB b) { this.fight = b; } } // =========== public abstract class Colleague { IMediator mediator; public abstract void doSomething(); } public class ColleagueA extends Colleague { public ColleagueA(IMediator mediator) { this.mediator = mediator; this.mediator.registerA(this); } @Override public void doSomething() { this.mediator.talk(); } } public class ColleagueB extends Colleague { public ColleagueB(IMediator mediator) { this.mediator = mediator; this.mediator.registerB(this); } @Override public void doSomething() { this.mediator.fight(); } } 1 2 3 4 5 6 7 8 9 10 public static void main(String[] args) { IMediator mediator = new ConcreteMediator(); ColleagueA talkColleague= new ColleagueA(mediator); talkColleague.doSomething(); ColleagueB fightColleague = new ColleagueB(mediator); fightColleague.doSomething(); } 一組對像以定義明確但複雜的方式進行互動。由此產生的相互依賴是非結構化的並且難以理解。 重用一個對像很困難，因為它引用了許多其他對象並與之互動。 分佈在多個類之間的行為應該是可定制的，無需大量子類化。 ","permalink":"https://xinqilin.github.io/post/architecture/mediator/","tags":[],"title":"DesignPattern - Behavioral - Mediator"},{"content":"Template Method Template Method pattern 定義了操作中算法的骨架，將一些步驟推遲到子類。 Template Method讓子類在不改變算法結構的情況下重新定義算法的某些步驟。 可以在有算法的情況下使用Template Method pattern，其中一些步驟可以以多種不同的方式實現。在這種情況下，Template Method pattern 建議將算法的大綱保留在一個單獨的方法中，該方法稱為類中的Template方法。我們可以將其稱為Template類，將算法的變體部分（可以以多種不同方式實現的步驟）的具體實現留給該類的不同子類。\nTemplate 類不必將實現完全留給它的子類。相反，作為提供算法大綱的一部分，Template 類還可以提供一些實現，我們可以認為這些實現在不同的實現中是不變的。如果合適，它甚至可以為可變部分提供默認實現。我們只在不同的子類中實現特定的細節。這種類型的實現消除了重複代碼的需要，這意味著要編寫的代碼量最少。\n大多數都是子類別呼叫父類別方法, 但在Template Method中，父類別 Template 調用子類的方法 =\u0026gt; 好萊塢原則—— \u0026ldquo;Don’t call us, we’ll call you.\u0026rdquo; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 public abstract class OrderTemplate { // 定義是否要覆寫 public abstract boolean hook(){ return true; // 是否複寫 } // 只開放 overwrite 給會變的 public abstract void doSelect(); public abstract void doPayment(); public abstract void doDelivery(); // 樣板中不變的 （重複的） public final void doPack(){ System.out.println(\u0026#34;Gift wrap done.\u0026#34;); } public final void processOrder() { doSelect(); doPayment(); doPack(); doDelivery(); } } public class PhysicalStoreOrder extends OrderTemplate { @Override public void doSelect() { System.out.println(\u0026#34;David buy it \u0026#34;); } @Override public void doPayment() { System.out.println(\u0026#34;David pay it by credit card\u0026#34;); } @Override public void doDelivery() { System.out.println(\u0026#34;David call Paul to delivery\u0026#34;); } } public class OnlineOrder extends OrderTemplate { @Override public void doSelect() { System.out.println(\u0026#34;select item on website\u0026#34;); System.out.println(\u0026#34;add to cart\u0026#34;); } @Override public void doPayment() { System.out.println(\u0026#34;Online pay\u0026#34;); } @Override public void doDelivery() { System.out.println(\u0026#34;write the address\u0026#34;); System.out.println(\u0026#34;pay delivery fee online\u0026#34;); } } 1 2 3 4 5 6 7 8 public static void main(String[] args) { var online = new OnlineOrder(); online.processOrder(); var store = new StoreOrder(); store.processOrder(); } 減少複製貼上（寫重複code） 的機會 一次實現算法的不變部分並將其留給子類來實現可以變化的行為。 當子類之間的共同行為應該在一個共同的類中被分解和本地化以避免代碼重複時。應該先識別現有 code 中的差異，然後區分新操作中的差異。最後，用調用這些新操作之一的模板方法替換不同的代碼。 ","permalink":"https://xinqilin.github.io/post/architecture/templatemethod/","tags":[],"title":"DesignPattern - Behavioral - Template Method"},{"content":"Decorator Decorator 的主要目的是動態地為對象附加額外的職責。Decorator 為擴展功能提供了一種靈活的替代子類的方法。\n當我們需要動態擴展對象的功能而無需更改原始類源或使用繼承時，Decorator 為我們提供了便利。這是通過在實際對象周圍創建一個稱為裝飾器的對象包裝器來實現的。\nDecorator 對象與底層對象具有相同的接口。這允許客戶端對像以與底層實際對象完全相同的方式與裝飾器對象交互。Decorator 對象包含對實際對象的引用。Decorator 對象接收來自客戶端的所有請求（調用）。反過來，它將這些調用轉發到底層對象。Decorator 對像在將請求轉發到底層對象之前或之後添加了一些附加功能。這確保了附加功能可以在運行時從外部添加到給定對象，而無需修改其結構。\n使用繼承或組合來擴展對象的行為，但這是在編譯時完成的，它適用於類的所有實例。不能在運行時添加任何新功能或刪除任何現有行為——這就是裝飾器模式出現的時候。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public interface Pc { public String buyPc(); } public class SimplePc implements Pc { @Override public String buyPc() { return \u0026#34;spend 1000\u0026#34;; } } // 裝飾器類實現了組件接口，它與組件接口具有HAS-A關係。 // 子裝飾器類應該可以訪問組件變量，因此保護這個變量。例如，下面的 IcecreamDecorator 類將在我們的例子中用作裝飾器。 public class PcDecorator implements Pc { protected Pc specialPc; public PcDecorator(Pc specialPc){ this.specialPc = specialPc; } @Override public String buyPc() { return specialPc.buyPc(); } } public class UsaDecorator extends PcDecorator { public UsaDecorator(Pc specialPc) { super(specialPc); } public String buyPc(){ return specialPc.buyPc() + addFee(); } private String addFee() { return \u0026#34; + 2000\u0026#34;; } } // 在裝飾一層 public class TaiwanDecorator extends PcDecorator { public TaiwanDecorator(Pc specialPc) { super(specialPc); } public String buyPc(){ return specialPc.buyPc() + addFee(); } private String addFee() { return \u0026#34; + 5000\u0026#34;; } } 1 2 3 4 5 public static void main(String[] args) { Pc pc = new TaiwanDecorator(new UsaDecorator(new SimplePc())); System.out.println(pc.buyPc()); } 動態且透明地向單個對象添加職責，即不影響其他對象。 對於可以撤回的責任。 當通過子分類擴展是不切實際的。有時大量的獨立擴展是可能的，並且會產生大量的子類來支持每種組合。或者一個類定義可能被隱藏或不能用於子分類。 當選擇的數量更多時，它很容易維護和擴展。 ","permalink":"https://xinqilin.github.io/post/architecture/decorator/","tags":[],"title":"DesignPattern - Structural - Decorator"},{"content":"Bridge 在接口和實現中都有接口層次結構時，使用 Bridge 設計模式將接口與實現分離，並對客戶端程序隱藏實現細節。\n根據 GoF 橋的設計模式是：將抽象與其實現分離，以便兩者可以獨立變化。\n將抽象及其實現分開，並為抽象和實現者開發單獨的繼承結構。抽像是接口或抽像類，同樣實現者是接口或抽像類。抽象包含對實現者的引用。抽象的孩子被稱為精煉抽象，實現者的孩子是具體的實現者。由於我們可以在抽像中更改對實現者的引用，因此我們可以在運行時更改抽象的實現者。但是，對實現者的更改不會影響客戶端代碼。\nBridge 的目的是將抽象和實現放入兩個不同的類層次結構中，以便兩者都可以獨立擴展。 Bridge 幫助兩個不兼容的 類一起工作。但是 Bridge 通過創建兩個不同的層次結構來分離抽象和實現。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 /** * abstraction in Bridge pattern * */ public abstract class Vehicle { protected VehicleType type1; protected VehicleType type2; public Vehicle(VehicleType type1, VehicleType type2) { this.type1 = type1; this.type2 = type2; } abstract public void purchase(); } /** * Implementor for Bridge pattern * */ public interface VehicleType { abstract public void book(); } /** * Refine abstraction 1 in Bridge pattern */ public class Car extends Vehicle { public Car(VehicleType type1, VehicleType type2) { super(type1, type2); } @Override public void purchase() { System.out.print(\u0026#34;Car\u0026#34;); type1.book(); type2.book(); } } /** * Refine abstraction 2 in Bridge pattern */ public class Bike extends Vehicle { public Bike(VehicleType type1, VehicleType type2) { super(type1, type2); } @Override public void purchase() { System.out.print(\u0026#34;Bike\u0026#34;); type1.book(); type2.book(); } } /** * Concrete implementation 1 for Bridge pattern * */ public class NewVehicle implements VehicleType { @Override public void book() { System.out.print(\u0026#34; : New Vehicle\u0026#34;); } } /** * Concrete implementation 2 for Bridge pattern * */ public class OldVehicle implements VehicleType { @Override public void book() { System.out.println(\u0026#34; : Old Vehicle\u0026#34;); } } 1 2 3 4 5 6 7 8 9 public static void main(String[] args) { Vehicle vehicle1= new Car(new NewVehicle(),new OldVehicle()); vehicle1.purchase(); Bike vehicle2 = new Bike(new NewVehicle(),new OldVehicle()); vehicle2.purchase(); } 多個實現時最好使用。 需要在運行時切換實現時應該使用。 如果抽象的實現有修改，客戶端不應該受到影響。 創建兩個不同的層次結構。一個用於抽象，另一個用於實現。 通過消除抽象和實現之間的依賴關係來避免永久綁定, 創建了一個在抽象和實現之間協調的橋樑。 抽象和實現可以分開擴展。 ","permalink":"https://xinqilin.github.io/post/architecture/bridge/","tags":[],"title":"DesignPattern - Structural - Bridge"},{"content":"Facade 為子系統中的一組 interface 提供統一的入口。Facade Pattern 定義了一個更高級別的接口，使子系統更易於使用 Facade 並沒有封裝子系統類或接口；它只是為其功能提供了一個簡化的界面。 此外，客戶端可以直接訪問這些類。它仍然為可能需要它的客戶公開系統的全部功能。簡而言之，它只是為子系統的複雜接口提供了一層，使其更易於使用。\n外觀設計模式是促進鬆散耦合的其他設計模式之一。它強調了設計中最重要的一個方面，即抽象。通過隱藏它背後的複雜性並暴露一個簡單的接口，它實現了抽象。 Facade 和 Adapter 一樣可以封裝多個類，但是 Facade 使用接口來簡化複雜接口的使用，而 Adapter 用於將接口轉換為客戶端期望的接口。 在抽象方面，中介者設計模式可能看起來與外觀設計模式非常相似。Mediator 以類似於外觀模式的方式抽象子系統的功能。然而，在中介者模式的實現中，子系統或對等點的組件都知道中介者並與之交互。但是在外觀模式的情況下，子系統不知道外觀的存在。只有外觀與子系統對話。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class Service1 { public int doSth(int x) { // 複雜的業務邏輯... return x + x; } } public class Service2 { public int doSth2(int x, int y) { // 複雜的業務邏輯... return x + y; } } public class Service3 { public int doSth3(int x, int y, double z) { // 複雜的業務邏輯... return x + y + Integer.parseInt(z); } } public class Facade { public int sum(int x) { Service1 s = new Service1(); return s.doSth(x + 1); } public int cut(int x) { Service1 s = new Service1(); Service2 s2 = new Service2(); return s.doSth(x) + s3.doSth(x, 0); } public int multiply(int x) { return Service3.doSth3(x, 2, 3.0); } } 1 2 3 4 5 6 7 8 public static void main(String[] args) { Facade facade = new Facade(); int x = 3; System.out.println(\u0026#34;Cube of \u0026#34; + x + \u0026#34;:\u0026#34; + facade.sum(100)); System.out.println(\u0026#34;Cube of \u0026#34; + x + \u0026#34; times 2:\u0026#34; + facade.cut(100)); System.out.println(x + \u0026#34; multiply class1 \u0026amp; class2 :\u0026#34; + facade.multiply(100)); } 子系統接口不知道 Facade，它們不應該有任何 Facade 接口的引用。 子系統可以相互依賴。在這種情況下，外觀可以充當協調器並解耦子系統之間的依賴關係。 外觀模式更像是客戶端應用程序的助手；它不會對客戶端隱藏子系統接口。是否使用 Facade 完全取決於客戶端代碼。 外觀模式可以應用於任何開發點，通常是在接口數量增加和系統變得複雜時。 外觀模式應該應用於類似類型的接口；它的目的是提供一個接口而不是多個接口來完成類似的工作。 可以使用帶有 Facade 的工廠模式來為客戶端系統提供更好的接口。 ","permalink":"https://xinqilin.github.io/post/architecture/facade/","tags":[],"title":"DesignPattern - Structural - Facade"},{"content":"Flyweight Flyweight 中，我們重複使用對象，而不是創建大量相似的對象。我們可以使用它來減少內存需求和實例化時間以及相關成本。\n在我們應用 Flyweight 之前，我們需要考慮以下因素：\n如果應用程序中所需的對像數量巨大。 如果對象創建佔用大量內存並且也可能很耗時。 太多的對象會降低應用程序的性能。顯然，太多的對象可能會消耗更大的內存。此外，它們可能會降低應用程序的速度，甚至可能導致內存不足問題。 在應用程序中控制它。當我們有很多相似的對象並且池中的兩個對象之間沒有太多差異時，尤其如此。 有時，應用程序中的對象可能具有很大的相似性並且屬於相似類型（此處的相似類型意味著它們的大多數屬性具有相似的值，並且只有少數屬性值不同）。如果它們也是要創建的重物，應用程序開發人員應該控制它們。否則，它們可能會消耗大量內存並最終減慢整個應用程序的速度。\nFlyweight 旨在控制此類對象的創建，並為您提供基本的緩存機制。它允許您為每種類型創建一個對象（此處的類型因該對象的屬性而異），如果您請求具有相同屬性的對象（已創建），它將返回相同的對象而不是創建一個新的對象一。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public interface Msg { public void show(String msg); } public class EmergentMsg implements Msg { private String key; EmergentMsg(String key) { this.key = key; System.out.println(\u0026#34;send \u0026#34; + key + \u0026#34; emergent msg\u0026#34;); } public void show(String msg) { System.out.println(msg); } } public class MsgFactory { private static MsgFactory FACTORY = new MsgFactory(); private static Map\u0026lt;String, Msg\u0026gt; msgs = new HashMap\u0026lt;\u0026gt;(); public static MsgFactory getInstance() { // 看要不要 double lock check return FACTORY; } public Msg getMsg(String key) { Msg msg = (Msg)msgs.get(key); if (msg != null) { System.out.println(\u0026#34;msg \u0026#34; + key + \u0026#34; exist\u0026#34;); } else { msg = new EmergentMsg(key); msgs.put(key, msg); } return msg; } } 有點像資源重複使用 maybe, service locator pattern !?\n","permalink":"https://xinqilin.github.io/post/architecture/flyweight/","tags":[],"title":"DesignPattern - Structural - Flyweight"},{"content":"Proxy Proxy pattern 為另一個對象 create a representative object that controls access to another object。 事實上，Proxy pattern 是用來創建一個代表對象來控制對另一個對象的訪問。成本高或需要保護以至於存取消費較大。\n控制對對象的訪問的一個原因是將其創建和初始化的全部成本推遲到我們真正需要使用它時。另一個原因可能是充當位於不同 JVM 中的對象的本地代表。此外，代理在控制對原始對象的訪問方面非常有用，尤其是當對象應該具有不同的訪問權限時。\n在代理設計模式中，客戶端不直接與原始對像對話，它將調用委託給代理對象，代理對象調用原始對象的方法。此外，重要的一點是客戶端不知道代理。代理充當客戶端的原始對象。但是這種方法有很多變體，我們很快就會看到。\n代理模式有三種主要變體：\nproxy 為不同 remote address 的對象提供 local access (跳板)。 A virtual proxy creates expensive objects on demand. 保護代理控制對原始對象的訪問。當對象應該具有不同的訪問權限時，保護代理很有用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class User { String userName; String password; // Getter, Setter, Constructor } public interface IFolder { public void performOperations(); } public class Folder implements IFolder { @Override public void performOperations() { // 訪問 folder 並執行各種操作 System.out.println(\u0026#34;execute sth in folder\u0026#34;); } } public class FolderProxy implements IFolder { Folder folder; User user; public FolderProxy(User user){ this.user = user; } @Override public void performOperations() { if ((\u0026#34;dev\u0026#34;).equals(user.getUserName()) \u0026amp;\u0026amp; (\u0026#34;dev\u0026#34;).equals(user.getPassword())) { folder = new Folder(); folder.performOperations(); } else { System.out.println(\u0026#34;can\u0026#39;t access this folder\u0026#34;); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) { var user = new User(\u0026#34;dev\u0026#34;, \u0026#34;dev\u0026#34;); FolderProxy folderProxy = new FolderProxy(user); folderProxy.performOperations(); System.out.println(\u0026#34;------------------------------------\u0026#34;); // if we give wrong userName and Password var userWrong = new User(\u0026#34;staging\u0026#34;, \u0026#34;staging\u0026#34;); FolderProxy folderProxyWrong = new FolderProxy(userWrong); folderProxyWrong.performOperations(); } 有一個現有的類，它的接口與您需要的不匹配。 想創建一個可重用的類，它與不相關或不可預見的類（即不一定具有兼容接口的類）協作。 有幾個現有的子類可供使用，但通過對每個子類進行子類化來調整它們的接口是不切實際的。對象 adapter 可以適配其父類的接口。 ","permalink":"https://xinqilin.github.io/post/architecture/proxy/","tags":[],"title":"DesignPattern - Structural - Proxy"},{"content":"Composite Composite 讓客戶可以統一處理單個對象和對象的組合，這就是 Composite Pattern 的意圖。 在復合模式中，存在一個樹結構，可以在葉子和節點上執行相同的操作。樹中的節點是可以有孩子的類。節點類是“複合”類。樹上的葉子是沒有孩子的“原始”類。 組合的子節點可以是葉子或其他組合。 葉類和復合類共享一個通用的 \u0026ldquo;Composite\u0026rdquo; interface，該接口定義了可以在葉和復合上執行的通用操作。當對組合執行操作時，將對組合的所有子節點執行此操作，無論它們是葉子還是組合。因此，複合模式可用於對組成樹的對象執行常見操作。\nBase Component: 是組合中所有對象的接口。客戶端程序使用基本組件來處理組合中的對象。此外，它可以是一個 interface 或 abstract class，其中包含所有對象共有的一些方法。 Leaf: 定義組合中元素的行為。它是組合的構建塊並實現基本組件。雖然，它沒有對其他組件的引用。 Composite: 它由葉元素組成，並在基本組件中實現操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 /** * Manager(Composite) * Developer(Leaf) * Employee(Component) */ public interface Employee { public void add(Employee emp); public void remove(Employee emp); public Employee getChild(int i); public String getName(); public double getSalary(); public void print(); } // 現在我們將創建 Manager (Composite)。這裡的關鍵點是所有通用方法都將其操作委託給子對象。它具有訪問和修改其子級的方法。 public class Manager implements Employee { private String name; private double salary; public Manager(String name, double salary) { this.name = name; this.salary = salary; } var employees = new ArrayList\u0026lt;Employee\u0026gt;(); @Override public void add(Employee emp) { employees.add(emp); } @Override public void remove(Employee emp) { employees.remove(emp); } @Override public Employee getChild(int i) { return employees.get(i); } @Override public String getName() { return name; } @Override public double getSalary() { return salary; } @Override public void print() { System.out.println(\u0026#34;Name = \u0026#34; + getName()); System.out.println(\u0026#34;Salary = \u0026#34; + getSalary()); System.out.println(\u0026#34;-------------\u0026#34;); Iterator\u0026lt;Employee\u0026gt; empIterator = employees.iterator(); while(empIterator.hasNext()){ var emp = empIterator.next(); emp.print(); } } } public class Manager implements Employee { private String name; private double salary; public Manager(String name, double salary) { this.name = name; this.salary = salary; } var employees = new ArrayList\u0026lt;Employee\u0026gt;(); @Override public void add(Employee emp) { employees.add(emp); } @Override public void remove(Employee emp) { employees.remove(emp); } @Override public Employee getChild(int i) { return employees.get(i); } @Override public String getName() { return name; } @Override public double getSalary() { return salary; } @Override public void print() { System.out.println(\u0026#34;Name = \u0026#34; + getName()); System.out.println(\u0026#34;Salary = \u0026#34; + getSalary()); System.out.println(\u0026#34;-------------\u0026#34;); Iterator\u0026lt;Employee\u0026gt; empIterator = employees.iterator(); while(empIterator.hasNext()){ Employee emp= empIterator.next(); emp.print(); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class CompositePatternTest { public static void main(String[] args) { Employee emp1 = new Developer(\u0026#34;Bill\u0026#34;, 10000); Employee emp2 = new Developer(\u0026#34;David\u0026#34;, 15000); Employee manager1 = new Manager(\u0026#34;Paul\u0026#34;, 25000); manager1.add(emp1); manager1.add(emp2); Employee emp3 = new Developer(\u0026#34;Lag\u0026#34;, 20000); Manager generalManager = new Manager(\u0026#34;Howard\u0026#34;, 50000); generalManager.add(emp3); generalManager.add(manager1); generalManager.print(); } } 當我們想要表示對象的部分整體層次結構時。 當我們希望客戶能夠忽略對象組合和單個對象之間的差異時。客戶端將統一對待複合結構中的所有對象。 ","permalink":"https://xinqilin.github.io/post/architecture/composite/","tags":[],"title":"DesignPattern - Structural - Composite"},{"content":"Adapter 將一個類別的介面 轉換成另一個類別的介面供客戶使用 讓介面不相容的類別可以合作\n有時，可能會出現兩個對像不適合在一起的情況，或者在代碼中更改第 3 方 API 時，可能會出現這種情況。 顯然，這是由於兩個不適合在一起的對象的接口不兼容造成的。\n正如適配器一詞所暗示的那樣，適配器設計模式 是 使兩個不相關的接口協同工作的結構設計模式之一。此外，連接這些不相關接口的對象稱為適配器，就像中介一樣。\n在適配器模式中，一個包裝類（adapter）用於將請求從它轉換到另一個類（adoptee）。實際上，適配器提供了與被收養者不直接提供的特定交互。\n適配器模式可以採用兩種形式：繼承或組合形式。在第一種形式中，“類適配器”利用繼承。類適配器擴展了被收養類並將所需的方法添加到適配器中。 這些方法可以在接口（即“目標”接口）中聲明。但是，在第二種形式中；\u0026ldquo;對象 adapter\u0026rdquo; 利用組合。對象 adapter 包含被收養者並實現目標接口以與被收養者交互。\nClient: 你使用Target介面 Target: 定義 User 所呼叫的 interface Adaptor(core): 將 Adaptee 轉換成要用的介面 Adaptee: 需要被轉換的介面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Apple { public void getAppleColor(String color){ System.out.println(\u0026#34;Apple color is : \u0026#34; +color); } } public class Orange { public void getOrangeColor(String color){ System.out.println(\u0026#34;Orange color is : \u0026#34; +color); } } public class AppleAdapter extends Apple { //The purpose of the sample problem is to adapt an orange as an apple. private Orange orange; // This is the main logic of Adapter pattern public AppleAdapter(Orange orange){ this.orange = orange; } public void getColor(String color){ orange.getOrangeColor(color); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 public class AdapterPatternTest { public static void main(String[] args) { Apple apple = new Apple(); apple.getAppleColor(\u0026#34;green\u0026#34;); Orange orange = new Orange(); AppleAdapter adapter = new AppleAdapter(orange); adapter.getAppleColor(\u0026#34;red\u0026#34;); } } 有一個現有的類，它的接口與需要的不匹配。 想要創建一個可重用的類，它與不相關或不可預見的類（即不一定具有兼容接口的類）協作。 有幾個現有的子類可供使用，但通過對每個子類進行子類化來調整它們的接口是不切實際的。對象適配器可以適配其父類的接口。 more sample Adapter 模式將 Adaptee 類別的 specificRequest() 方法包裝成 Target 接口的 request() 方法。\nClient 類別可以通過呼叫 Target 接口的 request() 方法來發送請求，而不用知道底層使用的是 Adaptee 類別的 specificRequest() 方法。\n通過使用 Adapter 模式，我們可以讓不兼容的類別一起工作，這對於在現有系統中加入新功能非常有用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // Target interface public interface Target { void request(); } // Adaptee class public class Adaptee { public void specificRequest() { // Perform some specific request } } // Adapter class public class Adapter implements Target { private Adaptee adaptee; public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } @Override public void request() { adaptee.specificRequest(); } } // Client public class Client { public void makeRequest(Target target) { target.request(); } } // Usage Adaptee adaptee = new Adaptee(); Target target = new Adapter(adaptee); Client client = new Client(); client.makeRequest(target); ","permalink":"https://xinqilin.github.io/post/architecture/adapter/","tags":[],"title":"DesignPattern - Structural - Adapter"},{"content":"Prototype 一種對象創建機制。\n假設有一個從 DB 加載數據的對象。現在，我們需要在程序中多次修改這些數據。因此，使用 new 關鍵字創建對象並再次從數據庫中加載所有數據並不是一個好主意。因此，更好的方法是將現有對象 clone 為新對象，然後進行數據操作。\n但是，原型設計模式要求您正在復制的對象應提供複製功能。顯然，它不應該由任何其他類來完成。但是，是使用 Object 屬性的淺拷貝還是深拷貝取決於需求，這是一個設計決定。\n例如，讓我們看看這有什麼用處。如果創建原始對象時使用的資源（例如數據流）在需要對象克隆時可能不可用。另一個例子是，如果原始對象創建涉及大量時間投入，例如從數據庫或通過網絡讀取數據。\nobject clone 利用 clone() 方法和 implements Cloneable interface。默認情況下，clone() 執行淺拷貝。此外，Serializable 可用於簡化深度複製。 BTW, 可以實現自己的原型模式。為此，創建一個具有 doClone () 方法的 Prototype 接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Pc implements Cloneable { private String keyboard; private String mouse; private String screen; public Pc() { keyboard = \u0026#34;機械\u0026#34;; mouse = \u0026#34;羅技\u0026#34;; screen = \u0026#34;Dell\u0026#34;; } public Pc clone(){ return new Pc(); } public void makeAmericaStyle(){ keyboard = \u0026#34;Magic Keyboard\u0026#34;; mouse = \u0026#34;Apple Mouse\u0026#34;; screen = \u0026#34;Apple Screen\u0026#34;; } public String getMouse(){ return mouse; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class PrototypeTest { public Bike getUSAPc(Pc basicPc){ pc.makeAmericaStyle(); return basicBike; } public static void main(String[] args) { Pc pc = new Pc(); Pc basicPc = pc.clone(); PrototypeTest prototype = new PrototypeTest(); Pc americaPc = prototype.getUSAPc(basicPc); System.out.println(\u0026#34;overwrite method \u0026#34; + americaPc.getMouse()); System.out.println(\u0026#34;all attribute\u0026#34; + americaPc.toString()); } } 當在運行時指定要實例化的類時，例如，通過動態加載 避免建立與產品類層次結構平行的工廠類層次結構 當類的實例可以具有僅有的幾種不同狀態組合之一時。但是，安裝相應數量的原型並克隆它們可能更方便，而不是每次使用適當的狀態手動實例化類。 ","permalink":"https://xinqilin.github.io/post/architecture/prototype/","tags":[],"title":"DesignPattern - Basic - Prototype"},{"content":"Builder 對象構造的細節，實例化和初始化構成對象的組件，都保存在對像中，通常作為其構造函數的一部分。這種類型的設計將對象構造過程與構成對象的組件緊密聯繫在一起。但是，只要構造對像簡單，對象構造過程明確，並且總是產生對象的相同表示，這種方法就適用。\n此外，當被創建的對像很複雜並且構成對象創建過程的一系列步驟可以以不同的方式實現時，這種設計可能無效。因此，產生對象的不同表示。因為構造過程的不同實現都保存在對像中，所以對象可能變得龐大（構造膨脹）並且模塊化程度較低。隨後，添加新實現或更改現有實現需要更改現有代碼。\nBuilder 的目的是將復雜對象的構造與其表示分離，以便相同的構造過程可以創建不同的表示。這種類型的分離減小了對象的大小。該設計變得更加模塊化，每個實現都包含在不同的構建器對像中。因此，添加一個新的實現（即添加一個新的構建器）變得更容易了。此外，對象構造過程變得獨立於構成對象的組件。這提供了對對象構造過程的更多控制。\n它指定了一個抽象接口，用於創建 Product 對象的各個部分。構建器模式建議將構建邏輯從對像類移到一個單獨的類，稱為構建器類。但是，可以有多個這樣的構建器類，每個構建器類對於構建對象的一系列步驟都有不同的實現。此外，每個構建器實現都會導致對象的不同表示。\nConcreteBuilder 通過實現 Builder 接口來構造和組裝產品的各個部分。 定義並跟踪它創建的表示。 提供用於檢索產品的接口。 Director 它使用 Builder 接口構造一個對象。Builder 模式建議使用稱為 Director 的專用對象，它負責調用構建最終對象所需的不同構建器方法。此外，不同的客戶端對象可以利用 Director 對象來創建所需的對象。一旦構造了對象，客戶端對象就可以直接向構造器請求完整構造的對象。為了方便這個過程，可以在公共Builder接口中聲明一個新方法getObject()，由不同的具體builder實現。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public interface PcBuilder { public void buildKeyboard(); public void buildMouse(); public void buildScreen(); public Pc getPc(); } public class Pc { private String keyboard; private String mouse; private String screen; // Getter / Setter / toString method } public class AcerPcBuilder implements PcBuilder { Pc pc; public AcerPcBuilder(){ pc = new Pc(); } @Override public void buildKeyboard() { pc.setKeyboard(\u0026#34;Acer keyyyyyyyyy\u0026#34;); } @Override public void buildMouse() { pc.setMouse(\u0026#34;Acer micky mouse\u0026#34;); } @Override public void buildScreen() { pc.setScreen(\u0026#34;Acer 24 inch screen\u0026#34;); } @Override public Pc getPc() { return pc; } } Director\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class PcDirector { private PcDirector pcDirector = null; public PcDirector(PcBuilder pcBuilder) { this.pcBuilder = pcBuilder; } public void constructPc() { pcBuilder.buildKeyboard(); pcBuilder.buildMouse(); pcBuilder.buildScreen(); } public Meal getPc(){ return pcBuilder.getPc(); } } 1 2 3 4 5 6 7 8 9 10 public static void main(String[] args) { PcBuilder acerPcBuilder = new AcerPcBuilder(); PcDirector pcDirector = new PcDirector(acerPcBuilder); pcDirector.constructPc(); Pc pc = pcDirector.getPc(); log.info(\u0026#34;acer pc builder ~\u0026#34;); } 其他版本 Builder 有一個具有一長串屬性的對象。這些屬性中的大多數都是可選的。 用戶不是直接創建所需的對象，而是調用具有所有必需參數的構造函數並獲取構建器對象。然後，用戶在構建器對像上調用類似 setter 的方法來設置每個感興趣的可選參數。最後，用戶調用無參數構建方法來生成對象。\n需要創建一個靜態類，然後將所有參數從外部類複製到 Builder 類。 接下來，Builder 類應該有一個公共構造函數，其中包含所有必需的屬性作為參數。 Builder 類應該具有設置可選參數的方法，並且在設置可選屬性後它應該返回相同的 Builder 對象。 最後，我們需要在構建器類中提供一個 build() 方法，該方法將返回客戶端程序所需的 Object。 為了做到這一點，需要在 Class 中有一個以 Builder 類作為參數的私有構造函數。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class Pc{ private final String keyboard; private final String mouse; private final String screen; private final int screenCount; private final double price; // in real case, you should use BigDecimal XD public static class Builder { private String keyboard; private String mouse; private String screen; private int screenCount; private double price; //builder methods for setter public Builder keyboard(String keyboard){this.keyboard = keyboard; return this; } public Builder mouse(String mouse){this.butter = cup; return this; } public Builder screen(String screen){this.eggs = number; return this; } public Builder screenCount(int screenCount){this.vanila = spoon; return this; } public Builder price(double price){this.flour = cup; return this; } // already build object public Pc build() { return new Pc(this); } } //private constructor to enforce object creation through builder private Pc(Builder builder) { this.keyboard = builder.keyboard; this.mouse = builder.mouse; this.screen = builder.screen; this.screenCount = builder.screenCount; this.price = builder.price; } } 1 2 3 4 5 6 7 8 public static void main(String[] args) { Pc pc = new Pc.Builder().keyboard(\u0026#34;機械鍵盤\u0026#34;).mouse(\u0026#34;羅技\u0026#34;).screen(\u0026#34;Dell\u0026#34;).build(); log.info(\u0026#34;pc: {}\u0026#34;, pc); } 何時創建複雜對象的算法應該獨立於構成對象的部分以及它們的組裝方式。 當構造過程必須允許構造對象的不同表示時。 ","permalink":"https://xinqilin.github.io/post/architecture/builder/","tags":[],"title":"DesignPattern  - Basic - Builder"},{"content":"Factory 一個具有多個子類的父類別並且基於輸入，我們需要返回其中一個子類時，使用工廠設計模式。這種模式將類從客戶端程序實例化到工廠類的責任。 工廠模式中的超類可以是 interface，也可以是 abstract class，也可以是普通的 Java class。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public interface ICellPhone { public void open(); public void close(); public void call(); } public class ApplePhone implements ICellPhone { @Override public void open() { System.out.println(\u0026#34;apple open\u0026#34;); } @Override public void close() { System.out.println(\u0026#34;apple close\u0026#34;); } @Override public void call() { System.out.println(\u0026#34;apple phone call David\u0026#34;); } } public class SamsungPhone implements ICellPhone { @Override public void open() { // ... } @Override public void close() { // ... } @Override public void call() { // ... } } Factory\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class CellPhoneFactory { public CellPhoneFactory(){ } ICellPhone createCellPhone(String type){ ICellPhone cellPhone = null; if(\u0026#34;apple\u0026#34;.equalsIgnoreCase(type)){ cellPhone = new ApplePhone(); System.out.println(\u0026#34;apple cell phone created\u0026#34;); }else if(\u0026#34;samsung\u0026#34;.equalsIgnoreCase(type)){ cellPhone = new SamsungPhone(); System.out.println(\u0026#34;three start cell phone created\u0026#34;); } return cellPhone; } } 1 2 3 4 5 6 7 8 9 10 public static void main(String[] args) { var factory = new CellPhoneFactory(); ApplePhone apple = (ApplePhone)factory.createCellPhone(\u0026#34;apple\u0026#34;); len.open(); SamsungPhone threeStarts = (SamsungPhone)factory.createCellPhone(\u0026#34;samsung\u0026#34;); sam.close(); } 小節\n工廠模式為接口而不是實現提供了一種代碼方法。 工廠模式從客戶端代碼中刪除了實際實現類的實例化，使其更健壯、耦合更少且易於擴展。例如，我們可以很容易地更改類的實現，因為客戶端不知道它。 工廠模式還通過繼承在實現類和客戶端類之間提供抽象。 Abstract Factory 幾乎類似於 工廠模式，除了它更像工廠的工廠。 一個 Factory 類，它根據提供的輸入返回不同的子類。通常，工廠類使用 if-else 或 switch-case 語句來實現這一點。 但是，在抽象工廠模式中，擺脫了 if-else 塊，並為每個子類創建了一個工廠類，然後是一個抽象工廠類，該類將根據輸入工廠類返回子類。\n實際上，抽象工廠就是返回工廠的工廠。為什麼這個抽象層有用？普通工廠可用於創建相關對象集。抽象工廠返回工廠。因此，抽象工廠用於返回可用於創建相關對象集的工廠。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public interface ICellPhoneFactory { ICellPhoneFactory createPhone(String type); } // 抽象工廠 =\u0026gt; 生產工廠 public class CellPhoneFactory implements ICellPhoneFactory { @Override ICellPhoneFactory createPhone(String type){ ICellPhoneFactory cellPhoneFactory = null; if(\u0026#34;apple\u0026#34;.equalsIgnoreCase(type)){ cellPhoneFactory = new AppleCellPhoneFactory(); System.out.println(\u0026#34;apple factory created\u0026#34;); }else if(\u0026#34;samsung\u0026#34;.equalsIgnoreCase(type)){ cellPhoneFactory = new AppleCellPhoneFactory(); System.out.println(\u0026#34;three start factory created\u0026#34;); } return cellPhone; } } 1 2 3 4 5 6 7 public class AppleCellPhoneFactory extends CellPhoneFactory { AppleCellPhone createApplePhone(){ return new AppleCellPhone(); } } 1 2 3 4 5 6 7 8 9 10 public class AbstractFactoryTest { public static void main(String[] args) { CellPhoneFactory factory = new CellPhoneFactory(); AppleCellPhoneFactory apple = (AppleCellPhoneFactory)factory.createPhone(\u0026#34;apple\u0026#34;); AppleCellPhone apple = (AppleCellPhone)apple.createApplePhone(); apple.call(); } } 抽象工廠模式還提供了一種為接口而不是實現編寫代碼的方法。 工廠模式是 \u0026ldquo;工廠中的工廠\u0026rdquo;，可以輕鬆擴展以容納更多產品。例如，可以添加另一個子類 \u0026ldquo;HTC\u0026rdquo; 和工廠 \u0026ldquo;TwCellPhoneFactory\u0026rdquo;。 抽象工廠模式是強大的，它消除了與工廠模式不同的條件邏輯。 ","permalink":"https://xinqilin.github.io/post/architecture/factory/","tags":[],"title":"DesignPattern - Basic - Factory"},{"content":"概述 Singleton（單例模式）是最常見的創建型設計模式之一，它確保一個類別在整個應用程式生命週期中只有一個實例存在，並提供全域訪問點。這個模式廣泛應用於資料庫連線池、日志記錄器、快取管理器、設定管理器等場景。\n單例模式的核心特徵 唯一實例：確保類別只有一個實例 全域訪問：提供全域訪問該實例的方法 自我實例化：類別自己負責創建和管理實例 延遲初始化：通常在首次需要時才創建實例 傳統實作方式 1. 餓漢式（Eager Initialization） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * 餓漢式單例 - 類別載入時立即創建實例 * 優點：執行緒安全、實作簡單 * 缺點：不管是否使用都會創建實例，可能造成資源浪費 */ public class EagerSingleton { // 在類別載入時就創建實例 private static final EagerSingleton INSTANCE = new EagerSingleton(); // 私有建構子防止外部實例化 private EagerSingleton() { // 防止反射攻擊 if (INSTANCE != null) { throw new IllegalStateException(\u0026#34;單例已存在，不能創建新實例\u0026#34;); } System.out.println(\u0026#34;EagerSingleton 實例創建\u0026#34;); } public static EagerSingleton getInstance() { return INSTANCE; } // 業務方法範例 public void doSomething() { System.out.println(\u0026#34;執行 EagerSingleton 業務邏輯\u0026#34;); } // 防止克隆攻擊 @Override protected Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(\u0026#34;單例不支援克隆\u0026#34;); } // 防止序列化攻擊 private Object readResolve() { return INSTANCE; } } 2. 懶漢式（Lazy Initialization） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 懶漢式單例 - 延遲創建實例 * 問題：執行緒不安全 */ public class LazySingleton { private static LazySingleton instance; private LazySingleton() { System.out.println(\u0026#34;LazySingleton 實例創建\u0026#34;); } // ❌ 執行緒不安全的實作 public static LazySingleton getInstance() { if (instance == null) { instance = new LazySingleton(); } return instance; } } 3. 執行緒安全的懶漢式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * 執行緒安全的懶漢式單例 * 優點：執行緒安全、延遲初始化 * 缺點：性能開銷大（每次訪問都需要同步） */ public class ThreadSafeLazySingleton { private static ThreadSafeLazySingleton instance; private ThreadSafeLazySingleton() { System.out.println(\u0026#34;ThreadSafeLazySingleton 實例創建\u0026#34;); } // ❌ 性能較差的同步方法 public static synchronized ThreadSafeLazySingleton getInstance() { if (instance == null) { instance = new ThreadSafeLazySingleton(); } return instance; } } 推薦的現代化實作方式 1. Double-Checked Locking（雙重檢查鎖定） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 /** * 雙重檢查鎖定單例 * 優點：執行緒安全、性能好、延遲初始化 * 推薦：現代 Java 應用的標準實作 */ public class DoubleCheckedSingleton { // volatile 關鍵字確保可見性和禁止指令重排序 private static volatile DoubleCheckedSingleton instance; private DoubleCheckedSingleton() { // 防止反射攻擊 if (instance != null) { throw new IllegalStateException(\u0026#34;單例已存在，不能創建新實例\u0026#34;); } // 模擬複雜的初始化過程 try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } System.out.println(\u0026#34;DoubleCheckedSingleton 實例創建\u0026#34;); } public static DoubleCheckedSingleton getInstance() { // 第一次檢查：避免不必要的同步 if (instance == null) { synchronized (DoubleCheckedSingleton.class) { // 第二次檢查：確保只創建一個實例 if (instance == null) { instance = new DoubleCheckedSingleton(); } } } return instance; } public void performOperation() { System.out.println(\u0026#34;執行 DoubleCheckedSingleton 操作\u0026#34;); } // 防止克隆攻擊 @Override protected Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(\u0026#34;單例不支援克隆\u0026#34;); } // 防止序列化攻擊 private Object readResolve() { return instance; } } 2. 靜態內部類別（Initialization-on-demand Holder） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * 靜態內部類別單例 * 優點：執行緒安全、延遲初始化、性能最佳、程式碼簡潔 * 推薦：最優雅的實作方式 */ public class StaticHolderSingleton { private StaticHolderSingleton() { System.out.println(\u0026#34;StaticHolderSingleton 實例創建\u0026#34;); } // 靜態內部類別，只有在被引用時才會載入 private static class SingletonHolder { private static final StaticHolderSingleton INSTANCE = new StaticHolderSingleton(); } public static StaticHolderSingleton getInstance() { return SingletonHolder.INSTANCE; } public void executeTask() { System.out.println(\u0026#34;執行 StaticHolderSingleton 任務\u0026#34;); } } 3. 枚舉單例（推薦） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * 枚舉單例 * 優點：執行緒安全、防止反射和序列化攻擊、程式碼最簡潔 * 推薦：Joshua Bloch 推薦的最佳實作方式 */ public enum EnumSingleton { INSTANCE; // 實例變數 private String data; // 建構子（枚舉的建構子總是私有的） EnumSingleton() { this.data = \u0026#34;EnumSingleton 初始化資料\u0026#34;; System.out.println(\u0026#34;EnumSingleton 實例創建\u0026#34;); } // 業務方法 public void setData(String data) { this.data = data; } public String getData() { return data; } public void processData() { System.out.println(\u0026#34;處理資料: \u0026#34; + data); } // 可以實作介面 public void performAction() { System.out.println(\u0026#34;執行 EnumSingleton 動作\u0026#34;); } } // 使用範例 class EnumSingletonExample { public static void main(String[] args) { EnumSingleton singleton = EnumSingleton.INSTANCE; singleton.setData(\u0026#34;更新的資料\u0026#34;); singleton.processData(); } } 實際應用範例 1. 資料庫連線管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /** * 資料庫連線管理器單例 * 使用靜態內部類別實作 */ public class DatabaseManager { private final HikariDataSource dataSource; private DatabaseManager() { // 初始化連線池配置 HikariConfig config = new HikariConfig(); config.setJdbcUrl(\u0026#34;jdbc:mysql://localhost:3306/mydb\u0026#34;); config.setUsername(\u0026#34;user\u0026#34;); config.setPassword(\u0026#34;password\u0026#34;); config.setMaximumPoolSize(20); config.setMinimumIdle(5); config.setConnectionTimeout(30000); config.setIdleTimeout(600000); config.setMaxLifetime(1800000); this.dataSource = new HikariDataSource(config); System.out.println(\u0026#34;資料庫連線池初始化完成\u0026#34;); } private static class Holder { private static final DatabaseManager INSTANCE = new DatabaseManager(); } public static DatabaseManager getInstance() { return Holder.INSTANCE; } public Connection getConnection() throws SQLException { return dataSource.getConnection(); } public void closeDataSource() { if (dataSource != null \u0026amp;\u0026amp; !dataSource.isClosed()) { dataSource.close(); System.out.println(\u0026#34;資料庫連線池已關閉\u0026#34;); } } // JVM 關閉時清理資源 static { Runtime.getRuntime().addShutdownHook(new Thread(() -\u0026gt; { DatabaseManager.getInstance().closeDataSource(); })); } } 2. 應用程式設定管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 /** * 應用程式設定管理器 * 使用枚舉實作，支援動態設定更新 */ public enum ConfigurationManager { INSTANCE; private final Properties properties; private final Map\u0026lt;String, Object\u0026gt; runtimeConfig; private final ReadWriteLock lock; ConfigurationManager() { this.properties = new Properties(); this.runtimeConfig = new ConcurrentHashMap\u0026lt;\u0026gt;(); this.lock = new ReentrantReadWriteLock(); loadConfiguration(); } private void loadConfiguration() { try (InputStream input = getClass().getClassLoader() .getResourceAsStream(\u0026#34;application.properties\u0026#34;)) { if (input != null) { properties.load(input); System.out.println(\u0026#34;設定檔載入完成\u0026#34;); } else { System.out.println(\u0026#34;找不到設定檔，使用預設設定\u0026#34;); loadDefaultConfiguration(); } } catch (IOException e) { System.err.println(\u0026#34;載入設定檔失敗: \u0026#34; + e.getMessage()); loadDefaultConfiguration(); } } private void loadDefaultConfiguration() { properties.setProperty(\u0026#34;app.name\u0026#34;, \u0026#34;MyApplication\u0026#34;); properties.setProperty(\u0026#34;app.version\u0026#34;, \u0026#34;1.0.0\u0026#34;); properties.setProperty(\u0026#34;app.environment\u0026#34;, \u0026#34;development\u0026#34;); properties.setProperty(\u0026#34;database.pool.max\u0026#34;, \u0026#34;20\u0026#34;); properties.setProperty(\u0026#34;cache.ttl\u0026#34;, \u0026#34;3600\u0026#34;); } public String getProperty(String key) { lock.readLock().lock(); try { return properties.getProperty(key); } finally { lock.readLock().unlock(); } } public String getProperty(String key, String defaultValue) { lock.readLock().lock(); try { return properties.getProperty(key, defaultValue); } finally { lock.readLock().unlock(); } } public void setProperty(String key, String value) { lock.writeLock().lock(); try { properties.setProperty(key, value); System.out.println(\u0026#34;設定已更新: \u0026#34; + key + \u0026#34; = \u0026#34; + value); } finally { lock.writeLock().unlock(); } } public int getIntProperty(String key, int defaultValue) { try { String value = getProperty(key); return value != null ? Integer.parseInt(value) : defaultValue; } catch (NumberFormatException e) { return defaultValue; } } public boolean getBooleanProperty(String key, boolean defaultValue) { String value = getProperty(key); return value != null ? Boolean.parseBoolean(value) : defaultValue; } // 執行時設定（不會持久化） public void setRuntimeConfig(String key, Object value) { runtimeConfig.put(key, value); } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T\u0026gt; T getRuntimeConfig(String key, Class\u0026lt;T\u0026gt; type, T defaultValue) { Object value = runtimeConfig.get(key); return type.isInstance(value) ? (T) value : defaultValue; } public void reloadConfiguration() { lock.writeLock().lock(); try { properties.clear(); loadConfiguration(); System.out.println(\u0026#34;設定已重新載入\u0026#34;); } finally { lock.writeLock().unlock(); } } public Map\u0026lt;String, String\u0026gt; getAllProperties() { lock.readLock().lock(); try { Map\u0026lt;String, String\u0026gt; result = new HashMap\u0026lt;\u0026gt;(); for (String key : properties.stringPropertyNames()) { result.put(key, properties.getProperty(key)); } return result; } finally { lock.readLock().unlock(); } } } 3. 日志管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 /** * 自訂日志管理器單例 * 使用雙重檢查鎖定實作 */ public class LoggerManager { private static volatile LoggerManager instance; private final Map\u0026lt;String, Logger\u0026gt; loggers; private final String logLevel; private final boolean enableConsoleOutput; private final String logFilePath; private LoggerManager() { this.loggers = new ConcurrentHashMap\u0026lt;\u0026gt;(); // 從設定管理器獲取設定 ConfigurationManager config = ConfigurationManager.INSTANCE; this.logLevel = config.getProperty(\u0026#34;log.level\u0026#34;, \u0026#34;INFO\u0026#34;); this.enableConsoleOutput = config.getBooleanProperty(\u0026#34;log.console.enabled\u0026#34;, true); this.logFilePath = config.getProperty(\u0026#34;log.file.path\u0026#34;, \u0026#34;logs/application.log\u0026#34;); initializeLoggers(); System.out.println(\u0026#34;日志管理器初始化完成\u0026#34;); } public static LoggerManager getInstance() { if (instance == null) { synchronized (LoggerManager.class) { if (instance == null) { instance = new LoggerManager(); } } } return instance; } private void initializeLoggers() { // 初始化預設日志記錄器 createLogger(\u0026#34;DEFAULT\u0026#34;); createLogger(\u0026#34;DATABASE\u0026#34;); createLogger(\u0026#34;SECURITY\u0026#34;); createLogger(\u0026#34;PERFORMANCE\u0026#34;); } public Logger getLogger(String name) { return loggers.computeIfAbsent(name, this::createLogger); } private Logger createLogger(String name) { Logger logger = LoggerFactory.getLogger(name); // 這裡可以根據需要配置 logger 的 appender 和 level // 實際應用中通常使用 logback.xml 或 log4j2.xml 配置 System.out.println(\u0026#34;創建 Logger: \u0026#34; + name); return logger; } public void logInfo(String loggerName, String message) { getLogger(loggerName).info(message); } public void logError(String loggerName, String message, Throwable throwable) { getLogger(loggerName).error(message, throwable); } public void logDebug(String loggerName, String message) { getLogger(loggerName).debug(message); } public void logWarn(String loggerName, String message) { getLogger(loggerName).warn(message); } // 獲取所有 logger 的統計資訊 public Map\u0026lt;String, String\u0026gt; getLoggerStats() { Map\u0026lt;String, String\u0026gt; stats = new HashMap\u0026lt;\u0026gt;(); stats.put(\u0026#34;totalLoggers\u0026#34;, String.valueOf(loggers.size())); stats.put(\u0026#34;logLevel\u0026#34;, logLevel); stats.put(\u0026#34;consoleOutput\u0026#34;, String.valueOf(enableConsoleOutput)); stats.put(\u0026#34;logFilePath\u0026#34;, logFilePath); return stats; } } Spring 框架中的單例模式 1. Spring Bean 的單例作用域 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /** * Spring 中的單例 Bean * Spring 預設使用單例作用域管理 Bean */ @Component @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON) // 預設值，可省略 public class SpringSingletonService { private final String instanceId; private final LocalDateTime createdAt; public SpringSingletonService() { this.instanceId = UUID.randomUUID().toString(); this.createdAt = LocalDateTime.now(); System.out.println(\u0026#34;SpringSingletonService 實例創建: \u0026#34; + instanceId); } public String getInstanceInfo() { return String.format(\u0026#34;實例ID: %s, 創建時間: %s\u0026#34;, instanceId, createdAt); } @PostConstruct private void init() { System.out.println(\u0026#34;SpringSingletonService 初始化完成\u0026#34;); } @PreDestroy private void destroy() { System.out.println(\u0026#34;SpringSingletonService 銷毀: \u0026#34; + instanceId); } } /** * 使用 @Configuration 和 @Bean 註解創建單例 */ @Configuration public class SingletonBeanConfiguration { @Bean @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON) public CacheManager cacheManager() { return new ConcurrentMapCacheManager(\u0026#34;users\u0026#34;, \u0026#34;products\u0026#34;, \u0026#34;orders\u0026#34;); } @Bean public TaskExecutor taskExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(5); executor.setMaxPoolSize(20); executor.setQueueCapacity(100); executor.setThreadNamePrefix(\u0026#34;App-\u0026#34;); executor.initialize(); return executor; } } 2. Spring Boot 中的單例服務 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Spring Boot 中的單例服務範例 */ @Service public class UserService { private final UserRepository userRepository; private final CacheManager cacheManager; private final String serviceId; public UserService(UserRepository userRepository, CacheManager cacheManager) { this.userRepository = userRepository; this.cacheManager = cacheManager; this.serviceId = UUID.randomUUID().toString(); System.out.println(\u0026#34;UserService 單例創建: \u0026#34; + serviceId); } @Cacheable(\u0026#34;users\u0026#34;) public User findById(Long id) { System.out.println(\u0026#34;從資料庫載入用戶: \u0026#34; + id); return userRepository.findById(id).orElse(null); } @CacheEvict(value = \u0026#34;users\u0026#34;, key = \u0026#34;#user.id\u0026#34;) public User save(User user) { return userRepository.save(user); } public String getServiceInfo() { return \u0026#34;UserService 實例ID: \u0026#34; + serviceId; } } 單例模式的潛在問題與解決方案 1. 反射攻擊防護 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /** * 防範反射攻擊的單例實作 */ public class ReflectionSafeSingleton { private static volatile ReflectionSafeSingleton instance; private static boolean instanceCreated = false; private ReflectionSafeSingleton() { synchronized (ReflectionSafeSingleton.class) { if (instanceCreated) { throw new IllegalStateException(\u0026#34;單例已存在，禁止透過反射創建新實例\u0026#34;); } instanceCreated = true; } System.out.println(\u0026#34;ReflectionSafeSingleton 實例創建\u0026#34;); } public static ReflectionSafeSingleton getInstance() { if (instance == null) { synchronized (ReflectionSafeSingleton.class) { if (instance == null) { instance = new ReflectionSafeSingleton(); } } } return instance; } } // 測試反射攻擊 class ReflectionAttackTest { public static void main(String[] args) { try { ReflectionSafeSingleton singleton1 = ReflectionSafeSingleton.getInstance(); Constructor\u0026lt;ReflectionSafeSingleton\u0026gt; constructor = ReflectionSafeSingleton.class.getDeclaredConstructor(); constructor.setAccessible(true); // 這裡會拋出 IllegalStateException ReflectionSafeSingleton singleton2 = constructor.newInstance(); } catch (Exception e) { System.out.println(\u0026#34;反射攻擊被阻止: \u0026#34; + e.getMessage()); } } } 2. 序列化攻擊防護 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * 防範序列化攻擊的單例實作 */ public class SerializationSafeSingleton implements Serializable { private static final long serialVersionUID = 1L; private static volatile SerializationSafeSingleton instance; private SerializationSafeSingleton() { System.out.println(\u0026#34;SerializationSafeSingleton 實例創建\u0026#34;); } public static SerializationSafeSingleton getInstance() { if (instance == null) { synchronized (SerializationSafeSingleton.class) { if (instance == null) { instance = new SerializationSafeSingleton(); } } } return instance; } // 防止序列化攻擊的關鍵方法 private Object readResolve() { return getInstance(); } // 可選：自訂序列化邏輯 private void writeObject(ObjectOutputStream out) throws IOException { out.defaultWriteObject(); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); } } 3. 多執行緒測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * 多執行緒環境下的單例測試 */ public class SingletonThreadTest { public static void main(String[] args) throws InterruptedException { final int threadCount = 1000; final CountDownLatch startLatch = new CountDownLatch(1); final CountDownLatch endLatch = new CountDownLatch(threadCount); final Set\u0026lt;Integer\u0026gt; instanceHashCodes = ConcurrentHashMap.newKeySet(); // 創建多個執行緒同時獲取單例 for (int i = 0; i \u0026lt; threadCount; i++) { new Thread(() -\u0026gt; { try { startLatch.await(); // 等待開始信號 // 測試不同的單例實作 DoubleCheckedSingleton instance1 = DoubleCheckedSingleton.getInstance(); StaticHolderSingleton instance2 = StaticHolderSingleton.getInstance(); EnumSingleton instance3 = EnumSingleton.INSTANCE; instanceHashCodes.add(System.identityHashCode(instance1)); instanceHashCodes.add(System.identityHashCode(instance2)); instanceHashCodes.add(System.identityHashCode(instance3)); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } finally { endLatch.countDown(); } }).start(); } System.out.println(\u0026#34;開始多執行緒單例測試...\u0026#34;); startLatch.countDown(); // 發出開始信號 endLatch.await(); // 等待所有執行緒完成 System.out.println(\u0026#34;測試完成\u0026#34;); System.out.println(\u0026#34;DoubleCheckedSingleton 不同實例數量: \u0026#34; + (instanceHashCodes.size() \u0026gt;= 3 ? \u0026#34;3 個（正常）\u0026#34; : \u0026#34;異常\u0026#34;)); } } 單例模式的效能比較 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /** * 不同單例實作的效能測試 */ public class SingletonPerformanceTest { private static final int ITERATIONS = 10_000_000; public static void main(String[] args) { // 預熱 JVM warmUp(); // 測試不同實作的效能 testEagerSingleton(); testDoubleCheckedSingleton(); testStaticHolderSingleton(); testEnumSingleton(); } private static void warmUp() { for (int i = 0; i \u0026lt; 100_000; i++) { EagerSingleton.getInstance(); DoubleCheckedSingleton.getInstance(); StaticHolderSingleton.getInstance(); EnumSingleton.INSTANCE.getData(); } } private static void testEagerSingleton() { long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; ITERATIONS; i++) { EagerSingleton.getInstance(); } long endTime = System.nanoTime(); System.out.printf(\u0026#34;EagerSingleton: %.2f ms%n\u0026#34;, (endTime - startTime) / 1_000_000.0); } private static void testDoubleCheckedSingleton() { long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; ITERATIONS; i++) { DoubleCheckedSingleton.getInstance(); } long endTime = System.nanoTime(); System.out.printf(\u0026#34;DoubleCheckedSingleton: %.2f ms%n\u0026#34;, (endTime - startTime) / 1_000_000.0); } private static void testStaticHolderSingleton() { long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; ITERATIONS; i++) { StaticHolderSingleton.getInstance(); } long endTime = System.nanoTime(); System.out.printf(\u0026#34;StaticHolderSingleton: %.2f ms%n\u0026#34;, (endTime - startTime) / 1_000_000.0); } private static void testEnumSingleton() { long startTime = System.nanoTime(); for (int i = 0; i \u0026lt; ITERATIONS; i++) { EnumSingleton.INSTANCE.getData(); } long endTime = System.nanoTime(); System.out.printf(\u0026#34;EnumSingleton: %.2f ms%n\u0026#34;, (endTime - startTime) / 1_000_000.0); } } 總結與最佳實踐 推薦的實作方式 枚舉單例：適合大多數情況，最安全、最簡潔 靜態內部類別：適合需要延遲初始化的場景 雙重檢查鎖定：適合複雜初始化邏輯的場景 選擇指南 場景 推薦實作 原因 一般用途 枚舉單例 最安全、最簡潔 Spring 應用 Spring Bean 框架管理生命週期 延遲初始化 靜態內部類別 性能最佳、執行緒安全 複雜初始化 雙重檢查鎖定 靈活性高 簡單場景 餓漢式 實作簡單 注意事項 避免過度使用：單例會增加程式碼的耦合度 考慮測試性：單例可能影響單元測試的獨立性 執行緒安全：確保在多執行緒環境下的正確性 資源清理：適當時候釋放單例持有的資源 序列化考慮：實作 readResolve() 方法防止序列化攻擊 現代替代方案 在現代應用開發中，可以考慮以下替代方案：\n依賴注入容器：如 Spring IoC 容器 靜態工廠方法：提供更好的測試性 Builder 模式：適合複雜對象的創建 Registry 模式：管理多個相關的單例 單例模式雖然簡單，但在實際應用中需要謹慎考慮其適用性和實作方式。選擇合適的實作方案能夠確保程式碼的健壯性和可維護性。\n參考資料 Effective Java by Joshua Bloch Design Patterns: Elements of Reusable Object-Oriented Software Java Concurrency in Practice Spring Framework Documentation ","permalink":"https://xinqilin.github.io/post/architecture/singleton/","tags":["Design Pattern","Singleton","Java","Thread Safety","Best Practices","Creational Pattern"],"title":"Singleton 設計模式完整指南：單例實作與現代化最佳實踐"}]